


NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: faregi.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FAREGI_MT64                         &
(    4) &                     (FA,  CDCLEF, KVAL, KOPT)
(    5) USE FA_MOD, ONLY : FA_COM, JPNIIL
(    6) USE PARKIND1, ONLY : JPRB
(    7) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    8) USE LFI_PRECISION
(    9) IMPLICIT NONE
(   10) !****
(   11) !      Ce sous-programme controle (lecture/ecriture) les options
(   12) !      de compression de GRIBEX implicites.
(   13) !      (REGlage des options Implicites de codage de gribex)
(   14) !**
(   15) !    Arguments : CDCLEF (Entree) ==> Mot clef precisant l'action a faire;
(   16) !                KVAL   (Sortie  ==> Valeur lue ou ecrite;
(   17) !                      ou Entree)
(   18) !                KOPT   (Entree) ==> Flag: 0->lecture 1->ecriture;
(   19) !*
(   20) !     Signification des divers elements du tableau FA%NCODGRI
(   21) !
(   22) !     NCODGRI(1) = type de codage (0->option HOPER='C'; 1->option HOPER='K')
(   23) !     NCODGRI(2) = KSEC4(6), indicateur de la presence de flags
(   24) !                            additionnels (0->non; 16->oui)
(   25) !     NCODGRI(3) = KSEC4(7)
(   26) !     NCODGRI(4) = KSEC4(9), indicateur de la presence de bitmaps
(   27) !                          secondaires (0->non; 32->oui)
(   28) !     NCODGRI(5) = KSEC4(10), indicateur pour le nb de bits des
(   29) !                     groupes de pts de grille (0->const.; 16->different)
(   30) !     NCODGRI(6) = KSEC4(11), nb de bits pour les groupes de pts de






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 3

(   31) !                   grille, quand il est constant.
(   32) !                     Si negatif, le logiciel calcule un nb optimal a partir
(   33) !                     de -KSEC4(11).
(   34) !     NCODGRI(7) = KSEC4(12), indicateur pour les extensions generales de la
(   35) !                     compression (0->non; 8->oui)
(   36) !     NCODGRI(8) = KSEC4(13), indicateur pour le rearrangement boustrophedo
(   37) !                     nique (0->non; 4->oui)
(   38) !     NCODGRI(9) = KSEC4(14) (valeurs possibles: -1, 0 et 2)
(   39) !     NCODGRI(10) = KSEC4(15) (valeurs possibles: -1, 0 et 1), sert avec
(   40) !                      KSEC4(14) a definir la technique de la difference
(   41) !                      spatiale.Si l'un des 2 est negatif, l'ordre de
(   42) !                      differentiation est estime dynamiquement, sinon
(   43) !                      l'ordre vaut KSEC4(14)+KSEC4(15)
(   44) !     NCODGRI(11) = 1->Calcul automatique de KSEC1 (23), 0->On laisse faire
(   45) !     NCODGRI(12) = Ecriture des champs GRIB1 dans un fichier externe
(   46) !     NCODGRI(13) = Champs de surface uniquement
(   47) !
(   48) !
(   49) TYPE(FA_COM) :: FA
(   50) INTEGER (KIND=JPLIKB) KVAL, KOPT
(   51) !
(   52) CHARACTER(LEN=*) CDCLEF
(   53) !
(   54) INTEGER (KIND=JPLIKB) INUMER, INIMES, IREP, INBITSMAX
(   55) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   56) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   57) LOGICAL                  LLFATA
(   58) 
(   59) !
(   60) !
(   61) !
(   62) !**
(   63) !     0.  -  INITIALISATIONS ET ALLOCATIONS PREALABLES
(   64) !-----------------------------------------------------------------------
(   65) !
(   66) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   67) IF (LHOOK) CALL DR_HOOK('FAREGI_MT',0,ZHOOK_HANDLE)
(   68) IREP=0
(   69) IF (FA%FAREGI_LLPREA) THEN
(   70) !
(   71) !          A la premiere utilisation, appel au sous-programme "FARINE".
(   72) !
(   73)   CALL FARINE_MT64             &
(   74) &                (FA, 2_JPLIKB )
(   75)   FA%FAREGI_LLPREA=.FALSE.
(   76) ENDIF
(   77) INBITSMAX=MAX(FA%NBIPDG,FA%NBICSP)
(   78) !
(   79) !**
(   80) !     1.  -  SPECIFICATION D'UN NOUVEAU CODAGE
(   81) !-----------------------------------------------------------------------
(   82) !
(   83) IF (KOPT==1) THEN
(   84) !
(   85) !   Pas de compression (sous-tronc et puissance laplacien
(   86) !   ajoutees systematiquement + tard pour les coeff spectraux)
(   87) !
(   88)   IF (CDCLEF=='BASIC'.OR.CDCLEF=='basic') THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 4

(   89)     FA%NCODGRI(1)=0
(   90)     FA%NCODGRI(2)=0
(   91)     FA%NCODGRI(3)=0
(   92)     FA%NCODGRI(4)=0
(   93)     FA%NCODGRI(5)=0
(   94)     FA%NCODGRI(6)=0
(   95)   ELSEIF (CDCLEF=='IDCEN'.OR.CDCLEF=='idcen') THEN
(   96)     FA%NIDCEN = KVAL
(   97) !
(   98) !   Comme le "BASIC" avec une compression
(   99) !   ligne a ligne pour les points de grille
(  100) !
(  101)   ELSEIF (CDCLEF=='PACK1'.OR.CDCLEF=='pack1') THEN
(  102)     FA%NCODGRI(1)=0
(  103)     FA%NCODGRI(2)=16
(  104)     FA%NCODGRI(3)=0
(  105)     FA%NCODGRI(4)=0
(  106)     FA%NCODGRI(5)=16
(  107)     FA%NCODGRI(6)=0
(  108) !
(  109) !   Comme le "BASIC" avec une compression
(  110) !   pour les points de grille ou le nb de bits est le meme
(  111) !   dans chaque groupe de points de grille
(  112) !
(  113)   ELSEIF (CDCLEF=='PACK2'.OR.CDCLEF=='pack2') THEN
(  114)     FA%NCODGRI(1)=0
(  115)     FA%NCODGRI(2)=16
(  116)     FA%NCODGRI(3)=0
(  117)     FA%NCODGRI(4)=32
(  118)     FA%NCODGRI(5)=0
(  119) ! Un nb de bits optimal sera recherche par le logiciel
(  120)     FA%NCODGRI(6)=-99
(  121) !
(  122) !   Comme le "BASIC" avec une compression
(  123) !   "OMM general" pour les points de grille
(  124) !
(  125)   ELSEIF (CDCLEF=='PACK3'.OR.CDCLEF=='pack3') THEN
(  126)     FA%NCODGRI(1)=0
(  127)     FA%NCODGRI(2)=16
(  128)     FA%NCODGRI(3)=0
(  129)     FA%NCODGRI(4)=32
(  130)     FA%NCODGRI(5)=16
(  131)     FA%NCODGRI(6)=0
(  132) !
(  133) !   Compression "aggressive": le logiciel va
(  134) !   tenter la compression ligne a ligne et comparer la
(  135) !   longueur de message obtenue avec celle en l'absence de
(  136) !   compression et au final retenir la meilleure solution.
(  137) !
(  138)   ELSEIF (CDCLEF=='APAC1'.OR.CDCLEF=='apac1') THEN
(  139)     FA%NCODGRI(1)=1
(  140)     FA%NCODGRI(2)=16
(  141)     FA%NCODGRI(3)=0
(  142)     FA%NCODGRI(4)=0
(  143)     FA%NCODGRI(5)=16
(  144)     FA%NCODGRI(6)=0
(  145) !
(  146) !   Compression "aggressive": le logiciel va






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 5

(  147) !   suivre la demarche "APAC1" en testant en plus le nb de bits
(  148) !   constant par groupe de pts de grille et retenir la meilleure
(  149) !   compression
(  150) !
(  151)   ELSEIF (CDCLEF=='APAC2'.OR.CDCLEF=='apac2') THEN
(  152)     FA%NCODGRI(1)=1
(  153)     FA%NCODGRI(2)=16
(  154)     FA%NCODGRI(3)=0
(  155)     FA%NCODGRI(4)=0
(  156)     FA%NCODGRI(5)=0
(  157) ! Un nb de bits optimal sera recherche par le logiciel
(  158)     FA%NCODGRI(6)=-99
(  159) !
(  160) !   Compression "aggressive": le logiciel va
(  161) !   suivre la demarche "APAC1" en testant en plus la compression
(  162) !   "general OMM" et retenir la meilleure compression.
(  163) !
(  164)   ELSEIF (CDCLEF=='APAC3'.OR.CDCLEF=='apac3') THEN
(  165)     FA%NCODGRI(1)=1
(  166)     FA%NCODGRI(2)=16
(  167)     FA%NCODGRI(3)=0
(  168)     FA%NCODGRI(4)=32
(  169)     FA%NCODGRI(5)=16
(  170)     FA%NCODGRI(6)=0
(  171) !
(  172) !   Compression "aggressive": le logiciel va
(  173) !   suivre la demarche "APAC3" en testant en plus le nb de bits
(  174) !   constant par groupe de pts de grille et retenir la meilleure
(  175) !   compression.
(  176) !
(  177)   ELSEIF (CDCLEF=='APAC4'.OR.CDCLEF=='apac4') THEN
(  178)     FA%NCODGRI(1)=1
(  179)     FA%NCODGRI(2)=16
(  180)     FA%NCODGRI(3)=0
(  181)     FA%NCODGRI(4)=32
(  182)     FA%NCODGRI(5)=0
(  183) ! Un nb de bits optimal sera recherche par le logiciel
(  184)     FA%NCODGRI(6)=-99
(  185) !
(  186) !   Specification du nb de bits a utiliser dans le cadre
(  187) !   de la compression avec nb de bits constant
(  188) !   par groupe de pts de grille
(  189) !   
(  190)   ELSEIF (CDCLEF=='WIDPA'.OR.CDCLEF=='widpa') THEN
(  191)     IF (KVAL.LT.1-INBITSMAX.OR.KVAL.GT.INBITSMAX-1) THEN
(  192)       IREP=-97
(  193)       GOTO 1001
(  194)     ENDIF
(  195)     FA%NCODGRI(6)=KVAL
(  196) !
(  197) !   Demande supplementaire de l'extension generale de la compression
(  198) !   (si KVAL=1, sinon c'est le retrait de cette option)
(  199) !
(  200)   ELSEIF (CDCLEF=='GEXTE'.OR.CDCLEF=='gexte') THEN
(  201)     IF (KVAL.EQ.1) THEN
(  202)       FA%IOPTGRSX2O=1
(  203)       FA%NCODGRI(7)=8
(  204)     ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 6

(  205)       FA%NCODGRI(7)=0
(  206)     ENDIF
(  207) !
(  208) !   Demande supplementaire du rearrangement boustrophedonique dans la
(  209) !   compression (si KVAL=1, sinon c'est le retrait de cette option)
(  210) !
(  211)   ELSEIF (CDCLEF=='BOUST'.OR.CDCLEF=='boust') THEN
(  212)     IF (KVAL.EQ.1) THEN
(  213)       FA%IOPTGRSX2O=1
(  214)       FA%NCODGRI(8)=4
(  215)     ELSE
(  216)       FA%NCODGRI(8)=0
(  217)     ENDIF
(  218) !
(  219) !   Demande supplementaire de la difference spatiale dans la compression.
(  220) !   KVAL donne l'ordre de differentiation:
(  221) !   -1-> calcul dynamique par GRIBEX; 1 a 3->ordre; 0->desactiv; autre->err
(  222) !
(  223)   ELSEIF (CDCLEF=='DIFFE'.OR.CDCLEF=='diffe') THEN
(  224)     IF (KVAL.EQ.-1) THEN
(  225)       FA%IOPTGRSX2O=1
(  226)       FA%IOPTGRSN2O=1
(  227)       FA%NCODGRI( 9)=0
(  228)       FA%NCODGRI(10)=-1
(  229)     ELSEIF (KVAL.EQ.1) THEN
(  230)       FA%IOPTGRSX2O=1
(  231)       FA%IOPTGRSN2O=1
(  232)       FA%NCODGRI( 9)=0
(  233)       FA%NCODGRI(10)=1
(  234)     ELSEIF (KVAL.EQ.2) THEN
(  235)       FA%IOPTGRSX2O=1
(  236)       FA%IOPTGRSN2O=1
(  237)       FA%NCODGRI( 9)=2
(  238)       FA%NCODGRI(10)=0
(  239)     ELSEIF (KVAL.EQ.3) THEN
(  240)       FA%IOPTGRSX2O=1
(  241)       FA%IOPTGRSN2O=1
(  242)       FA%NCODGRI( 9)=2
(  243)       FA%NCODGRI(10)=1
(  244)     ELSEIF (KVAL.EQ.0) THEN
(  245)       FA%IOPTGRSX2O=0
(  246)       FA%NCODGRI( 9)=0
(  247)       FA%NCODGRI(10)=0
(  248)     ELSE
(  249)       IREP=-125
(  250)       GOTO 1001
(  251)     ENDIF
(  252) !
(  253) !   Facteur decimal; calcul automatique
(  254) !
(  255)   ELSEIF (CDCLEF=='FACDEC'.OR.CDCLEF=='facdec') THEN
(  256)     FA%NCODGRI(11)=KVAL
(  257) 
(  258) !
(  259) !  Ecriture dans un fichier externe
(  260) !
(  261)   ELSEIF (CDCLEF=='EXTERN'.OR.CDCLEF=='extern') THEN
(  262)     FA%NCODGRI(12)=KVAL






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 7

(  263) !
(  264) !  Champs de surface uniquement; pas d'ecriture ni controle des niveaux verticaux
(  265) !
(  266)   ELSEIF (CDCLEF=='SURF'.OR.CDCLEF=='surf') THEN
(  267)     FA%NCODGRI(13)=KVAL
(  268) !
(  269) !  Tolerance sur le controle de cadre
(  270) !
(  271)   ELSEIF (CDCLEF=='ZEPS'.OR.CDCLEF=='zeps') THEN
(  272)     FA%NCODGRI(14)=KVAL
(  273)   ENDIF
(  274) !**
(  275) !     2.  -  DEMANDE D'INFORMATION
(  276) !-----------------------------------------------------------------------
(  277) !
(  278) ELSEIF (KOPT==0) THEN
(  279) !
(  280) !   Obtention des mots-clef disponibles
(  281) !
(  282)   IF (CDCLEF=='CLEFS'.OR.CDCLEF=='clefs') THEN
(  283)     KVAL=0
(  284)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  285)     WRITE (UNIT=FA%NULOUT,FMT=*) 'Mots clef disponibles pour FAREGI:'
(  286)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  287)     WRITE (UNIT=FA%NULOUT,FMT=*) 'BASIC: pas de compression'
(  288)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK1: BASIC avec une compression'
(  289)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ligne a ligne pour les pts de grille'
(  290)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK2: BASIC avec une compression'
(  291)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ou le nb de bits est cst pour les groupes'
(  292)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK3: BASIC avec une compression'
(  293)     WRITE (UNIT=FA%NULOUT,FMT=*) '       OMM general pour les points de grille'
(  294)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC1: compression agressive'
(  295)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC et PACK1 sont testes'
(  296)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC2: compression agressive'
(  297)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1 et PACK2 sont testes'
(  298)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC3: compression agressive'
(  299)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1 et PACK3 sont testes'
(  300)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC4: compression agressive'
(  301)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1, PACK2 et PACK3 testes'
(  302)     WRITE (UNIT=FA%NULOUT,FMT=*) 'WIDPA: lecture/ecriture du nb de bits'
(  303)     WRITE (UNIT=FA%NULOUT,FMT=*) '       a utiliser pour les groupes de points'
(  304)     WRITE (UNIT=FA%NULOUT,FMT=*) '       de grille dans le cas PACK2'
(  305)     WRITE (UNIT=FA%NULOUT,FMT=*) 'GEXTE: les extensions generales de la compression'
(  306)     WRITE (UNIT=FA%NULOUT,FMT=*) '       sont activees (KVAL=1) ou desactiv. (KVAL=0)'
(  307)     WRITE (UNIT=FA%NULOUT,FMT=*) 'BOUST: le rearrangement boustrophedonique est'
(  308)     WRITE (UNIT=FA%NULOUT,FMT=*) '       active (KVAL=1) ou desactive (KVAL=0)'
(  309)     WRITE (UNIT=FA%NULOUT,FMT=*) 'DIFFE: la differenciation spatiale est'
(  310)     WRITE (UNIT=FA%NULOUT,FMT=*) '       activee (KVAL=ordre de differ. (1 a 3)'
(  311)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ou -1 (calcul dyn)) ou desactivee (0)'
(  312)     WRITE (UNIT=FA%NULOUT,FMT=*) 'FACDEC: calcul automatique du facteur decimal'
(  313)     WRITE (UNIT=FA%NULOUT,FMT=*) 'EXTERN: ecriture dans un fichier externe'
(  314)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  315)   ELSEIF (CDCLEF=='IDCEN'.OR.CDCLEF=='idcen') THEN
(  316)     KVAL = FA%NIDCEN 
(  317) !
(  318) !   Lecture du nb de bits a utiliser dans le cadre
(  319) !   de la compression avec nb de bits constant
(  320) !   par groupe de pts de grille






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 8

(  321) !   
(  322)   ELSEIF (CDCLEF=='WIDPA'.OR.CDCLEF=='widpa') THEN
(  323)     KVAL=FA%NCODGRI(6)
(  324) !
(  325) !   Lecture de la presence ou non de la compression
(  326) !   "general extended"
(  327) !
(  328)   ELSEIF (CDCLEF=='GEXTE'.OR.CDCLEF=='gexte') THEN
(  329)     KVAL = FA%NCODGRI(7) / 8
(  330) !
(  331) !   Lecture de la presence ou non du rearrangement
(  332) !   boustrophedonique.
(  333) !
(  334)   ELSEIF (CDCLEF=='BOUST'.OR.CDCLEF=='boust') THEN
(  335)     KVAL = FA%NCODGRI(8) / 4
(  336) !
(  337) !   Lecture de la presence ou non de la differentiation spatiale
(  338) !
(  339)   ELSEIF (CDCLEF=='DIFFE'.OR.CDCLEF=='diffe') THEN
(  340)     KVAL=FA%NCODGRI( 9)+FA%NCODGRI(10)
(  341) !
(  342) !   Facteur decimal; calcul automatique
(  343) !
(  344)   ELSEIF (CDCLEF=='FACDEC'.OR.CDCLEF=='facdec') THEN
(  345)     KVAL=FA%NCODGRI(11)
(  346) !
(  347) !   Ecriture dans un fichier externe
(  348) !
(  349)   ELSEIF (CDCLEF=='EXTERN'.OR.CDCLEF=='extern') THEN
(  350)     KVAL=FA%NCODGRI(12)
(  351) !
(  352) !  Champs de surface uniquement; pas d'ecriture ni controle des niveaux verticaux
(  353) !
(  354)   ELSEIF (CDCLEF=='SURF'.OR.CDCLEF=='surf') THEN
(  355)     KVAL=FA%NCODGRI(13)
(  356)   ELSEIF (CDCLEF=='ZEPS'.OR.CDCLEF=='zeps') THEN
(  357)     KVAL=FA%NCODGRI(14)
(  358)   ELSE
(  359)     IREP=-125
(  360)     GOTO 1001
(  361)   ENDIF
(  362) !**
(  363) !     3.  -  OPTION INCONNUE
(  364) !-----------------------------------------------------------------------
(  365) !
(  366) ELSE
(  367)   IREP=-125
(  368)   GOTO 1001
(  369) ENDIF
(  370) !**
(  371) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  372) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  373) !-----------------------------------------------------------------------
(  374) !
(  375) 1001 CONTINUE
(  376) LLFATA=LLMOER (IREP,0_JPLIKB )
(  377) !
(  378) IF (LLFATA) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 9

(  379)   INIMES=2
(  380) ELSE
(  381)   INIMES=FA%NIMSGA
(  382) ENDIF
(  383) !
(  384) IF (INIMES.EQ.0)  THEN 
(  385)   IF (LHOOK) CALL DR_HOOK('FAREGI_MT',1,ZHOOK_HANDLE)
(  386)   RETURN
(  387) ENDIF
(  388) !
(  389) CLNSPR='FAREGI'
(  390) INUMER=JPNIIL
(  391) !
(  392) WRITE (UNIT=CLMESS,FMT='(''IREP='',I2,            &
(  393) &        '', CDCLEF='''''',A,'''''', KVAL='',I12, &
(  394) &        '', KOPT='',I4)')                        &
(  395) &        IREP,CDCLEF,KVAL,KOPT
(  396) INUMER=JPNIIL
(  397) CALL FAIPAR_MT64                                       &
(  398) &               (FA, INUMER,INIMES,IREP,LLFATA,CLMESS, &
(  399) &                CLNSPR,CLNSPR,.FALSE.)
(  400) !
(  401) IF (LHOOK) CALL DR_HOOK('FAREGI_MT',1,ZHOOK_HANDLE)
(  402) 
(  403) CONTAINS
(  404) 
(  405) #include "facom2.llmoer.h"
(  406) 
(  407) END SUBROUTINE FAREGI_MT64
(  408) 
(  409) 
(  410) 
(  411) ! Oct-2012 P. Marguinaud 64b LFI
(  412) SUBROUTINE FAREGI64            &
(  413) &           (CDCLEF, KVAL, KOPT)
(  414) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  415) &                  FA_COM_DEFAULT_INIT,  &
(  416) &                  NEW_FA_DEFAULT
(  417) USE LFI_PRECISION
(  418) IMPLICIT NONE
(  419) ! Arguments
(  420) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  421) INTEGER (KIND=JPLIKB)  KVAL                                   ! INOUT
(  422) INTEGER (KIND=JPLIKB)  KOPT                                   ! IN   
(  423) 
(  424) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  425) 
(  426) CALL FAREGI_MT64                   &
(  427) &           (FA, CDCLEF, KVAL, KOPT)
(  428) 
(  429) END SUBROUTINE FAREGI64
(  430) 
(  431) SUBROUTINE FAREGI              &
(  432) &           (CDCLEF, KVAL, KOPT)
(  433) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  434) &                  FA_COM_DEFAULT_INIT,  &
(  435) &                  NEW_FA_DEFAULT
(  436) USE LFI_PRECISION






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 10

(  437) IMPLICIT NONE
(  438) ! Arguments
(  439) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  440) INTEGER (KIND=JPLIKM)  KVAL                                   ! INOUT
(  441) INTEGER (KIND=JPLIKM)  KOPT                                   ! IN   
(  442) 
(  443) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  444) 
(  445) CALL FAREGI_MT                     &
(  446) &           (FA, CDCLEF, KVAL, KOPT)
(  447) 
(  448) END SUBROUTINE FAREGI
(  449) 
(  450) SUBROUTINE FAREGI_MT               &
(  451) &           (FA, CDCLEF, KVAL, KOPT)
(  452) USE FA_MOD, ONLY : FA_COM
(  453) USE LFI_PRECISION
(  454) IMPLICIT NONE
(  455) ! Arguments
(  456) TYPE (FA_COM)          FA                                     ! INOUT
(  457) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  458) INTEGER (KIND=JPLIKM)  KVAL                                   ! INOUT
(  459) INTEGER (KIND=JPLIKM)  KOPT                                   ! IN   
(  460) ! Local integers
(  461) INTEGER (KIND=JPLIKB)  IVAL                                   ! INOUT
(  462) INTEGER (KIND=JPLIKB)  IOPT                                   ! IN   
(  463) ! Convert arguments
(  464) 
(  465) IF (KOPT==1) THEN
(  466)   IVAL       = INT (      KVAL, JPLIKB)
(  467) ENDIF
(  468) IOPT       = INT (      KOPT, JPLIKB)
(  469) 
(  470) CALL FAREGI_MT64                   &
(  471) &           (FA, CDCLEF, IVAL, IOPT)
(  472) 
(  473) IF (KOPT==0) THEN
(  474)   KVAL       = INT (      IVAL, JPLIKM)
(  475) ENDIF
(  476) 
(  477) END SUBROUTINE FAREGI_MT
(  478) 
(  479) !INTF CDCLEF        IN                                                                 
(  480) !INTF KVAL          INOUT IN_IF=KOPT==1                  OUT_IF=KOPT==0                
(  481) !INTF KOPT          IN                                                                 



















NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 11

(    1) # 1 "faregi.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FAREGI_MT64                         &
(    4) &                     (FA,  CDCLEF, KVAL, KOPT)
(    5) USE FA_MOD, ONLY : FA_COM, JPNIIL
(    6) USE PARKIND1, ONLY : JPRB
(    7) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    8) USE LFI_PRECISION
(    9) IMPLICIT NONE
(   10) !****
(   11) !      Ce sous-programme controle (lecture/ecriture) les options
(   12) !      de compression de GRIBEX implicites.
(   13) !      (REGlage des options Implicites de codage de gribex)
(   14) !**
(   15) !    Arguments : CDCLEF (Entree) ==> Mot clef precisant l'action a faire;
(   16) !                KVAL   (Sortie  ==> Valeur lue ou ecrite;
(   17) !                      ou Entree)
(   18) !                KOPT   (Entree) ==> Flag: 0->lecture 1->ecriture;
(   19) !*
(   20) !     Signification des divers elements du tableau FA%NCODGRI
(   21) !
(   22) !     NCODGRI(1) = type de codage (0->option HOPER='C'; 1->option HOPER='K')
(   23) !     NCODGRI(2) = KSEC4(6), indicateur de la presence de flags
(   24) !                            additionnels (0->non; 16->oui)
(   25) !     NCODGRI(3) = KSEC4(7)
(   26) !     NCODGRI(4) = KSEC4(9), indicateur de la presence de bitmaps
(   27) !                          secondaires (0->non; 32->oui)
(   28) !     NCODGRI(5) = KSEC4(10), indicateur pour le nb de bits des
(   29) !                     groupes de pts de grille (0->const.; 16->different)
(   30) !     NCODGRI(6) = KSEC4(11), nb de bits pour les groupes de pts de
(   31) !                   grille, quand il est constant.
(   32) !                     Si negatif, le logiciel calcule un nb optimal a partir
(   33) !                     de -KSEC4(11).
(   34) !     NCODGRI(7) = KSEC4(12), indicateur pour les extensions generales de la
(   35) !                     compression (0->non; 8->oui)
(   36) !     NCODGRI(8) = KSEC4(13), indicateur pour le rearrangement boustrophedo
(   37) !                     nique (0->non; 4->oui)
(   38) !     NCODGRI(9) = KSEC4(14) (valeurs possibles: -1, 0 et 2)
(   39) !     NCODGRI(10) = KSEC4(15) (valeurs possibles: -1, 0 et 1), sert avec
(   40) !                      KSEC4(14) a definir la technique de la difference
(   41) !                      spatiale.Si l'un des 2 est negatif, l'ordre de
(   42) !                      differentiation est estime dynamiquement, sinon
(   43) !                      l'ordre vaut KSEC4(14)+KSEC4(15)
(   44) !     NCODGRI(11) = 1->Calcul automatique de KSEC1 (23), 0->On laisse faire
(   45) !     NCODGRI(12) = Ecriture des champs GRIB1 dans un fichier externe
(   46) !     NCODGRI(13) = Champs de surface uniquement
(   47) !
(   48) !
(   49) TYPE(FA_COM) :: FA
(   50) INTEGER (KIND=JPLIKB) KVAL, KOPT
(   51) !
(   52) CHARACTER(LEN=*) CDCLEF
(   53) !
(   54) INTEGER (KIND=JPLIKB) INUMER, INIMES, IREP, INBITSMAX
(   55) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   56) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   57) LOGICAL                  LLFATA






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 12

(   58) # 59 "faregi.F90"
(   59) !
(   60) !
(   61) !
(   62) !**
(   63) !     0.  -  INITIALISATIONS ET ALLOCATIONS PREALABLES
(   64) !-----------------------------------------------------------------------
(   65) !
(   66) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   67) IF (LHOOK) CALL DR_HOOK('FAREGI_MT',0,ZHOOK_HANDLE)
(   68) IREP=0
(   69) IF (FA%FAREGI_LLPREA) THEN
(   70) !
(   71) !          A la premiere utilisation, appel au sous-programme "FARINE".
(   72) !
(   73)   CALL FARINE_MT64             &
(   74) &                (FA, 2_JPLIKB )
(   75)   FA%FAREGI_LLPREA=.FALSE.
(   76) ENDIF
(   77) INBITSMAX=MAX(FA%NBIPDG,FA%NBICSP)
(   78) !
(   79) !**
(   80) !     1.  -  SPECIFICATION D'UN NOUVEAU CODAGE
(   81) !-----------------------------------------------------------------------
(   82) !
(   83) IF (KOPT==1) THEN
(   84) !
(   85) !   Pas de compression (sous-tronc et puissance laplacien
(   86) !   ajoutees systematiquement + tard pour les coeff spectraux)
(   87) !
(   88)   IF (CDCLEF=='BASIC'.OR.CDCLEF=='basic') THEN
(   89)     FA%NCODGRI(1)=0
(   90)     FA%NCODGRI(2)=0
(   91)     FA%NCODGRI(3)=0
(   92)     FA%NCODGRI(4)=0
(   93)     FA%NCODGRI(5)=0
(   94)     FA%NCODGRI(6)=0
(   95)   ELSEIF (CDCLEF=='IDCEN'.OR.CDCLEF=='idcen') THEN
(   96)     FA%NIDCEN = KVAL
(   97) !
(   98) !   Comme le "BASIC" avec une compression
(   99) !   ligne a ligne pour les points de grille
(  100) !
(  101)   ELSEIF (CDCLEF=='PACK1'.OR.CDCLEF=='pack1') THEN
(  102)     FA%NCODGRI(1)=0
(  103)     FA%NCODGRI(2)=16
(  104)     FA%NCODGRI(3)=0
(  105)     FA%NCODGRI(4)=0
(  106)     FA%NCODGRI(5)=16
(  107)     FA%NCODGRI(6)=0
(  108) !
(  109) !   Comme le "BASIC" avec une compression
(  110) !   pour les points de grille ou le nb de bits est le meme
(  111) !   dans chaque groupe de points de grille
(  112) !
(  113)   ELSEIF (CDCLEF=='PACK2'.OR.CDCLEF=='pack2') THEN
(  114)     FA%NCODGRI(1)=0
(  115)     FA%NCODGRI(2)=16






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 13

(  116)     FA%NCODGRI(3)=0
(  117)     FA%NCODGRI(4)=32
(  118)     FA%NCODGRI(5)=0
(  119) ! Un nb de bits optimal sera recherche par le logiciel
(  120)     FA%NCODGRI(6)=-99
(  121) !
(  122) !   Comme le "BASIC" avec une compression
(  123) !   "OMM general" pour les points de grille
(  124) !
(  125)   ELSEIF (CDCLEF=='PACK3'.OR.CDCLEF=='pack3') THEN
(  126)     FA%NCODGRI(1)=0
(  127)     FA%NCODGRI(2)=16
(  128)     FA%NCODGRI(3)=0
(  129)     FA%NCODGRI(4)=32
(  130)     FA%NCODGRI(5)=16
(  131)     FA%NCODGRI(6)=0
(  132) !
(  133) !   Compression "aggressive": le logiciel va
(  134) !   tenter la compression ligne a ligne et comparer la
(  135) !   longueur de message obtenue avec celle en l'absence de
(  136) !   compression et au final retenir la meilleure solution.
(  137) !
(  138)   ELSEIF (CDCLEF=='APAC1'.OR.CDCLEF=='apac1') THEN
(  139)     FA%NCODGRI(1)=1
(  140)     FA%NCODGRI(2)=16
(  141)     FA%NCODGRI(3)=0
(  142)     FA%NCODGRI(4)=0
(  143)     FA%NCODGRI(5)=16
(  144)     FA%NCODGRI(6)=0
(  145) !
(  146) !   Compression "aggressive": le logiciel va
(  147) !   suivre la demarche "APAC1" en testant en plus le nb de bits
(  148) !   constant par groupe de pts de grille et retenir la meilleure
(  149) !   compression
(  150) !
(  151)   ELSEIF (CDCLEF=='APAC2'.OR.CDCLEF=='apac2') THEN
(  152)     FA%NCODGRI(1)=1
(  153)     FA%NCODGRI(2)=16
(  154)     FA%NCODGRI(3)=0
(  155)     FA%NCODGRI(4)=0
(  156)     FA%NCODGRI(5)=0
(  157) ! Un nb de bits optimal sera recherche par le logiciel
(  158)     FA%NCODGRI(6)=-99
(  159) !
(  160) !   Compression "aggressive": le logiciel va
(  161) !   suivre la demarche "APAC1" en testant en plus la compression
(  162) !   "general OMM" et retenir la meilleure compression.
(  163) !
(  164)   ELSEIF (CDCLEF=='APAC3'.OR.CDCLEF=='apac3') THEN
(  165)     FA%NCODGRI(1)=1
(  166)     FA%NCODGRI(2)=16
(  167)     FA%NCODGRI(3)=0
(  168)     FA%NCODGRI(4)=32
(  169)     FA%NCODGRI(5)=16
(  170)     FA%NCODGRI(6)=0
(  171) !
(  172) !   Compression "aggressive": le logiciel va
(  173) !   suivre la demarche "APAC3" en testant en plus le nb de bits






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 14

(  174) !   constant par groupe de pts de grille et retenir la meilleure
(  175) !   compression.
(  176) !
(  177)   ELSEIF (CDCLEF=='APAC4'.OR.CDCLEF=='apac4') THEN
(  178)     FA%NCODGRI(1)=1
(  179)     FA%NCODGRI(2)=16
(  180)     FA%NCODGRI(3)=0
(  181)     FA%NCODGRI(4)=32
(  182)     FA%NCODGRI(5)=0
(  183) ! Un nb de bits optimal sera recherche par le logiciel
(  184)     FA%NCODGRI(6)=-99
(  185) !
(  186) !   Specification du nb de bits a utiliser dans le cadre
(  187) !   de la compression avec nb de bits constant
(  188) !   par groupe de pts de grille
(  189) !   
(  190)   ELSEIF (CDCLEF=='WIDPA'.OR.CDCLEF=='widpa') THEN
(  191)     IF (KVAL.LT.1-INBITSMAX.OR.KVAL.GT.INBITSMAX-1) THEN
(  192)       IREP=-97
(  193)       GOTO 1001
(  194)     ENDIF
(  195)     FA%NCODGRI(6)=KVAL
(  196) !
(  197) !   Demande supplementaire de l'extension generale de la compression
(  198) !   (si KVAL=1, sinon c'est le retrait de cette option)
(  199) !
(  200)   ELSEIF (CDCLEF=='GEXTE'.OR.CDCLEF=='gexte') THEN
(  201)     IF (KVAL.EQ.1) THEN
(  202)       FA%IOPTGRSX2O=1
(  203)       FA%NCODGRI(7)=8
(  204)     ELSE
(  205)       FA%NCODGRI(7)=0
(  206)     ENDIF
(  207) !
(  208) !   Demande supplementaire du rearrangement boustrophedonique dans la
(  209) !   compression (si KVAL=1, sinon c'est le retrait de cette option)
(  210) !
(  211)   ELSEIF (CDCLEF=='BOUST'.OR.CDCLEF=='boust') THEN
(  212)     IF (KVAL.EQ.1) THEN
(  213)       FA%IOPTGRSX2O=1
(  214)       FA%NCODGRI(8)=4
(  215)     ELSE
(  216)       FA%NCODGRI(8)=0
(  217)     ENDIF
(  218) !
(  219) !   Demande supplementaire de la difference spatiale dans la compression.
(  220) !   KVAL donne l'ordre de differentiation:
(  221) !   -1-> calcul dynamique par GRIBEX; 1 a 3->ordre; 0->desactiv; autre->err
(  222) !
(  223)   ELSEIF (CDCLEF=='DIFFE'.OR.CDCLEF=='diffe') THEN
(  224)     IF (KVAL.EQ.-1) THEN
(  225)       FA%IOPTGRSX2O=1
(  226)       FA%IOPTGRSN2O=1
(  227)       FA%NCODGRI( 9)=0
(  228)       FA%NCODGRI(10)=-1
(  229)     ELSEIF (KVAL.EQ.1) THEN
(  230)       FA%IOPTGRSX2O=1
(  231)       FA%IOPTGRSN2O=1






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 15

(  232)       FA%NCODGRI( 9)=0
(  233)       FA%NCODGRI(10)=1
(  234)     ELSEIF (KVAL.EQ.2) THEN
(  235)       FA%IOPTGRSX2O=1
(  236)       FA%IOPTGRSN2O=1
(  237)       FA%NCODGRI( 9)=2
(  238)       FA%NCODGRI(10)=0
(  239)     ELSEIF (KVAL.EQ.3) THEN
(  240)       FA%IOPTGRSX2O=1
(  241)       FA%IOPTGRSN2O=1
(  242)       FA%NCODGRI( 9)=2
(  243)       FA%NCODGRI(10)=1
(  244)     ELSEIF (KVAL.EQ.0) THEN
(  245)       FA%IOPTGRSX2O=0
(  246)       FA%NCODGRI( 9)=0
(  247)       FA%NCODGRI(10)=0
(  248)     ELSE
(  249)       IREP=-125
(  250)       GOTO 1001
(  251)     ENDIF
(  252) !
(  253) !   Facteur decimal; calcul automatique
(  254) !
(  255)   ELSEIF (CDCLEF=='FACDEC'.OR.CDCLEF=='facdec') THEN
(  256)     FA%NCODGRI(11)=KVAL
(  257) # 258 "faregi.F90"
(  258) !
(  259) !  Ecriture dans un fichier externe
(  260) !
(  261)   ELSEIF (CDCLEF=='EXTERN'.OR.CDCLEF=='extern') THEN
(  262)     FA%NCODGRI(12)=KVAL
(  263) !
(  264) !  Champs de surface uniquement; pas d'ecriture ni controle des niveaux verticaux
(  265) !
(  266)   ELSEIF (CDCLEF=='SURF'.OR.CDCLEF=='surf') THEN
(  267)     FA%NCODGRI(13)=KVAL
(  268) !
(  269) !  Tolerance sur le controle de cadre
(  270) !
(  271)   ELSEIF (CDCLEF=='ZEPS'.OR.CDCLEF=='zeps') THEN
(  272)     FA%NCODGRI(14)=KVAL
(  273)   ENDIF
(  274) !**
(  275) !     2.  -  DEMANDE D'INFORMATION
(  276) !-----------------------------------------------------------------------
(  277) !
(  278) ELSEIF (KOPT==0) THEN
(  279) !
(  280) !   Obtention des mots-clef disponibles
(  281) !
(  282)   IF (CDCLEF=='CLEFS'.OR.CDCLEF=='clefs') THEN
(  283)     KVAL=0
(  284)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  285)     WRITE (UNIT=FA%NULOUT,FMT=*) 'Mots clef disponibles pour FAREGI:'
(  286)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  287)     WRITE (UNIT=FA%NULOUT,FMT=*) 'BASIC: pas de compression'
(  288)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK1: BASIC avec une compression'
(  289)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ligne a ligne pour les pts de grille'






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 16

(  290)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK2: BASIC avec une compression'
(  291)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ou le nb de bits est cst pour les groupes'
(  292)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK3: BASIC avec une compression'
(  293)     WRITE (UNIT=FA%NULOUT,FMT=*) '       OMM general pour les points de grille'
(  294)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC1: compression agressive'
(  295)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC et PACK1 sont testes'
(  296)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC2: compression agressive'
(  297)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1 et PACK2 sont testes'
(  298)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC3: compression agressive'
(  299)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1 et PACK3 sont testes'
(  300)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC4: compression agressive'
(  301)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1, PACK2 et PACK3 testes'
(  302)     WRITE (UNIT=FA%NULOUT,FMT=*) 'WIDPA: lecture/ecriture du nb de bits'
(  303)     WRITE (UNIT=FA%NULOUT,FMT=*) '       a utiliser pour les groupes de points'
(  304)     WRITE (UNIT=FA%NULOUT,FMT=*) '       de grille dans le cas PACK2'
(  305)     WRITE (UNIT=FA%NULOUT,FMT=*) 'GEXTE: les extensions generales de la compression'
(  306)     WRITE (UNIT=FA%NULOUT,FMT=*) '       sont activees (KVAL=1) ou desactiv. (KVAL=0)'
(  307)     WRITE (UNIT=FA%NULOUT,FMT=*) 'BOUST: le rearrangement boustrophedonique est'
(  308)     WRITE (UNIT=FA%NULOUT,FMT=*) '       active (KVAL=1) ou desactive (KVAL=0)'
(  309)     WRITE (UNIT=FA%NULOUT,FMT=*) 'DIFFE: la differenciation spatiale est'
(  310)     WRITE (UNIT=FA%NULOUT,FMT=*) '       activee (KVAL=ordre de differ. (1 a 3)'
(  311)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ou -1 (calcul dyn)) ou desactivee (0)'
(  312)     WRITE (UNIT=FA%NULOUT,FMT=*) 'FACDEC: calcul automatique du facteur decimal'
(  313)     WRITE (UNIT=FA%NULOUT,FMT=*) 'EXTERN: ecriture dans un fichier externe'
(  314)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  315)   ELSEIF (CDCLEF=='IDCEN'.OR.CDCLEF=='idcen') THEN
(  316)     KVAL = FA%NIDCEN 
(  317) !
(  318) !   Lecture du nb de bits a utiliser dans le cadre
(  319) !   de la compression avec nb de bits constant
(  320) !   par groupe de pts de grille
(  321) !   
(  322)   ELSEIF (CDCLEF=='WIDPA'.OR.CDCLEF=='widpa') THEN
(  323)     KVAL=FA%NCODGRI(6)
(  324) !
(  325) !   Lecture de la presence ou non de la compression
(  326) !   "general extended"
(  327) !
(  328)   ELSEIF (CDCLEF=='GEXTE'.OR.CDCLEF=='gexte') THEN
(  329)     KVAL = FA%NCODGRI(7) / 8
(  330) !
(  331) !   Lecture de la presence ou non du rearrangement
(  332) !   boustrophedonique.
(  333) !
(  334)   ELSEIF (CDCLEF=='BOUST'.OR.CDCLEF=='boust') THEN
(  335)     KVAL = FA%NCODGRI(8) / 4
(  336) !
(  337) !   Lecture de la presence ou non de la differentiation spatiale
(  338) !
(  339)   ELSEIF (CDCLEF=='DIFFE'.OR.CDCLEF=='diffe') THEN
(  340)     KVAL=FA%NCODGRI( 9)+FA%NCODGRI(10)
(  341) !
(  342) !   Facteur decimal; calcul automatique
(  343) !
(  344)   ELSEIF (CDCLEF=='FACDEC'.OR.CDCLEF=='facdec') THEN
(  345)     KVAL=FA%NCODGRI(11)
(  346) !
(  347) !   Ecriture dans un fichier externe






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 17

(  348) !
(  349)   ELSEIF (CDCLEF=='EXTERN'.OR.CDCLEF=='extern') THEN
(  350)     KVAL=FA%NCODGRI(12)
(  351) !
(  352) !  Champs de surface uniquement; pas d'ecriture ni controle des niveaux verticaux
(  353) !
(  354)   ELSEIF (CDCLEF=='SURF'.OR.CDCLEF=='surf') THEN
(  355)     KVAL=FA%NCODGRI(13)
(  356)   ELSEIF (CDCLEF=='ZEPS'.OR.CDCLEF=='zeps') THEN
(  357)     KVAL=FA%NCODGRI(14)
(  358)   ELSE
(  359)     IREP=-125
(  360)     GOTO 1001
(  361)   ENDIF
(  362) !**
(  363) !     3.  -  OPTION INCONNUE
(  364) !-----------------------------------------------------------------------
(  365) !
(  366) ELSE
(  367)   IREP=-125
(  368)   GOTO 1001
(  369) ENDIF
(  370) !**
(  371) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  372) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  373) !-----------------------------------------------------------------------
(  374) !
(  375) 1001 CONTINUE
(  376) LLFATA=LLMOER (IREP,0_JPLIKB )
(  377) !
(  378) IF (LLFATA) THEN
(  379)   INIMES=2
(  380) ELSE
(  381)   INIMES=FA%NIMSGA
(  382) ENDIF
(  383) !
(  384) IF (INIMES.EQ.0)  THEN 
(  385)   IF (LHOOK) CALL DR_HOOK('FAREGI_MT',1,ZHOOK_HANDLE)
(  386)   RETURN
(  387) ENDIF
(  388) !
(  389) CLNSPR='FAREGI'
(  390) INUMER=JPNIIL
(  391) !
(  392) WRITE (UNIT=CLMESS,FMT='(''IREP='',I2,            &
(  393) &        '', CDCLEF='''''',A,'''''', KVAL='',I12, &
(  394) &        '', KOPT='',I4)')                        &
(  395) &        IREP,CDCLEF,KVAL,KOPT
(  396) INUMER=JPNIIL
(  397) CALL FAIPAR_MT64                                       &
(  398) &               (FA, INUMER,INIMES,IREP,LLFATA,CLMESS, &
(  399) &                CLNSPR,CLNSPR,.FALSE.)
(  400) !
(  401) IF (LHOOK) CALL DR_HOOK('FAREGI_MT',1,ZHOOK_HANDLE)
(  402) # 403 "faregi.F90"
(  403) CONTAINS
(  404) # 405 "faregi.F90"
(  405) # 1 ".D[27]/facom2.llmoer.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 18

(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,
(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 406 "faregi.F90"
(  406) # 407 "faregi.F90"
(  407) END SUBROUTINE FAREGI_MT64
(  408) # 411 "faregi.F90"
(  411) ! Oct-2012 P. Marguinaud 64b LFI
(  412) SUBROUTINE FAREGI64            &
(  413) &           (CDCLEF, KVAL, KOPT)
(  414) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  415) &                  FA_COM_DEFAULT_INIT,  &
(  416) &                  NEW_FA_DEFAULT
(  417) USE LFI_PRECISION
(  418) IMPLICIT NONE
(  419) ! Arguments
(  420) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  421) INTEGER (KIND=JPLIKB)  KVAL                                   ! INOUT
(  422) INTEGER (KIND=JPLIKB)  KOPT                                   ! IN   
(  423) # 424 "faregi.F90"
(  424) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  425) # 426 "faregi.F90"
(  426) CALL FAREGI_MT64                   &
(  427) &           (FA, CDCLEF, KVAL, KOPT)
(  428) # 429 "faregi.F90"
(  429) END SUBROUTINE FAREGI64
(  430) # 431 "faregi.F90"
(  431) SUBROUTINE FAREGI              &
(  432) &           (CDCLEF, KVAL, KOPT)
(  433) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  434) &                  FA_COM_DEFAULT_INIT,  &
(  435) &                  NEW_FA_DEFAULT
(  436) USE LFI_PRECISION
(  437) IMPLICIT NONE
(  438) ! Arguments
(  439) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  440) INTEGER (KIND=JPLIKM)  KVAL                                   ! INOUT
(  441) INTEGER (KIND=JPLIKM)  KOPT                                   ! IN   
(  442) # 443 "faregi.F90"
(  443) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  444) # 445 "faregi.F90"
(  445) CALL FAREGI_MT                     &
(  446) &           (FA, CDCLEF, KVAL, KOPT)
(  447) # 448 "faregi.F90"
(  448) END SUBROUTINE FAREGI
(  449) # 450 "faregi.F90"
(  450) SUBROUTINE FAREGI_MT               &
(  451) &           (FA, CDCLEF, KVAL, KOPT)
(  452) USE FA_MOD, ONLY : FA_COM






NVFORTRAN (Version     23.1)          02/24/2023  13:54:35      page 19

(  453) USE LFI_PRECISION
(  454) IMPLICIT NONE
(  455) ! Arguments
(  456) TYPE (FA_COM)          FA                                     ! INOUT
(  457) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  458) INTEGER (KIND=JPLIKM)  KVAL                                   ! INOUT
(  459) INTEGER (KIND=JPLIKM)  KOPT                                   ! IN   
(  460) ! Local integers
(  461) INTEGER (KIND=JPLIKB)  IVAL                                   ! INOUT
(  462) INTEGER (KIND=JPLIKB)  IOPT                                   ! IN   
(  463) ! Convert arguments
(  464) # 465 "faregi.F90"
(  465) IF (KOPT==1) THEN
(  466)   IVAL       = INT (      KVAL, JPLIKB)
(  467) ENDIF
(  468) IOPT       = INT (      KOPT, JPLIKB)
(  469) # 470 "faregi.F90"
(  470) CALL FAREGI_MT64                   &
(  471) &           (FA, CDCLEF, IVAL, IOPT)
(  472) # 473 "faregi.F90"
(  473) IF (KOPT==0) THEN
(  474)   KVAL       = INT (      IVAL, JPLIKM)
(  475) ENDIF
(  476) # 477 "faregi.F90"
(  477) END SUBROUTINE FAREGI_MT
(  478) # 479 "faregi.F90"
(  479) !INTF CDCLEF        IN                                                                 
(  480) !INTF KVAL          INOUT IN_IF=KOPT==1                  OUT_IF=KOPT==0                
(  481) !INTF KOPT          IN                                                                 
