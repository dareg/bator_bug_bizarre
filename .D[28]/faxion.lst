


NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: faxion.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FAXION_MT64                                           &
(    4) &                     (FA,  PCHAME, KPUISS, KDIMNC, KLCHAM, PMIN,  &
(    5) &                      PMAX, KNBITS, LDARPE, PECART, LDMLAM,       &
(    6) &                      KNOZPA, KSTROF, KTRONC, KXLOPA )
(    7) USE FA_MOD, ONLY : FA_COM
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !        Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   14) !     calcul de l'erreur totale par le codage GRIB
(   15) !     sur un champ en coefficients spectraux, en mode "complex packing".
(   16) !**
(   17) !    Arguments :
(   18) !    ( Tableau ) PCHAME (Entree) ==> Champ en coef. spectraux en entree;
(   19) !                KPUISS (Entree) ==> Puissance de laplacien a utiliser;
(   20) !                KDIMNC (Entree) ==> Taille de la zone non codee;
(   21) !                KLCHAM (Entree) ==> Longueur totale du champ en c.spx.;
(   22) !                PMIN   (Entree) ==> Minimum precalcule du champ module;
(   23) !                PMAX   (Entree) ==> Maximum      "      "    "     "  ;
(   24) !                KNBITS (Entree) ==> Nombre de bits par valeur a coder;
(   25) !                LDARPE (Entree) ==> Vrai si GRIB non standard;
(   26) !                PECART (Sortie) ==> Erreur relative maximum commise,
(   27) !                                    en valeur absolue;
(   28) !                LDMLAM (Entree) ==> Vrai si fichier aladin
(   29) !    (Tableau)   KNOZPA (Entree) ==> Nombre d'onde zonal maxi par parallele;
(   30) !                                    (du pole nord vers l'equateur seulement)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 3

(   31) !                KSTROF (Entree) ==> Sous-troncature non compactee EFFECTIVE (coef. spectraux)
(   32) !                KTRONC (Entree) ==> Troncature (NS pour Aladin)
(   33) !                KXLOPA (Entree) ==> Nombre maximum de longitudes par cercle de latitudes
(   34) !
(   35) !     Modifications
(   36) !     -------------
(   37) !
(   38) !  Juillet 1998, J. Clochard, SCEM/TTI/DAO:
(   39) !
(   40) !    -Le critere a minimiser est mis sous la forme de fonctions
(   41) !    -Pour le cas LDARPE=.TRUE., utilisation des memes gardes-fous
(   42) !     que dans CODEGA.
(   43) !
(   44) !  Septem. 2000, D. Paradis, SCEM/TTI/DEV:
(   45) !
(   46) !    -Ajustement de la puissance Dolby pour des nb d'onde (JN)
(   47) !     uniquement inferieurs a MIN(FA%MTRONC(),(FA%NXLOPA()-1)/3): on
(   48) !     s'affranchit de l'influence des grands nb d'onde sur des
(   49) !     grilles lineaires pour le choix du Dolby.
(   50) !
(   51) !  Mars 2003, R. El Khatib CNRM/GMAP:
(   52) !
(   53) !    -Optimisation : ISAMAX remplace par MAXLOC
(   54) !
(   55) !  March 2010: J. Masek - fix of precomputed optimal Laplacian power
(   56) !
(   57) !
(   58) TYPE(FA_COM) :: FA
(   59) INTEGER (KIND=JPLIKB) KPUISS, KDIMNC, KLCHAM, KNBITS, KSTROF
(   60) INTEGER (KIND=JPLIKB) KTRONC, KXLOPA
(   61) !
(   62) INTEGER (KIND=JPLIKB) KNOZPA (FA%JPXIND)
(   63) !
(   64) REAL (KIND=JPDBLR) PMIN, PMAX, PECART
(   65) REAL (KIND=JPDBLR) PCHAME(KLCHAM)
(   66) REAL (KIND=JPDBLR) ZERR  (KLCHAM)
(   67) REAL (KIND=JPDBLR) ZECART_LOC
(   68) !
(   69) LOGICAL LDARPE, LDMLAM
(   70) !
(   71) INTEGER (KIND=JPLIKB) JN, JIND, ISCALE, J
(   72) INTEGER (KIND=JPLIKB) INDICE, IPUISX, IOFF, IM
(   73) INTEGER (KIND=JPLIKB) INDLAP, IRAPOR, IPUISR
(   74) INTEGER (KIND=JPLIKB) IMLIM, IEXP, IMANT, IPUIS2
(   75) INTEGER (KIND=JPLIKB) IDEB, IFIN, ITRDOL, ILCHADO
(   76) INTEGER (KIND=JPLIKB) IEXP32, IMANT32
(   77) !
(   78) REAL (KIND=JPDBLR) ZREFER, ZDIFFR, ZCOMPA, ZAUXI1, ZAUXI2, ZS
(   79) 
(   80) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   81) 
(   82) IF (LHOOK) CALL DR_HOOK('FAXION_MT',0,ZHOOK_HANDLE)
(   83) !**
(   84) !     0.  -  INITIALISATIONS FAITES AU PREMIER APPEL DU SOUS-PROGRAMME.
(   85) !-----------------------------------------------------------------------
(   86) !
(   87) IF (FA%FAXION_LLPREA) THEN
(   88)   FA%FAXION_ZEPSIL=TINY(FA%FAXION_ZEPSIL)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 4

(   89)   FA%FAXION_ISCALX=99
(   90)   FA%FAXION_LLPREA=.FALSE.
(   91) ENDIF
(   92) !**
(   93) !     1.  -  CALCUL DIRECT, EN ESSAYANT DE MINIMISER LES OPERATIONS.
(   94) !            ( a l'aide des puissances precalculees dans FA%XLAP2D )
(   95) !-----------------------------------------------------------------------
(   96) !
(   97) IF (LDARPE) THEN
(   98) !
(   99)   ZDIFFR=PMAX-PMIN
(  100) !
(  101)   IF ( ZDIFFR .LE. FA%FAXION_ZEPSIL ) THEN
(  102)     ZAUXI1=MIN ( ABS (PMIN), ABS (PMAX) )
(  103)     IF ( ZAUXI1 .LE. FA%FAXION_ZEPSIL ) ZAUXI1=0._JPDBLR
(  104)     PMAX=SIGN (ZAUXI1,PMAX)
(  105)     PMIN=PMAX
(  106)     ZAUXI1=0._JPDBLR
(  107)     ZAUXI2=0._JPDBLR
(  108)   ELSE
(  109)     ZCOMPA=REAL (2**KNBITS-1, JPDBLR)
(  110)     ZAUXI1=ZCOMPA/ZDIFFR
(  111)     ZAUXI2=ZDIFFR/ZCOMPA
(  112)   ENDIF
(  113) !
(  114)   ZREFER=PMIN
(  115) !
(  116) ELSE
(  117) !
(  118)   CALL CONFI (PMIN,IEXP32,IMANT32,ZREFER)
(  119)   IEXP=IEXP32
(  120)   IMANT=IMANT32
(  121) 
(  122)   ZS = (PMAX-ZREFER)/(2**(KNBITS+1)-1)
(  123)   ZAUXI1=1._JPDBLR
(  124)   ZAUXI2=2._JPDBLR
(  125)   IF (ZS.NE.0._JPDBLR) ZS = LOG(ZS)/LOG(ZAUXI2) + ZAUXI2
(  126)   ISCALE = MIN(INT(ZS,JPLIKB),                 &
(  127) &               INT(ZS+SIGN(ZAUXI1,ZS),JPLIKB))
(  128)   ISCALE = MAX(-FA%FAXION_ISCALX,MIN(FA%FAXION_ISCALX,ISCALE))
(  129)   ZAUXI1 = ZAUXI2**(-ISCALE)
(  130)   ZAUXI2 = ZAUXI2**ISCALE
(  131) !
(  132) ENDIF
(  133) !
(  134) !  Calcul de la borne superieure de la plage des nb d'onde
(  135) !  servant pour l'ajustement du Dolby (borne inferieure=KSTROF)
(  136) !  valable uniquement dans le cas Arpege pour ne pas prendre
(  137) !  en compte les coeff spectraux relatifs aux nb d'onde non
(  138) !  quadratiques (grille lineaire).
(  139) !
(  140) IF (LDARPE.AND..NOT.LDMLAM) THEN
(  141)   ITRDOL = MIN ( KTRONC , (KXLOPA-1)/3 )
(  142)   ILCHADO = (ITRDOL+1)**2
(  143) ENDIF
(  144) !
(  145) IF (KPUISS.EQ.0) THEN
(  146) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 5

(  147)   IF (LDMLAM) THEN 
(  148) !$OMP PARALLEL DO PRIVATE(JN,JIND) IF(FA%LOPENMP)
(  149)     DO JN=0,KTRONC
(  150)     DO JIND=KNOZPA(2*JN+3),KNOZPA(2*JN+4)
(  151)     ZERR(JIND)=ZCRIT0(JIND)
(  152)     ENDDO
(  153)     ENDDO
(  154) !$OMP END PARALLEL DO
(  155)   ELSE
(  156)     DO J=KDIMNC+1,ILCHADO
(  157)     ZERR(J)=ZCRIT0(J)
(  158)     ENDDO
(  159)   ENDIF
(  160) !
(  161) ELSE
(  162)   IPUISX=ABS (KPUISS)
(  163) !
(  164)   IF (KPUISS.GT.0) THEN
(  165)     INDICE=1
(  166)   ELSE
(  167)     INDICE=0
(  168)   ENDIF
(  169) !
(  170)   IF (IPUISX.LE.FA%JPUILA) THEN
(  171) !
(  172) !        Dans ce cas precis, on pourrait aussi remplacer la division
(  173) !     par ZCOEFF par une multiplication par FA%XLAP2D(J,IPUISX,1-INDICE).
(  174) !     Il y aurait gain en calcul, mais reference memoire supplementaire.
(  175) !
(  176)     IF (LDMLAM) THEN
(  177) #ifndef RS6K
(  178) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  179) !$OMP&  IF(FA%LOPENMP)
(  180) #endif
(  181)       DO JN=1,KTRONC
(  182)       DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  183)       IOFF=JIND-KNOZPA(2*JN+3)
(  184)       IM=IOFF/4 
(  185)       INDLAP=((JN-1)*FA%JPXTRO)+IM
(  186)       ZERR(JIND)=ZCRITR(JIND,FA%XLAP2DA(INDLAP,IPUISX,INDICE))
(  187)       ENDDO
(  188)       ENDDO
(  189) #ifndef RS6K
(  190) !$OMP END PARALLEL DO
(  191) #endif
(  192)     ELSE
(  193)       DO J=KDIMNC+1,ILCHADO
(  194)       ZERR(J)=ZCRITR(J,FA%XLAP2D(J,IPUISX,INDICE))
(  195)       ENDDO
(  196)     ENDIF
(  197) !
(  198)   ELSEIF (IPUISX.LE.2*FA%JPUILA) THEN
(  199)     IPUIS2=IPUISX/2
(  200) !
(  201)     IF (IPUISX.EQ.2*IPUIS2) THEN
(  202) !
(  203)       IF (LDMLAM) THEN
(  204) #ifndef RS6K






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 6

(  205) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  206) !$OMP&  IF(FA%LOPENMP)
(  207) #endif
(  208)         DO JN=1,KTRONC
(  209)         DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  210)         IOFF=JIND-KNOZPA(2*JN+3)
(  211)         IM=IOFF/4 
(  212)         INDLAP=((JN-1)*FA%JPXTRO)+IM
(  213)         ZERR(JIND)=ZCRITR(JIND,                         &
(  214) &                   FA%XLAP2DA(INDLAP,IPUIS2,INDICE)**2)
(  215)         ENDDO
(  216)         ENDDO
(  217) #ifndef RS6K
(  218) !$OMP END PARALLEL DO
(  219) #endif
(  220)       ELSE
(  221)         DO J=KDIMNC+1,ILCHADO
(  222)         ZERR(J)=ZCRITR(J,FA%XLAP2D(J,IPUIS2,INDICE)**2)
(  223)         ENDDO
(  224)       ENDIF
(  225) !
(  226)     ELSE
(  227) !
(  228)     IF (LDMLAM) THEN
(  229) #ifndef RS6K
(  230) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  231) !$OMP&  IF(FA%LOPENMP)
(  232) #endif
(  233)        DO JN=1,KTRONC
(  234)        DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  235)         IOFF=JIND-KNOZPA(2*JN+3)
(  236)         IM=IOFF/4 
(  237)         INDLAP=((JN-1)*FA%JPXTRO)+IM
(  238)         ZERR(JIND)=ZCRITR(JIND,FA%XLAP2DA(INDLAP,FA%JPUILA,INDICE) &
(  239) &             *FA%XLAP2DA(INDLAP,IPUISX-FA%JPUILA,INDICE))
(  240)        ENDDO
(  241)        ENDDO
(  242) #ifndef RS6K
(  243) !$OMP END PARALLEL DO
(  244) #endif
(  245)     ELSE
(  246)         DO J=KDIMNC+1,ILCHADO
(  247)         ZERR(J)=ZCRITR(J,FA%XLAP2D(J,FA%JPUILA,INDICE) &
(  248) &             *FA%XLAP2D(J,IPUISX-FA%JPUILA,INDICE))
(  249)         ENDDO
(  250)     ENDIF
(  251) !
(  252)     ENDIF
(  253) !
(  254)   ELSE
(  255)     IRAPOR=1+(IPUISX-1)/FA%JPUILA
(  256)     IPUISR=IPUISX/IRAPOR
(  257) !
(  258)     IF (IPUISX.EQ.IRAPOR*IPUISR) THEN
(  259) !
(  260)       IF (LDMLAM) THEN
(  261) #ifndef RS6K
(  262) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 7

(  263) !$OMP&  IF(FA%LOPENMP)
(  264) #endif
(  265)         DO JN=1,KTRONC
(  266)         DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  267)         IOFF=JIND-KNOZPA(2*JN+3)
(  268)         IM=IOFF/4 
(  269)         INDLAP=((JN-1)*FA%JPXTRO)+IM
(  270)         ZERR(JIND)=ZCRITR(JIND,                          &
(  271) &               FA%XLAP2DA(INDLAP,IPUISR,INDICE)**IRAPOR)
(  272)         ENDDO
(  273)         ENDDO
(  274) #ifndef RS6K
(  275) !$OMP END PARALLEL DO
(  276) #endif
(  277)       ELSE
(  278)         DO J=KDIMNC+1,ILCHADO
(  279)         ZERR(J)=ZCRITR(J,FA%XLAP2D(J,IPUISR,INDICE)**IRAPOR)
(  280)         ENDDO
(  281)       ENDIF
(  282) !
(  283)     ELSE
(  284) !
(  285)      IF (LDMLAM) THEN
(  286) #ifndef RS6K
(  287) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  288) !$OMP&  IF(FA%LOPENMP)
(  289) #endif
(  290)         DO JN=1,KTRONC
(  291)         DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  292)         IOFF=JIND-KNOZPA(2*JN+3)
(  293)         IM=IOFF/4 
(  294)         INDLAP=((JN-1)*FA%JPXTRO)+IM
(  295)         ZERR(JIND)=ZCRITR(JIND,                                   &
(  296) &           FA%XLAP2DA(INDLAP,FA%JPUILA,INDICE)**(IRAPOR-1)        &
(  297) &          *FA%XLAP2DA(INDLAP,IPUISX-FA%JPUILA*(IRAPOR-1),INDICE))
(  298)         ENDDO
(  299)         ENDDO
(  300) #ifndef RS6K
(  301) !$OMP END PARALLEL DO
(  302) #endif
(  303)      ELSE
(  304)         DO J=KDIMNC+1,ILCHADO
(  305)         ZERR(J)=ZCRITR(J,                                      &
(  306) &             FA%XLAP2D(J,FA%JPUILA,INDICE)**(IRAPOR-1)        &
(  307) &            *FA%XLAP2D(J,IPUISX-FA%JPUILA*(IRAPOR-1),INDICE))
(  308)         ENDDO
(  309)       ENDIF
(  310) !
(  311)     ENDIF
(  312) !
(  313)   ENDIF
(  314) !
(  315) ENDIF
(  316) !
(  317) PECART=0._JPDBLR
(  318) IF (LDMLAM) THEN
(  319) !$OMP PARALLEL IF(FA%LOPENMP)                         &
(  320) !$OMP& PRIVATE(JN,IMLIM,IDEB,IFIN,JIND,ZECART_LOC)    &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 8

(  321) !$OMP& REDUCTION(+:PECART)
(  322) !$OMP DO
(  323)   DO JN=1,KTRONC
(  324)   IMLIM=KSTROF-JN
(  325)   IDEB=MAX(KNOZPA(2*JN+3)+4,KNOZPA(2*JN+3)+4*(1+IMLIM))
(  326)   IFIN=KNOZPA(2*JN+4)
(  327)   ZECART_LOC=0._JPDBLR
(  328)   DO JIND=IDEB,IFIN
(  329)     ZECART_LOC=ZECART_LOC+ZERR(JIND)
(  330)   ENDDO
(  331)   PECART=PECART+ZECART_LOC
(  332) !
(  333)   ENDDO
(  334) !$OMP END DO 
(  335) !$OMP END PARALLEL
(  336) ELSE
(  337)   DO J=KDIMNC+1,ILCHADO
(  338)     PECART=PECART+ZERR(J)
(  339)   ENDDO
(  340) ENDIF
(  341) !
(  342) IF (FA%LFAMOP) THEN
(  343)   IF (LDARPE.AND..NOT.LDMLAM) THEN
(  344)     WRITE (UNIT=FA%NULOUT,FMT=*)                                    &
(  345) &           'FAXION: KPUISS=', KPUISS,', KDIMNC=',KDIMNC,           &
(  346) &           ', KLCHAM=', KLCHAM, ', ITRDOL=', ITRDOL, ', ILCHADO=', &
(  347) &           ILCHADO, ', PMIN=', PMIN, ', PMAX=', PMAX
(  348)   ELSE
(  349)     WRITE (UNIT=FA%NULOUT,FMT=*)                          &
(  350) &           'FAXION: KPUISS=', KPUISS,', KDIMNC=',KDIMNC, &
(  351) &           ', KLCHAM=', KLCHAM,                          &
(  352) &           ', PMIN=', PMIN, ', PMAX=', PMAX
(  353)   ENDIF
(  354)   WRITE (UNIT=FA%NULOUT,FMT=*)'FAXION: PECART=', PECART
(  355) ENDIF
(  356) !
(  357) IF (LHOOK) CALL DR_HOOK('FAXION_MT',1,ZHOOK_HANDLE)
(  358) 
(  359) CONTAINS
(  360) 
(  361) REAL (KIND=JPDBLR) FUNCTION ZYPR (IZZZZZ, ZCOEFF)
(  362) INTEGER (KIND=JPLIKB) :: IZZZZZ
(  363) REAL (KIND=JPDBLR)    :: ZCOEFF
(  364) ZYPR = ZREFER + ZAUXI2 * ANINT (ZAUXI1 * (PCHAME(IZZZZZ)/ZCOEFF - ZREFER))
(  365) END FUNCTION
(  366) 
(  367) REAL (KIND=JPDBLR) FUNCTION ZYP0 (IZZZZZ)
(  368) INTEGER (KIND=JPLIKB) :: IZZZZZ
(  369) ZYP0 = ZREFER + ZAUXI2 * ANINT (ZAUXI1 * (PCHAME(IZZZZZ) - ZREFER))
(  370) END FUNCTION
(  371) 
(  372) !
(  373) !       Fonction "critere" a minimiser lorsque la modulation de la
(  374) !       puissance de laplacien est possible.
(  375) !
(  376) REAL (KIND=JPDBLR) FUNCTION ZCRITR (IZZZZZ, ZCOEFF)
(  377) INTEGER (KIND=JPLIKB) :: IZZZZZ
(  378) REAL (KIND=JPDBLR)    :: ZCOEFF






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 9

(  379) ZCRITR = (ZYPR(IZZZZZ,ZCOEFF)*ZCOEFF - PCHAME(IZZZZZ))**2
(  380) END FUNCTION
(  381) 
(  382) !
(  383) !       Meme chose, mais pour la puissance 0.
(  384) !
(  385) REAL (KIND=JPDBLR) FUNCTION ZCRIT0 (IZZZZZ)
(  386) INTEGER (KIND=JPLIKB) :: IZZZZZ
(  387) ZCRIT0 = (ZYP0(IZZZZZ) - PCHAME(IZZZZZ))**2
(  388) END FUNCTION
(  389) 
(  390) END SUBROUTINE
(  391) 
(  392) !INTF PCHAME        IN    DIMS=KLCHAM                   
(  393) !INTF KPUISS        IN                                  
(  394) !INTF KDIMNC        IN                                  
(  395) !INTF KLCHAM        IN                                  
(  396) !INTF PMIN          IN                                  
(  397) !INTF PMAX          IN                                  
(  398) !INTF KNBITS        IN                                  
(  399) !INTF LDARPE        IN                                  
(  400) !INTF PECART          OUT                               
(  401) !INTF LDMLAM        IN                                  
(  402) !INTF KNOZPA        IN    DIMS=FA%JPXIND                
(  403) !INTF KSTROF        IN                                  
(  404) !INTF KTRONC        IN                                  
(  405) !INTF KXLOPA        IN                                  





































NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 10

(    1) # 1 "faxion.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FAXION_MT64                                           &
(    4) &                     (FA,  PCHAME, KPUISS, KDIMNC, KLCHAM, PMIN,  &
(    5) &                      PMAX, KNBITS, LDARPE, PECART, LDMLAM,       &
(    6) &                      KNOZPA, KSTROF, KTRONC, KXLOPA )
(    7) USE FA_MOD, ONLY : FA_COM
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !        Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   14) !     calcul de l'erreur totale par le codage GRIB
(   15) !     sur un champ en coefficients spectraux, en mode "complex packing".
(   16) !**
(   17) !    Arguments :
(   18) !    ( Tableau ) PCHAME (Entree) ==> Champ en coef. spectraux en entree;
(   19) !                KPUISS (Entree) ==> Puissance de laplacien a utiliser;
(   20) !                KDIMNC (Entree) ==> Taille de la zone non codee;
(   21) !                KLCHAM (Entree) ==> Longueur totale du champ en c.spx.;
(   22) !                PMIN   (Entree) ==> Minimum precalcule du champ module;
(   23) !                PMAX   (Entree) ==> Maximum      "      "    "     "  ;
(   24) !                KNBITS (Entree) ==> Nombre de bits par valeur a coder;
(   25) !                LDARPE (Entree) ==> Vrai si GRIB non standard;
(   26) !                PECART (Sortie) ==> Erreur relative maximum commise,
(   27) !                                    en valeur absolue;
(   28) !                LDMLAM (Entree) ==> Vrai si fichier aladin
(   29) !    (Tableau)   KNOZPA (Entree) ==> Nombre d'onde zonal maxi par parallele;
(   30) !                                    (du pole nord vers l'equateur seulement)
(   31) !                KSTROF (Entree) ==> Sous-troncature non compactee EFFECTIVE (coef. spectraux)
(   32) !                KTRONC (Entree) ==> Troncature (NS pour Aladin)
(   33) !                KXLOPA (Entree) ==> Nombre maximum de longitudes par cercle de latitudes
(   34) !
(   35) !     Modifications
(   36) !     -------------
(   37) !
(   38) !  Juillet 1998, J. Clochard, SCEM/TTI/DAO:
(   39) !
(   40) !    -Le critere a minimiser est mis sous la forme de fonctions
(   41) !    -Pour le cas LDARPE=.TRUE., utilisation des memes gardes-fous
(   42) !     que dans CODEGA.
(   43) !
(   44) !  Septem. 2000, D. Paradis, SCEM/TTI/DEV:
(   45) !
(   46) !    -Ajustement de la puissance Dolby pour des nb d'onde (JN)
(   47) !     uniquement inferieurs a MIN(FA%MTRONC(),(FA%NXLOPA()-1)/3): on
(   48) !     s'affranchit de l'influence des grands nb d'onde sur des
(   49) !     grilles lineaires pour le choix du Dolby.
(   50) !
(   51) !  Mars 2003, R. El Khatib CNRM/GMAP:
(   52) !
(   53) !    -Optimisation : ISAMAX remplace par MAXLOC
(   54) !
(   55) !  March 2010: J. Masek - fix of precomputed optimal Laplacian power
(   56) !
(   57) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 11

(   58) TYPE(FA_COM) :: FA
(   59) INTEGER (KIND=JPLIKB) KPUISS, KDIMNC, KLCHAM, KNBITS, KSTROF
(   60) INTEGER (KIND=JPLIKB) KTRONC, KXLOPA
(   61) !
(   62) INTEGER (KIND=JPLIKB) KNOZPA (FA%JPXIND)
(   63) !
(   64) REAL (KIND=JPDBLR) PMIN, PMAX, PECART
(   65) REAL (KIND=JPDBLR) PCHAME(KLCHAM)
(   66) REAL (KIND=JPDBLR) ZERR  (KLCHAM)
(   67) REAL (KIND=JPDBLR) ZECART_LOC
(   68) !
(   69) LOGICAL LDARPE, LDMLAM
(   70) !
(   71) INTEGER (KIND=JPLIKB) JN, JIND, ISCALE, J
(   72) INTEGER (KIND=JPLIKB) INDICE, IPUISX, IOFF, IM
(   73) INTEGER (KIND=JPLIKB) INDLAP, IRAPOR, IPUISR
(   74) INTEGER (KIND=JPLIKB) IMLIM, IEXP, IMANT, IPUIS2
(   75) INTEGER (KIND=JPLIKB) IDEB, IFIN, ITRDOL, ILCHADO
(   76) INTEGER (KIND=JPLIKB) IEXP32, IMANT32
(   77) !
(   78) REAL (KIND=JPDBLR) ZREFER, ZDIFFR, ZCOMPA, ZAUXI1, ZAUXI2, ZS
(   79) # 80 "faxion.F90"
(   80) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   81) # 82 "faxion.F90"
(   82) IF (LHOOK) CALL DR_HOOK('FAXION_MT',0,ZHOOK_HANDLE)
(   83) !**
(   84) !     0.  -  INITIALISATIONS FAITES AU PREMIER APPEL DU SOUS-PROGRAMME.
(   85) !-----------------------------------------------------------------------
(   86) !
(   87) IF (FA%FAXION_LLPREA) THEN
(   88)   FA%FAXION_ZEPSIL=TINY(FA%FAXION_ZEPSIL)
(   89)   FA%FAXION_ISCALX=99
(   90)   FA%FAXION_LLPREA=.FALSE.
(   91) ENDIF
(   92) !**
(   93) !     1.  -  CALCUL DIRECT, EN ESSAYANT DE MINIMISER LES OPERATIONS.
(   94) !            ( a l'aide des puissances precalculees dans FA%XLAP2D )
(   95) !-----------------------------------------------------------------------
(   96) !
(   97) IF (LDARPE) THEN
(   98) !
(   99)   ZDIFFR=PMAX-PMIN
(  100) !
(  101)   IF ( ZDIFFR .LE. FA%FAXION_ZEPSIL ) THEN
(  102)     ZAUXI1=MIN ( ABS (PMIN), ABS (PMAX) )
(  103)     IF ( ZAUXI1 .LE. FA%FAXION_ZEPSIL ) ZAUXI1=0._JPDBLR
(  104)     PMAX=SIGN (ZAUXI1,PMAX)
(  105)     PMIN=PMAX
(  106)     ZAUXI1=0._JPDBLR
(  107)     ZAUXI2=0._JPDBLR
(  108)   ELSE
(  109)     ZCOMPA=REAL (2**KNBITS-1, JPDBLR)
(  110)     ZAUXI1=ZCOMPA/ZDIFFR
(  111)     ZAUXI2=ZDIFFR/ZCOMPA
(  112)   ENDIF
(  113) !
(  114)   ZREFER=PMIN
(  115) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 12

(  116) ELSE
(  117) !
(  118)   CALL CONFI (PMIN,IEXP32,IMANT32,ZREFER)
(  119)   IEXP=IEXP32
(  120)   IMANT=IMANT32
(  121) # 122 "faxion.F90"
(  122)   ZS = (PMAX-ZREFER)/(2**(KNBITS+1)-1)
(  123)   ZAUXI1=1._JPDBLR
(  124)   ZAUXI2=2._JPDBLR
(  125)   IF (ZS.NE.0._JPDBLR) ZS = LOG(ZS)/LOG(ZAUXI2) + ZAUXI2
(  126)   ISCALE = MIN(INT(ZS,JPLIKB),                 &
(  127) &               INT(ZS+SIGN(ZAUXI1,ZS),JPLIKB))
(  128)   ISCALE = MAX(-FA%FAXION_ISCALX,MIN(FA%FAXION_ISCALX,ISCALE))
(  129)   ZAUXI1 = ZAUXI2**(-ISCALE)
(  130)   ZAUXI2 = ZAUXI2**ISCALE
(  131) !
(  132) ENDIF
(  133) !
(  134) !  Calcul de la borne superieure de la plage des nb d'onde
(  135) !  servant pour l'ajustement du Dolby (borne inferieure=KSTROF)
(  136) !  valable uniquement dans le cas Arpege pour ne pas prendre
(  137) !  en compte les coeff spectraux relatifs aux nb d'onde non
(  138) !  quadratiques (grille lineaire).
(  139) !
(  140) IF (LDARPE.AND..NOT.LDMLAM) THEN
(  141)   ITRDOL = MIN ( KTRONC , (KXLOPA-1)/3 )
(  142)   ILCHADO = (ITRDOL+1)**2
(  143) ENDIF
(  144) !
(  145) IF (KPUISS.EQ.0) THEN
(  146) !
(  147)   IF (LDMLAM) THEN 
(  148) !$OMP PARALLEL DO PRIVATE(JN,JIND) IF(FA%LOPENMP)
(  149)     DO JN=0,KTRONC
(  150)     DO JIND=KNOZPA(2*JN+3),KNOZPA(2*JN+4)
(  151)     ZERR(JIND)=ZCRIT0(JIND)
(  152)     ENDDO
(  153)     ENDDO
(  154) !$OMP END PARALLEL DO
(  155)   ELSE
(  156)     DO J=KDIMNC+1,ILCHADO
(  157)     ZERR(J)=ZCRIT0(J)
(  158)     ENDDO
(  159)   ENDIF
(  160) !
(  161) ELSE
(  162)   IPUISX=ABS (KPUISS)
(  163) !
(  164)   IF (KPUISS.GT.0) THEN
(  165)     INDICE=1
(  166)   ELSE
(  167)     INDICE=0
(  168)   ENDIF
(  169) !
(  170)   IF (IPUISX.LE.FA%JPUILA) THEN
(  171) !
(  172) !        Dans ce cas precis, on pourrait aussi remplacer la division
(  173) !     par ZCOEFF par une multiplication par FA%XLAP2D(J,IPUISX,1-INDICE).






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 13

(  174) !     Il y aurait gain en calcul, mais reference memoire supplementaire.
(  175) !
(  176)     IF (LDMLAM) THEN
(  177) # 178 "faxion.F90"
(  178) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  179) !$OMP&  IF(FA%LOPENMP)
(  180) # 181 "faxion.F90"
(  181)       DO JN=1,KTRONC
(  182)       DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  183)       IOFF=JIND-KNOZPA(2*JN+3)
(  184)       IM=IOFF/4 
(  185)       INDLAP=((JN-1)*FA%JPXTRO)+IM
(  186)       ZERR(JIND)=ZCRITR(JIND,FA%XLAP2DA(INDLAP,IPUISX,INDICE))
(  187)       ENDDO
(  188)       ENDDO
(  189) # 190 "faxion.F90"
(  190) !$OMP END PARALLEL DO
(  191) # 192 "faxion.F90"
(  192)     ELSE
(  193)       DO J=KDIMNC+1,ILCHADO
(  194)       ZERR(J)=ZCRITR(J,FA%XLAP2D(J,IPUISX,INDICE))
(  195)       ENDDO
(  196)     ENDIF
(  197) !
(  198)   ELSEIF (IPUISX.LE.2*FA%JPUILA) THEN
(  199)     IPUIS2=IPUISX/2
(  200) !
(  201)     IF (IPUISX.EQ.2*IPUIS2) THEN
(  202) !
(  203)       IF (LDMLAM) THEN
(  204) # 205 "faxion.F90"
(  205) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  206) !$OMP&  IF(FA%LOPENMP)
(  207) # 208 "faxion.F90"
(  208)         DO JN=1,KTRONC
(  209)         DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  210)         IOFF=JIND-KNOZPA(2*JN+3)
(  211)         IM=IOFF/4 
(  212)         INDLAP=((JN-1)*FA%JPXTRO)+IM
(  213)         ZERR(JIND)=ZCRITR(JIND,                         &
(  214) &                   FA%XLAP2DA(INDLAP,IPUIS2,INDICE)**2)
(  215)         ENDDO
(  216)         ENDDO
(  217) # 218 "faxion.F90"
(  218) !$OMP END PARALLEL DO
(  219) # 220 "faxion.F90"
(  220)       ELSE
(  221)         DO J=KDIMNC+1,ILCHADO
(  222)         ZERR(J)=ZCRITR(J,FA%XLAP2D(J,IPUIS2,INDICE)**2)
(  223)         ENDDO
(  224)       ENDIF
(  225) !
(  226)     ELSE
(  227) !
(  228)     IF (LDMLAM) THEN
(  229) # 230 "faxion.F90"
(  230) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  231) !$OMP&  IF(FA%LOPENMP)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 14

(  232) # 233 "faxion.F90"
(  233)        DO JN=1,KTRONC
(  234)        DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  235)         IOFF=JIND-KNOZPA(2*JN+3)
(  236)         IM=IOFF/4 
(  237)         INDLAP=((JN-1)*FA%JPXTRO)+IM
(  238)         ZERR(JIND)=ZCRITR(JIND,FA%XLAP2DA(INDLAP,FA%JPUILA,INDICE) &
(  239) &             *FA%XLAP2DA(INDLAP,IPUISX-FA%JPUILA,INDICE))
(  240)        ENDDO
(  241)        ENDDO
(  242) # 243 "faxion.F90"
(  243) !$OMP END PARALLEL DO
(  244) # 245 "faxion.F90"
(  245)     ELSE
(  246)         DO J=KDIMNC+1,ILCHADO
(  247)         ZERR(J)=ZCRITR(J,FA%XLAP2D(J,FA%JPUILA,INDICE) &
(  248) &             *FA%XLAP2D(J,IPUISX-FA%JPUILA,INDICE))
(  249)         ENDDO
(  250)     ENDIF
(  251) !
(  252)     ENDIF
(  253) !
(  254)   ELSE
(  255)     IRAPOR=1+(IPUISX-1)/FA%JPUILA
(  256)     IPUISR=IPUISX/IRAPOR
(  257) !
(  258)     IF (IPUISX.EQ.IRAPOR*IPUISR) THEN
(  259) !
(  260)       IF (LDMLAM) THEN
(  261) # 262 "faxion.F90"
(  262) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  263) !$OMP&  IF(FA%LOPENMP)
(  264) # 265 "faxion.F90"
(  265)         DO JN=1,KTRONC
(  266)         DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  267)         IOFF=JIND-KNOZPA(2*JN+3)
(  268)         IM=IOFF/4 
(  269)         INDLAP=((JN-1)*FA%JPXTRO)+IM
(  270)         ZERR(JIND)=ZCRITR(JIND,                          &
(  271) &               FA%XLAP2DA(INDLAP,IPUISR,INDICE)**IRAPOR)
(  272)         ENDDO
(  273)         ENDDO
(  274) # 275 "faxion.F90"
(  275) !$OMP END PARALLEL DO
(  276) # 277 "faxion.F90"
(  277)       ELSE
(  278)         DO J=KDIMNC+1,ILCHADO
(  279)         ZERR(J)=ZCRITR(J,FA%XLAP2D(J,IPUISR,INDICE)**IRAPOR)
(  280)         ENDDO
(  281)       ENDIF
(  282) !
(  283)     ELSE
(  284) !
(  285)      IF (LDMLAM) THEN
(  286) # 287 "faxion.F90"
(  287) !$OMP PARALLEL DO PRIVATE(JN,JIND,IOFF,IM,INDLAP) &
(  288) !$OMP&  IF(FA%LOPENMP)
(  289) # 290 "faxion.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 15

(  290)         DO JN=1,KTRONC
(  291)         DO JIND=KNOZPA(2*JN+3)+4,KNOZPA(2*JN+4)
(  292)         IOFF=JIND-KNOZPA(2*JN+3)
(  293)         IM=IOFF/4 
(  294)         INDLAP=((JN-1)*FA%JPXTRO)+IM
(  295)         ZERR(JIND)=ZCRITR(JIND,                                   &
(  296) &           FA%XLAP2DA(INDLAP,FA%JPUILA,INDICE)**(IRAPOR-1)        &
(  297) &          *FA%XLAP2DA(INDLAP,IPUISX-FA%JPUILA*(IRAPOR-1),INDICE))
(  298)         ENDDO
(  299)         ENDDO
(  300) # 301 "faxion.F90"
(  301) !$OMP END PARALLEL DO
(  302) # 303 "faxion.F90"
(  303)      ELSE
(  304)         DO J=KDIMNC+1,ILCHADO
(  305)         ZERR(J)=ZCRITR(J,                                      &
(  306) &             FA%XLAP2D(J,FA%JPUILA,INDICE)**(IRAPOR-1)        &
(  307) &            *FA%XLAP2D(J,IPUISX-FA%JPUILA*(IRAPOR-1),INDICE))
(  308)         ENDDO
(  309)       ENDIF
(  310) !
(  311)     ENDIF
(  312) !
(  313)   ENDIF
(  314) !
(  315) ENDIF
(  316) !
(  317) PECART=0._JPDBLR
(  318) IF (LDMLAM) THEN
(  319) !$OMP PARALLEL IF(FA%LOPENMP)                         &
(  320) !$OMP& PRIVATE(JN,IMLIM,IDEB,IFIN,JIND,ZECART_LOC)    &
(  321) !$OMP& REDUCTION(+:PECART)
(  322) !$OMP DO
(  323)   DO JN=1,KTRONC
(  324)   IMLIM=KSTROF-JN
(  325)   IDEB=MAX(KNOZPA(2*JN+3)+4,KNOZPA(2*JN+3)+4*(1+IMLIM))
(  326)   IFIN=KNOZPA(2*JN+4)
(  327)   ZECART_LOC=0._JPDBLR
(  328)   DO JIND=IDEB,IFIN
(  329)     ZECART_LOC=ZECART_LOC+ZERR(JIND)
(  330)   ENDDO
(  331)   PECART=PECART+ZECART_LOC
(  332) !
(  333)   ENDDO
(  334) !$OMP END DO 
(  335) !$OMP END PARALLEL
(  336) ELSE
(  337)   DO J=KDIMNC+1,ILCHADO
(  338)     PECART=PECART+ZERR(J)
(  339)   ENDDO
(  340) ENDIF
(  341) !
(  342) IF (FA%LFAMOP) THEN
(  343)   IF (LDARPE.AND..NOT.LDMLAM) THEN
(  344)     WRITE (UNIT=FA%NULOUT,FMT=*)                                    &
(  345) &           'FAXION: KPUISS=', KPUISS,', KDIMNC=',KDIMNC,           &
(  346) &           ', KLCHAM=', KLCHAM, ', ITRDOL=', ITRDOL, ', ILCHADO=', &
(  347) &           ILCHADO, ', PMIN=', PMIN, ', PMAX=', PMAX






NVFORTRAN (Version     23.1)          02/24/2023  13:54:23      page 16

(  348)   ELSE
(  349)     WRITE (UNIT=FA%NULOUT,FMT=*)                          &
(  350) &           'FAXION: KPUISS=', KPUISS,', KDIMNC=',KDIMNC, &
(  351) &           ', KLCHAM=', KLCHAM,                          &
(  352) &           ', PMIN=', PMIN, ', PMAX=', PMAX
(  353)   ENDIF
(  354)   WRITE (UNIT=FA%NULOUT,FMT=*)'FAXION: PECART=', PECART
(  355) ENDIF
(  356) !
(  357) IF (LHOOK) CALL DR_HOOK('FAXION_MT',1,ZHOOK_HANDLE)
(  358) # 359 "faxion.F90"
(  359) CONTAINS
(  360) # 361 "faxion.F90"
(  361) REAL (KIND=JPDBLR) FUNCTION ZYPR (IZZZZZ, ZCOEFF)
(  362) INTEGER (KIND=JPLIKB) :: IZZZZZ
(  363) REAL (KIND=JPDBLR)    :: ZCOEFF
(  364) ZYPR = ZREFER + ZAUXI2 * ANINT (ZAUXI1 * (PCHAME(IZZZZZ)/ZCOEFF - ZREFER))
(  365) END FUNCTION
(  366) # 367 "faxion.F90"
(  367) REAL (KIND=JPDBLR) FUNCTION ZYP0 (IZZZZZ)
(  368) INTEGER (KIND=JPLIKB) :: IZZZZZ
(  369) ZYP0 = ZREFER + ZAUXI2 * ANINT (ZAUXI1 * (PCHAME(IZZZZZ) - ZREFER))
(  370) END FUNCTION
(  371) # 372 "faxion.F90"
(  372) !
(  373) !       Fonction "critere" a minimiser lorsque la modulation de la
(  374) !       puissance de laplacien est possible.
(  375) !
(  376) REAL (KIND=JPDBLR) FUNCTION ZCRITR (IZZZZZ, ZCOEFF)
(  377) INTEGER (KIND=JPLIKB) :: IZZZZZ
(  378) REAL (KIND=JPDBLR)    :: ZCOEFF
(  379) ZCRITR = (ZYPR(IZZZZZ,ZCOEFF)*ZCOEFF - PCHAME(IZZZZZ))**2
(  380) END FUNCTION
(  381) # 382 "faxion.F90"
(  382) !
(  383) !       Meme chose, mais pour la puissance 0.
(  384) !
(  385) REAL (KIND=JPDBLR) FUNCTION ZCRIT0 (IZZZZZ)
(  386) INTEGER (KIND=JPLIKB) :: IZZZZZ
(  387) ZCRIT0 = (ZYP0(IZZZZZ) - PCHAME(IZZZZZ))**2
(  388) END FUNCTION
(  389) # 390 "faxion.F90"
(  390) END SUBROUTINE
(  391) # 392 "faxion.F90"
(  392) !INTF PCHAME        IN    DIMS=KLCHAM                   
(  393) !INTF KPUISS        IN                                  
(  394) !INTF KDIMNC        IN                                  
(  395) !INTF KLCHAM        IN                                  
(  396) !INTF PMIN          IN                                  
(  397) !INTF PMAX          IN                                  
(  398) !INTF KNBITS        IN                                  
(  399) !INTF LDARPE        IN                                  
(  400) !INTF PECART          OUT                               
(  401) !INTF LDMLAM        IN                                  
(  402) !INTF KNOZPA        IN    DIMS=FA%JPXIND                
(  403) !INTF KSTROF        IN                                  
(  404) !INTF KTRONC        IN                                  
(  405) !INTF KXLOPA        IN                                  



