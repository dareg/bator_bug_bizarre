


NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: faregu.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FAREGU_MT64                                 &
(    4) &                     (FA,  KNUMER, CDCLEF, KVAL, KOPT)
(    5) USE FA_MOD, ONLY : FA_COM
(    6) USE PARKIND1, ONLY : JPRB
(    7) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    8) USE LFI_PRECISION
(    9) IMPLICIT NONE
(   10) !****
(   11) !      Ce sous-programme controle (lecture/ecriture) les options
(   12) !      de compression de GRIBEX, pour chacune des unites logiques et
(   13) !      certains descripteurs GRIB communs a l'unite logique.
(   14) !      (REGLAGE des options de codage de gribex pour une Unite)
(   15) !**
(   16) !    Arguments : KNUMER (Entree) ==> Numero de l'unite logique;
(   17) !                CDCLEF (Entree) ==> Mot clef precisant l'action a faire;
(   18) !                KVAL   (Sortie  ==> Valeur lue ou a ecrire;
(   19) !                      ou Entree)
(   20) !                KOPT   (Entree) ==> Flag: 0->lecture 1->ecriture;
(   21) !*
(   22) !     Signification des divers elements du tableau NCOGRIF
(   23) !
(   24) !     NCOGRIF(1) = type de codage (0->option HOPER='C'
(   25) !                               1->option HOPER='K')
(   26) !     NCOGRIF(2) = KSEC4(6), indicateur de la presence de flags
(   27) !               additionnels (0->non; 16->oui)
(   28) !     NCOGRIF(3) = KSEC4(7)
(   29) !     NCOGRIF(4) = KSEC4(9), indicateur de la presence de bitmaps
(   30) !               secondaires (0->non; 32->oui)






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 3

(   31) !     NCOGRIF(5) = KSEC4(10), indicateur pour le nb de bits des
(   32) !               groupes de pts de grille (0->const.; 16->different)
(   33) !     NCOGRIF(6) = KSEC4(11), nb de bits pour les groupes de pts de grille
(   34) !               quand il est constant.
(   35) !               Si negatif, le logiciel calcule un nb optimal a partir
(   36) !               de -KSEC4(11).
(   37) !     NCOGRIF(7) = KSEC4(12), indicateur pour les extensions generales de
(   38) !               la compression (0->non; 8->oui)
(   39) !     NCOGRIF(8) = KSEC4(13), indicateur pour le rearrangement boustrophedo
(   40) !               nique (0->non; 4->oui)
(   41) !     NCOGRIF(9) = KSEC4(14) (valeurs possibles: -1, 0 et 2)
(   42) !     NCOGRIF(10) = KSEC4(15) (valeurs possibles: -1, 0 et 1), sert avec
(   43) !                KSEC4(14) a definir la technique de la difference
(   44) !                spatiale. Si l'un des 2 est negatif, l'ordre de
(   45) !                differentiation est estime dynamiquement, sinon
(   46) !                l'ordre = KSEC4(14)+KSEC4(15)
(   47) !     NCOGRIF(11) = 1->Calcul automatique de KSEC1 (23), 0->On laisse faire
(   48) !     NCODGRI(12) = Ecriture des champs GRIB1 dans un fichier externe
(   49) !
(   50) !
(   51) !
(   52) TYPE(FA_COM) :: FA
(   53) INTEGER (KIND=JPLIKB) KNUMER, KVAL, KOPT
(   54) !
(   55) CHARACTER(LEN=*) CDCLEF
(   56) !
(   57) INTEGER (KIND=JPLIKB) IRANG, INIMES, IREP, INBITSMAX
(   58) !
(   59) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   60) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   61) LOGICAL                  LLFATA
(   62) 
(   63) !
(   64) !**
(   65) !     0.  -  INITIALISATIONS ET ALLOCATIONS PREALABLES
(   66) !-----------------------------------------------------------------------
(   67) !
(   68) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   69) IF (LHOOK) CALL DR_HOOK('FAREGU_MT',0,ZHOOK_HANDLE)
(   70) IREP=0
(   71) !
(   72) CALL FANUMU_MT64                 &
(   73) &               (FA, KNUMER,IRANG)
(   74) !
(   75) IF (IRANG.EQ.0) THEN
(   76)   IREP=-51
(   77)   GOTO 1001
(   78) ENDIF
(   79) !
(   80) ! Appel prealable a FAISC1 pour initialiser FA%NSEC1(2:21,IRANG).
(   81) ! On le fait ici plutot que dans FAINIG pour ne pas ecraser
(   82) ! les eventuelles modifs apportees par IDCEN et/ou IDMOD
(   83) !
(   84) IF (FA%FICHIER(IRANG)%LISEC1) THEN
(   85)   CALL FAISC1_MT64              &
(   86) &                (FA, IREP,IRANG)
(   87)   IF (IREP.NE.0) THEN
(   88)     WRITE (UNIT=FA%NULOUT,FMT=*) &






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 4

(   89) &           'FAREGU: ERROR ',IREP,' dans appel a FAISC1 !!'
(   90)     GOTO 1001
(   91)   ENDIF
(   92)   FA%FICHIER(IRANG)%LISEC1=.FALSE.
(   93) ENDIF
(   94) !
(   95) INBITSMAX=MAX(FA%FICHIER(IRANG)%NBFPDG,FA%FICHIER(IRANG)%NBFCSP)
(   96) !**
(   97) !     1.  -  SPECIFICATION D'UN NOUVEAU CODAGE
(   98) !-----------------------------------------------------------------------
(   99) !
(  100) IF (KOPT==1) THEN
(  101) !
(  102) !   Pas de compression (sous-tronc et puissance laplacien ajoutees
(  103) !   systematiquement + tard pour les coeff spectraux)
(  104) !
(  105)   IF (CDCLEF=='BASIC'.OR.CDCLEF=='basic') THEN
(  106)     FA%FICHIER(IRANG)%NCOGRIF(1)=0
(  107)     FA%FICHIER(IRANG)%NCOGRIF(2)=0
(  108)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  109)     FA%FICHIER(IRANG)%NCOGRIF(4)=0
(  110)     FA%FICHIER(IRANG)%NCOGRIF(5)=0
(  111)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  112) !
(  113) !   Comme le "BASIC" avec une compression
(  114) !   ligne a ligne pour les points de grille
(  115) !
(  116)   ELSEIF (CDCLEF=='PACK1'.OR.CDCLEF=='pack1') THEN
(  117)     FA%FICHIER(IRANG)%NCOGRIF(1)=0
(  118)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  119)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  120)     FA%FICHIER(IRANG)%NCOGRIF(4)=0
(  121)     FA%FICHIER(IRANG)%NCOGRIF(5)=16
(  122)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  123) !
(  124) !   Comme le "BASIC" avec une compression
(  125) !   pour les points de grille ou le nb de bits est le meme
(  126) !   dans chaque groupe de points de grille
(  127) !
(  128)   ELSEIF (CDCLEF=='PACK2'.OR.CDCLEF=='pack2') THEN
(  129)     FA%FICHIER(IRANG)%NCOGRIF(1)=0
(  130)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  131)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  132)     FA%FICHIER(IRANG)%NCOGRIF(4)=32
(  133)     FA%FICHIER(IRANG)%NCOGRIF(5)=0
(  134) ! Un nb de bits optimal sera recherche par le logiciel
(  135)     FA%FICHIER(IRANG)%NCOGRIF(6)=-99
(  136) !
(  137) !   Comme le "BASIC" avec une compression general OMM
(  138) !   pour les points de grille
(  139) !
(  140)   ELSEIF (CDCLEF=='PACK3'.OR.CDCLEF=='pack3') THEN
(  141)     FA%FICHIER(IRANG)%NCOGRIF(1)=0
(  142)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  143)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  144)     FA%FICHIER(IRANG)%NCOGRIF(4)=32
(  145)     FA%FICHIER(IRANG)%NCOGRIF(5)=16
(  146)     FA%FICHIER(IRANG)%NCOGRIF(6)=0






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 5

(  147) !
(  148) !   Compression "aggressive": le logiciel va
(  149) !   tenter la compression ligne a ligne puis l'absence
(  150) !   de compression et retenir la meilleure methode
(  151) !
(  152)   ELSEIF (CDCLEF=='APAC1'.OR.CDCLEF=='apac1') THEN
(  153)     FA%FICHIER(IRANG)%NCOGRIF(1)=1
(  154)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  155)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  156)     FA%FICHIER(IRANG)%NCOGRIF(4)=0
(  157)     FA%FICHIER(IRANG)%NCOGRIF(5)=16
(  158)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  159) !
(  160) !   Compression "aggressive": le logiciel va
(  161) !   tenter la compression type "APAC1" puis celle avec le nb de bits
(  162) !   constant par groupe de pts de grille et retenir la meilleure
(  163) !
(  164)   ELSEIF (CDCLEF=='APAC2'.OR.CDCLEF=='apac2') THEN
(  165)     FA%FICHIER(IRANG)%NCOGRIF(1)=1
(  166)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  167)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  168)     FA%FICHIER(IRANG)%NCOGRIF(4)=0
(  169)     FA%FICHIER(IRANG)%NCOGRIF(5)=0
(  170) ! Un nb de bits optimal sera recherche par le logiciel
(  171)     FA%FICHIER(IRANG)%NCOGRIF(6)=-99
(  172) !
(  173) !   Compression "aggressive": le logiciel va tenter
(  174) !   la compression type "APAC1" puis la compression generale
(  175) !   OMM et retenir la meilleure
(  176) !
(  177)   ELSEIF (CDCLEF=='APAC3'.OR.CDCLEF=='apac3') THEN
(  178)     FA%FICHIER(IRANG)%NCOGRIF(1)=1
(  179)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  180)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  181)     FA%FICHIER(IRANG)%NCOGRIF(4)=32
(  182)     FA%FICHIER(IRANG)%NCOGRIF(5)=16
(  183)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  184) !
(  185) !   Compression "aggressive": le logiciel va
(  186) !   tenter la compression type "APAC3" puis celle avec le nb de bits
(  187) !   constant par groupe de pts de grille et retenir la meilleure
(  188) !
(  189)   ELSEIF (CDCLEF=='APAC4'.OR.CDCLEF=='apac4') THEN
(  190)     FA%FICHIER(IRANG)%NCOGRIF(1)=1
(  191)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  192)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  193)     FA%FICHIER(IRANG)%NCOGRIF(4)=32
(  194)     FA%FICHIER(IRANG)%NCOGRIF(5)=0
(  195) ! Un nb de bits optimal sera recherche par le logiciel
(  196)     FA%FICHIER(IRANG)%NCOGRIF(6)=-99
(  197) !
(  198) !   Specification du nb de bits a utiliser dans le cadre
(  199) !   de la compression avec nb de bits constant
(  200) !   par groupe de pts de grille
(  201) !   
(  202)   ELSEIF (CDCLEF=='WIDPA'.OR.CDCLEF=='widpa') THEN
(  203)     IF (KVAL.LT.1-INBITSMAX.OR.KVAL.GT.INBITSMAX-1) THEN
(  204)       IREP=-97






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 6

(  205)       WRITE (UNIT=FA%NULOUT,FMT='(A)')'Dans FAREGU, action WIDPA:'
(  206)       WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)')                       &
(  207) &   '!!  ERREUR  !! Valeur incorrecte, non prise en compte: ',KVAL
(  208)       GOTO 1001
(  209)     ENDIF
(  210)     FA%FICHIER(IRANG)%NCOGRIF(6)=KVAL
(  211) !
(  212) !   Demande supplementaire de la compression avec extension
(  213) !   generale a la norme OMM (si KVAL=1, sinon c'est le retrait de l'option)
(  214) !
(  215)   ELSEIF (CDCLEF=='GEXTE'.OR.CDCLEF=='gexte') THEN
(  216)     IF (KVAL.EQ.1) THEN
(  217)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  218)       FA%FICHIER(IRANG)%NCOGRIF(7)=8
(  219)     ELSE
(  220)       FA%FICHIER(IRANG)%NCOGRIF(7)=0
(  221)     ENDIF
(  222) !
(  223) !   Demande supplementaire du rearrangement boustrophedonique dans la compression
(  224) !   (si KVAL=1, sinon c'est le retrait de cette option)
(  225) !
(  226)   ELSEIF (CDCLEF=='BOUST'.OR.CDCLEF=='boust') THEN
(  227)     IF (KVAL.EQ.1) THEN
(  228)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  229)       FA%FICHIER(IRANG)%NCOGRIF(8)=4
(  230)     ELSE
(  231)       FA%FICHIER(IRANG)%NCOGRIF(8)=0
(  232)     ENDIF
(  233) !
(  234) !   Demande supplementaire de la difference spatiale dans la
(  235) !   compression. KVAL donne l'ordre de differentiation
(  236) !   (-1-> calcul dynamique par GRIBEX; 1 a 3->ordre; 0->desactiv; autre->err)
(  237) !
(  238)   ELSEIF (CDCLEF=='DIFFE'.OR.CDCLEF=='diffe') THEN
(  239)     IF (KVAL.EQ.-1) THEN
(  240)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  241)       FA%FICHIER(IRANG)%IOPTGRSN2O=1
(  242)       FA%FICHIER(IRANG)%NCOGRIF( 9)=0
(  243)       FA%FICHIER(IRANG)%NCOGRIF(10)=-1
(  244)     ELSEIF (KVAL.EQ.1) THEN
(  245)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  246)       FA%FICHIER(IRANG)%IOPTGRSN2O=1
(  247)       FA%FICHIER(IRANG)%NCOGRIF( 9)=0
(  248)       FA%FICHIER(IRANG)%NCOGRIF(10)=1
(  249)     ELSEIF (KVAL.EQ.2) THEN
(  250)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  251)       FA%FICHIER(IRANG)%IOPTGRSN2O=1
(  252)       FA%FICHIER(IRANG)%NCOGRIF( 9)=2
(  253)       FA%FICHIER(IRANG)%NCOGRIF(10)=0
(  254)     ELSEIF (KVAL.EQ.3) THEN
(  255)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  256)       FA%FICHIER(IRANG)%IOPTGRSN2O=1
(  257)       FA%FICHIER(IRANG)%NCOGRIF( 9)=2
(  258)       FA%FICHIER(IRANG)%NCOGRIF(10)=1
(  259)     ELSEIF (KVAL.EQ.0) THEN
(  260)       FA%FICHIER(IRANG)%IOPTGRSX2O=0
(  261)       FA%FICHIER(IRANG)%NCOGRIF( 9)=0
(  262)       FA%FICHIER(IRANG)%NCOGRIF(10)=0






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 7

(  263)     ELSE
(  264)       IREP=-125
(  265)       WRITE (UNIT=FA%NULOUT,FMT='(A)')    &
(  266) &             'Dans FAREGU, action DIFFE:'
(  267)       WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)')                       &
(  268) &   '!!  ERREUR  !! Valeur incorrecte, non prise en compte: ',KVAL
(  269)       GOTO 1001
(  270)     ENDIF
(  271) !
(  272) !   Specification de l'identificateur du centre meteo (defaut=85 pour
(  273) !   Toulouse; pour Reading, il vaut 98). Sera utilise pour initialiser
(  274) !   KSEC1(2), le 2ieme elt de la section 1 de GRIBEX
(  275) !
(  276)   ELSEIF (CDCLEF=='IDCEN'.OR.CDCLEF=='idcen') THEN
(  277)     IF (KVAL.LT.7.OR.KVAL.GT.99) THEN
(  278)       IREP=-125
(  279)       WRITE (UNIT=FA%NULOUT,FMT='(A)')    &
(  280) &             'Dans FAREGU, action IDCEN:'
(  281)       WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)') &
(  282) &   '!!  ERREUR  !! Valeur incorrecte, non prise en compte: ',KVAL
(  283)       GOTO 1001
(  284)     ENDIF
(  285)     FA%FICHIER(IRANG)%NSEC1(2) = KVAL
(  286)     FA%FICHIER(IRANG)%NIDCEN   = KVAL
(  287) 
(  288) !
(  289) !   Specification de l'identificateur de modele.
(  290) !   FAISC1 initialise automatiquement a
(  291) !      177 pour ALADIN
(  292) !      211 pour les previsions ARPEGE
(  293) !      201 pour les analyses ARPEGE
(  294) !   Sera utilise pour initialiser KSEC1(3).
(  295) !
(  296)   ELSEIF (CDCLEF=='IDMOD'.OR.CDCLEF=='idmod') THEN
(  297)     IF (KVAL.LT.0.OR.KVAL.GT.255) THEN
(  298)       IREP=-125
(  299)       WRITE (UNIT=FA%NULOUT,FMT='(A)')    &
(  300) &             'Dans FAREGU, action IDMOD:'
(  301)       WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)') &
(  302) &   '!!  ERREUR  !! Valeur incorrecte, non prise en compte: ',KVAL
(  303)       GOTO 1001
(  304)     ENDIF
(  305)     FA%FICHIER(IRANG)%NSEC1(3)=KVAL
(  306)   ELSEIF (CDCLEF (1:MIN (7, LEN (CDCLEF)))=='CMODEL=') THEN
(  307)     FA%FICHIER(IRANG)%CMODEL = CDCLEF (8:)
(  308) !
(  309) !   Facteur decimal; calcul automatique
(  310) !
(  311)   ELSEIF (CDCLEF=='FACDEC'.OR.CDCLEF=='facdec') THEN
(  312)     FA%FICHIER(IRANG)%NCOGRIF(11)=KVAL
(  313) !
(  314) !   Ecriture dans un fichier externe
(  315) !
(  316)   ELSEIF (CDCLEF=='EXTERN'.OR.CDCLEF=='extern') THEN
(  317)     FA%FICHIER(IRANG)%NCOGRIF(12)=KVAL
(  318)   ELSE
(  319)     IREP=-125
(  320)     WRITE (UNIT=FA%NULOUT,FMT='(A)') &






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 8

(  321) &     '!!  ERREUR  !! Dans FAREGU, action inconnue: '//CDCLEF
(  322)     GOTO 1001
(  323)   ENDIF
(  324) !**
(  325) !     2.  -  DEMANDE D'INFORMATION
(  326) !-----------------------------------------------------------------------
(  327) !
(  328) ELSEIF (KOPT==0) THEN
(  329) !
(  330) !   Obtention des mots-clef disponibles
(  331) !
(  332)   IF (CDCLEF=='CLEFS'.OR. CDCLEF=='clefs' .OR. &
(  333) &      CDCLEF=='HELP' .OR. CDCLEF=='help') THEN
(  334)     KVAL=0
(  335)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  336)     WRITE (UNIT=FA%NULOUT,FMT=*) 'Mots clef disponibles pour FAREGU:'
(  337)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  338)     WRITE (UNIT=FA%NULOUT,FMT=*) 'BASIC: pas de compression'
(  339)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK1: BASIC avec une compression'
(  340)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ligne a ligne pour les pts de grille'
(  341)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK2: BASIC avec une compression avec'
(  342)     WRITE (UNIT=FA%NULOUT,FMT=*) '       nb de bits cst pour les groupes'
(  343)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK3: BASIC avec une compression generale'
(  344)     WRITE (UNIT=FA%NULOUT,FMT=*) '       OMM pour les points de grille'
(  345)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC1: compression agressive:'
(  346)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC et PACK1 sont testes'
(  347)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC2: compression agressive:'
(  348)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1 et PACK2 sont testes'
(  349)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC3: compression agressive:'
(  350)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1 et PACK3 sont testes'
(  351)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC4: compression agressive:'
(  352)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1, PACK2 et PACK3 testes'
(  353)     WRITE (UNIT=FA%NULOUT,FMT=*) 'WIDPA: lecture/ecriture du nb de bits'
(  354)     WRITE (UNIT=FA%NULOUT,FMT=*) '       a utiliser pour les groupes de points'
(  355)     WRITE (UNIT=FA%NULOUT,FMT=*) '       de grille dans le cas PACK2'
(  356)     WRITE (UNIT=FA%NULOUT,FMT=*) 'GEXTE: la compression avec extensions generales'
(  357)     WRITE (UNIT=FA%NULOUT,FMT=*) '       activees (KVAL=1) ou desactivees (KVAL=0)'
(  358)     WRITE (UNIT=FA%NULOUT,FMT=*) 'BOUST: le rearrangement boustrophedonique est'
(  359)     WRITE (UNIT=FA%NULOUT,FMT=*) '       active (KVAL=1) ou desactive (KVAL=0)'
(  360)     WRITE (UNIT=FA%NULOUT,FMT=*) 'DIFFE: la differenciation spatiale est'
(  361)     WRITE (UNIT=FA%NULOUT,FMT=*) '       activee (KVAL=ordre de differ. (1 a 3)'
(  362)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ou -1 (calcul dyn)) ou desactivee (0)'
(  363)     WRITE (UNIT=FA%NULOUT,FMT=*) 'IDCEN: lect/ecriture de l''identificateur du'
(  364)     WRITE (UNIT=FA%NULOUT,FMT=*) '       centre meteo'
(  365)     WRITE (UNIT=FA%NULOUT,FMT=*) 'IDMOD: lect/ecriture de l''identificateur du'
(  366)     WRITE (UNIT=FA%NULOUT,FMT=*) '       modele'
(  367)     WRITE (UNIT=FA%NULOUT,FMT=*) 'CMODEL: lect/ecriture de l''identificateur du'
(  368)     WRITE (UNIT=FA%NULOUT,FMT=*) '        modele'
(  369)     WRITE (UNIT=FA%NULOUT,FMT=*) 'FACDEC: calcul automatique du facteur decimal'
(  370)     WRITE (UNIT=FA%NULOUT,FMT=*) 'EXTERN: ecriture dans un fichier externe'
(  371)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  372) !
(  373) !   Lecture du nb de bits a utiliser dans le cadre
(  374) !   de la compression avec nb de bits
(  375) !   constant par groupe de pts de grille
(  376) !   
(  377)   ELSEIF (CDCLEF=='WIDPA'.OR.CDCLEF=='widpa') THEN
(  378)     KVAL=FA%FICHIER(IRANG)%NCOGRIF(6)






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 9

(  379) !
(  380) !   Lecture de la presence ou non de la compression
(  381) !   "general extended"
(  382) !
(  383)   ELSEIF (CDCLEF=='GEXTE'.OR.CDCLEF=='gexte') THEN
(  384)     KVAL = FA%FICHIER(IRANG)%NCOGRIF(7)/8
(  385) !
(  386) !   Lecture de la presence ou non du rearrangement
(  387) !   boustrophedonique.
(  388) !
(  389)   ELSEIF (CDCLEF=='BOUST'.OR.CDCLEF=='boust') THEN
(  390)     KVAL = FA%FICHIER(IRANG)%NCOGRIF(8)/4
(  391) !
(  392) !   Lecture de la presence ou non de la differentiation spatiale
(  393) !
(  394)   ELSEIF (CDCLEF=='DIFFE'.OR.CDCLEF=='diffe') THEN
(  395)     KVAL=FA%FICHIER(IRANG)%NCOGRIF( 9)+FA%FICHIER(IRANG)%NCOGRIF(10)
(  396) !
(  397) !   Lecture de l'identificateur du centre meteo (defaut=85 pour
(  398) !   Toulouse; pour Reading, il vaut 98). Sera utilise pour initialiser
(  399) !   KSEC1(2), le 2ieme elt de la section 1 de GRIBEX
(  400) !
(  401)   ELSEIF (CDCLEF=='IDCEN'.OR.CDCLEF=='idcen') THEN
(  402)     KVAL=FA%FICHIER(IRANG)%NIDCEN
(  403) !
(  404) !   Lecture de l'identificateur du modele
(  405) !
(  406)   ELSEIF (CDCLEF=='IDMOD'.OR.CDCLEF=='idmod') THEN
(  407)     KVAL=FA%FICHIER(IRANG)%NSEC1(3)
(  408)   ELSEIF (CDCLEF (1:MIN (7, LEN (CDCLEF)))=='CMODEL=') THEN
(  409)     CDCLEF (8:) = FA%FICHIER(IRANG)%CMODEL
(  410) !
(  411) !   Facteur decimal; calcul automatique
(  412) !
(  413)   ELSEIF (CDCLEF=='FACDEC'.OR.CDCLEF=='facdec') THEN
(  414)     KVAL=FA%FICHIER(IRANG)%NCOGRIF(11)
(  415) !
(  416) !   Ecriture dans un fichier externe
(  417) !
(  418)   ELSEIF (CDCLEF=='EXTERN'.OR.CDCLEF=='extern') THEN
(  419)     KVAL=FA%FICHIER(IRANG)%NCOGRIF(12)
(  420)   ELSE
(  421)     IREP=-125
(  422)     WRITE (UNIT=FA%NULOUT,FMT='(A)')                          &
(  423) &      '!!  ERREUR  !! Dans FAREGU, action inconnue: '//CDCLEF
(  424)     GOTO 1001
(  425)   ENDIF
(  426) !**
(  427) !     3.  -  OPTION INCONNUE
(  428) !-----------------------------------------------------------------------
(  429) !
(  430) ELSE
(  431)   IREP=-125
(  432)   WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)')                        &
(  433) &    '!!  ERREUR  !! Dans FAREGU, option inconnue: KOPT= ',KOPT
(  434)   GOTO 1001
(  435) ENDIF
(  436) !**






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 10

(  437) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  438) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  439) !-----------------------------------------------------------------------
(  440) !
(  441) 1001 CONTINUE
(  442) LLFATA=LLMOER (IREP,IRANG)
(  443) !
(  444) IF (LLFATA) THEN
(  445)   INIMES=2
(  446) ELSE
(  447)   INIMES=IXNVMS(IRANG)
(  448) ENDIF
(  449) !
(  450) IF (.NOT.LLFATA.AND.INIMES.NE.2)  THEN
(  451)   IF (LHOOK) CALL DR_HOOK('FAREGU_MT',1,ZHOOK_HANDLE)
(  452)   RETURN
(  453) ENDIF
(  454) !
(  455) CLNSPR='FAREGU'
(  456) !
(  457) WRITE (UNIT=CLMESS,FMT='(''IREP='',I4,'', KNUMER='',I3,  &
(  458) &         '', CDCLEF='''''',A,'''''', KVAL='',I12,       &
(  459) &        '', KOPT='',I4)')                               &
(  460) &              IREP,KNUMER,CDCLEF,KVAL,KOPT
(  461) CALL FAIPAR_MT64                                       &
(  462) &               (FA, KNUMER,INIMES,IREP,LLFATA,CLMESS, &
(  463) &                CLNSPR,CLNSPR,.FALSE.)
(  464) !
(  465) IF (LHOOK) CALL DR_HOOK('FAREGU_MT',1,ZHOOK_HANDLE)
(  466) 
(  467) CONTAINS
(  468) 
(  469) #include "facom2.llmoer.h"
(  470) #include "facom2.ixnvms.h"
(  471) 
(  472) END SUBROUTINE FAREGU_MT64
(  473) 
(  474) 
(  475) 
(  476) ! Oct-2012 P. Marguinaud 64b LFI
(  477) SUBROUTINE FAREGU64                    &
(  478) &           (KNUMER, CDCLEF, KVAL, KOPT)
(  479) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  480) &                  FA_COM_DEFAULT_INIT,  &
(  481) &                  NEW_FA_DEFAULT
(  482) USE LFI_PRECISION
(  483) IMPLICIT NONE
(  484) ! Arguments
(  485) INTEGER (KIND=JPLIKB)  KNUMER                                 ! IN   
(  486) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  487) INTEGER (KIND=JPLIKB)  KVAL                                   ! INOUT
(  488) INTEGER (KIND=JPLIKB)  KOPT                                   ! IN   
(  489) 
(  490) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  491) 
(  492) CALL FAREGU_MT64                           &
(  493) &           (FA, KNUMER, CDCLEF, KVAL, KOPT)
(  494) 






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 11

(  495) END SUBROUTINE FAREGU64
(  496) 
(  497) SUBROUTINE FAREGU                      &
(  498) &           (KNUMER, CDCLEF, KVAL, KOPT)
(  499) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  500) &                  FA_COM_DEFAULT_INIT,  &
(  501) &                  NEW_FA_DEFAULT
(  502) USE LFI_PRECISION
(  503) IMPLICIT NONE
(  504) ! Arguments
(  505) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  506) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  507) INTEGER (KIND=JPLIKM)  KVAL                                   ! INOUT
(  508) INTEGER (KIND=JPLIKM)  KOPT                                   ! IN   
(  509) 
(  510) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  511) 
(  512) CALL FAREGU_MT                             &
(  513) &           (FA, KNUMER, CDCLEF, KVAL, KOPT)
(  514) 
(  515) END SUBROUTINE FAREGU
(  516) 
(  517) SUBROUTINE FAREGU_MT                       &
(  518) &           (FA, KNUMER, CDCLEF, KVAL, KOPT)
(  519) USE FA_MOD, ONLY : FA_COM
(  520) USE LFI_PRECISION
(  521) IMPLICIT NONE
(  522) ! Arguments
(  523) TYPE (FA_COM)          FA                                     ! INOUT
(  524) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  525) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  526) INTEGER (KIND=JPLIKM)  KVAL                                   ! INOUT
(  527) INTEGER (KIND=JPLIKM)  KOPT                                   ! IN   
(  528) ! Local integers
(  529) INTEGER (KIND=JPLIKB)  INUMER                                 ! IN   
(  530) INTEGER (KIND=JPLIKB)  IVAL                                   ! INOUT
(  531) INTEGER (KIND=JPLIKB)  IOPT                                   ! IN   
(  532) ! Convert arguments
(  533) 
(  534) INUMER     = INT (    KNUMER, JPLIKB)
(  535) IF (KOPT==1) THEN
(  536)   IVAL       = INT (      KVAL, JPLIKB)
(  537) ENDIF
(  538) IOPT       = INT (      KOPT, JPLIKB)
(  539) 
(  540) CALL FAREGU_MT64                           &
(  541) &           (FA, INUMER, CDCLEF, IVAL, IOPT)
(  542) 
(  543) IF (KOPT==0) THEN
(  544)   KVAL       = INT (      IVAL, JPLIKM)
(  545) ENDIF
(  546) 
(  547) END SUBROUTINE FAREGU_MT
(  548) 
(  549) !INTF KNUMER        IN                                                                 
(  550) !INTF CDCLEF        IN                                                                 
(  551) !INTF KVAL          INOUT IN_IF=KOPT==1                  OUT_IF=KOPT==0                
(  552) !INTF KOPT          IN                                                                 






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 12

(  553) 































































NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 13

(    1) # 1 "faregu.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FAREGU_MT64                                 &
(    4) &                     (FA,  KNUMER, CDCLEF, KVAL, KOPT)
(    5) USE FA_MOD, ONLY : FA_COM
(    6) USE PARKIND1, ONLY : JPRB
(    7) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    8) USE LFI_PRECISION
(    9) IMPLICIT NONE
(   10) !****
(   11) !      Ce sous-programme controle (lecture/ecriture) les options
(   12) !      de compression de GRIBEX, pour chacune des unites logiques et
(   13) !      certains descripteurs GRIB communs a l'unite logique.
(   14) !      (REGLAGE des options de codage de gribex pour une Unite)
(   15) !**
(   16) !    Arguments : KNUMER (Entree) ==> Numero de l'unite logique;
(   17) !                CDCLEF (Entree) ==> Mot clef precisant l'action a faire;
(   18) !                KVAL   (Sortie  ==> Valeur lue ou a ecrire;
(   19) !                      ou Entree)
(   20) !                KOPT   (Entree) ==> Flag: 0->lecture 1->ecriture;
(   21) !*
(   22) !     Signification des divers elements du tableau NCOGRIF
(   23) !
(   24) !     NCOGRIF(1) = type de codage (0->option HOPER='C'
(   25) !                               1->option HOPER='K')
(   26) !     NCOGRIF(2) = KSEC4(6), indicateur de la presence de flags
(   27) !               additionnels (0->non; 16->oui)
(   28) !     NCOGRIF(3) = KSEC4(7)
(   29) !     NCOGRIF(4) = KSEC4(9), indicateur de la presence de bitmaps
(   30) !               secondaires (0->non; 32->oui)
(   31) !     NCOGRIF(5) = KSEC4(10), indicateur pour le nb de bits des
(   32) !               groupes de pts de grille (0->const.; 16->different)
(   33) !     NCOGRIF(6) = KSEC4(11), nb de bits pour les groupes de pts de grille
(   34) !               quand il est constant.
(   35) !               Si negatif, le logiciel calcule un nb optimal a partir
(   36) !               de -KSEC4(11).
(   37) !     NCOGRIF(7) = KSEC4(12), indicateur pour les extensions generales de
(   38) !               la compression (0->non; 8->oui)
(   39) !     NCOGRIF(8) = KSEC4(13), indicateur pour le rearrangement boustrophedo
(   40) !               nique (0->non; 4->oui)
(   41) !     NCOGRIF(9) = KSEC4(14) (valeurs possibles: -1, 0 et 2)
(   42) !     NCOGRIF(10) = KSEC4(15) (valeurs possibles: -1, 0 et 1), sert avec
(   43) !                KSEC4(14) a definir la technique de la difference
(   44) !                spatiale. Si l'un des 2 est negatif, l'ordre de
(   45) !                differentiation est estime dynamiquement, sinon
(   46) !                l'ordre = KSEC4(14)+KSEC4(15)
(   47) !     NCOGRIF(11) = 1->Calcul automatique de KSEC1 (23), 0->On laisse faire
(   48) !     NCODGRI(12) = Ecriture des champs GRIB1 dans un fichier externe
(   49) !
(   50) !
(   51) !
(   52) TYPE(FA_COM) :: FA
(   53) INTEGER (KIND=JPLIKB) KNUMER, KVAL, KOPT
(   54) !
(   55) CHARACTER(LEN=*) CDCLEF
(   56) !
(   57) INTEGER (KIND=JPLIKB) IRANG, INIMES, IREP, INBITSMAX






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 14

(   58) !
(   59) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   60) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   61) LOGICAL                  LLFATA
(   62) # 63 "faregu.F90"
(   63) !
(   64) !**
(   65) !     0.  -  INITIALISATIONS ET ALLOCATIONS PREALABLES
(   66) !-----------------------------------------------------------------------
(   67) !
(   68) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   69) IF (LHOOK) CALL DR_HOOK('FAREGU_MT',0,ZHOOK_HANDLE)
(   70) IREP=0
(   71) !
(   72) CALL FANUMU_MT64                 &
(   73) &               (FA, KNUMER,IRANG)
(   74) !
(   75) IF (IRANG.EQ.0) THEN
(   76)   IREP=-51
(   77)   GOTO 1001
(   78) ENDIF
(   79) !
(   80) ! Appel prealable a FAISC1 pour initialiser FA%NSEC1(2:21,IRANG).
(   81) ! On le fait ici plutot que dans FAINIG pour ne pas ecraser
(   82) ! les eventuelles modifs apportees par IDCEN et/ou IDMOD
(   83) !
(   84) IF (FA%FICHIER(IRANG)%LISEC1) THEN
(   85)   CALL FAISC1_MT64              &
(   86) &                (FA, IREP,IRANG)
(   87)   IF (IREP.NE.0) THEN
(   88)     WRITE (UNIT=FA%NULOUT,FMT=*) &
(   89) &           'FAREGU: ERROR ',IREP,' dans appel a FAISC1 !!'
(   90)     GOTO 1001
(   91)   ENDIF
(   92)   FA%FICHIER(IRANG)%LISEC1=.FALSE.
(   93) ENDIF
(   94) !
(   95) INBITSMAX=MAX(FA%FICHIER(IRANG)%NBFPDG,FA%FICHIER(IRANG)%NBFCSP)
(   96) !**
(   97) !     1.  -  SPECIFICATION D'UN NOUVEAU CODAGE
(   98) !-----------------------------------------------------------------------
(   99) !
(  100) IF (KOPT==1) THEN
(  101) !
(  102) !   Pas de compression (sous-tronc et puissance laplacien ajoutees
(  103) !   systematiquement + tard pour les coeff spectraux)
(  104) !
(  105)   IF (CDCLEF=='BASIC'.OR.CDCLEF=='basic') THEN
(  106)     FA%FICHIER(IRANG)%NCOGRIF(1)=0
(  107)     FA%FICHIER(IRANG)%NCOGRIF(2)=0
(  108)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  109)     FA%FICHIER(IRANG)%NCOGRIF(4)=0
(  110)     FA%FICHIER(IRANG)%NCOGRIF(5)=0
(  111)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  112) !
(  113) !   Comme le "BASIC" avec une compression
(  114) !   ligne a ligne pour les points de grille
(  115) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 15

(  116)   ELSEIF (CDCLEF=='PACK1'.OR.CDCLEF=='pack1') THEN
(  117)     FA%FICHIER(IRANG)%NCOGRIF(1)=0
(  118)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  119)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  120)     FA%FICHIER(IRANG)%NCOGRIF(4)=0
(  121)     FA%FICHIER(IRANG)%NCOGRIF(5)=16
(  122)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  123) !
(  124) !   Comme le "BASIC" avec une compression
(  125) !   pour les points de grille ou le nb de bits est le meme
(  126) !   dans chaque groupe de points de grille
(  127) !
(  128)   ELSEIF (CDCLEF=='PACK2'.OR.CDCLEF=='pack2') THEN
(  129)     FA%FICHIER(IRANG)%NCOGRIF(1)=0
(  130)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  131)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  132)     FA%FICHIER(IRANG)%NCOGRIF(4)=32
(  133)     FA%FICHIER(IRANG)%NCOGRIF(5)=0
(  134) ! Un nb de bits optimal sera recherche par le logiciel
(  135)     FA%FICHIER(IRANG)%NCOGRIF(6)=-99
(  136) !
(  137) !   Comme le "BASIC" avec une compression general OMM
(  138) !   pour les points de grille
(  139) !
(  140)   ELSEIF (CDCLEF=='PACK3'.OR.CDCLEF=='pack3') THEN
(  141)     FA%FICHIER(IRANG)%NCOGRIF(1)=0
(  142)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  143)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  144)     FA%FICHIER(IRANG)%NCOGRIF(4)=32
(  145)     FA%FICHIER(IRANG)%NCOGRIF(5)=16
(  146)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  147) !
(  148) !   Compression "aggressive": le logiciel va
(  149) !   tenter la compression ligne a ligne puis l'absence
(  150) !   de compression et retenir la meilleure methode
(  151) !
(  152)   ELSEIF (CDCLEF=='APAC1'.OR.CDCLEF=='apac1') THEN
(  153)     FA%FICHIER(IRANG)%NCOGRIF(1)=1
(  154)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  155)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  156)     FA%FICHIER(IRANG)%NCOGRIF(4)=0
(  157)     FA%FICHIER(IRANG)%NCOGRIF(5)=16
(  158)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  159) !
(  160) !   Compression "aggressive": le logiciel va
(  161) !   tenter la compression type "APAC1" puis celle avec le nb de bits
(  162) !   constant par groupe de pts de grille et retenir la meilleure
(  163) !
(  164)   ELSEIF (CDCLEF=='APAC2'.OR.CDCLEF=='apac2') THEN
(  165)     FA%FICHIER(IRANG)%NCOGRIF(1)=1
(  166)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  167)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  168)     FA%FICHIER(IRANG)%NCOGRIF(4)=0
(  169)     FA%FICHIER(IRANG)%NCOGRIF(5)=0
(  170) ! Un nb de bits optimal sera recherche par le logiciel
(  171)     FA%FICHIER(IRANG)%NCOGRIF(6)=-99
(  172) !
(  173) !   Compression "aggressive": le logiciel va tenter






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 16

(  174) !   la compression type "APAC1" puis la compression generale
(  175) !   OMM et retenir la meilleure
(  176) !
(  177)   ELSEIF (CDCLEF=='APAC3'.OR.CDCLEF=='apac3') THEN
(  178)     FA%FICHIER(IRANG)%NCOGRIF(1)=1
(  179)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  180)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  181)     FA%FICHIER(IRANG)%NCOGRIF(4)=32
(  182)     FA%FICHIER(IRANG)%NCOGRIF(5)=16
(  183)     FA%FICHIER(IRANG)%NCOGRIF(6)=0
(  184) !
(  185) !   Compression "aggressive": le logiciel va
(  186) !   tenter la compression type "APAC3" puis celle avec le nb de bits
(  187) !   constant par groupe de pts de grille et retenir la meilleure
(  188) !
(  189)   ELSEIF (CDCLEF=='APAC4'.OR.CDCLEF=='apac4') THEN
(  190)     FA%FICHIER(IRANG)%NCOGRIF(1)=1
(  191)     FA%FICHIER(IRANG)%NCOGRIF(2)=16
(  192)     FA%FICHIER(IRANG)%NCOGRIF(3)=0
(  193)     FA%FICHIER(IRANG)%NCOGRIF(4)=32
(  194)     FA%FICHIER(IRANG)%NCOGRIF(5)=0
(  195) ! Un nb de bits optimal sera recherche par le logiciel
(  196)     FA%FICHIER(IRANG)%NCOGRIF(6)=-99
(  197) !
(  198) !   Specification du nb de bits a utiliser dans le cadre
(  199) !   de la compression avec nb de bits constant
(  200) !   par groupe de pts de grille
(  201) !   
(  202)   ELSEIF (CDCLEF=='WIDPA'.OR.CDCLEF=='widpa') THEN
(  203)     IF (KVAL.LT.1-INBITSMAX.OR.KVAL.GT.INBITSMAX-1) THEN
(  204)       IREP=-97
(  205)       WRITE (UNIT=FA%NULOUT,FMT='(A)')'Dans FAREGU, action WIDPA:'
(  206)       WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)')                       &
(  207) &   '!!  ERREUR  !! Valeur incorrecte, non prise en compte: ',KVAL
(  208)       GOTO 1001
(  209)     ENDIF
(  210)     FA%FICHIER(IRANG)%NCOGRIF(6)=KVAL
(  211) !
(  212) !   Demande supplementaire de la compression avec extension
(  213) !   generale a la norme OMM (si KVAL=1, sinon c'est le retrait de l'option)
(  214) !
(  215)   ELSEIF (CDCLEF=='GEXTE'.OR.CDCLEF=='gexte') THEN
(  216)     IF (KVAL.EQ.1) THEN
(  217)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  218)       FA%FICHIER(IRANG)%NCOGRIF(7)=8
(  219)     ELSE
(  220)       FA%FICHIER(IRANG)%NCOGRIF(7)=0
(  221)     ENDIF
(  222) !
(  223) !   Demande supplementaire du rearrangement boustrophedonique dans la compression
(  224) !   (si KVAL=1, sinon c'est le retrait de cette option)
(  225) !
(  226)   ELSEIF (CDCLEF=='BOUST'.OR.CDCLEF=='boust') THEN
(  227)     IF (KVAL.EQ.1) THEN
(  228)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  229)       FA%FICHIER(IRANG)%NCOGRIF(8)=4
(  230)     ELSE
(  231)       FA%FICHIER(IRANG)%NCOGRIF(8)=0






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 17

(  232)     ENDIF
(  233) !
(  234) !   Demande supplementaire de la difference spatiale dans la
(  235) !   compression. KVAL donne l'ordre de differentiation
(  236) !   (-1-> calcul dynamique par GRIBEX; 1 a 3->ordre; 0->desactiv; autre->err)
(  237) !
(  238)   ELSEIF (CDCLEF=='DIFFE'.OR.CDCLEF=='diffe') THEN
(  239)     IF (KVAL.EQ.-1) THEN
(  240)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  241)       FA%FICHIER(IRANG)%IOPTGRSN2O=1
(  242)       FA%FICHIER(IRANG)%NCOGRIF( 9)=0
(  243)       FA%FICHIER(IRANG)%NCOGRIF(10)=-1
(  244)     ELSEIF (KVAL.EQ.1) THEN
(  245)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  246)       FA%FICHIER(IRANG)%IOPTGRSN2O=1
(  247)       FA%FICHIER(IRANG)%NCOGRIF( 9)=0
(  248)       FA%FICHIER(IRANG)%NCOGRIF(10)=1
(  249)     ELSEIF (KVAL.EQ.2) THEN
(  250)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  251)       FA%FICHIER(IRANG)%IOPTGRSN2O=1
(  252)       FA%FICHIER(IRANG)%NCOGRIF( 9)=2
(  253)       FA%FICHIER(IRANG)%NCOGRIF(10)=0
(  254)     ELSEIF (KVAL.EQ.3) THEN
(  255)       FA%FICHIER(IRANG)%IOPTGRSX2O=1
(  256)       FA%FICHIER(IRANG)%IOPTGRSN2O=1
(  257)       FA%FICHIER(IRANG)%NCOGRIF( 9)=2
(  258)       FA%FICHIER(IRANG)%NCOGRIF(10)=1
(  259)     ELSEIF (KVAL.EQ.0) THEN
(  260)       FA%FICHIER(IRANG)%IOPTGRSX2O=0
(  261)       FA%FICHIER(IRANG)%NCOGRIF( 9)=0
(  262)       FA%FICHIER(IRANG)%NCOGRIF(10)=0
(  263)     ELSE
(  264)       IREP=-125
(  265)       WRITE (UNIT=FA%NULOUT,FMT='(A)')    &
(  266) &             'Dans FAREGU, action DIFFE:'
(  267)       WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)')                       &
(  268) &   '!!  ERREUR  !! Valeur incorrecte, non prise en compte: ',KVAL
(  269)       GOTO 1001
(  270)     ENDIF
(  271) !
(  272) !   Specification de l'identificateur du centre meteo (defaut=85 pour
(  273) !   Toulouse; pour Reading, il vaut 98). Sera utilise pour initialiser
(  274) !   KSEC1(2), le 2ieme elt de la section 1 de GRIBEX
(  275) !
(  276)   ELSEIF (CDCLEF=='IDCEN'.OR.CDCLEF=='idcen') THEN
(  277)     IF (KVAL.LT.7.OR.KVAL.GT.99) THEN
(  278)       IREP=-125
(  279)       WRITE (UNIT=FA%NULOUT,FMT='(A)')    &
(  280) &             'Dans FAREGU, action IDCEN:'
(  281)       WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)') &
(  282) &   '!!  ERREUR  !! Valeur incorrecte, non prise en compte: ',KVAL
(  283)       GOTO 1001
(  284)     ENDIF
(  285)     FA%FICHIER(IRANG)%NSEC1(2) = KVAL
(  286)     FA%FICHIER(IRANG)%NIDCEN   = KVAL
(  287) # 288 "faregu.F90"
(  288) !
(  289) !   Specification de l'identificateur de modele.






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 18

(  290) !   FAISC1 initialise automatiquement a
(  291) !      177 pour ALADIN
(  292) !      211 pour les previsions ARPEGE
(  293) !      201 pour les analyses ARPEGE
(  294) !   Sera utilise pour initialiser KSEC1(3).
(  295) !
(  296)   ELSEIF (CDCLEF=='IDMOD'.OR.CDCLEF=='idmod') THEN
(  297)     IF (KVAL.LT.0.OR.KVAL.GT.255) THEN
(  298)       IREP=-125
(  299)       WRITE (UNIT=FA%NULOUT,FMT='(A)')    &
(  300) &             'Dans FAREGU, action IDMOD:'
(  301)       WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)') &
(  302) &   '!!  ERREUR  !! Valeur incorrecte, non prise en compte: ',KVAL
(  303)       GOTO 1001
(  304)     ENDIF
(  305)     FA%FICHIER(IRANG)%NSEC1(3)=KVAL
(  306)   ELSEIF (CDCLEF (1:MIN (7, LEN (CDCLEF)))=='CMODEL=') THEN
(  307)     FA%FICHIER(IRANG)%CMODEL = CDCLEF (8:)
(  308) !
(  309) !   Facteur decimal; calcul automatique
(  310) !
(  311)   ELSEIF (CDCLEF=='FACDEC'.OR.CDCLEF=='facdec') THEN
(  312)     FA%FICHIER(IRANG)%NCOGRIF(11)=KVAL
(  313) !
(  314) !   Ecriture dans un fichier externe
(  315) !
(  316)   ELSEIF (CDCLEF=='EXTERN'.OR.CDCLEF=='extern') THEN
(  317)     FA%FICHIER(IRANG)%NCOGRIF(12)=KVAL
(  318)   ELSE
(  319)     IREP=-125
(  320)     WRITE (UNIT=FA%NULOUT,FMT='(A)') &
(  321) &     '!!  ERREUR  !! Dans FAREGU, action inconnue: '//CDCLEF
(  322)     GOTO 1001
(  323)   ENDIF
(  324) !**
(  325) !     2.  -  DEMANDE D'INFORMATION
(  326) !-----------------------------------------------------------------------
(  327) !
(  328) ELSEIF (KOPT==0) THEN
(  329) !
(  330) !   Obtention des mots-clef disponibles
(  331) !
(  332)   IF (CDCLEF=='CLEFS'.OR. CDCLEF=='clefs' .OR. &
(  333) &      CDCLEF=='HELP' .OR. CDCLEF=='help') THEN
(  334)     KVAL=0
(  335)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  336)     WRITE (UNIT=FA%NULOUT,FMT=*) 'Mots clef disponibles pour FAREGU:'
(  337)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  338)     WRITE (UNIT=FA%NULOUT,FMT=*) 'BASIC: pas de compression'
(  339)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK1: BASIC avec une compression'
(  340)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ligne a ligne pour les pts de grille'
(  341)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK2: BASIC avec une compression avec'
(  342)     WRITE (UNIT=FA%NULOUT,FMT=*) '       nb de bits cst pour les groupes'
(  343)     WRITE (UNIT=FA%NULOUT,FMT=*) 'PACK3: BASIC avec une compression generale'
(  344)     WRITE (UNIT=FA%NULOUT,FMT=*) '       OMM pour les points de grille'
(  345)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC1: compression agressive:'
(  346)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC et PACK1 sont testes'
(  347)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC2: compression agressive:'






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 19

(  348)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1 et PACK2 sont testes'
(  349)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC3: compression agressive:'
(  350)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1 et PACK3 sont testes'
(  351)     WRITE (UNIT=FA%NULOUT,FMT=*) 'APAC4: compression agressive:'
(  352)     WRITE (UNIT=FA%NULOUT,FMT=*) '       BASIC, PACK1, PACK2 et PACK3 testes'
(  353)     WRITE (UNIT=FA%NULOUT,FMT=*) 'WIDPA: lecture/ecriture du nb de bits'
(  354)     WRITE (UNIT=FA%NULOUT,FMT=*) '       a utiliser pour les groupes de points'
(  355)     WRITE (UNIT=FA%NULOUT,FMT=*) '       de grille dans le cas PACK2'
(  356)     WRITE (UNIT=FA%NULOUT,FMT=*) 'GEXTE: la compression avec extensions generales'
(  357)     WRITE (UNIT=FA%NULOUT,FMT=*) '       activees (KVAL=1) ou desactivees (KVAL=0)'
(  358)     WRITE (UNIT=FA%NULOUT,FMT=*) 'BOUST: le rearrangement boustrophedonique est'
(  359)     WRITE (UNIT=FA%NULOUT,FMT=*) '       active (KVAL=1) ou desactive (KVAL=0)'
(  360)     WRITE (UNIT=FA%NULOUT,FMT=*) 'DIFFE: la differenciation spatiale est'
(  361)     WRITE (UNIT=FA%NULOUT,FMT=*) '       activee (KVAL=ordre de differ. (1 a 3)'
(  362)     WRITE (UNIT=FA%NULOUT,FMT=*) '       ou -1 (calcul dyn)) ou desactivee (0)'
(  363)     WRITE (UNIT=FA%NULOUT,FMT=*) 'IDCEN: lect/ecriture de l''identificateur du'
(  364)     WRITE (UNIT=FA%NULOUT,FMT=*) '       centre meteo'
(  365)     WRITE (UNIT=FA%NULOUT,FMT=*) 'IDMOD: lect/ecriture de l''identificateur du'
(  366)     WRITE (UNIT=FA%NULOUT,FMT=*) '       modele'
(  367)     WRITE (UNIT=FA%NULOUT,FMT=*) 'CMODEL: lect/ecriture de l''identificateur du'
(  368)     WRITE (UNIT=FA%NULOUT,FMT=*) '        modele'
(  369)     WRITE (UNIT=FA%NULOUT,FMT=*) 'FACDEC: calcul automatique du facteur decimal'
(  370)     WRITE (UNIT=FA%NULOUT,FMT=*) 'EXTERN: ecriture dans un fichier externe'
(  371)     WRITE (UNIT=FA%NULOUT,FMT=*)
(  372) !
(  373) !   Lecture du nb de bits a utiliser dans le cadre
(  374) !   de la compression avec nb de bits
(  375) !   constant par groupe de pts de grille
(  376) !   
(  377)   ELSEIF (CDCLEF=='WIDPA'.OR.CDCLEF=='widpa') THEN
(  378)     KVAL=FA%FICHIER(IRANG)%NCOGRIF(6)
(  379) !
(  380) !   Lecture de la presence ou non de la compression
(  381) !   "general extended"
(  382) !
(  383)   ELSEIF (CDCLEF=='GEXTE'.OR.CDCLEF=='gexte') THEN
(  384)     KVAL = FA%FICHIER(IRANG)%NCOGRIF(7)/8
(  385) !
(  386) !   Lecture de la presence ou non du rearrangement
(  387) !   boustrophedonique.
(  388) !
(  389)   ELSEIF (CDCLEF=='BOUST'.OR.CDCLEF=='boust') THEN
(  390)     KVAL = FA%FICHIER(IRANG)%NCOGRIF(8)/4
(  391) !
(  392) !   Lecture de la presence ou non de la differentiation spatiale
(  393) !
(  394)   ELSEIF (CDCLEF=='DIFFE'.OR.CDCLEF=='diffe') THEN
(  395)     KVAL=FA%FICHIER(IRANG)%NCOGRIF( 9)+FA%FICHIER(IRANG)%NCOGRIF(10)
(  396) !
(  397) !   Lecture de l'identificateur du centre meteo (defaut=85 pour
(  398) !   Toulouse; pour Reading, il vaut 98). Sera utilise pour initialiser
(  399) !   KSEC1(2), le 2ieme elt de la section 1 de GRIBEX
(  400) !
(  401)   ELSEIF (CDCLEF=='IDCEN'.OR.CDCLEF=='idcen') THEN
(  402)     KVAL=FA%FICHIER(IRANG)%NIDCEN
(  403) !
(  404) !   Lecture de l'identificateur du modele
(  405) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 20

(  406)   ELSEIF (CDCLEF=='IDMOD'.OR.CDCLEF=='idmod') THEN
(  407)     KVAL=FA%FICHIER(IRANG)%NSEC1(3)
(  408)   ELSEIF (CDCLEF (1:MIN (7, LEN (CDCLEF)))=='CMODEL=') THEN
(  409)     CDCLEF (8:) = FA%FICHIER(IRANG)%CMODEL
(  410) !
(  411) !   Facteur decimal; calcul automatique
(  412) !
(  413)   ELSEIF (CDCLEF=='FACDEC'.OR.CDCLEF=='facdec') THEN
(  414)     KVAL=FA%FICHIER(IRANG)%NCOGRIF(11)
(  415) !
(  416) !   Ecriture dans un fichier externe
(  417) !
(  418)   ELSEIF (CDCLEF=='EXTERN'.OR.CDCLEF=='extern') THEN
(  419)     KVAL=FA%FICHIER(IRANG)%NCOGRIF(12)
(  420)   ELSE
(  421)     IREP=-125
(  422)     WRITE (UNIT=FA%NULOUT,FMT='(A)')                          &
(  423) &      '!!  ERREUR  !! Dans FAREGU, action inconnue: '//CDCLEF
(  424)     GOTO 1001
(  425)   ENDIF
(  426) !**
(  427) !     3.  -  OPTION INCONNUE
(  428) !-----------------------------------------------------------------------
(  429) !
(  430) ELSE
(  431)   IREP=-125
(  432)   WRITE (UNIT=FA%NULOUT,FMT='(A57,I8)')                        &
(  433) &    '!!  ERREUR  !! Dans FAREGU, option inconnue: KOPT= ',KOPT
(  434)   GOTO 1001
(  435) ENDIF
(  436) !**
(  437) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  438) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  439) !-----------------------------------------------------------------------
(  440) !
(  441) 1001 CONTINUE
(  442) LLFATA=LLMOER (IREP,IRANG)
(  443) !
(  444) IF (LLFATA) THEN
(  445)   INIMES=2
(  446) ELSE
(  447)   INIMES=IXNVMS(IRANG)
(  448) ENDIF
(  449) !
(  450) IF (.NOT.LLFATA.AND.INIMES.NE.2)  THEN
(  451)   IF (LHOOK) CALL DR_HOOK('FAREGU_MT',1,ZHOOK_HANDLE)
(  452)   RETURN
(  453) ENDIF
(  454) !
(  455) CLNSPR='FAREGU'
(  456) !
(  457) WRITE (UNIT=CLMESS,FMT='(''IREP='',I4,'', KNUMER='',I3,  &
(  458) &         '', CDCLEF='''''',A,'''''', KVAL='',I12,       &
(  459) &        '', KOPT='',I4)')                               &
(  460) &              IREP,KNUMER,CDCLEF,KVAL,KOPT
(  461) CALL FAIPAR_MT64                                       &
(  462) &               (FA, KNUMER,INIMES,IREP,LLFATA,CLMESS, &
(  463) &                CLNSPR,CLNSPR,.FALSE.)






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 21

(  464) !
(  465) IF (LHOOK) CALL DR_HOOK('FAREGU_MT',1,ZHOOK_HANDLE)
(  466) # 467 "faregu.F90"
(  467) CONTAINS
(  468) # 469 "faregu.F90"
(  469) # 1 ".D[27]/facom2.llmoer.h"
(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,
(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 470 "faregu.F90"
(  470) # 470 "faregu.F90"
(  470) # 1 ".D[27]/facom2.ixnvms.h"
(    1) !*
(    2) !       Fonction "en ligne" donnant le plus haut niveau de messagerie
(    3) !       acceptable pour l'unite logique de rang "I3456"
(    4) !       (utilisation des niveaux de messagerie global et propre au
(    5) !        fichier; s'il n'y a pas de fichier - I3456=0, d'ou le dimensio-
(    6) !        nnement de *NIVOMS* a partir de zero, le niveau de filtrage
(    7) !        global joue seul)
(    8) !
(    9) INTEGER (KIND=JPLIKB) FUNCTION IXNVMS (I3456)
(   10) INTEGER (KIND=JPLIKB) :: I3456
(   11) IXNVMS =MIN (2_JPLIKB ,2_JPLIKB *FA%NIMSGA,MAX (2_JPLIKB *FA%NIMSGA-2_JPLIKB ,FA%FICHIER(I3456)%NIVOMS))
(   12) END FUNCTION
(   13) # 471 "faregu.F90"
(  471) # 472 "faregu.F90"
(  472) END SUBROUTINE FAREGU_MT64
(  473) # 476 "faregu.F90"
(  476) ! Oct-2012 P. Marguinaud 64b LFI
(  477) SUBROUTINE FAREGU64                    &
(  478) &           (KNUMER, CDCLEF, KVAL, KOPT)
(  479) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  480) &                  FA_COM_DEFAULT_INIT,  &
(  481) &                  NEW_FA_DEFAULT
(  482) USE LFI_PRECISION
(  483) IMPLICIT NONE
(  484) ! Arguments
(  485) INTEGER (KIND=JPLIKB)  KNUMER                                 ! IN   
(  486) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  487) INTEGER (KIND=JPLIKB)  KVAL                                   ! INOUT
(  488) INTEGER (KIND=JPLIKB)  KOPT                                   ! IN   
(  489) # 490 "faregu.F90"
(  490) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  491) # 492 "faregu.F90"
(  492) CALL FAREGU_MT64                           &
(  493) &           (FA, KNUMER, CDCLEF, KVAL, KOPT)
(  494) # 495 "faregu.F90"
(  495) END SUBROUTINE FAREGU64
(  496) # 497 "faregu.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:55:14      page 22

(  497) SUBROUTINE FAREGU                      &
(  498) &           (KNUMER, CDCLEF, KVAL, KOPT)
(  499) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  500) &                  FA_COM_DEFAULT_INIT,  &
(  501) &                  NEW_FA_DEFAULT
(  502) USE LFI_PRECISION
(  503) IMPLICIT NONE
(  504) ! Arguments
(  505) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  506) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  507) INTEGER (KIND=JPLIKM)  KVAL                                   ! INOUT
(  508) INTEGER (KIND=JPLIKM)  KOPT                                   ! IN   
(  509) # 510 "faregu.F90"
(  510) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  511) # 512 "faregu.F90"
(  512) CALL FAREGU_MT                             &
(  513) &           (FA, KNUMER, CDCLEF, KVAL, KOPT)
(  514) # 515 "faregu.F90"
(  515) END SUBROUTINE FAREGU
(  516) # 517 "faregu.F90"
(  517) SUBROUTINE FAREGU_MT                       &
(  518) &           (FA, KNUMER, CDCLEF, KVAL, KOPT)
(  519) USE FA_MOD, ONLY : FA_COM
(  520) USE LFI_PRECISION
(  521) IMPLICIT NONE
(  522) ! Arguments
(  523) TYPE (FA_COM)          FA                                     ! INOUT
(  524) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  525) CHARACTER (LEN=*)      CDCLEF                                 ! IN   
(  526) INTEGER (KIND=JPLIKM)  KVAL                                   ! INOUT
(  527) INTEGER (KIND=JPLIKM)  KOPT                                   ! IN   
(  528) ! Local integers
(  529) INTEGER (KIND=JPLIKB)  INUMER                                 ! IN   
(  530) INTEGER (KIND=JPLIKB)  IVAL                                   ! INOUT
(  531) INTEGER (KIND=JPLIKB)  IOPT                                   ! IN   
(  532) ! Convert arguments
(  533) # 534 "faregu.F90"
(  534) INUMER     = INT (    KNUMER, JPLIKB)
(  535) IF (KOPT==1) THEN
(  536)   IVAL       = INT (      KVAL, JPLIKB)
(  537) ENDIF
(  538) IOPT       = INT (      KOPT, JPLIKB)
(  539) # 540 "faregu.F90"
(  540) CALL FAREGU_MT64                           &
(  541) &           (FA, INUMER, CDCLEF, IVAL, IOPT)
(  542) # 543 "faregu.F90"
(  543) IF (KOPT==0) THEN
(  544)   KVAL       = INT (      IVAL, JPLIKM)
(  545) ENDIF
(  546) # 547 "faregu.F90"
(  547) END SUBROUTINE FAREGU_MT
(  548) # 549 "faregu.F90"
(  549) !INTF KNUMER        IN                                                                 
(  550) !INTF CDCLEF        IN                                                                 
(  551) !INTF KVAL          INOUT IN_IF=KOPT==1                  OUT_IF=KOPT==0                
(  552) !INTF KOPT          IN                                                                 
