


NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: fanouv.F90

(    1) ! Feb-2013 P. Marguinaud fix uninitialized output variable
(    2) ! Oct-2012 P. Marguinaud 64b LFI
(    3) ! Jan-2011 P. Marguinaud Thread-safe FA
(    4) ! Sep-2012 P. Marguinaud Remove unused local variables
(    5) SUBROUTINE FANOUV_MT64                                             &
(    6) &                     (FA, KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU,   &
(    7) &                      LDERFA, LDIMST, KNIMES, KNBARP, KNBARI,     &
(    8) &                      CDNOMC)
(    9) USE FA_MOD, ONLY : FA_COM, NEW_FICHIER, JPNIIL
(   10) USE PARKIND1, ONLY : JPRB
(   11) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   12) USE LFI_PRECISION
(   13) IMPLICIT NONE
(   14) !****
(   15) !        Sous-programme d'initialisation SANS OUVERTURE d'une unite logique 
(   16) !        "Fichier ARPEGE". Il s'agit d'un fichier indexe, 
(   17) !        traite par le logiciel LFI.
(   18) !
(   19) !      FANOUV est derive de FAITOU, mais ne fait pas l'appel a la couche LFI
(   20) !             pour l'ouverture reelle.
(   21) !
(   22) !      utilise pour la seule compression des donnees par des processeurs
(   23) !      qui ne font pas d'ecriture effective sur disque
(   24) !
(   25) !**
(   26) !     ARGUMENTS : Ce sont les memes que pour "LFIOUV", avec CDNOMC comme
(   27) !                 argument supplementaire.
(   28) !
(   29) !                 KREP   (Sortie) ==> Code-reponse du sous-programme;
(   30) !                 KNUMER (Entree) ==> Numero de l'unite logique;






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 3

(   31) !                 LDNOMM (Entree) ==> Vrai si l'unite logique doit etre
(   32) !                                     associee a un NOM de Fichier EXP-
(   33) !                                     LICITE lors de l'"OPEN" FORTRAN;
(   34) !                 CDNOMF (Entree) ==> Nom de fichier explicite, si
(   35) !                                     *LDNOMM* est VRAI - Meme si ce
(   36) !                                     n'est pas le cas, ce *DOIT* ETRE
(   37) !                                     UN OBJET DE TYPE "CHARACTER" .
(   38) !                 CDSTTU (Entree) ==> "STATUS" pour l'"OPEN" FORTRAN
(   39) !                                     ('OLD','NEW','UNKNOWN','SCRATCH')
(   40) !                                     par defaut, mettre 'UNKNOWN';
(   41) !                 LDERFA (Entree) ==> Option d'erreur fatale;
(   42) !                 LDIMST (Entree) ==> Option impression de Statistiques
(   43) !                                     au moment de la fermeture;
(   44) !                 KNIMES (Entree) ==> Niveau de la Messagerie (0,1 ou 2)
(   45) !                                     ( 0==>Rien, 2==>Tout )
(   46) !                 KNBARP (Entree) ==> Nombre d'articles logiques prevus,
(   47) !                                     ce qui n'est utilise que lors de
(   48) !                                     la Creation du fichier,
(   49) !                                     et qui n'empeche quand meme pas
(   50) !                                     d'avoir plus d'articles logiques;
(   51) !                 KNBARI (Sortie) ==> Nombre d'articles logiques de don-
(   52) !                                     nees sur le fichier, initialement.
(   53) !                                     (zero si creation)
(   54) !                 CDNOMC (Entree) ==> Nom du CADRE associe au fichier.
(   55) !*
(   56) !     N.B. :  Pour un fichier en mode creation, ce cadre doit avoir ete
(   57) !          defini au prealable (via le sous-programme FACADE, ou par
(   58) !          l'ouverture d'un fichier preexistant).
(   59) !             Pour un fichier ARPEGE preexistant, le cadre est lu sur le
(   60) !          fichier; s'il etait deja defini auparavant, il y a controle
(   61) !          de coherence entre les deux versions du cadre.
(   62) !
(   63) !
(   64) !
(   65) TYPE(FA_COM) :: FA
(   66) INTEGER (KIND=JPLIKB) KREP, KNUMER, KNIMES, KNBARP, KNBARI
(   67) !
(   68) INTEGER (KIND=JPLIKB) IRANG, IRANMS, IREPOU
(   69) INTEGER (KIND=JPLIKB) ILNOMC, ILOMIN, IREP, J
(   70) INTEGER (KIND=JPLIKB) IRANER, IRANGC
(   71) INTEGER (KIND=JPLIKB) ITRONC, ILACTI, INIMES
(   72) INTEGER (KIND=JPLIKB) ITYPTR, IPUILA
(   73) !
(   74) INTEGER (KIND=JPLIKB) IDATEF (FA%JPLDAT)
(   75) !
(   76) LOGICAL LDNOMM, LDERFA, LDIMST, LLNOUF, LLNOUC, LLRLFI
(   77) !
(   78) CHARACTER CDNOMF*(*), CDSTTU*(*), CDNOMC*(*)
(   79) !
(   80) CHARACTER(LEN=FA%JPXNOM) CLACTI 
(   81) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   82) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   83) LOGICAL                  LLFATA
(   84) 
(   85) !**
(   86) !     1.  -  CONTROLES DIVERS
(   87) !-----------------------------------------------------------------------
(   88) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 4

(   89) !     Controle sommaire sur les arguments...
(   90) !
(   91) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   92) IF (LHOOK) CALL DR_HOOK('FANOUV_MT',0,ZHOOK_HANDLE)
(   93) KNBARI=0
(   94) CLACTI=''
(   95) IRANG=0
(   96) IRANER=0
(   97) IRANMS=0
(   98) IREPOU=JPNIIL
(   99) LLRLFI=.FALSE.
(  100) ILNOMC=INT (LEN (CDNOMC), JPLIKB)
(  101) ILOMIN=MIN ( INT (LEN (CDNOMF), JPLIKB),         &
(  102) &             INT (LEN (CDSTTU), JPLIKB), ILNOMC)
(  103) !
(  104) !        L'appel ci-dessous est legerement anticipe, de maniere a
(  105) !     initialiser les variables globales du logiciel s'il s'agit
(  106) !     du premier appel a un sous-programme de ce logiciel.
(  107) !
(  108) CALL FANUMU_MT64                 &
(  109) &               (FA, KNUMER,IRANG)
(  110) !        Si KNUMER est nul, alors le numero d'unite logique est
(  111) !     attribué automatiquement
(  112) IF (KNUMER == 0) THEN
(  113)   CALL FAAUTO_MT64  (FA, KNUMER, .FALSE.)
(  114)   IRANG=0
(  115) ENDIF
(  116) !
(  117) IF (ILOMIN.LE.0) THEN
(  118)   IREP=-65
(  119)   GOTO 1001
(  120) ELSEIF (IRANG.NE.0) THEN
(  121) !
(  122) !            Controle de non-ouverture prealable (au sens du logiciel)
(  123) !
(  124)   IREP=-55
(  125)   IRANMS=IRANG
(  126)   GOTO 1001
(  127) ENDIF
(  128) !
(  129) !             Verrouillage global, si necessaire.
(  130) !
(  131) !        A-t-on deja atteint le nombre limite de fichiers ARPEGE
(  132) !     ouverts simultanement ? Si non, on cherche un emplacement libre
(  133) !     dans la table FA%NULOGI (logiquement, il devrait en exister un)
(  134) !
(  135) IF (FA%NFIOUV.GE.FA%JPNXFA) THEN
(  136)   IREP=-56
(  137)   GOTO 1001
(  138) ELSE
(  139) !
(  140)   DO J=1,FA%JPNXFA
(  141) !
(  142)   IF (FA%FICHIER(J)%NULOGI.EQ.JPNIIL) THEN
(  143)     IRANG=J
(  144)     GOTO 102
(  145)   ENDIF
(  146) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 5

(  147)   ENDDO
(  148) !
(  149)   IREP=-66
(  150)   GOTO 1001
(  151) !
(  152) 102 CONTINUE
(  153) !
(  154) ENDIF
(  155) !
(  156) !**
(  157) !     2.  -  CONTROLES SPECIFIQUES AU LOGICIEL DE FICHIERS ARPEGE.
(  158) !-----------------------------------------------------------------------
(  159) !
(  160) LLNOUF=KNBARI.EQ.0
(  161) CALL FANUCA_MT64                          &
(  162) &               (FA, CDNOMC,IRANGC,.FALSE.)
(  163) LLNOUC=IRANGC.EQ.0
(  164) !
(  165) IF (LLNOUF) THEN
(  166) !
(  167)   IF (LLNOUC) THEN
(  168)     IREP=-57
(  169)     GOTO 1001
(  170)   ELSE
(  171) !
(  172) !         Fichier en mode creation et cadre predefini... OK a ce niveau.
(  173) !
(  174) !       On ecrit les articles definissant le cadre sur le fichier,
(  175) !     ainsi qu'un article ayant pour nom l'identificateur "par defaut",
(  176) !     (en fait, le nom du cadre) de maniere a ce que cet article soit
(  177) !     sequentiellement celui qui suit le dernier article du cadre.
(  178) !
(  179)     ILNOMC=FA%CADRE(IRANGC)%NLCCAD
(  180) !
(  181)   ENDIF
(  182) !
(  183) ENDIF
(  184) 
(  185) ITRONC=FA%CADRE(IRANGC)%MTRONC
(  186) ITYPTR=FA%CADRE(IRANGC)%NTYPTR
(  187) 
(  188) CALL NEW_FICHIER (FA, FA%FICHIER(IRANG), FA%JPLDAT, ITRONC, ITYPTR)
(  189) 
(  190) !*
(  191) !        Controle de la Date fichier, et stockage dans FA%MADATE.
(  192) !
(  193) !  IDATEF arbitraire pour contenter FACOND
(  194) IDATEF(1) = 1993
(  195) IDATEF(2) = 9
(  196) IDATEF(3) = 2
(  197) IDATEF(4) = 0
(  198) IDATEF(5) = 0
(  199) IDATEF(6) = 1
(  200) IDATEF(7) = 0
(  201) IDATEF(8) = 0
(  202) IDATEF(9) = 1
(  203) IDATEF(10) = 0
(  204) IDATEF(11) = 0






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 6

(  205) 
(  206) DO J=1,FA%JPLDAT
(  207)   FA%FICHIER(IRANG)%MADATE(J)=IDATEF(J)
(  208) ENDDO
(  209) 
(  210) FA%FICHIER(IRANG)%MADATX (:) = 0
(  211) 
(  212) !**
(  213) !     3.  -  ON MET A JOUR LES TABLES RELATIVES AUX FICHIERS.
(  214) !-----------------------------------------------------------------------
(  215) !
(  216) !
(  217) IREPOU=0
(  218) !
(  219) !
(  220) FA%NFIOUV=FA%NFIOUV+1
(  221) FA%NULIND(FA%NFIOUV)=IRANG
(  222) FA%FICHIER(IRANG)%NULOGI=KNUMER
(  223) FA%FICHIER(IRANG)%NUCADR=IRANGC
(  224) !
(  225) FA%FICHIER(IRANG)%LNOMME=LDNOMM
(  226) FA%FICHIER(IRANG)%NIVOMS=KNIMES
(  227) FA%FICHIER(IRANG)%LERRFA=LDERFA
(  228) FA%FICHIER(IRANG)%LCREAF=.FALSE.
(  229) FA%FICHIER(IRANG)%NBFPDG=FA%NBIPDG
(  230) FA%FICHIER(IRANG)%NBFCSP=FA%NBICSP
(  231) FA%FICHIER(IRANG)%NPUFLA=FA%NPUILA
(  232) FA%FICHIER(IRANG)%NMFDPL=FA%NMIDPL
(  233) FA%FICHIER(IRANG)%NFGRIB=FA%NIGRIB
(  234) FA%FICHIER(IRANG)%CIDENT=CDNOMC
(  235) !
(  236) IF (ITYPTR.LT.0) THEN
(  237)   FA%FICHIER(IRANG)%NSTROF=MIN (FA%NSTROI,ITRONC-1,-ITYPTR-1)
(  238) ELSE
(  239)   FA%FICHIER(IRANG)%NSTROF=MIN (FA%NSTROI,ITRONC-1)
(  240) ENDIF
(  241) !
(  242) ! Appel a FAINOC pour interpreter les eventuels defauts
(  243) ! de -1 pris par FA%NBFPDG, FA%NBFCSP, FA%NSTROF et FA%NPUFLA en
(  244) ! IRANG-ieme position.
(  245) !
(  246) CALL FAINOC_MT64            &
(  247) &               (FA,  IRANG )
(  248) !
(  249) IRANER=IRANG
(  250) IRANMS=IRANG
(  251) IPUILA=FA%FICHIER(IRANG)%NPUFLA
(  252) !
(  253) FA%FICHIER(IRANG)%NCOGRIF(:)=FA%NCODGRI(:)
(  254) FA%FICHIER(IRANG)%NRASHO = 0
(  255) FA%FICHIER(IRANG)%NRASVE = 0
(  256) !
(  257) !   L'initialisation de FLAP1Dx sera faite dans FACSIM
(  258) !
(  259) FA%FICHIER(IRANG)%LIFLAP=.TRUE.
(  260) !
(  261) !        On incremente le nombre de fichiers attaches au cadre specifie.
(  262) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 7

(  263) FA%CADRE(IRANGC)%NULCAD=FA%CADRE(IRANGC)%NULCAD+1
(  264) IREP=IREPOU
(  265) GOTO 1001
(  266) !**
(  267) !     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
(  268) !-----------------------------------------------------------------------
(  269) !
(  270) CLACTI='INQUIRE'
(  271) !
(  272) !      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
(  273) !
(  274) IREP=ABS (IREP)
(  275) !**
(  276) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  277) !            VIA LE SOUS-PROGRAMME "LFIEMS" .
(  278) !-----------------------------------------------------------------------
(  279) !
(  280) 1001 CONTINUE
(  281) KREP=IREP
(  282) LLFATA=LLMOER (IREP,IRANER)
(  283) !
(  284) IF (LLFATA) THEN
(  285)   INIMES=2
(  286) ELSE
(  287)   INIMES=IXNVMS (IRANMS)
(  288) ENDIF
(  289) !
(  290) IF (.NOT.LLFATA.AND.INIMES.EQ.0)  THEN 
(  291)   IF (LHOOK) CALL DR_HOOK('FANOUV_MT',1,ZHOOK_HANDLE)
(  292)   RETURN
(  293) ENDIF
(  294) !
(  295) CLNSPR='FANOUV'
(  296) !
(  297) IF (INIMES.EQ.2) THEN
(  298) !
(  299)   IF (ILNOMC.GT.0) THEN
(  300)     ILACTI=MIN (INT (LEN (CLACTI), JPLIKB),ILNOMC)
(  301)     CLACTI(1:ILACTI)=CDNOMC(1:ILNOMC)
(  302)   ELSE
(  303)     ILACTI=8
(  304)     CLACTI=FA%CHAINC(:ILACTI)
(  305)   ENDIF
(  306) !
(  307)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,          &
(  308) &     '', LDNOMM= '',L1,'', CDSTTU='''''',A7,'''''', LDERFA= '',L1, &
(  309) &     '',  LDIMST= '',L1,                                           &
(  310) &         '', KNIMES='',I2,'', KNBARP='',I6,'' KNBARI='',I6)')      &
(  311) &   KREP,KNUMER,LDNOMM,CDSTTU,LDERFA,LDIMST,KNIMES,KNBARP,KNBARI
(  312)   CALL FAIPAR_MT64                                      &
(  313) &                 (FA, KNUMER,INIMES,IREP,.FALSE.,CLMESS, &
(  314) &                  CLNSPR,CLACTI(1:ILACTI),LLRLFI)
(  315)   CLMESS='CDNOMC='''//CLACTI(1:ILACTI)//''''
(  316)   CALL FAIPAR_MT64                                     &
(  317) &                 (FA, KNUMER,INIMES,IREP,LLFATA,CLMESS, &
(  318) &               CLNSPR,                                  &
(  319) &               CLACTI(1:ILACTI),LLRLFI)
(  320) ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 8

(  321) !
(  322) IF (LHOOK) CALL DR_HOOK('FANOUV_MT',1,ZHOOK_HANDLE)
(  323) 
(  324) CONTAINS
(  325) 
(  326) #include "facom2.llmoer.h"
(  327) #include "facom2.ixnvms.h"
(  328) 
(  329) END SUBROUTINE FANOUV_MT64
(  330) 
(  331) 
(  332) 
(  333) 
(  334) ! Oct-2012 P. Marguinaud 64b LFI
(  335) SUBROUTINE FANOUV64                                      &
(  336) &           (KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  337) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  338) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  339) &                   FA_COM_DEFAULT_INIT,  &
(  340) &                   NEW_FA_DEFAULT
(  341) USE LFI_PRECISION
(  342) IMPLICIT NONE
(  343) ! Arguments
(  344) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  345) INTEGER (KIND=JPLIKB)  KNUMER                                 ! IN   
(  346) LOGICAL                LDNOMM                                 ! IN   
(  347) CHARACTER (LEN=*)      CDNOMF                                 ! IN   
(  348) CHARACTER (LEN=*)      CDSTTU                                 ! IN   
(  349) LOGICAL                LDERFA                                 ! IN   
(  350) LOGICAL                LDIMST                                 ! IN   
(  351) INTEGER (KIND=JPLIKB)  KNIMES                                 ! IN   
(  352) INTEGER (KIND=JPLIKB)  KNBARP                                 ! IN   
(  353) INTEGER (KIND=JPLIKB)  KNBARI                                 !   OUT
(  354) CHARACTER (LEN=*)      CDNOMC                                 ! IN   
(  355) 
(  356) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  357) 
(  358) CALL FANOUV_MT64                                             &
(  359) &           (FA, KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  360) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  361) 
(  362) END SUBROUTINE FANOUV64
(  363) 
(  364) SUBROUTINE FANOUV                                        &
(  365) &           (KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  366) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  367) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  368) &                   FA_COM_DEFAULT_INIT,  &
(  369) &                   NEW_FA_DEFAULT
(  370) USE LFI_PRECISION
(  371) IMPLICIT NONE
(  372) ! Arguments
(  373) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  374) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  375) LOGICAL                LDNOMM                                 ! IN   
(  376) CHARACTER (LEN=*)      CDNOMF                                 ! IN   
(  377) CHARACTER (LEN=*)      CDSTTU                                 ! IN   
(  378) LOGICAL                LDERFA                                 ! IN   






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 9

(  379) LOGICAL                LDIMST                                 ! IN   
(  380) INTEGER (KIND=JPLIKM)  KNIMES                                 ! IN   
(  381) INTEGER (KIND=JPLIKM)  KNBARP                                 ! IN   
(  382) INTEGER (KIND=JPLIKM)  KNBARI                                 !   OUT
(  383) CHARACTER (LEN=*)      CDNOMC                                 ! IN   
(  384) 
(  385) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  386) 
(  387) CALL FANOUV_MT                                               &
(  388) &           (FA, KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  389) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  390) 
(  391) END SUBROUTINE FANOUV
(  392) 
(  393) SUBROUTINE FANOUV_MT                                         &
(  394) &           (FA, KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  395) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  396) USE FA_MOD, ONLY : FA_COM
(  397) USE LFI_PRECISION
(  398) IMPLICIT NONE
(  399) ! Arguments
(  400) TYPE (FA_COM)          FA                                     ! INOUT
(  401) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  402) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  403) LOGICAL                LDNOMM                                 ! IN   
(  404) CHARACTER (LEN=*)      CDNOMF                                 ! IN   
(  405) CHARACTER (LEN=*)      CDSTTU                                 ! IN   
(  406) LOGICAL                LDERFA                                 ! IN   
(  407) LOGICAL                LDIMST                                 ! IN   
(  408) INTEGER (KIND=JPLIKM)  KNIMES                                 ! IN   
(  409) INTEGER (KIND=JPLIKM)  KNBARP                                 ! IN   
(  410) INTEGER (KIND=JPLIKM)  KNBARI                                 !   OUT
(  411) CHARACTER (LEN=*)      CDNOMC                                 ! IN   
(  412) ! Local integers
(  413) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  414) INTEGER (KIND=JPLIKB)  INUMER                                 ! IN   
(  415) INTEGER (KIND=JPLIKB)  INIMES                                 ! IN   
(  416) INTEGER (KIND=JPLIKB)  INBARP                                 ! IN   
(  417) INTEGER (KIND=JPLIKB)  INBARI                                 !   OUT
(  418) ! Convert arguments
(  419) 
(  420) INUMER     = INT (    KNUMER, JPLIKB)
(  421) INIMES     = INT (    KNIMES, JPLIKB)
(  422) INBARP     = INT (    KNBARP, JPLIKB)
(  423) 
(  424) CALL FANOUV_MT64                                             &
(  425) &           (FA, IREP, INUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  426) &           LDIMST, INIMES, INBARP, INBARI, CDNOMC)
(  427) 
(  428) KREP       = INT (      IREP, JPLIKM)
(  429) KNBARI     = INT (    INBARI, JPLIKM)
(  430) 
(  431) IF (KNUMER == 0) THEN
(  432)   KNUMER = INT (    INUMER, JPLIKM)
(  433) ENDIF
(  434) 
(  435) END SUBROUTINE FANOUV_MT
(  436) 






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 10

(  437) 
(  438) 
(  439) !INTF KREP            OUT 
(  440) !INTF KNUMER        IN    
(  441) !INTF LDNOMM        IN    
(  442) !INTF CDNOMF        IN    
(  443) !INTF CDSTTU        IN    
(  444) !INTF LDERFA        IN    
(  445) !INTF LDIMST        IN    
(  446) !INTF KNIMES        IN    
(  447) !INTF KNBARP        IN    
(  448) !INTF KNBARI          OUT 
(  449) !INTF CDNOMC        IN    



















































NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 11

(    1) # 1 "fanouv.F90"
(    1) ! Feb-2013 P. Marguinaud fix uninitialized output variable
(    2) ! Oct-2012 P. Marguinaud 64b LFI
(    3) ! Jan-2011 P. Marguinaud Thread-safe FA
(    4) ! Sep-2012 P. Marguinaud Remove unused local variables
(    5) SUBROUTINE FANOUV_MT64                                             &
(    6) &                     (FA, KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU,   &
(    7) &                      LDERFA, LDIMST, KNIMES, KNBARP, KNBARI,     &
(    8) &                      CDNOMC)
(    9) USE FA_MOD, ONLY : FA_COM, NEW_FICHIER, JPNIIL
(   10) USE PARKIND1, ONLY : JPRB
(   11) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   12) USE LFI_PRECISION
(   13) IMPLICIT NONE
(   14) !****
(   15) !        Sous-programme d'initialisation SANS OUVERTURE d'une unite logique 
(   16) !        "Fichier ARPEGE". Il s'agit d'un fichier indexe, 
(   17) !        traite par le logiciel LFI.
(   18) !
(   19) !      FANOUV est derive de FAITOU, mais ne fait pas l'appel a la couche LFI
(   20) !             pour l'ouverture reelle.
(   21) !
(   22) !      utilise pour la seule compression des donnees par des processeurs
(   23) !      qui ne font pas d'ecriture effective sur disque
(   24) !
(   25) !**
(   26) !     ARGUMENTS : Ce sont les memes que pour "LFIOUV", avec CDNOMC comme
(   27) !                 argument supplementaire.
(   28) !
(   29) !                 KREP   (Sortie) ==> Code-reponse du sous-programme;
(   30) !                 KNUMER (Entree) ==> Numero de l'unite logique;
(   31) !                 LDNOMM (Entree) ==> Vrai si l'unite logique doit etre
(   32) !                                     associee a un NOM de Fichier EXP-
(   33) !                                     LICITE lors de l'"OPEN" FORTRAN;
(   34) !                 CDNOMF (Entree) ==> Nom de fichier explicite, si
(   35) !                                     *LDNOMM* est VRAI - Meme si ce
(   36) !                                     n'est pas le cas, ce *DOIT* ETRE
(   37) !                                     UN OBJET DE TYPE "CHARACTER" .
(   38) !                 CDSTTU (Entree) ==> "STATUS" pour l'"OPEN" FORTRAN
(   39) !                                     ('OLD','NEW','UNKNOWN','SCRATCH')
(   40) !                                     par defaut, mettre 'UNKNOWN';
(   41) !                 LDERFA (Entree) ==> Option d'erreur fatale;
(   42) !                 LDIMST (Entree) ==> Option impression de Statistiques
(   43) !                                     au moment de la fermeture;
(   44) !                 KNIMES (Entree) ==> Niveau de la Messagerie (0,1 ou 2)
(   45) !                                     ( 0==>Rien, 2==>Tout )
(   46) !                 KNBARP (Entree) ==> Nombre d'articles logiques prevus,
(   47) !                                     ce qui n'est utilise que lors de
(   48) !                                     la Creation du fichier,
(   49) !                                     et qui n'empeche quand meme pas
(   50) !                                     d'avoir plus d'articles logiques;
(   51) !                 KNBARI (Sortie) ==> Nombre d'articles logiques de don-
(   52) !                                     nees sur le fichier, initialement.
(   53) !                                     (zero si creation)
(   54) !                 CDNOMC (Entree) ==> Nom du CADRE associe au fichier.
(   55) !*
(   56) !     N.B. :  Pour un fichier en mode creation, ce cadre doit avoir ete
(   57) !          defini au prealable (via le sous-programme FACADE, ou par






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 12

(   58) !          l'ouverture d'un fichier preexistant).
(   59) !             Pour un fichier ARPEGE preexistant, le cadre est lu sur le
(   60) !          fichier; s'il etait deja defini auparavant, il y a controle
(   61) !          de coherence entre les deux versions du cadre.
(   62) !
(   63) !
(   64) !
(   65) TYPE(FA_COM) :: FA
(   66) INTEGER (KIND=JPLIKB) KREP, KNUMER, KNIMES, KNBARP, KNBARI
(   67) !
(   68) INTEGER (KIND=JPLIKB) IRANG, IRANMS, IREPOU
(   69) INTEGER (KIND=JPLIKB) ILNOMC, ILOMIN, IREP, J
(   70) INTEGER (KIND=JPLIKB) IRANER, IRANGC
(   71) INTEGER (KIND=JPLIKB) ITRONC, ILACTI, INIMES
(   72) INTEGER (KIND=JPLIKB) ITYPTR, IPUILA
(   73) !
(   74) INTEGER (KIND=JPLIKB) IDATEF (FA%JPLDAT)
(   75) !
(   76) LOGICAL LDNOMM, LDERFA, LDIMST, LLNOUF, LLNOUC, LLRLFI
(   77) !
(   78) CHARACTER CDNOMF*(*), CDSTTU*(*), CDNOMC*(*)
(   79) !
(   80) CHARACTER(LEN=FA%JPXNOM) CLACTI 
(   81) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   82) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   83) LOGICAL                  LLFATA
(   84) # 85 "fanouv.F90"
(   85) !**
(   86) !     1.  -  CONTROLES DIVERS
(   87) !-----------------------------------------------------------------------
(   88) !
(   89) !     Controle sommaire sur les arguments...
(   90) !
(   91) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   92) IF (LHOOK) CALL DR_HOOK('FANOUV_MT',0,ZHOOK_HANDLE)
(   93) KNBARI=0
(   94) CLACTI=''
(   95) IRANG=0
(   96) IRANER=0
(   97) IRANMS=0
(   98) IREPOU=JPNIIL
(   99) LLRLFI=.FALSE.
(  100) ILNOMC=INT (LEN (CDNOMC), JPLIKB)
(  101) ILOMIN=MIN ( INT (LEN (CDNOMF), JPLIKB),         &
(  102) &             INT (LEN (CDSTTU), JPLIKB), ILNOMC)
(  103) !
(  104) !        L'appel ci-dessous est legerement anticipe, de maniere a
(  105) !     initialiser les variables globales du logiciel s'il s'agit
(  106) !     du premier appel a un sous-programme de ce logiciel.
(  107) !
(  108) CALL FANUMU_MT64                 &
(  109) &               (FA, KNUMER,IRANG)
(  110) !        Si KNUMER est nul, alors le numero d'unite logique est
(  111) !     attribué automatiquement
(  112) IF (KNUMER == 0) THEN
(  113)   CALL FAAUTO_MT64  (FA, KNUMER, .FALSE.)
(  114)   IRANG=0
(  115) ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 13

(  116) !
(  117) IF (ILOMIN.LE.0) THEN
(  118)   IREP=-65
(  119)   GOTO 1001
(  120) ELSEIF (IRANG.NE.0) THEN
(  121) !
(  122) !            Controle de non-ouverture prealable (au sens du logiciel)
(  123) !
(  124)   IREP=-55
(  125)   IRANMS=IRANG
(  126)   GOTO 1001
(  127) ENDIF
(  128) !
(  129) !             Verrouillage global, si necessaire.
(  130) !
(  131) !        A-t-on deja atteint le nombre limite de fichiers ARPEGE
(  132) !     ouverts simultanement ? Si non, on cherche un emplacement libre
(  133) !     dans la table FA%NULOGI (logiquement, il devrait en exister un)
(  134) !
(  135) IF (FA%NFIOUV.GE.FA%JPNXFA) THEN
(  136)   IREP=-56
(  137)   GOTO 1001
(  138) ELSE
(  139) !
(  140)   DO J=1,FA%JPNXFA
(  141) !
(  142)   IF (FA%FICHIER(J)%NULOGI.EQ.JPNIIL) THEN
(  143)     IRANG=J
(  144)     GOTO 102
(  145)   ENDIF
(  146) !
(  147)   ENDDO
(  148) !
(  149)   IREP=-66
(  150)   GOTO 1001
(  151) !
(  152) 102 CONTINUE
(  153) !
(  154) ENDIF
(  155) !
(  156) !**
(  157) !     2.  -  CONTROLES SPECIFIQUES AU LOGICIEL DE FICHIERS ARPEGE.
(  158) !-----------------------------------------------------------------------
(  159) !
(  160) LLNOUF=KNBARI.EQ.0
(  161) CALL FANUCA_MT64                          &
(  162) &               (FA, CDNOMC,IRANGC,.FALSE.)
(  163) LLNOUC=IRANGC.EQ.0
(  164) !
(  165) IF (LLNOUF) THEN
(  166) !
(  167)   IF (LLNOUC) THEN
(  168)     IREP=-57
(  169)     GOTO 1001
(  170)   ELSE
(  171) !
(  172) !         Fichier en mode creation et cadre predefini... OK a ce niveau.
(  173) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 14

(  174) !       On ecrit les articles definissant le cadre sur le fichier,
(  175) !     ainsi qu'un article ayant pour nom l'identificateur "par defaut",
(  176) !     (en fait, le nom du cadre) de maniere a ce que cet article soit
(  177) !     sequentiellement celui qui suit le dernier article du cadre.
(  178) !
(  179)     ILNOMC=FA%CADRE(IRANGC)%NLCCAD
(  180) !
(  181)   ENDIF
(  182) !
(  183) ENDIF
(  184) # 185 "fanouv.F90"
(  185) ITRONC=FA%CADRE(IRANGC)%MTRONC
(  186) ITYPTR=FA%CADRE(IRANGC)%NTYPTR
(  187) # 188 "fanouv.F90"
(  188) CALL NEW_FICHIER (FA, FA%FICHIER(IRANG), FA%JPLDAT, ITRONC, ITYPTR)
(  189) # 190 "fanouv.F90"
(  190) !*
(  191) !        Controle de la Date fichier, et stockage dans FA%MADATE.
(  192) !
(  193) !  IDATEF arbitraire pour contenter FACOND
(  194) IDATEF(1) = 1993
(  195) IDATEF(2) = 9
(  196) IDATEF(3) = 2
(  197) IDATEF(4) = 0
(  198) IDATEF(5) = 0
(  199) IDATEF(6) = 1
(  200) IDATEF(7) = 0
(  201) IDATEF(8) = 0
(  202) IDATEF(9) = 1
(  203) IDATEF(10) = 0
(  204) IDATEF(11) = 0
(  205) # 206 "fanouv.F90"
(  206) DO J=1,FA%JPLDAT
(  207)   FA%FICHIER(IRANG)%MADATE(J)=IDATEF(J)
(  208) ENDDO
(  209) # 210 "fanouv.F90"
(  210) FA%FICHIER(IRANG)%MADATX (:) = 0
(  211) # 212 "fanouv.F90"
(  212) !**
(  213) !     3.  -  ON MET A JOUR LES TABLES RELATIVES AUX FICHIERS.
(  214) !-----------------------------------------------------------------------
(  215) !
(  216) !
(  217) IREPOU=0
(  218) !
(  219) !
(  220) FA%NFIOUV=FA%NFIOUV+1
(  221) FA%NULIND(FA%NFIOUV)=IRANG
(  222) FA%FICHIER(IRANG)%NULOGI=KNUMER
(  223) FA%FICHIER(IRANG)%NUCADR=IRANGC
(  224) !
(  225) FA%FICHIER(IRANG)%LNOMME=LDNOMM
(  226) FA%FICHIER(IRANG)%NIVOMS=KNIMES
(  227) FA%FICHIER(IRANG)%LERRFA=LDERFA
(  228) FA%FICHIER(IRANG)%LCREAF=.FALSE.
(  229) FA%FICHIER(IRANG)%NBFPDG=FA%NBIPDG
(  230) FA%FICHIER(IRANG)%NBFCSP=FA%NBICSP
(  231) FA%FICHIER(IRANG)%NPUFLA=FA%NPUILA






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 15

(  232) FA%FICHIER(IRANG)%NMFDPL=FA%NMIDPL
(  233) FA%FICHIER(IRANG)%NFGRIB=FA%NIGRIB
(  234) FA%FICHIER(IRANG)%CIDENT=CDNOMC
(  235) !
(  236) IF (ITYPTR.LT.0) THEN
(  237)   FA%FICHIER(IRANG)%NSTROF=MIN (FA%NSTROI,ITRONC-1,-ITYPTR-1)
(  238) ELSE
(  239)   FA%FICHIER(IRANG)%NSTROF=MIN (FA%NSTROI,ITRONC-1)
(  240) ENDIF
(  241) !
(  242) ! Appel a FAINOC pour interpreter les eventuels defauts
(  243) ! de -1 pris par FA%NBFPDG, FA%NBFCSP, FA%NSTROF et FA%NPUFLA en
(  244) ! IRANG-ieme position.
(  245) !
(  246) CALL FAINOC_MT64            &
(  247) &               (FA,  IRANG )
(  248) !
(  249) IRANER=IRANG
(  250) IRANMS=IRANG
(  251) IPUILA=FA%FICHIER(IRANG)%NPUFLA
(  252) !
(  253) FA%FICHIER(IRANG)%NCOGRIF(:)=FA%NCODGRI(:)
(  254) FA%FICHIER(IRANG)%NRASHO = 0
(  255) FA%FICHIER(IRANG)%NRASVE = 0
(  256) !
(  257) !   L'initialisation de FLAP1Dx sera faite dans FACSIM
(  258) !
(  259) FA%FICHIER(IRANG)%LIFLAP=.TRUE.
(  260) !
(  261) !        On incremente le nombre de fichiers attaches au cadre specifie.
(  262) !
(  263) FA%CADRE(IRANGC)%NULCAD=FA%CADRE(IRANGC)%NULCAD+1
(  264) IREP=IREPOU
(  265) GOTO 1001
(  266) !**
(  267) !     9.  - CI-DESSOUS, ETIQUETTES DE BRANCHEMENT EN CAS D'ERREUR E/S.
(  268) !-----------------------------------------------------------------------
(  269) !
(  270) CLACTI='INQUIRE'
(  271) !
(  272) !      AU CAS OU, ON FORCE LE CODE-REPONSE ENTREE/SORTIE A ETRE POSITIF.
(  273) !
(  274) IREP=ABS (IREP)
(  275) !**
(  276) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  277) !            VIA LE SOUS-PROGRAMME "LFIEMS" .
(  278) !-----------------------------------------------------------------------
(  279) !
(  280) 1001 CONTINUE
(  281) KREP=IREP
(  282) LLFATA=LLMOER (IREP,IRANER)
(  283) !
(  284) IF (LLFATA) THEN
(  285)   INIMES=2
(  286) ELSE
(  287)   INIMES=IXNVMS (IRANMS)
(  288) ENDIF
(  289) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 16

(  290) IF (.NOT.LLFATA.AND.INIMES.EQ.0)  THEN 
(  291)   IF (LHOOK) CALL DR_HOOK('FANOUV_MT',1,ZHOOK_HANDLE)
(  292)   RETURN
(  293) ENDIF
(  294) !
(  295) CLNSPR='FANOUV'
(  296) !
(  297) IF (INIMES.EQ.2) THEN
(  298) !
(  299)   IF (ILNOMC.GT.0) THEN
(  300)     ILACTI=MIN (INT (LEN (CLACTI), JPLIKB),ILNOMC)
(  301)     CLACTI(1:ILACTI)=CDNOMC(1:ILNOMC)
(  302)   ELSE
(  303)     ILACTI=8
(  304)     CLACTI=FA%CHAINC(:ILACTI)
(  305)   ENDIF
(  306) !
(  307)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUMER='',I3,          &
(  308) &     '', LDNOMM= '',L1,'', CDSTTU='''''',A7,'''''', LDERFA= '',L1, &
(  309) &     '',  LDIMST= '',L1,                                           &
(  310) &         '', KNIMES='',I2,'', KNBARP='',I6,'' KNBARI='',I6)')      &
(  311) &   KREP,KNUMER,LDNOMM,CDSTTU,LDERFA,LDIMST,KNIMES,KNBARP,KNBARI
(  312)   CALL FAIPAR_MT64                                      &
(  313) &                 (FA, KNUMER,INIMES,IREP,.FALSE.,CLMESS, &
(  314) &                  CLNSPR,CLACTI(1:ILACTI),LLRLFI)
(  315)   CLMESS='CDNOMC='''//CLACTI(1:ILACTI)//''''
(  316)   CALL FAIPAR_MT64                                     &
(  317) &                 (FA, KNUMER,INIMES,IREP,LLFATA,CLMESS, &
(  318) &               CLNSPR,                                  &
(  319) &               CLACTI(1:ILACTI),LLRLFI)
(  320) ENDIF
(  321) !
(  322) IF (LHOOK) CALL DR_HOOK('FANOUV_MT',1,ZHOOK_HANDLE)
(  323) # 324 "fanouv.F90"
(  324) CONTAINS
(  325) # 326 "fanouv.F90"
(  326) # 1 ".D[27]/facom2.llmoer.h"
(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,
(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 327 "fanouv.F90"
(  327) # 327 "fanouv.F90"
(  327) # 1 ".D[27]/facom2.ixnvms.h"
(    1) !*
(    2) !       Fonction "en ligne" donnant le plus haut niveau de messagerie
(    3) !       acceptable pour l'unite logique de rang "I3456"
(    4) !       (utilisation des niveaux de messagerie global et propre au
(    5) !        fichier; s'il n'y a pas de fichier - I3456=0, d'ou le dimensio-
(    6) !        nnement de *NIVOMS* a partir de zero, le niveau de filtrage






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 17

(    7) !        global joue seul)
(    8) !
(    9) INTEGER (KIND=JPLIKB) FUNCTION IXNVMS (I3456)
(   10) INTEGER (KIND=JPLIKB) :: I3456
(   11) IXNVMS =MIN (2_JPLIKB ,2_JPLIKB *FA%NIMSGA,MAX (2_JPLIKB *FA%NIMSGA-2_JPLIKB ,FA%FICHIER(I3456)%NIVOMS))
(   12) END FUNCTION
(   13) # 328 "fanouv.F90"
(  328) # 329 "fanouv.F90"
(  329) END SUBROUTINE FANOUV_MT64
(  330) # 334 "fanouv.F90"
(  334) ! Oct-2012 P. Marguinaud 64b LFI
(  335) SUBROUTINE FANOUV64                                      &
(  336) &           (KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  337) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  338) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  339) &                   FA_COM_DEFAULT_INIT,  &
(  340) &                   NEW_FA_DEFAULT
(  341) USE LFI_PRECISION
(  342) IMPLICIT NONE
(  343) ! Arguments
(  344) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  345) INTEGER (KIND=JPLIKB)  KNUMER                                 ! IN   
(  346) LOGICAL                LDNOMM                                 ! IN   
(  347) CHARACTER (LEN=*)      CDNOMF                                 ! IN   
(  348) CHARACTER (LEN=*)      CDSTTU                                 ! IN   
(  349) LOGICAL                LDERFA                                 ! IN   
(  350) LOGICAL                LDIMST                                 ! IN   
(  351) INTEGER (KIND=JPLIKB)  KNIMES                                 ! IN   
(  352) INTEGER (KIND=JPLIKB)  KNBARP                                 ! IN   
(  353) INTEGER (KIND=JPLIKB)  KNBARI                                 !   OUT
(  354) CHARACTER (LEN=*)      CDNOMC                                 ! IN   
(  355) # 356 "fanouv.F90"
(  356) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  357) # 358 "fanouv.F90"
(  358) CALL FANOUV_MT64                                             &
(  359) &           (FA, KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  360) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  361) # 362 "fanouv.F90"
(  362) END SUBROUTINE FANOUV64
(  363) # 364 "fanouv.F90"
(  364) SUBROUTINE FANOUV                                        &
(  365) &           (KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  366) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  367) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  368) &                   FA_COM_DEFAULT_INIT,  &
(  369) &                   NEW_FA_DEFAULT
(  370) USE LFI_PRECISION
(  371) IMPLICIT NONE
(  372) ! Arguments
(  373) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  374) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  375) LOGICAL                LDNOMM                                 ! IN   
(  376) CHARACTER (LEN=*)      CDNOMF                                 ! IN   
(  377) CHARACTER (LEN=*)      CDSTTU                                 ! IN   
(  378) LOGICAL                LDERFA                                 ! IN   
(  379) LOGICAL                LDIMST                                 ! IN   
(  380) INTEGER (KIND=JPLIKM)  KNIMES                                 ! IN   
(  381) INTEGER (KIND=JPLIKM)  KNBARP                                 ! IN   






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 18

(  382) INTEGER (KIND=JPLIKM)  KNBARI                                 !   OUT
(  383) CHARACTER (LEN=*)      CDNOMC                                 ! IN   
(  384) # 385 "fanouv.F90"
(  385) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  386) # 387 "fanouv.F90"
(  387) CALL FANOUV_MT                                               &
(  388) &           (FA, KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  389) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  390) # 391 "fanouv.F90"
(  391) END SUBROUTINE FANOUV
(  392) # 393 "fanouv.F90"
(  393) SUBROUTINE FANOUV_MT                                         &
(  394) &           (FA, KREP, KNUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  395) &           LDIMST, KNIMES, KNBARP, KNBARI, CDNOMC)
(  396) USE FA_MOD, ONLY : FA_COM
(  397) USE LFI_PRECISION
(  398) IMPLICIT NONE
(  399) ! Arguments
(  400) TYPE (FA_COM)          FA                                     ! INOUT
(  401) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  402) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  403) LOGICAL                LDNOMM                                 ! IN   
(  404) CHARACTER (LEN=*)      CDNOMF                                 ! IN   
(  405) CHARACTER (LEN=*)      CDSTTU                                 ! IN   
(  406) LOGICAL                LDERFA                                 ! IN   
(  407) LOGICAL                LDIMST                                 ! IN   
(  408) INTEGER (KIND=JPLIKM)  KNIMES                                 ! IN   
(  409) INTEGER (KIND=JPLIKM)  KNBARP                                 ! IN   
(  410) INTEGER (KIND=JPLIKM)  KNBARI                                 !   OUT
(  411) CHARACTER (LEN=*)      CDNOMC                                 ! IN   
(  412) ! Local integers
(  413) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  414) INTEGER (KIND=JPLIKB)  INUMER                                 ! IN   
(  415) INTEGER (KIND=JPLIKB)  INIMES                                 ! IN   
(  416) INTEGER (KIND=JPLIKB)  INBARP                                 ! IN   
(  417) INTEGER (KIND=JPLIKB)  INBARI                                 !   OUT
(  418) ! Convert arguments
(  419) # 420 "fanouv.F90"
(  420) INUMER     = INT (    KNUMER, JPLIKB)
(  421) INIMES     = INT (    KNIMES, JPLIKB)
(  422) INBARP     = INT (    KNBARP, JPLIKB)
(  423) # 424 "fanouv.F90"
(  424) CALL FANOUV_MT64                                             &
(  425) &           (FA, IREP, INUMER, LDNOMM, CDNOMF, CDSTTU, LDERFA, &
(  426) &           LDIMST, INIMES, INBARP, INBARI, CDNOMC)
(  427) # 428 "fanouv.F90"
(  428) KREP       = INT (      IREP, JPLIKM)
(  429) KNBARI     = INT (    INBARI, JPLIKM)
(  430) # 431 "fanouv.F90"
(  431) IF (KNUMER == 0) THEN
(  432)   KNUMER = INT (    INUMER, JPLIKM)
(  433) ENDIF
(  434) # 435 "fanouv.F90"
(  435) END SUBROUTINE FANOUV_MT
(  436) # 439 "fanouv.F90"
(  439) !INTF KREP            OUT 
(  440) !INTF KNUMER        IN    
(  441) !INTF LDNOMM        IN    






NVFORTRAN (Version     23.1)          02/24/2023  13:55:04      page 19

(  442) !INTF CDNOMF        IN    
(  443) !INTF CDSTTU        IN    
(  444) !INTF LDERFA        IN    
(  445) !INTF LDIMST        IN    
(  446) !INTF KNIMES        IN    
(  447) !INTF KNBARP        IN    
(  448) !INTF KNBARI          OUT 
(  449) !INTF CDNOMC        IN    
