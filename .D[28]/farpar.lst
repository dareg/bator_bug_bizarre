


NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: farpar.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FARPAR_MT64                                         &
(    4) &                     (FA,  KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(    5) USE FA_MOD, ONLY : FA_COM, JPNIIL, FAGR1TAB
(    6) USE PARKIND1, ONLY : JPRB
(    7) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    8) USE LFI_PRECISION
(    9) IMPLICIT NONE
(   10) !****
(   11) !      Sous-programme de reglage de la correspondance "nom d'article FA"
(   12) !              <-> "descripteurs GRIB du parametre+niveau"
(   13) !**
(   14) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   15) !    ( Tableau ) CDPREF (Entree) ==> Prefixe pour les KNUM noms d'article;
(   16) !    ( Tableau ) CDSUFF (Entree) ==> Suffixe pour les KNUM noms d'article;
(   17) !    ( Tableau ) KCODPA (Entree) ==> 6 descripteurs GRIB pour chacun
(   18) !                                    des KNUM parametres:
(   19) !      KCODPA(J,1) = KSEC1(1)  version de la table parametres
(   20) !      KCODPA(J,2) = KSEC1(6)  indicateur du parametre
(   21) !      KCODPA(J,3) = KSEC1(7)  indicateur du type de niveau
(   22) !      KCODPA(J,4) = KSEC1(8)  niveau
(   23) !      KCODPA(J,5) = KSEC1(9)  2ieme nv si couche, sinon 0
(   24) !      KCODPA(J,6) = KSEC1(18) indicateur du type de champ
(   25) !                              (0 sf si min/max:2 ou si cumul:4)
(   26) !
(   27) !                KNUM   (Entree  ==> Nombre de parametres a regler
(   28) !                          et        (dimension de CDPREF, CDSUFF et KCODPA)
(   29) !                        Sortie) ==> Nb de nouveaux parametres pouvant encore
(   30) !                                    etre definis lors d'un appel ulterieur.






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 3

(   31) !
(   32) !
(   33) !
(   34) TYPE(FA_COM) :: FA
(   35) INTEGER (KIND=JPLIKB) KREP, KNUM
(   36) INTEGER (KIND=JPLIKB) KCODPA(KNUM,8)
(   37) !
(   38) CHARACTER (LEN=*) CDPREF(KNUM), CDSUFF(KNUM)
(   39) !
(   40) TYPE (FAGR1TAB), POINTER :: YLGR1TAB (:)
(   41) !
(   42) INTEGER (KIND=JPLIKB) J, JJ, INUMER, INIMES, JMEM, IMEM (KNUM), IADD
(   43) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   44) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   45) 
(   46) !
(   47) INTRINSIC LEN_TRIM
(   48) !
(   49) !**
(   50) !     0.  -  CONTROLES ET INITIALISATIONS PREALABLES
(   51) !-----------------------------------------------------------------------
(   52) !
(   53) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   54) IF (LHOOK) CALL DR_HOOK('FARPAR_MT',0,ZHOOK_HANDLE)
(   55) IF (KNUM.LT.1) THEN
(   56)   KREP=-129
(   57)   IF (FA%LFAMOP) THEN
(   58)     WRITE (UNIT=FA%NULOUT,FMT=*)                         &
(   59) &           'FARPAR: Nb de parametres ',KNUM,' incorrect'
(   60)   ENDIF
(   61)   GOTO 1001
(   62) ENDIF
(   63) DO J = 1,KNUM
(   64)   IF ( INT (LEN_TRIM(CDPREF(J)), JPLIKB).LE.0 .OR.           &
(   65) &      INT (LEN_TRIM(CDPREF(J)), JPLIKB).GT.FA%JPXPRF ) THEN
(   66)     KREP=-129
(   67)     IF (FA%LFAMOP) THEN
(   68)       WRITE (UNIT=FA%NULOUT,FMT=*)                                &
(   69) &              'FARPAR: Longueur du prefixe ',CDPREF(J),          &
(   70) &              ' incorrecte : ',INT (LEN_TRIM(CDPREF(J)), JPLIKB)
(   71)     ENDIF
(   72)     GOTO 1001
(   73)   ENDIF
(   74)   IF ( INT (LEN_TRIM(CDSUFF(J)), JPLIKB).LE.0 .OR.     &
(   75) &      INT (LEN_TRIM(CDSUFF(J)), JPLIKB).GT.FA%JPXNOM- &
(   76) &      INT (LEN_TRIM(CDPREF(J)), JPLIKB) ) THEN
(   77)     KREP=-129
(   78)     IF (FA%LFAMOP) THEN
(   79)       WRITE (UNIT=FA%NULOUT,FMT=*)                                &
(   80) &              'FARPAR: Longueur du suffixe ',CDSUFF(J),          &
(   81) &              ' incorrecte : ',INT (LEN_TRIM(CDSUFF(J)), JPLIKB)
(   82)     ENDIF
(   83)     GOTO 1001
(   84)   ENDIF
(   85)   DO JJ = 1,3
(   86)     IF (KCODPA(J,JJ).LT.1 .OR. KCODPA(J,JJ).GT.255) THEN
(   87)       KREP=-129
(   88)       IF (FA%LFAMOP) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 4

(   89)         WRITE (UNIT=FA%NULOUT,FMT=*)                     &
(   90) &                'FARPAR: descripteur GRIB num ',JJ,     &
(   91) &                ' pour le parametre num ',J,' ( ',      &
(   92) &                CDPREF(J)//CDSUFF(J),' ) incorrect : ', &
(   93) &                KCODPA(J,JJ)
(   94)       ENDIF
(   95)       GOTO 1001
(   96)     ENDIF
(   97)   ENDDO
(   98)   IF (KCODPA(J,6).LT.0 .OR. KCODPA(J,6).GT.124) THEN
(   99)     KREP=-129
(  100)     IF (FA%LFAMOP) THEN
(  101)       WRITE (UNIT=FA%NULOUT,FMT=*)                     &
(  102) &              'FARPAR: descripteur GRIB, KSEC1(18),', &
(  103) &              ' pour le parametre num ',J,' ( ',      &
(  104) &              CDPREF(J)//CDSUFF(J),' ) incorrect : ', &
(  105) &              KCODPA(J,6)
(  106)     ENDIF
(  107)     GOTO 1001
(  108)   ENDIF
(  109)   IF (KCODPA(J,4).LT.0) THEN
(  110)     KREP=-129
(  111)     IF (FA%LFAMOP) THEN
(  112)       WRITE (UNIT=FA%NULOUT,FMT=*)                    &
(  113) &              'FARPAR: descripteur GRIB, KSEC1(8),',  &
(  114) &              ' pour le parametre num ',J,' ( ',      &
(  115) &              CDPREF(J)//CDSUFF(J),' ) incorrect : ', &
(  116) &              KCODPA(J,4)
(  117)     ENDIF
(  118)     GOTO 1001
(  119)   ENDIF
(  120) ENDDO
(  121) !
(  122) !**
(  123) !     2.  -  Prise en compte des nouvelles correspondances
(  124) !---------------------------------------------------------
(  125) !
(  126) !
(  127) 
(  128) IADD=0
(  129) 
(  130) DO J = 1,KNUM
(  131) ! Recherche prealable de l'eventuelle existence de la definition
(  132) ! de ce parametre (il faudra alors l'ecraser).
(  133)   JMEM = 0
(  134)   DO JJ = 1,FA%NBPARC
(  135)     IF (CDPREF(J)(1:INT (LEN_TRIM(CDPREF(J )), JPLIKB)).EQ.FA%YGR1TAB(JJ)%CIPREF(1:INT (LEN_TRIM(FA%YGR1TAB(JJ)%CIPREF), JPL
(  136)       & .AND. &
(  137)       & CDSUFF(J)(1:INT (LEN_TRIM(CDSUFF(J )), JPLIKB)).EQ.FA%YGR1TAB(JJ)%CISUFF(1:INT (LEN_TRIM(FA%YGR1TAB(JJ)%CISUFF), JPL
(  138)     THEN
(  139)       JMEM = JJ
(  140)       EXIT
(  141)     ENDIF
(  142)   ENDDO
(  143)   IF (JMEM==0) THEN
(  144)     IADD = IADD + 1
(  145)     IMEM (J) = FA%NBPARC + IADD
(  146)   ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 5

(  147)     IMEM (J) = JMEM
(  148)   ENDIF
(  149) ENDDO
(  150) 
(  151) IF (IADD > 0) THEN
(  152)   YLGR1TAB => FA%YGR1TAB
(  153)   ALLOCATE (FA%YGR1TAB (FA%NBPARC+IADD))
(  154)   FA%YGR1TAB (1:FA%NBPARC) = YLGR1TAB (1:FA%NBPARC)
(  155)   FA%NBPARC = FA%NBPARC+IADD
(  156)   DEALLOCATE (YLGR1TAB)
(  157) ENDIF
(  158) 
(  159) DO J = 1, KNUM
(  160)   
(  161)   JMEM = IMEM (J)
(  162) 
(  163)   FA%YGR1TAB(JMEM)%CIPREF      = CDPREF(J)(1:INT (LEN_TRIM(CDPREF(J)), JPLIKB))
(  164)   FA%YGR1TAB(JMEM)%CISUFF      = CDSUFF(J)(1:INT (LEN_TRIM(CDSUFF(J)), JPLIKB))
(  165)   FA%YGR1TAB(JMEM)%NCODPA(1:8) = KCODPA(J,1:8)
(  166) 
(  167)   IF (FA%LFAMOP) THEN
(  168)     WRITE (UNIT=FA%NULOUT,FMT=*)                              &
(  169) &           'FARPAR: Prise en compte de ',CDPREF(J)//CDSUFF(J)
(  170)     WRITE (UNIT=FA%NULOUT,FMT=*)                       &
(  171) &           '        associe a KSEC1(1,6:9 et 18) = ', &
(  172) &           FA%YGR1TAB(JMEM)%NCODPA(1:8)
(  173)   ENDIF
(  174) 
(  175) ENDDO
(  176) !
(  177) !**
(  178) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  179) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  180) !-----------------------------------------------------------------------
(  181) !
(  182) 1001 CONTINUE
(  183) !
(  184) IF (FA%LFAMOP) THEN
(  185)   INIMES=2
(  186)   CLNSPR='FARPAR'
(  187)   INUMER=JPNIIL
(  188) !
(  189)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4)') KREP
(  190)   CALL FAIPAR_MT64                                        &
(  191) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  192) &                  CLNSPR,CLNSPR,.FALSE.)
(  193) ENDIF
(  194) !
(  195) IF (LHOOK) CALL DR_HOOK('FARPAR_MT',1,ZHOOK_HANDLE)
(  196) END SUBROUTINE FARPAR_MT64
(  197) 
(  198) 
(  199) 
(  200) ! Oct-2012 P. Marguinaud 64b LFI
(  201) SUBROUTINE FARPAR64                            &
(  202) &           (KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  203) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  204) &                  FA_COM_DEFAULT_INIT,  &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 6

(  205) &                  NEW_FA_DEFAULT
(  206) USE LFI_PRECISION
(  207) IMPLICIT NONE
(  208) ! Arguments
(  209) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  210) INTEGER (KIND=JPLIKB)  KNUM                                   ! IN
(  211) CHARACTER (LEN=*)      CDPREF     (KNUM)                      ! IN   
(  212) CHARACTER (LEN=*)      CDSUFF     (KNUM)                      ! IN   
(  213) INTEGER (KIND=JPLIKB)  KCODPA     (KNUM,7)                    ! IN   
(  214) 
(  215) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  216) 
(  217) CALL FARPAR_MT64                                   &
(  218) &           (FA, KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  219) 
(  220) END SUBROUTINE FARPAR64
(  221) 
(  222) SUBROUTINE FARPAR                              &
(  223) &           (KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  224) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  225) &                  FA_COM_DEFAULT_INIT,  &
(  226) &                  NEW_FA_DEFAULT
(  227) USE LFI_PRECISION
(  228) IMPLICIT NONE
(  229) ! Arguments
(  230) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  231) INTEGER (KIND=JPLIKM)  KNUM                                   ! IN
(  232) CHARACTER (LEN=*)      CDPREF     (KNUM)                      ! IN   
(  233) CHARACTER (LEN=*)      CDSUFF     (KNUM)                      ! IN   
(  234) INTEGER (KIND=JPLIKM)  KCODPA     (KNUM,7)                    ! IN   
(  235) 
(  236) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  237) 
(  238) CALL FARPAR_MT                                     &
(  239) &           (FA, KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  240) 
(  241) END SUBROUTINE FARPAR
(  242) 
(  243) SUBROUTINE FARPAR_MT                               &
(  244) &           (FA, KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  245) USE FA_MOD, ONLY : FA_COM
(  246) USE LFI_PRECISION
(  247) IMPLICIT NONE
(  248) ! Arguments
(  249) TYPE (FA_COM)          FA                                     ! INOUT
(  250) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  251) INTEGER (KIND=JPLIKM)  KNUM                                   ! IN
(  252) CHARACTER (LEN=*)      CDPREF     (KNUM)                      ! IN   
(  253) CHARACTER (LEN=*)      CDSUFF     (KNUM)                      ! IN   
(  254) INTEGER (KIND=JPLIKM)  KCODPA     (KNUM,7)                    ! IN   
(  255) ! Local integers
(  256) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  257) INTEGER (KIND=JPLIKB)  ICODPA     (KNUM,7)                    ! IN   
(  258) INTEGER (KIND=JPLIKB)  INUM                                   ! INOUT
(  259) ! Convert arguments
(  260) 
(  261) ICODPA     = INT (    KCODPA, JPLIKB)
(  262) INUM       = INT (      KNUM, JPLIKB)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 7

(  263) 
(  264) CALL FARPAR_MT64                                   &
(  265) &           (FA, IREP, CDPREF, CDSUFF, ICODPA, INUM)
(  266) 
(  267) KREP       = INT (      IREP, JPLIKM)
(  268) 
(  269) END SUBROUTINE FARPAR_MT
(  270) 
(  271) !INTF KREP            OUT                               
(  272) !INTF CDPREF        IN    DIMS=KNUM                     
(  273) !INTF CDSUFF        IN    DIMS=KNUM                     
(  274) !INTF KCODPA        IN    DIMS=KNUM,7                   
(  275) !INTF KNUM          IN
(  276) 


















































NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 8

(    1) # 1 "farpar.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FARPAR_MT64                                         &
(    4) &                     (FA,  KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(    5) USE FA_MOD, ONLY : FA_COM, JPNIIL, FAGR1TAB
(    6) USE PARKIND1, ONLY : JPRB
(    7) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    8) USE LFI_PRECISION
(    9) IMPLICIT NONE
(   10) !****
(   11) !      Sous-programme de reglage de la correspondance "nom d'article FA"
(   12) !              <-> "descripteurs GRIB du parametre+niveau"
(   13) !**
(   14) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   15) !    ( Tableau ) CDPREF (Entree) ==> Prefixe pour les KNUM noms d'article;
(   16) !    ( Tableau ) CDSUFF (Entree) ==> Suffixe pour les KNUM noms d'article;
(   17) !    ( Tableau ) KCODPA (Entree) ==> 6 descripteurs GRIB pour chacun
(   18) !                                    des KNUM parametres:
(   19) !      KCODPA(J,1) = KSEC1(1)  version de la table parametres
(   20) !      KCODPA(J,2) = KSEC1(6)  indicateur du parametre
(   21) !      KCODPA(J,3) = KSEC1(7)  indicateur du type de niveau
(   22) !      KCODPA(J,4) = KSEC1(8)  niveau
(   23) !      KCODPA(J,5) = KSEC1(9)  2ieme nv si couche, sinon 0
(   24) !      KCODPA(J,6) = KSEC1(18) indicateur du type de champ
(   25) !                              (0 sf si min/max:2 ou si cumul:4)
(   26) !
(   27) !                KNUM   (Entree  ==> Nombre de parametres a regler
(   28) !                          et        (dimension de CDPREF, CDSUFF et KCODPA)
(   29) !                        Sortie) ==> Nb de nouveaux parametres pouvant encore
(   30) !                                    etre definis lors d'un appel ulterieur.
(   31) !
(   32) !
(   33) !
(   34) TYPE(FA_COM) :: FA
(   35) INTEGER (KIND=JPLIKB) KREP, KNUM
(   36) INTEGER (KIND=JPLIKB) KCODPA(KNUM,8)
(   37) !
(   38) CHARACTER (LEN=*) CDPREF(KNUM), CDSUFF(KNUM)
(   39) !
(   40) TYPE (FAGR1TAB), POINTER :: YLGR1TAB (:)
(   41) !
(   42) INTEGER (KIND=JPLIKB) J, JJ, INUMER, INIMES, JMEM, IMEM (KNUM), IADD
(   43) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   44) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   45) # 46 "farpar.F90"
(   46) !
(   47) INTRINSIC LEN_TRIM
(   48) !
(   49) !**
(   50) !     0.  -  CONTROLES ET INITIALISATIONS PREALABLES
(   51) !-----------------------------------------------------------------------
(   52) !
(   53) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   54) IF (LHOOK) CALL DR_HOOK('FARPAR_MT',0,ZHOOK_HANDLE)
(   55) IF (KNUM.LT.1) THEN
(   56)   KREP=-129
(   57)   IF (FA%LFAMOP) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 9

(   58)     WRITE (UNIT=FA%NULOUT,FMT=*)                         &
(   59) &           'FARPAR: Nb de parametres ',KNUM,' incorrect'
(   60)   ENDIF
(   61)   GOTO 1001
(   62) ENDIF
(   63) DO J = 1,KNUM
(   64)   IF ( INT (LEN_TRIM(CDPREF(J)), JPLIKB).LE.0 .OR.           &
(   65) &      INT (LEN_TRIM(CDPREF(J)), JPLIKB).GT.FA%JPXPRF ) THEN
(   66)     KREP=-129
(   67)     IF (FA%LFAMOP) THEN
(   68)       WRITE (UNIT=FA%NULOUT,FMT=*)                                &
(   69) &              'FARPAR: Longueur du prefixe ',CDPREF(J),          &
(   70) &              ' incorrecte : ',INT (LEN_TRIM(CDPREF(J)), JPLIKB)
(   71)     ENDIF
(   72)     GOTO 1001
(   73)   ENDIF
(   74)   IF ( INT (LEN_TRIM(CDSUFF(J)), JPLIKB).LE.0 .OR.     &
(   75) &      INT (LEN_TRIM(CDSUFF(J)), JPLIKB).GT.FA%JPXNOM- &
(   76) &      INT (LEN_TRIM(CDPREF(J)), JPLIKB) ) THEN
(   77)     KREP=-129
(   78)     IF (FA%LFAMOP) THEN
(   79)       WRITE (UNIT=FA%NULOUT,FMT=*)                                &
(   80) &              'FARPAR: Longueur du suffixe ',CDSUFF(J),          &
(   81) &              ' incorrecte : ',INT (LEN_TRIM(CDSUFF(J)), JPLIKB)
(   82)     ENDIF
(   83)     GOTO 1001
(   84)   ENDIF
(   85)   DO JJ = 1,3
(   86)     IF (KCODPA(J,JJ).LT.1 .OR. KCODPA(J,JJ).GT.255) THEN
(   87)       KREP=-129
(   88)       IF (FA%LFAMOP) THEN
(   89)         WRITE (UNIT=FA%NULOUT,FMT=*)                     &
(   90) &                'FARPAR: descripteur GRIB num ',JJ,     &
(   91) &                ' pour le parametre num ',J,' ( ',      &
(   92) &                CDPREF(J)//CDSUFF(J),' ) incorrect : ', &
(   93) &                KCODPA(J,JJ)
(   94)       ENDIF
(   95)       GOTO 1001
(   96)     ENDIF
(   97)   ENDDO
(   98)   IF (KCODPA(J,6).LT.0 .OR. KCODPA(J,6).GT.124) THEN
(   99)     KREP=-129
(  100)     IF (FA%LFAMOP) THEN
(  101)       WRITE (UNIT=FA%NULOUT,FMT=*)                     &
(  102) &              'FARPAR: descripteur GRIB, KSEC1(18),', &
(  103) &              ' pour le parametre num ',J,' ( ',      &
(  104) &              CDPREF(J)//CDSUFF(J),' ) incorrect : ', &
(  105) &              KCODPA(J,6)
(  106)     ENDIF
(  107)     GOTO 1001
(  108)   ENDIF
(  109)   IF (KCODPA(J,4).LT.0) THEN
(  110)     KREP=-129
(  111)     IF (FA%LFAMOP) THEN
(  112)       WRITE (UNIT=FA%NULOUT,FMT=*)                    &
(  113) &              'FARPAR: descripteur GRIB, KSEC1(8),',  &
(  114) &              ' pour le parametre num ',J,' ( ',      &
(  115) &              CDPREF(J)//CDSUFF(J),' ) incorrect : ', &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 10

(  116) &              KCODPA(J,4)
(  117)     ENDIF
(  118)     GOTO 1001
(  119)   ENDIF
(  120) ENDDO
(  121) !
(  122) !**
(  123) !     2.  -  Prise en compte des nouvelles correspondances
(  124) !---------------------------------------------------------
(  125) !
(  126) !
(  127) # 128 "farpar.F90"
(  128) IADD=0
(  129) # 130 "farpar.F90"
(  130) DO J = 1,KNUM
(  131) ! Recherche prealable de l'eventuelle existence de la definition
(  132) ! de ce parametre (il faudra alors l'ecraser).
(  133)   JMEM = 0
(  134)   DO JJ = 1,FA%NBPARC
(  135)     IF (CDPREF(J)(1:INT (LEN_TRIM(CDPREF(J )), JPLIKB)).EQ.FA%YGR1TAB(JJ)%CIPREF(1:INT (LEN_TRIM(FA%YGR1TAB(JJ)%CIPREF), JPLIKB))  &
(  136)       & .AND. &
(  137)       & CDSUFF(J)(1:INT (LEN_TRIM(CDSUFF(J )), JPLIKB)).EQ.FA%YGR1TAB(JJ)%CISUFF(1:INT (LEN_TRIM(FA%YGR1TAB(JJ)%CISUFF), JPLIKB))) &
(  138)     THEN
(  139)       JMEM = JJ
(  140)       EXIT
(  141)     ENDIF
(  142)   ENDDO
(  143)   IF (JMEM==0) THEN
(  144)     IADD = IADD + 1
(  145)     IMEM (J) = FA%NBPARC + IADD
(  146)   ELSE
(  147)     IMEM (J) = JMEM
(  148)   ENDIF
(  149) ENDDO
(  150) # 151 "farpar.F90"
(  151) IF (IADD > 0) THEN
(  152)   YLGR1TAB => FA%YGR1TAB
(  153)   ALLOCATE (FA%YGR1TAB (FA%NBPARC+IADD))
(  154)   FA%YGR1TAB (1:FA%NBPARC) = YLGR1TAB (1:FA%NBPARC)
(  155)   FA%NBPARC = FA%NBPARC+IADD
(  156)   DEALLOCATE (YLGR1TAB)
(  157) ENDIF
(  158) # 159 "farpar.F90"
(  159) DO J = 1, KNUM
(  160)   
(  161)   JMEM = IMEM (J)
(  162) # 163 "farpar.F90"
(  163)   FA%YGR1TAB(JMEM)%CIPREF      = CDPREF(J)(1:INT (LEN_TRIM(CDPREF(J)), JPLIKB))
(  164)   FA%YGR1TAB(JMEM)%CISUFF      = CDSUFF(J)(1:INT (LEN_TRIM(CDSUFF(J)), JPLIKB))
(  165)   FA%YGR1TAB(JMEM)%NCODPA(1:8) = KCODPA(J,1:8)
(  166) # 167 "farpar.F90"
(  167)   IF (FA%LFAMOP) THEN
(  168)     WRITE (UNIT=FA%NULOUT,FMT=*)                              &
(  169) &           'FARPAR: Prise en compte de ',CDPREF(J)//CDSUFF(J)
(  170)     WRITE (UNIT=FA%NULOUT,FMT=*)                       &
(  171) &           '        associe a KSEC1(1,6:9 et 18) = ', &
(  172) &           FA%YGR1TAB(JMEM)%NCODPA(1:8)
(  173)   ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 11

(  174) # 175 "farpar.F90"
(  175) ENDDO
(  176) !
(  177) !**
(  178) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  179) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  180) !-----------------------------------------------------------------------
(  181) !
(  182) 1001 CONTINUE
(  183) !
(  184) IF (FA%LFAMOP) THEN
(  185)   INIMES=2
(  186)   CLNSPR='FARPAR'
(  187)   INUMER=JPNIIL
(  188) !
(  189)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4)') KREP
(  190)   CALL FAIPAR_MT64                                        &
(  191) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  192) &                  CLNSPR,CLNSPR,.FALSE.)
(  193) ENDIF
(  194) !
(  195) IF (LHOOK) CALL DR_HOOK('FARPAR_MT',1,ZHOOK_HANDLE)
(  196) END SUBROUTINE FARPAR_MT64
(  197) # 200 "farpar.F90"
(  200) ! Oct-2012 P. Marguinaud 64b LFI
(  201) SUBROUTINE FARPAR64                            &
(  202) &           (KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  203) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  204) &                  FA_COM_DEFAULT_INIT,  &
(  205) &                  NEW_FA_DEFAULT
(  206) USE LFI_PRECISION
(  207) IMPLICIT NONE
(  208) ! Arguments
(  209) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  210) INTEGER (KIND=JPLIKB)  KNUM                                   ! IN
(  211) CHARACTER (LEN=*)      CDPREF     (KNUM)                      ! IN   
(  212) CHARACTER (LEN=*)      CDSUFF     (KNUM)                      ! IN   
(  213) INTEGER (KIND=JPLIKB)  KCODPA     (KNUM,7)                    ! IN   
(  214) # 215 "farpar.F90"
(  215) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  216) # 217 "farpar.F90"
(  217) CALL FARPAR_MT64                                   &
(  218) &           (FA, KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  219) # 220 "farpar.F90"
(  220) END SUBROUTINE FARPAR64
(  221) # 222 "farpar.F90"
(  222) SUBROUTINE FARPAR                              &
(  223) &           (KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  224) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  225) &                  FA_COM_DEFAULT_INIT,  &
(  226) &                  NEW_FA_DEFAULT
(  227) USE LFI_PRECISION
(  228) IMPLICIT NONE
(  229) ! Arguments
(  230) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  231) INTEGER (KIND=JPLIKM)  KNUM                                   ! IN
(  232) CHARACTER (LEN=*)      CDPREF     (KNUM)                      ! IN   
(  233) CHARACTER (LEN=*)      CDSUFF     (KNUM)                      ! IN   






NVFORTRAN (Version     23.1)          02/24/2023  13:54:17      page 12

(  234) INTEGER (KIND=JPLIKM)  KCODPA     (KNUM,7)                    ! IN   
(  235) # 236 "farpar.F90"
(  236) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  237) # 238 "farpar.F90"
(  238) CALL FARPAR_MT                                     &
(  239) &           (FA, KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  240) # 241 "farpar.F90"
(  241) END SUBROUTINE FARPAR
(  242) # 243 "farpar.F90"
(  243) SUBROUTINE FARPAR_MT                               &
(  244) &           (FA, KREP, CDPREF, CDSUFF, KCODPA, KNUM)
(  245) USE FA_MOD, ONLY : FA_COM
(  246) USE LFI_PRECISION
(  247) IMPLICIT NONE
(  248) ! Arguments
(  249) TYPE (FA_COM)          FA                                     ! INOUT
(  250) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  251) INTEGER (KIND=JPLIKM)  KNUM                                   ! IN
(  252) CHARACTER (LEN=*)      CDPREF     (KNUM)                      ! IN   
(  253) CHARACTER (LEN=*)      CDSUFF     (KNUM)                      ! IN   
(  254) INTEGER (KIND=JPLIKM)  KCODPA     (KNUM,7)                    ! IN   
(  255) ! Local integers
(  256) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  257) INTEGER (KIND=JPLIKB)  ICODPA     (KNUM,7)                    ! IN   
(  258) INTEGER (KIND=JPLIKB)  INUM                                   ! INOUT
(  259) ! Convert arguments
(  260) # 261 "farpar.F90"
(  261) ICODPA     = INT (    KCODPA, JPLIKB)
(  262) INUM       = INT (      KNUM, JPLIKB)
(  263) # 264 "farpar.F90"
(  264) CALL FARPAR_MT64                                   &
(  265) &           (FA, IREP, CDPREF, CDSUFF, ICODPA, INUM)
(  266) # 267 "farpar.F90"
(  267) KREP       = INT (      IREP, JPLIKM)
(  268) # 269 "farpar.F90"
(  269) END SUBROUTINE FARPAR_MT
(  270) # 271 "farpar.F90"
(  271) !INTF KREP            OUT                               
(  272) !INTF CDPREF        IN    DIMS=KNUM                     
(  273) !INTF CDSUFF        IN    DIMS=KNUM                     
(  274) !INTF KCODPA        IN    DIMS=KNUM,7                   
(  275) !INTF KNUM          IN
