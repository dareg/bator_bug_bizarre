


NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: fatran.F90

(    1) ! Nov-2012 P. Marguinaud Use local INDIRECT array
(    2) ! Oct-2012 P. Marguinaud 64b LFI
(    3) ! Jan-2011 P. Marguinaud Thread-safe FA
(    4) SUBROUTINE FATRAN_MT64                                            &
(    5) &                     (FA,  KREP,  KNUMER,  PCHAME, PCHAMS, LDOPT )
(    6) USE FA_MOD, ONLY : FA_COM
(    7) USE PARKIND1, ONLY : JPRB
(    8) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    9) USE LFI_PRECISION
(   10) IMPLICIT NONE
(   11) !****
(   12) !      Sous-programme du logiciel de Fichiers ARPEGE permettant la
(   13) !      TRANsposition d'un champ spectral ARPEGE ou ALADIN,
(   14) !      d'un rangement des coeff selon le MODELE vers un rangement
(   15) !      des coeff selon FA+GRIB_version0 et inversement.
(   16) !
(   17) !**
(   18) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   19) !                KNUMER (Entree) ==> Rang de l'unite logique;
(   20) !    ( Tableau ) PCHAME (Entree) ==> Valeurs du champ a transposer;
(   21) !    ( Tableau ) PCHAMS (Sortie) ==> Valeurs du champ transpose;
(   22) !                LDOPT   (Entree) ==> Option de transposition;
(   23) !                                    si .TRUE.  alors PCHAME range comme MODELE
(   24) !                                                     (soit "verticalement")
(   25) !                                                     PCHAMS range comme FA-GRIB0
(   26) !                                                     (soit "horizontalement")
(   27) !                                    si .FALSE. alors PCHAME range comme FA-GRIB0
(   28) !                                                     PCHAMS range comme MODELE
(   29) !*
(   30) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 3

(   31) !
(   32) !
(   33) TYPE(FA_COM) :: FA
(   34) INTEGER (KIND=JPLIKB) KREP, KNUMER
(   35) !
(   36) LOGICAL LDOPT
(   37) !
(   38) REAL (KIND=JPDBLR) PCHAME(*), PCHAMS(*)
(   39) !
(   40) INTEGER (KIND=JPLIKB) JN, JM, J, INDEX, ILOW, IHIGH
(   41) INTEGER (KIND=JPLIKB) IRANGC, IRANG
(   42) INTEGER (KIND=JPLIKB) INIMES, ITRONC, IMSMAX
(   43) INTEGER (KIND=JPLIKB), ALLOCATABLE :: IND(:,:)
(   44) INTEGER (KIND=JPLIKB), ALLOCATABLE :: INDIRECT(:)
(   45) !
(   46) LOGICAL LLMLAM
(   47) !
(   48) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   49) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   50) LOGICAL                  LLFATA
(   51) 
(   52) !
(   53) !
(   54) !
(   55) !**
(   56) !     1.  -  CONTROLES ET INITIALISATIONS.
(   57) !-----------------------------------------------------------------------
(   58) !
(   59) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   60) IF (LHOOK) CALL DR_HOOK('FATRAN_MT',0,ZHOOK_HANDLE)
(   61) KREP=0
(   62) CALL FANUMU_MT64                 &
(   63) &               (FA, KNUMER,IRANG)
(   64) !
(   65) IF (IRANG.EQ.0) THEN
(   66)   KREP=-51
(   67)   GOTO 1001
(   68) ENDIF
(   69) IRANGC=FA%FICHIER(IRANG)%NUCADR
(   70) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(   71) ITRONC=FA%CADRE(IRANGC)%MTRONC
(   72) IF (LLMLAM) THEN
(   73)   IMSMAX = FA%CADRE(IRANGC)%NOMPAR(2)
(   74) ENDIF
(   75) 
(   76) !
(   77) ! Initialisation de l'indirection pour IRANGC, si ce n'est pas deja fait.
(   78) ! Si ARPEGE, INDIRECT(J,IRANGC)=INDEX signifie que les indices J dans
(   79) !   le tableau "FA+GRIB0" et INDEX dans le tableau "modele ARPEGE"
(   80) !    designent un meme coeff spectral.
(   81) ! Si Aladin, INDIRECT(JM*(ITRONC+1)+JN+1,IRANGC)=J signifie que l'indice
(   82) !   J dans le tableau "FA+GRIB0" est le premier coeff associe au couple (JM,JN)
(   83) !   ou JM est le nombre d'onde zonal et JN le nombre d'onde meridien.
(   84) !   4 coeff spectraux sont associes a chaque couple (JM,JN) car JM varie
(   85) !   de 0 a IMSMAX et JN varie de 0 a ITRONC (soit 1/4 de l'ellipse).
(   86) !
(   87) !  CAS ARPEGE
(   88) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 4

(   89) IF (.NOT.LLMLAM) THEN
(   90)   ALLOCATE (IND(0:ITRONC,-ITRONC:ITRONC))
(   91)   ALLOCATE (INDIRECT ((ITRONC+1)**2))
(   92)   DO JN=0,ITRONC
(   93)     ILOW=JN**2+1
(   94)     IHIGH=(JN+1)**2
(   95)     JM=-JN-1
(   96)     DO J=ILOW,IHIGH
(   97)       JM=JM+1
(   98)       IND(JN,JM)=J
(   99)     ENDDO
(  100)   ENDDO
(  101) !
(  102)   INDEX=-1
(  103)   DO JM=0,ITRONC
(  104)   DO JN=JM,ITRONC
(  105)     INDEX=INDEX+2
(  106)     INDIRECT  (IND(JN, JM))=INDEX
(  107)     IF (JM.NE.0) THEN
(  108)       INDIRECT(IND(JN,-JM))=INDEX+1
(  109)     ENDIF
(  110)   ENDDO
(  111)   ENDDO
(  112)   DEALLOCATE (IND)
(  113) ENDIF
(  114) !
(  115) !  CAS ALADIN
(  116) !
(  117) IF (LLMLAM) THEN
(  118)   ALLOCATE (INDIRECT ((ITRONC+1)**2))
(  119)   DO JN=0,ITRONC
(  120)   DO J=FA%CADRE(IRANGC)%NOZPAR(2*JN+3), FA%CADRE(IRANGC)%NOZPAR(2*JN+4), 4
(  121)     JM=(J-FA%CADRE(IRANGC)%NOZPAR(2*JN+3)) / 4
(  122)     INDIRECT(JM*(ITRONC+1)+JN+1) = J
(  123)   ENDDO
(  124)   ENDDO
(  125) ENDIF
(  126) !**
(  127) !     2.  -  TRANSPOSITION DES DONNEES
(  128) !-----------------------------------------------------------------------
(  129) !
(  130) !  CAS ALADIN
(  131) !
(  132) IF (LLMLAM) THEN
(  133)     IF (LDOPT) THEN
(  134) ! PCHAME range comme MODELE (soit "verticalement")
(  135) !
(  136)     DO JM=0,IMSMAX
(  137)     DO INDEX=FA%CADRE(IRANGC)%NOMPAR(2*JM+3), FA%CADRE(IRANGC)%NOMPAR(2*JM+4), 4
(  138)       JN = (INDEX-FA%CADRE(IRANGC)%NOMPAR(2*JM+3)) / 4
(  139)       J  = INDIRECT(JM*(ITRONC+1)+JN+1)
(  140)       PCHAMS(J  )=PCHAME(INDEX  )  
(  141)       PCHAMS(J+1)=PCHAME(INDEX+1)
(  142)       PCHAMS(J+2)=PCHAME(INDEX+2)
(  143)       PCHAMS(J+3)=PCHAME(INDEX+3)
(  144)     ENDDO
(  145)     ENDDO
(  146)   ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 5

(  147) ! PCHAME range comme FA+GRIB0 (soit "horizontalement")
(  148) !
(  149)     DO JM=0,IMSMAX
(  150)     DO INDEX=FA%CADRE(IRANGC)%NOMPAR(2*JM+3), FA%CADRE(IRANGC)%NOMPAR(2*JM+4), 4
(  151)       JN = (INDEX-FA%CADRE(IRANGC)%NOMPAR(2*JM+3)) / 4
(  152)       J  = INDIRECT(JM*(ITRONC+1)+JN+1)
(  153)       PCHAMS(INDEX  )=PCHAME(J  )  
(  154)       PCHAMS(INDEX+1)=PCHAME(J+1)
(  155)       PCHAMS(INDEX+2)=PCHAME(J+2)
(  156)       PCHAMS(INDEX+3)=PCHAME(J+3)
(  157)     ENDDO
(  158)     ENDDO
(  159)   ENDIF
(  160) ELSE
(  161) !
(  162) !  CAS ARPEGE
(  163) !
(  164) !  1/ Passage du rangement des coeff. spectraux du type modele ARPEGE
(  165) !  a celui de FA associe a GRIB version0 (et pas associe a GRIBEX qui
(  166) !  reprend la structure de tableau de ARPEGE).
(  167) !
(  168)   IF (LDOPT) THEN
(  169)     DO JN=0,ITRONC
(  170)       ILOW=JN**2+1
(  171)       IHIGH=(JN+1)**2
(  172)       DO J=ILOW,IHIGH
(  173)         PCHAMS(J)=PCHAME(INDIRECT(J))
(  174)       ENDDO
(  175)     ENDDO
(  176) !
(  177) !  2/ Passage du rangement des coeff. spectraux du type FA associe
(  178) !  a GRIB version0 (et pas associe a GRIBEX qui reprend la structure de
(  179) !  tableau de ARPEGE) a celui du type modele ARPEGE.
(  180) !
(  181)   ELSE
(  182) !  Initialisation de la partie "JM=0" a zero, pour y introduire
(  183) !  ensuite uniquement les coeff reels correspondant dans PCHAME
(  184) !  (les coeff imaginaires etant donc crees et mis a zero).
(  185)     PCHAMS(1:2*(ITRONC+1))=0._JPDBLR
(  186) !
(  187)     DO JN=0,ITRONC
(  188)       ILOW=JN**2+1
(  189)       IHIGH=(JN+1)**2
(  190)       DO J=ILOW,IHIGH
(  191)         PCHAMS(INDIRECT(J))=PCHAME(J)
(  192)       ENDDO
(  193)     ENDDO
(  194)   ENDIF
(  195) ENDIF
(  196) !
(  197) !**
(  198) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  199) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  200) !-----------------------------------------------------------------------
(  201) !
(  202) 1001 CONTINUE
(  203) 
(  204) IF (ALLOCATED (INDIRECT)) DEALLOCATE (INDIRECT)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 6

(  205) 
(  206) LLFATA=LLMOER (KREP,IRANG)
(  207) !
(  208) IF (LLFATA) THEN
(  209)   INIMES=2
(  210) ELSE
(  211)   INIMES=IXNVMS(IRANG)
(  212) ENDIF
(  213) !
(  214) IF (INIMES.EQ.0)  THEN 
(  215)   IF (LHOOK) CALL DR_HOOK('FATRAN_MT',1,ZHOOK_HANDLE)
(  216)   RETURN
(  217) ENDIF
(  218) !
(  219) CLNSPR='FATRAN'
(  220) !
(  221) WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', IRANG='',I4, &
(  222) &         '', LDOPT='',L2)')  KREP, IRANG, LDOPT
(  223) CALL FAIPAR_MT64                                     &
(  224) &               (FA, KNUMER,INIMES,KREP,LLFATA,CLMESS, &
(  225) &               CLNSPR,CLNSPR,.FALSE.)
(  226) !
(  227) IF (LHOOK) CALL DR_HOOK('FATRAN_MT',1,ZHOOK_HANDLE)
(  228) 
(  229) CONTAINS
(  230) 
(  231) #include "facom2.llmoer.h"
(  232) #include "facom2.ixnvms.h"
(  233) 
(  234) END SUBROUTINE FATRAN_MT64
(  235) 
(  236) 
(  237) 
(  238) ! Oct-2012 P. Marguinaud 64b LFI
(  239) SUBROUTINE FATRAN64                             &
(  240) &           (KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  241) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  242) &                   FA_COM_DEFAULT_INIT,  &
(  243) &                   NEW_FA_DEFAULT
(  244) USE LFI_PRECISION
(  245) IMPLICIT NONE
(  246) ! Arguments
(  247) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  248) INTEGER (KIND=JPLIKB)  KNUMER                                 ! IN   
(  249) REAL (KIND=JPDBLR)     PCHAME     (*)                         ! IN   
(  250) REAL (KIND=JPDBLR)     PCHAMS     (*)                         !   OUT
(  251) LOGICAL                LDOPT                                  ! IN   
(  252) 
(  253) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  254) 
(  255) CALL FATRAN_MT64                                    &
(  256) &           (FA, KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  257) 
(  258) END SUBROUTINE FATRAN64
(  259) 
(  260) SUBROUTINE FATRAN                               &
(  261) &           (KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  262) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 7

(  263) &                   FA_COM_DEFAULT_INIT,  &
(  264) &                   NEW_FA_DEFAULT
(  265) USE LFI_PRECISION
(  266) IMPLICIT NONE
(  267) ! Arguments
(  268) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  269) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  270) REAL (KIND=JPDBLR)     PCHAME     (*)                         ! IN   
(  271) REAL (KIND=JPDBLR)     PCHAMS     (*)                         !   OUT
(  272) LOGICAL                LDOPT                                  ! IN   
(  273) 
(  274) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  275) 
(  276) CALL FATRAN_MT                                      &
(  277) &           (FA, KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  278) 
(  279) END SUBROUTINE FATRAN
(  280) 
(  281) SUBROUTINE FATRAN_MT                                &
(  282) &           (FA, KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  283) USE FA_MOD, ONLY : FA_COM
(  284) USE LFI_PRECISION
(  285) IMPLICIT NONE
(  286) ! Arguments
(  287) TYPE (FA_COM)          FA                                     ! INOUT
(  288) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  289) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  290) REAL (KIND=JPDBLR)     PCHAME     (*)                         ! IN   
(  291) REAL (KIND=JPDBLR)     PCHAMS     (*)                         !   OUT
(  292) LOGICAL                LDOPT                                  ! IN   
(  293) ! Local integers
(  294) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  295) INTEGER (KIND=JPLIKB)  INUMER                                 ! IN   
(  296) ! Convert arguments
(  297) 
(  298) INUMER     = INT (    KNUMER, JPLIKB)
(  299) 
(  300) CALL FATRAN_MT64                                    &
(  301) &           (FA, IREP, INUMER, PCHAME, PCHAMS, LDOPT)
(  302) 
(  303) KREP       = INT (      IREP, JPLIKM)
(  304) 
(  305) END SUBROUTINE FATRAN_MT
(  306) 
(  307) !INTF KREP            OUT                               
(  308) !INTF KNUMER        IN                                  
(  309) !INTF PCHAME        IN    DIMS=*                        
(  310) !INTF PCHAMS          OUT DIMS=*                        
(  311) !INTF LDOPT         IN                                  















NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 8

(    1) # 1 "fatran.F90"
(    1) ! Nov-2012 P. Marguinaud Use local INDIRECT array
(    2) ! Oct-2012 P. Marguinaud 64b LFI
(    3) ! Jan-2011 P. Marguinaud Thread-safe FA
(    4) SUBROUTINE FATRAN_MT64                                            &
(    5) &                     (FA,  KREP,  KNUMER,  PCHAME, PCHAMS, LDOPT )
(    6) USE FA_MOD, ONLY : FA_COM
(    7) USE PARKIND1, ONLY : JPRB
(    8) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    9) USE LFI_PRECISION
(   10) IMPLICIT NONE
(   11) !****
(   12) !      Sous-programme du logiciel de Fichiers ARPEGE permettant la
(   13) !      TRANsposition d'un champ spectral ARPEGE ou ALADIN,
(   14) !      d'un rangement des coeff selon le MODELE vers un rangement
(   15) !      des coeff selon FA+GRIB_version0 et inversement.
(   16) !
(   17) !**
(   18) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   19) !                KNUMER (Entree) ==> Rang de l'unite logique;
(   20) !    ( Tableau ) PCHAME (Entree) ==> Valeurs du champ a transposer;
(   21) !    ( Tableau ) PCHAMS (Sortie) ==> Valeurs du champ transpose;
(   22) !                LDOPT   (Entree) ==> Option de transposition;
(   23) !                                    si .TRUE.  alors PCHAME range comme MODELE
(   24) !                                                     (soit "verticalement")
(   25) !                                                     PCHAMS range comme FA-GRIB0
(   26) !                                                     (soit "horizontalement")
(   27) !                                    si .FALSE. alors PCHAME range comme FA-GRIB0
(   28) !                                                     PCHAMS range comme MODELE
(   29) !*
(   30) !
(   31) !
(   32) !
(   33) TYPE(FA_COM) :: FA
(   34) INTEGER (KIND=JPLIKB) KREP, KNUMER
(   35) !
(   36) LOGICAL LDOPT
(   37) !
(   38) REAL (KIND=JPDBLR) PCHAME(*), PCHAMS(*)
(   39) !
(   40) INTEGER (KIND=JPLIKB) JN, JM, J, INDEX, ILOW, IHIGH
(   41) INTEGER (KIND=JPLIKB) IRANGC, IRANG
(   42) INTEGER (KIND=JPLIKB) INIMES, ITRONC, IMSMAX
(   43) INTEGER (KIND=JPLIKB), ALLOCATABLE :: IND(:,:)
(   44) INTEGER (KIND=JPLIKB), ALLOCATABLE :: INDIRECT(:)
(   45) !
(   46) LOGICAL LLMLAM
(   47) !
(   48) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   49) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   50) LOGICAL                  LLFATA
(   51) # 52 "fatran.F90"
(   52) !
(   53) !
(   54) !
(   55) !**
(   56) !     1.  -  CONTROLES ET INITIALISATIONS.
(   57) !-----------------------------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 9

(   58) !
(   59) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   60) IF (LHOOK) CALL DR_HOOK('FATRAN_MT',0,ZHOOK_HANDLE)
(   61) KREP=0
(   62) CALL FANUMU_MT64                 &
(   63) &               (FA, KNUMER,IRANG)
(   64) !
(   65) IF (IRANG.EQ.0) THEN
(   66)   KREP=-51
(   67)   GOTO 1001
(   68) ENDIF
(   69) IRANGC=FA%FICHIER(IRANG)%NUCADR
(   70) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(   71) ITRONC=FA%CADRE(IRANGC)%MTRONC
(   72) IF (LLMLAM) THEN
(   73)   IMSMAX = FA%CADRE(IRANGC)%NOMPAR(2)
(   74) ENDIF
(   75) # 76 "fatran.F90"
(   76) !
(   77) ! Initialisation de l'indirection pour IRANGC, si ce n'est pas deja fait.
(   78) ! Si ARPEGE, INDIRECT(J,IRANGC)=INDEX signifie que les indices J dans
(   79) !   le tableau "FA+GRIB0" et INDEX dans le tableau "modele ARPEGE"
(   80) !    designent un meme coeff spectral.
(   81) ! Si Aladin, INDIRECT(JM*(ITRONC+1)+JN+1,IRANGC)=J signifie que l'indice
(   82) !   J dans le tableau "FA+GRIB0" est le premier coeff associe au couple (JM,JN)
(   83) !   ou JM est le nombre d'onde zonal et JN le nombre d'onde meridien.
(   84) !   4 coeff spectraux sont associes a chaque couple (JM,JN) car JM varie
(   85) !   de 0 a IMSMAX et JN varie de 0 a ITRONC (soit 1/4 de l'ellipse).
(   86) !
(   87) !  CAS ARPEGE
(   88) !
(   89) IF (.NOT.LLMLAM) THEN
(   90)   ALLOCATE (IND(0:ITRONC,-ITRONC:ITRONC))
(   91)   ALLOCATE (INDIRECT ((ITRONC+1)**2))
(   92)   DO JN=0,ITRONC
(   93)     ILOW=JN**2+1
(   94)     IHIGH=(JN+1)**2
(   95)     JM=-JN-1
(   96)     DO J=ILOW,IHIGH
(   97)       JM=JM+1
(   98)       IND(JN,JM)=J
(   99)     ENDDO
(  100)   ENDDO
(  101) !
(  102)   INDEX=-1
(  103)   DO JM=0,ITRONC
(  104)   DO JN=JM,ITRONC
(  105)     INDEX=INDEX+2
(  106)     INDIRECT  (IND(JN, JM))=INDEX
(  107)     IF (JM.NE.0) THEN
(  108)       INDIRECT(IND(JN,-JM))=INDEX+1
(  109)     ENDIF
(  110)   ENDDO
(  111)   ENDDO
(  112)   DEALLOCATE (IND)
(  113) ENDIF
(  114) !
(  115) !  CAS ALADIN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 10

(  116) !
(  117) IF (LLMLAM) THEN
(  118)   ALLOCATE (INDIRECT ((ITRONC+1)**2))
(  119)   DO JN=0,ITRONC
(  120)   DO J=FA%CADRE(IRANGC)%NOZPAR(2*JN+3), FA%CADRE(IRANGC)%NOZPAR(2*JN+4), 4
(  121)     JM=(J-FA%CADRE(IRANGC)%NOZPAR(2*JN+3)) / 4
(  122)     INDIRECT(JM*(ITRONC+1)+JN+1) = J
(  123)   ENDDO
(  124)   ENDDO
(  125) ENDIF
(  126) !**
(  127) !     2.  -  TRANSPOSITION DES DONNEES
(  128) !-----------------------------------------------------------------------
(  129) !
(  130) !  CAS ALADIN
(  131) !
(  132) IF (LLMLAM) THEN
(  133)     IF (LDOPT) THEN
(  134) ! PCHAME range comme MODELE (soit "verticalement")
(  135) !
(  136)     DO JM=0,IMSMAX
(  137)     DO INDEX=FA%CADRE(IRANGC)%NOMPAR(2*JM+3), FA%CADRE(IRANGC)%NOMPAR(2*JM+4), 4
(  138)       JN = (INDEX-FA%CADRE(IRANGC)%NOMPAR(2*JM+3)) / 4
(  139)       J  = INDIRECT(JM*(ITRONC+1)+JN+1)
(  140)       PCHAMS(J  )=PCHAME(INDEX  )  
(  141)       PCHAMS(J+1)=PCHAME(INDEX+1)
(  142)       PCHAMS(J+2)=PCHAME(INDEX+2)
(  143)       PCHAMS(J+3)=PCHAME(INDEX+3)
(  144)     ENDDO
(  145)     ENDDO
(  146)   ELSE
(  147) ! PCHAME range comme FA+GRIB0 (soit "horizontalement")
(  148) !
(  149)     DO JM=0,IMSMAX
(  150)     DO INDEX=FA%CADRE(IRANGC)%NOMPAR(2*JM+3), FA%CADRE(IRANGC)%NOMPAR(2*JM+4), 4
(  151)       JN = (INDEX-FA%CADRE(IRANGC)%NOMPAR(2*JM+3)) / 4
(  152)       J  = INDIRECT(JM*(ITRONC+1)+JN+1)
(  153)       PCHAMS(INDEX  )=PCHAME(J  )  
(  154)       PCHAMS(INDEX+1)=PCHAME(J+1)
(  155)       PCHAMS(INDEX+2)=PCHAME(J+2)
(  156)       PCHAMS(INDEX+3)=PCHAME(J+3)
(  157)     ENDDO
(  158)     ENDDO
(  159)   ENDIF
(  160) ELSE
(  161) !
(  162) !  CAS ARPEGE
(  163) !
(  164) !  1/ Passage du rangement des coeff. spectraux du type modele ARPEGE
(  165) !  a celui de FA associe a GRIB version0 (et pas associe a GRIBEX qui
(  166) !  reprend la structure de tableau de ARPEGE).
(  167) !
(  168)   IF (LDOPT) THEN
(  169)     DO JN=0,ITRONC
(  170)       ILOW=JN**2+1
(  171)       IHIGH=(JN+1)**2
(  172)       DO J=ILOW,IHIGH
(  173)         PCHAMS(J)=PCHAME(INDIRECT(J))






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 11

(  174)       ENDDO
(  175)     ENDDO
(  176) !
(  177) !  2/ Passage du rangement des coeff. spectraux du type FA associe
(  178) !  a GRIB version0 (et pas associe a GRIBEX qui reprend la structure de
(  179) !  tableau de ARPEGE) a celui du type modele ARPEGE.
(  180) !
(  181)   ELSE
(  182) !  Initialisation de la partie "JM=0" a zero, pour y introduire
(  183) !  ensuite uniquement les coeff reels correspondant dans PCHAME
(  184) !  (les coeff imaginaires etant donc crees et mis a zero).
(  185)     PCHAMS(1:2*(ITRONC+1))=0._JPDBLR
(  186) !
(  187)     DO JN=0,ITRONC
(  188)       ILOW=JN**2+1
(  189)       IHIGH=(JN+1)**2
(  190)       DO J=ILOW,IHIGH
(  191)         PCHAMS(INDIRECT(J))=PCHAME(J)
(  192)       ENDDO
(  193)     ENDDO
(  194)   ENDIF
(  195) ENDIF
(  196) !
(  197) !**
(  198) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  199) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  200) !-----------------------------------------------------------------------
(  201) !
(  202) 1001 CONTINUE
(  203) # 204 "fatran.F90"
(  204) IF (ALLOCATED (INDIRECT)) DEALLOCATE (INDIRECT)
(  205) # 206 "fatran.F90"
(  206) LLFATA=LLMOER (KREP,IRANG)
(  207) !
(  208) IF (LLFATA) THEN
(  209)   INIMES=2
(  210) ELSE
(  211)   INIMES=IXNVMS(IRANG)
(  212) ENDIF
(  213) !
(  214) IF (INIMES.EQ.0)  THEN 
(  215)   IF (LHOOK) CALL DR_HOOK('FATRAN_MT',1,ZHOOK_HANDLE)
(  216)   RETURN
(  217) ENDIF
(  218) !
(  219) CLNSPR='FATRAN'
(  220) !
(  221) WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', IRANG='',I4, &
(  222) &         '', LDOPT='',L2)')  KREP, IRANG, LDOPT
(  223) CALL FAIPAR_MT64                                     &
(  224) &               (FA, KNUMER,INIMES,KREP,LLFATA,CLMESS, &
(  225) &               CLNSPR,CLNSPR,.FALSE.)
(  226) !
(  227) IF (LHOOK) CALL DR_HOOK('FATRAN_MT',1,ZHOOK_HANDLE)
(  228) # 229 "fatran.F90"
(  229) CONTAINS
(  230) # 231 "fatran.F90"
(  231) # 1 ".D[27]/facom2.llmoer.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 12

(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,
(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 232 "fatran.F90"
(  232) # 232 "fatran.F90"
(  232) # 1 ".D[27]/facom2.ixnvms.h"
(    1) !*
(    2) !       Fonction "en ligne" donnant le plus haut niveau de messagerie
(    3) !       acceptable pour l'unite logique de rang "I3456"
(    4) !       (utilisation des niveaux de messagerie global et propre au
(    5) !        fichier; s'il n'y a pas de fichier - I3456=0, d'ou le dimensio-
(    6) !        nnement de *NIVOMS* a partir de zero, le niveau de filtrage
(    7) !        global joue seul)
(    8) !
(    9) INTEGER (KIND=JPLIKB) FUNCTION IXNVMS (I3456)
(   10) INTEGER (KIND=JPLIKB) :: I3456
(   11) IXNVMS =MIN (2_JPLIKB ,2_JPLIKB *FA%NIMSGA,MAX (2_JPLIKB *FA%NIMSGA-2_JPLIKB ,FA%FICHIER(I3456)%NIVOMS))
(   12) END FUNCTION
(   13) # 233 "fatran.F90"
(  233) # 234 "fatran.F90"
(  234) END SUBROUTINE FATRAN_MT64
(  235) # 238 "fatran.F90"
(  238) ! Oct-2012 P. Marguinaud 64b LFI
(  239) SUBROUTINE FATRAN64                             &
(  240) &           (KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  241) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  242) &                   FA_COM_DEFAULT_INIT,  &
(  243) &                   NEW_FA_DEFAULT
(  244) USE LFI_PRECISION
(  245) IMPLICIT NONE
(  246) ! Arguments
(  247) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  248) INTEGER (KIND=JPLIKB)  KNUMER                                 ! IN   
(  249) REAL (KIND=JPDBLR)     PCHAME     (*)                         ! IN   
(  250) REAL (KIND=JPDBLR)     PCHAMS     (*)                         !   OUT
(  251) LOGICAL                LDOPT                                  ! IN   
(  252) # 253 "fatran.F90"
(  253) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  254) # 255 "fatran.F90"
(  255) CALL FATRAN_MT64                                    &
(  256) &           (FA, KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  257) # 258 "fatran.F90"
(  258) END SUBROUTINE FATRAN64
(  259) # 260 "fatran.F90"
(  260) SUBROUTINE FATRAN                               &
(  261) &           (KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  262) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  263) &                   FA_COM_DEFAULT_INIT,  &
(  264) &                   NEW_FA_DEFAULT






NVFORTRAN (Version     23.1)          02/24/2023  13:54:51      page 13

(  265) USE LFI_PRECISION
(  266) IMPLICIT NONE
(  267) ! Arguments
(  268) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  269) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  270) REAL (KIND=JPDBLR)     PCHAME     (*)                         ! IN   
(  271) REAL (KIND=JPDBLR)     PCHAMS     (*)                         !   OUT
(  272) LOGICAL                LDOPT                                  ! IN   
(  273) # 274 "fatran.F90"
(  274) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  275) # 276 "fatran.F90"
(  276) CALL FATRAN_MT                                      &
(  277) &           (FA, KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  278) # 279 "fatran.F90"
(  279) END SUBROUTINE FATRAN
(  280) # 281 "fatran.F90"
(  281) SUBROUTINE FATRAN_MT                                &
(  282) &           (FA, KREP, KNUMER, PCHAME, PCHAMS, LDOPT)
(  283) USE FA_MOD, ONLY : FA_COM
(  284) USE LFI_PRECISION
(  285) IMPLICIT NONE
(  286) ! Arguments
(  287) TYPE (FA_COM)          FA                                     ! INOUT
(  288) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  289) INTEGER (KIND=JPLIKM)  KNUMER                                 ! IN   
(  290) REAL (KIND=JPDBLR)     PCHAME     (*)                         ! IN   
(  291) REAL (KIND=JPDBLR)     PCHAMS     (*)                         !   OUT
(  292) LOGICAL                LDOPT                                  ! IN   
(  293) ! Local integers
(  294) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  295) INTEGER (KIND=JPLIKB)  INUMER                                 ! IN   
(  296) ! Convert arguments
(  297) # 298 "fatran.F90"
(  298) INUMER     = INT (    KNUMER, JPLIKB)
(  299) # 300 "fatran.F90"
(  300) CALL FATRAN_MT64                                    &
(  301) &           (FA, IREP, INUMER, PCHAME, PCHAMS, LDOPT)
(  302) # 303 "fatran.F90"
(  303) KREP       = INT (      IREP, JPLIKM)
(  304) # 305 "fatran.F90"
(  305) END SUBROUTINE FATRAN_MT
(  306) # 307 "fatran.F90"
(  307) !INTF KREP            OUT                               
(  308) !INTF KNUMER        IN                                  
(  309) !INTF PCHAME        IN    DIMS=*                        
(  310) !INTF PCHAMS          OUT DIMS=*                        
(  311) !INTF LDOPT         IN                                  
