


NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: fapula.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FAPULA_MT64                                 &
(    4) &                     (FA,  KREP, KRANG, PSPEC, KPULAP)
(    5) USE FA_MOD, ONLY : FA_COM, JPNIIL
(    6) USE PARKIND1, ONLY : JPRB
(    7) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    8) USE LFI_PRECISION
(    9) IMPLICIT NONE
(   10) !****
(   11) !        Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   12) !     calcul de la PUissance de LAplacien "optimale" pour aplatir
(   13) !     le spectre hors de la sous-troncature.
(   14) !
(   15) !**
(   16) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   17) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   18) !    ( Tableau ) PSPEC  (Entree) ==> Champ en coef. spectraux en entree;
(   19) !                KPULAP (Sortie) ==> Puissance de laplacien calculee.
(   20) !*
(   21) !
(   22) !     Creation
(   23) !     --------
(   24) !  Avril 1999, D. Paradis, SCEM/TTI/DEV:
(   25) !     Ce ss-programme est derive de la routine CALCOP du logiciel GRIBEX
(   26) !     du CEPMMT. Il retourne la puissance de laplacien (exprimee en un
(   27) !     nombre entier de milliemes) qui aplatit le mieux le spectre des
(   28) !     coefficients spectraux (hors sous-troncature).
(   29) !     Cette puissance de laplacien, P, sera l'exposant du facteur
(   30) !     .(n*(n+1))**P   pour les champs ARPEGE ou n est le nombre d'onde total






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 3

(   31) !     .(n**2+m**2)**P pour les champs ALADIN ou n est le nombre d'onde meridien
(   32) !                                            et m est le nombre d'onde zonal
(   33) !     Ce facteur sera applique aux coefficients spectraux hors sous-troncature
(   34) !     pour en reduire l'amplitude avant le codage GRIB.
(   35) !
(   36) !
(   37) !     Method.
(   38) !     -------
(   39) !
(   40) !     For ARPEGE case, consider F(n,m) = (n*(n+1))**(-P) * G(n,m),
(   41) !     where F(n,m) is the original spectral field and n the total wavenumber.
(   42) !     For ALADIN case (LAM), consider F(n,m) = (n**2+m**2)**(-P) * G(n,m),
(   43) !     where F(n,m) is the original spectral field, n the meridian
(   44) !     wavenumber and m the zonal wavenumber.
(   45) !     The aim is to minimize G in a 1 norm with respect to P.  This can only
(   46) !     partially be achieved.
(   47) !
(   48) !     1) For ARPEGE case, what we do is to compute H(n), where
(   49) !         H(n) = max(F(n,m))    with respect to m.
(   50) !
(   51) !        We then perform a least square fit for the equation
(   52) !            log(H(n)) = beta0+beta1*log(n*(n+1)).
(   53) !
(   54) !        To ensure a better fit for the lower end of the spectrum, we
(   55) !        apply an (arbitrary) weighting function before fitting
(   56) !             W(n) = 1.0 / (n-ISTRON+1)
(   57) !
(   58) !     2) For ALADIN case, what we do is to compute H(in), where
(   59) !         H(in) = max(F(n,m))      where n and m verify: k = n**2 + m**2
(   60) !           and "in" is the rank of k among all the reached values by k:
(   61) !           we are only interested in k values which verify
(   62) !           k = n**2 + m**2, with (n,m) belonging to spectrum without
(   63) !           the non-compacted sub-truncation area. We call inmax the number
(   64) !           of these k values. "in" belongs to interval 1,inmax.
(   65) !
(   66) !        We then perform a least square fit for the equation
(   67) !            log(H(in)) = beta0+beta1*log(k).
(   68) !
(   69) !        To ensure a better fit for the lower end of the spectrum, we
(   70) !        apply an (arbitrary) weighting function before fitting
(   71) !           W(in) = 1.0 / in
(   72) !
(   73) !     Reference.
(   74) !     ----------
(   75) !
(   76) !     Seber, G.A.F. (1979). Linear Regression Analyses.
(   77) !     John Wiley and Sons
(   78) !
(   79) !     ECMWF Research Department documentation of the IFS
(   80) !
(   81) !
(   82) !     Modifications
(   83) !     -------------
(   84) !
(   85) !
(   86) !
(   87) !     Subroutine arguments
(   88) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 4

(   89) TYPE(FA_COM) :: FA
(   90) INTEGER (KIND=JPLIKB) KREP, KRANG, KPULAP
(   91) !
(   92) REAL (KIND=JPDBLR) PSPEC(*)
(   93) !
(   94) !     Local arguments
(   95) !
(   96) INTEGER (KIND=JPLIKB) IRANGC, ITRONC, IMTRONC, INMAX, INMIN
(   97) INTEGER (KIND=JPLIKB) IKMAX, IDEB, IFIN, JN, JM, JK, IK, IN, IM
(   98) INTEGER (KIND=JPLIKB) IMLIM, JIND, IOFF, INUMER
(   99) INTEGER (KIND=JPLIKB) INIMES, ISTRON
(  100) INTEGER (KIND=JPLIKB), DIMENSION(:), ALLOCATABLE :: ITAB1
(  101) INTEGER (KIND=JPLIKB), DIMENSION(:), ALLOCATABLE :: ITAB2
(  102) !
(  103) REAL (KIND=JPDBLR) ZEPS, ZZ, ZXMW, ZYMW, ZWSUM, ZX, ZY
(  104) REAL (KIND=JPDBLR) ZP, ZBETA1, ZSUM1, ZSUM2
(  105) REAL (KIND=JPDBLR), DIMENSION(:), ALLOCATABLE    :: ZW, ZNORM
(  106) !
(  107) LOGICAL LLMLAM
(  108) !
(  109) CHARACTER(LEN=FA%JPLMES) CLMESS 
(  110) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(  111) LOGICAL                  LLFATA
(  112) 
(  113) !**
(  114) !     1.  -  CONTROLES DES PARAMETRES D'APPEL, INITIALISATIONS.
(  115) !-----------------------------------------------------------------------
(  116) !
(  117) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  118) IF (LHOOK) CALL DR_HOOK('FAPULA_MT',0,ZHOOK_HANDLE)
(  119) IF (KRANG.LE.0.OR.KRANG.GT.FA%JPNXFA) THEN
(  120)   KREP=-66
(  121)   GOTO 1001
(  122) ENDIF
(  123) !
(  124) ISTRON=FA%FICHIER(KRANG)%NSTROF
(  125) IRANGC=FA%FICHIER(KRANG)%NUCADR
(  126) ITRONC=FA%CADRE(IRANGC)%MTRONC
(  127) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(  128) !
(  129) IF (LLMLAM) IMTRONC=FA%CADRE(IRANGC)%NOZPAR(2)
(  130) IF (ITRONC.LE.ISTRON) THEN
(  131)   KREP=-88
(  132)   GOTO 1001
(  133) ELSEIF (LLMLAM.AND.IMTRONC.LE.ISTRON) THEN
(  134)   KREP=-88
(  135)   GOTO 1001
(  136) ELSEIF (LLMLAM.AND.(IMTRONC.GT.3*ITRONC.OR. &
(  137) &    ITRONC.GT.3*IMTRONC)) THEN
(  138) ! Il s'agit d'un garde-fou, modifiable (ne pas oublier FARCIS et FACSIM)
(  139)   KREP=-114
(  140)   GOTO 1001
(  141) ELSE       
(  142)   KREP=0
(  143) ENDIF
(  144) !
(  145) ZEPS  = 1.0E-15_JPDBLR
(  146) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 5

(  147) IF (LLMLAM) THEN
(  148)   IKMAX = ITRONC*ITRONC + IMTRONC*IMTRONC
(  149) !
(  150) !  Pour le cas ALADIN, il faut creer les tableaux ITAB1 et ITAB2 :
(  151) !  ITAB1(JK) = 0 sauf pour JK tel qu'il existe (n,m) appartenant au spectre
(  152) !    hors de la sous-troncature non-compactee verifiant JK = n**2 + m**2:
(  153) !    on a alors ITAB1(JK) = 1
(  154) !  ITAB2 regroupe toutes les valeurs de JK precedentes.
(  155) !
(  156) !  ITAB1 est necessaire a la creation de ITAB2 et ITAB2 permet de boucler
(  157) !  directement sur les valeurs de JK utiles, et de dimensionner au plus
(  158) !  juste les tableaux ZW et ZNORM.
(  159) !
(  160)   ALLOCATE ( ITAB1(IKMAX) )
(  161)   ITAB1 = 0
(  162) !DP#ifdef SCALAR
(  163)   ALLOCATE ( ITAB2((ITRONC-1)*(IMTRONC-1)) )
(  164) !DP#else
(  165) !DP        ALLOCATE ( ITAB2(0:(ITRONC-1)*(IMTRONC-1)) )
(  166) !DP        ITAB2 = 0
(  167) !DP#endif
(  168)   DO JM = 1,IMTRONC
(  169)     IMLIM=ISTRON-JM
(  170)     IDEB=MAX(FA%CADRE(IRANGC)%NOMPAR(2*JM+3)+4*(1+IMLIM), &
(  171) &            FA%CADRE(IRANGC)%NOMPAR(2*JM+3)+4)
(  172)     IFIN=FA%CADRE(IRANGC)%NOMPAR(2*JM+4)
(  173)     DO JIND=IDEB,IFIN
(  174)       IOFF=JIND-FA%CADRE(IRANGC)%NOMPAR(2*JM+3)
(  175)       JN=IOFF/4
(  176)       JK=(JN**2 + JM**2)
(  177) !  On conserve les valeurs de JK atteintes
(  178)       ITAB1(JK) = 1
(  179)     ENDDO
(  180)   ENDDO
(  181) !  On construit le tableau ITAB2 des valeurs de JK atteintes
(  182)   IK = 0
(  183)   DO JK = 1,IKMAX
(  184) !DP#ifdef SCALAR
(  185)     IF (ITAB1(JK).GT.0) THEN
(  186)       IK = IK+1
(  187)       ITAB2(IK) = JK
(  188)       ITAB1(JK) = IK
(  189)     ENDIF
(  190) !DP#else
(  191) !DP       IK = IK + ITAB1(JK)
(  192) !DP       ITAB2(IK) = ITAB2(IK) + JK*ITAB1(JK)
(  193) !DP       ITAB1(JK) = IK
(  194) !DP#endif
(  195)   ENDDO
(  196)   INMIN = 1
(  197)   INMAX = IK
(  198) !
(  199) !  CAS ARPEGE
(  200) !
(  201) ELSE
(  202)   INMIN = ISTRON + 1
(  203)   INMAX = ITRONC
(  204) ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 6

(  205) !
(  206) !**
(  207) !     2.  -  CALCUL DES NORMES ET DES POIDS
(  208) !-----------------------------------------------------------------------
(  209) !
(  210) ALLOCATE ( ZW(0:INMAX), ZNORM(0:INMAX) )
(  211) ZNORM = 0.0_JPDBLR
(  212) !
(  213) IF (LLMLAM) THEN
(  214) !
(  215) !  CAS ALADIN
(  216) !
(  217)   DO JM = 1,IMTRONC
(  218)     IMLIM=ISTRON-JM
(  219)     IDEB=MAX(FA%CADRE(IRANGC)%NOMPAR(2*JM+3)+4*(1+IMLIM), &
(  220) &            FA%CADRE(IRANGC)%NOMPAR(2*JM+3)+4)
(  221)     IFIN=FA%CADRE(IRANGC)%NOMPAR(2*JM+4)
(  222)     DO JIND=IDEB,IFIN
(  223)       IOFF=JIND-FA%CADRE(IRANGC)%NOMPAR(2*JM+3)
(  224)       JN=IOFF/4
(  225)       JK=(JN**2 + JM**2)
(  226)       ZNORM(ITAB1(JK)) = MAX(ZNORM(ITAB1(JK)), ABS(PSPEC(JIND)))
(  227)     ENDDO
(  228)   ENDDO
(  229)   DEALLOCATE ( ITAB1 )
(  230) !
(  231) !  CAS ARPEGE
(  232) !
(  233) ELSE
(  234) !
(  235)   DO JN=0,INMAX
(  236)     DO JM=-JN,JN
(  237)       IM=ABS(JM)
(  238)       IF (JM < 0) THEN
(  239)         JIND=FA%CADRE(IRANGC)%NDIM0GG(IM)+(JN-IM)*2 +1
(  240)       ELSE
(  241)         JIND=FA%CADRE(IRANGC)%NDIM0GG(IM)+(JN-IM)*2
(  242)       ENDIF
(  243)       ZNORM(JN) = MAX(ZNORM(JN), ABS(PSPEC(JIND)))
(  244)     ENDDO
(  245)   ENDDO
(  246) !
(  247) ENDIF
(  248) !
(  249) ZZ = REAL(INMAX-INMIN+1,JPDBLR)
(  250) DO IN = INMIN, INMAX
(  251)   ZW(IN) = ZZ / REAL(IN-INMIN+1,JPDBLR)
(  252) !
(  253) !     Ensure the norms have a value which is not too small in case of
(  254) !     problems with math functions (e.g. LOG).
(  255) !
(  256)   IF(ZNORM(IN).LT.ZEPS) THEN
(  257)     ZNORM(IN) = ZEPS
(  258)     ZW(IN) = 100._JPDBLR*ZEPS
(  259)   ENDIF
(  260) ENDDO
(  261) !*
(  262) !     3.  -  AJUSTEMENT PAR LES MOINDRES CARRES POUR DETERMINER LA PENTE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 7

(  263) !            (ZBETA1).
(  264) !-----------------------------------------------------------------------
(  265) !
(  266) !
(  267) !
(  268) ZXMW  = 0.0_JPDBLR
(  269) ZYMW  = 0.0_JPDBLR
(  270) ZWSUM = 0.0_JPDBLR
(  271) !
(  272) !     Sum the weighted X and Ys.
(  273) DO JN = INMIN, INMAX
(  274)   IF (LLMLAM) THEN
(  275)     ZX =  LOG(REAL(ITAB2(JN),JPDBLR))
(  276)   ELSE
(  277)     ZX =  LOG(REAL(JN*(JN+1),JPDBLR))
(  278)   ENDIF
(  279)   ZY    = LOG(ZNORM(JN))
(  280)   ZXMW  = ZXMW+ZX*ZW(JN)
(  281)   ZYMW  = ZYMW+ZY*ZW(JN)
(  282)   ZWSUM = ZWSUM+ZW(JN)
(  283) ENDDO
(  284) !
(  285) !     Form mean weighted X and Y.
(  286) ZXMW  = ZXMW / ZWSUM
(  287) ZYMW  = ZYMW / ZWSUM
(  288) ZSUM1 = 0.0_JPDBLR
(  289) ZSUM2 = 0.0_JPDBLR
(  290) !
(  291) !     Perform a least square fit for the equation
(  292) DO JN = INMIN, INMAX
(  293)   IF (LLMLAM) THEN
(  294)     ZX =  LOG(REAL(ITAB2(JN),JPDBLR))
(  295)   ELSE
(  296)     ZX =  LOG(REAL(JN*(JN+1),JPDBLR))
(  297)   ENDIF
(  298)   ZY    = LOG(ZNORM(JN))
(  299)   ZSUM1 = ZSUM1+ZW(JN)*(ZY-ZYMW)*(ZX-ZXMW)
(  300)   ZSUM2 = ZSUM2+ZW(JN)*(ZX-ZXMW)**2
(  301) ENDDO
(  302) !
(  303) !
(  304) DEALLOCATE ( ZW, ZNORM )
(  305) IF (LLMLAM) DEALLOCATE ( ITAB2 )
(  306) !
(  307) !     On peut en tirer la pente recherchee:
(  308) ZBETA1 = ZSUM1 / ZSUM2
(  309) !
(  310) !     Et finalement, la puissance de laplacien, arrondie en un
(  311) !     nombre entier de milliemes.
(  312) ZP = -ZBETA1
(  313) ZP = MAX(-9.999_JPDBLR, MIN(9.999_JPDBLR, ZP))
(  314) KPULAP = NINT( ZP * 1000.0_JPDBLR, KIND=JPLIKB )
(  315) !**
(  316) !    10.  -  PHASE TERMINALE : MESSAGERIE EVENTUELLE,
(  317) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  318) !-----------------------------------------------------------------------
(  319) !
(  320) 1001 CONTINUE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 8

(  321) LLFATA=LLMOER (KREP,KRANG)
(  322) !
(  323) IF (FA%LFAMOP.OR.LLFATA) THEN
(  324)   INIMES=2
(  325)   CLNSPR='FAPULA'
(  326)   INUMER=JPNIIL
(  327)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I4,  &
(  328) &         '', ISTRON='',I4,'', KPULAP='',I6)')            &
(  329) &         KREP,KRANG,ISTRON,KPULAP
(  330)   CALL FAIPAR_MT64                                        &
(  331) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  332) &                  CLNSPR,CLNSPR,.FALSE.)
(  333) ENDIF
(  334) !
(  335) IF (LHOOK) CALL DR_HOOK('FAPULA_MT',1,ZHOOK_HANDLE)
(  336) 
(  337) CONTAINS
(  338) 
(  339) #include "facom2.llmoer.h"
(  340) 
(  341) END SUBROUTINE
(  342) 
(  343) !INTF KREP            OUT                               
(  344) !INTF KRANG         IN                                  
(  345) !INTF PSPEC         IN    DIMS=*                        
(  346) !INTF KPULAP          OUT                               
(  347) 





































NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 9

(    1) # 1 "fapula.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FAPULA_MT64                                 &
(    4) &                     (FA,  KREP, KRANG, PSPEC, KPULAP)
(    5) USE FA_MOD, ONLY : FA_COM, JPNIIL
(    6) USE PARKIND1, ONLY : JPRB
(    7) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(    8) USE LFI_PRECISION
(    9) IMPLICIT NONE
(   10) !****
(   11) !        Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   12) !     calcul de la PUissance de LAplacien "optimale" pour aplatir
(   13) !     le spectre hors de la sous-troncature.
(   14) !
(   15) !**
(   16) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   17) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   18) !    ( Tableau ) PSPEC  (Entree) ==> Champ en coef. spectraux en entree;
(   19) !                KPULAP (Sortie) ==> Puissance de laplacien calculee.
(   20) !*
(   21) !
(   22) !     Creation
(   23) !     --------
(   24) !  Avril 1999, D. Paradis, SCEM/TTI/DEV:
(   25) !     Ce ss-programme est derive de la routine CALCOP du logiciel GRIBEX
(   26) !     du CEPMMT. Il retourne la puissance de laplacien (exprimee en un
(   27) !     nombre entier de milliemes) qui aplatit le mieux le spectre des
(   28) !     coefficients spectraux (hors sous-troncature).
(   29) !     Cette puissance de laplacien, P, sera l'exposant du facteur
(   30) !     .(n*(n+1))**P   pour les champs ARPEGE ou n est le nombre d'onde total
(   31) !     .(n**2+m**2)**P pour les champs ALADIN ou n est le nombre d'onde meridien
(   32) !                                            et m est le nombre d'onde zonal
(   33) !     Ce facteur sera applique aux coefficients spectraux hors sous-troncature
(   34) !     pour en reduire l'amplitude avant le codage GRIB.
(   35) !
(   36) !
(   37) !     Method.
(   38) !     -------
(   39) !
(   40) !     For ARPEGE case, consider F(n,m) = (n*(n+1))**(-P) * G(n,m),
(   41) !     where F(n,m) is the original spectral field and n the total wavenumber.
(   42) !     For ALADIN case (LAM), consider F(n,m) = (n**2+m**2)**(-P) * G(n,m),
(   43) !     where F(n,m) is the original spectral field, n the meridian
(   44) !     wavenumber and m the zonal wavenumber.
(   45) !     The aim is to minimize G in a 1 norm with respect to P.  This can only
(   46) !     partially be achieved.
(   47) !
(   48) !     1) For ARPEGE case, what we do is to compute H(n), where
(   49) !         H(n) = max(F(n,m))    with respect to m.
(   50) !
(   51) !        We then perform a least square fit for the equation
(   52) !            log(H(n)) = beta0+beta1*log(n*(n+1)).
(   53) !
(   54) !        To ensure a better fit for the lower end of the spectrum, we
(   55) !        apply an (arbitrary) weighting function before fitting
(   56) !             W(n) = 1.0 / (n-ISTRON+1)
(   57) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 10

(   58) !     2) For ALADIN case, what we do is to compute H(in), where
(   59) !         H(in) = max(F(n,m))      where n and m verify: k = n**2 + m**2
(   60) !           and "in" is the rank of k among all the reached values by k:
(   61) !           we are only interested in k values which verify
(   62) !           k = n**2 + m**2, with (n,m) belonging to spectrum without
(   63) !           the non-compacted sub-truncation area. We call inmax the number
(   64) !           of these k values. "in" belongs to interval 1,inmax.
(   65) !
(   66) !        We then perform a least square fit for the equation
(   67) !            log(H(in)) = beta0+beta1*log(k).
(   68) !
(   69) !        To ensure a better fit for the lower end of the spectrum, we
(   70) !        apply an (arbitrary) weighting function before fitting
(   71) !           W(in) = 1.0 / in
(   72) !
(   73) !     Reference.
(   74) !     ----------
(   75) !
(   76) !     Seber, G.A.F. (1979). Linear Regression Analyses.
(   77) !     John Wiley and Sons
(   78) !
(   79) !     ECMWF Research Department documentation of the IFS
(   80) !
(   81) !
(   82) !     Modifications
(   83) !     -------------
(   84) !
(   85) !
(   86) !
(   87) !     Subroutine arguments
(   88) !
(   89) TYPE(FA_COM) :: FA
(   90) INTEGER (KIND=JPLIKB) KREP, KRANG, KPULAP
(   91) !
(   92) REAL (KIND=JPDBLR) PSPEC(*)
(   93) !
(   94) !     Local arguments
(   95) !
(   96) INTEGER (KIND=JPLIKB) IRANGC, ITRONC, IMTRONC, INMAX, INMIN
(   97) INTEGER (KIND=JPLIKB) IKMAX, IDEB, IFIN, JN, JM, JK, IK, IN, IM
(   98) INTEGER (KIND=JPLIKB) IMLIM, JIND, IOFF, INUMER
(   99) INTEGER (KIND=JPLIKB) INIMES, ISTRON
(  100) INTEGER (KIND=JPLIKB), DIMENSION(:), ALLOCATABLE :: ITAB1
(  101) INTEGER (KIND=JPLIKB), DIMENSION(:), ALLOCATABLE :: ITAB2
(  102) !
(  103) REAL (KIND=JPDBLR) ZEPS, ZZ, ZXMW, ZYMW, ZWSUM, ZX, ZY
(  104) REAL (KIND=JPDBLR) ZP, ZBETA1, ZSUM1, ZSUM2
(  105) REAL (KIND=JPDBLR), DIMENSION(:), ALLOCATABLE    :: ZW, ZNORM
(  106) !
(  107) LOGICAL LLMLAM
(  108) !
(  109) CHARACTER(LEN=FA%JPLMES) CLMESS 
(  110) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(  111) LOGICAL                  LLFATA
(  112) # 113 "fapula.F90"
(  113) !**
(  114) !     1.  -  CONTROLES DES PARAMETRES D'APPEL, INITIALISATIONS.
(  115) !-----------------------------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 11

(  116) !
(  117) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  118) IF (LHOOK) CALL DR_HOOK('FAPULA_MT',0,ZHOOK_HANDLE)
(  119) IF (KRANG.LE.0.OR.KRANG.GT.FA%JPNXFA) THEN
(  120)   KREP=-66
(  121)   GOTO 1001
(  122) ENDIF
(  123) !
(  124) ISTRON=FA%FICHIER(KRANG)%NSTROF
(  125) IRANGC=FA%FICHIER(KRANG)%NUCADR
(  126) ITRONC=FA%CADRE(IRANGC)%MTRONC
(  127) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(  128) !
(  129) IF (LLMLAM) IMTRONC=FA%CADRE(IRANGC)%NOZPAR(2)
(  130) IF (ITRONC.LE.ISTRON) THEN
(  131)   KREP=-88
(  132)   GOTO 1001
(  133) ELSEIF (LLMLAM.AND.IMTRONC.LE.ISTRON) THEN
(  134)   KREP=-88
(  135)   GOTO 1001
(  136) ELSEIF (LLMLAM.AND.(IMTRONC.GT.3*ITRONC.OR. &
(  137) &    ITRONC.GT.3*IMTRONC)) THEN
(  138) ! Il s'agit d'un garde-fou, modifiable (ne pas oublier FARCIS et FACSIM)
(  139)   KREP=-114
(  140)   GOTO 1001
(  141) ELSE       
(  142)   KREP=0
(  143) ENDIF
(  144) !
(  145) ZEPS  = 1.0E-15_JPDBLR
(  146) !
(  147) IF (LLMLAM) THEN
(  148)   IKMAX = ITRONC*ITRONC + IMTRONC*IMTRONC
(  149) !
(  150) !  Pour le cas ALADIN, il faut creer les tableaux ITAB1 et ITAB2 :
(  151) !  ITAB1(JK) = 0 sauf pour JK tel qu'il existe (n,m) appartenant au spectre
(  152) !    hors de la sous-troncature non-compactee verifiant JK = n**2 + m**2:
(  153) !    on a alors ITAB1(JK) = 1
(  154) !  ITAB2 regroupe toutes les valeurs de JK precedentes.
(  155) !
(  156) !  ITAB1 est necessaire a la creation de ITAB2 et ITAB2 permet de boucler
(  157) !  directement sur les valeurs de JK utiles, et de dimensionner au plus
(  158) !  juste les tableaux ZW et ZNORM.
(  159) !
(  160)   ALLOCATE ( ITAB1(IKMAX) )
(  161)   ITAB1 = 0
(  162) !DP#ifdef SCALAR
(  163)   ALLOCATE ( ITAB2((ITRONC-1)*(IMTRONC-1)) )
(  164) !DP#else
(  165) !DP        ALLOCATE ( ITAB2(0:(ITRONC-1)*(IMTRONC-1)) )
(  166) !DP        ITAB2 = 0
(  167) !DP#endif
(  168)   DO JM = 1,IMTRONC
(  169)     IMLIM=ISTRON-JM
(  170)     IDEB=MAX(FA%CADRE(IRANGC)%NOMPAR(2*JM+3)+4*(1+IMLIM), &
(  171) &            FA%CADRE(IRANGC)%NOMPAR(2*JM+3)+4)
(  172)     IFIN=FA%CADRE(IRANGC)%NOMPAR(2*JM+4)
(  173)     DO JIND=IDEB,IFIN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 12

(  174)       IOFF=JIND-FA%CADRE(IRANGC)%NOMPAR(2*JM+3)
(  175)       JN=IOFF/4
(  176)       JK=(JN**2 + JM**2)
(  177) !  On conserve les valeurs de JK atteintes
(  178)       ITAB1(JK) = 1
(  179)     ENDDO
(  180)   ENDDO
(  181) !  On construit le tableau ITAB2 des valeurs de JK atteintes
(  182)   IK = 0
(  183)   DO JK = 1,IKMAX
(  184) !DP#ifdef SCALAR
(  185)     IF (ITAB1(JK).GT.0) THEN
(  186)       IK = IK+1
(  187)       ITAB2(IK) = JK
(  188)       ITAB1(JK) = IK
(  189)     ENDIF
(  190) !DP#else
(  191) !DP       IK = IK + ITAB1(JK)
(  192) !DP       ITAB2(IK) = ITAB2(IK) + JK*ITAB1(JK)
(  193) !DP       ITAB1(JK) = IK
(  194) !DP#endif
(  195)   ENDDO
(  196)   INMIN = 1
(  197)   INMAX = IK
(  198) !
(  199) !  CAS ARPEGE
(  200) !
(  201) ELSE
(  202)   INMIN = ISTRON + 1
(  203)   INMAX = ITRONC
(  204) ENDIF
(  205) !
(  206) !**
(  207) !     2.  -  CALCUL DES NORMES ET DES POIDS
(  208) !-----------------------------------------------------------------------
(  209) !
(  210) ALLOCATE ( ZW(0:INMAX), ZNORM(0:INMAX) )
(  211) ZNORM = 0.0_JPDBLR
(  212) !
(  213) IF (LLMLAM) THEN
(  214) !
(  215) !  CAS ALADIN
(  216) !
(  217)   DO JM = 1,IMTRONC
(  218)     IMLIM=ISTRON-JM
(  219)     IDEB=MAX(FA%CADRE(IRANGC)%NOMPAR(2*JM+3)+4*(1+IMLIM), &
(  220) &            FA%CADRE(IRANGC)%NOMPAR(2*JM+3)+4)
(  221)     IFIN=FA%CADRE(IRANGC)%NOMPAR(2*JM+4)
(  222)     DO JIND=IDEB,IFIN
(  223)       IOFF=JIND-FA%CADRE(IRANGC)%NOMPAR(2*JM+3)
(  224)       JN=IOFF/4
(  225)       JK=(JN**2 + JM**2)
(  226)       ZNORM(ITAB1(JK)) = MAX(ZNORM(ITAB1(JK)), ABS(PSPEC(JIND)))
(  227)     ENDDO
(  228)   ENDDO
(  229)   DEALLOCATE ( ITAB1 )
(  230) !
(  231) !  CAS ARPEGE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 13

(  232) !
(  233) ELSE
(  234) !
(  235)   DO JN=0,INMAX
(  236)     DO JM=-JN,JN
(  237)       IM=ABS(JM)
(  238)       IF (JM < 0) THEN
(  239)         JIND=FA%CADRE(IRANGC)%NDIM0GG(IM)+(JN-IM)*2 +1
(  240)       ELSE
(  241)         JIND=FA%CADRE(IRANGC)%NDIM0GG(IM)+(JN-IM)*2
(  242)       ENDIF
(  243)       ZNORM(JN) = MAX(ZNORM(JN), ABS(PSPEC(JIND)))
(  244)     ENDDO
(  245)   ENDDO
(  246) !
(  247) ENDIF
(  248) !
(  249) ZZ = REAL(INMAX-INMIN+1,JPDBLR)
(  250) DO IN = INMIN, INMAX
(  251)   ZW(IN) = ZZ / REAL(IN-INMIN+1,JPDBLR)
(  252) !
(  253) !     Ensure the norms have a value which is not too small in case of
(  254) !     problems with math functions (e.g. LOG).
(  255) !
(  256)   IF(ZNORM(IN).LT.ZEPS) THEN
(  257)     ZNORM(IN) = ZEPS
(  258)     ZW(IN) = 100._JPDBLR*ZEPS
(  259)   ENDIF
(  260) ENDDO
(  261) !*
(  262) !     3.  -  AJUSTEMENT PAR LES MOINDRES CARRES POUR DETERMINER LA PENTE
(  263) !            (ZBETA1).
(  264) !-----------------------------------------------------------------------
(  265) !
(  266) !
(  267) !
(  268) ZXMW  = 0.0_JPDBLR
(  269) ZYMW  = 0.0_JPDBLR
(  270) ZWSUM = 0.0_JPDBLR
(  271) !
(  272) !     Sum the weighted X and Ys.
(  273) DO JN = INMIN, INMAX
(  274)   IF (LLMLAM) THEN
(  275)     ZX =  LOG(REAL(ITAB2(JN),JPDBLR))
(  276)   ELSE
(  277)     ZX =  LOG(REAL(JN*(JN+1),JPDBLR))
(  278)   ENDIF
(  279)   ZY    = LOG(ZNORM(JN))
(  280)   ZXMW  = ZXMW+ZX*ZW(JN)
(  281)   ZYMW  = ZYMW+ZY*ZW(JN)
(  282)   ZWSUM = ZWSUM+ZW(JN)
(  283) ENDDO
(  284) !
(  285) !     Form mean weighted X and Y.
(  286) ZXMW  = ZXMW / ZWSUM
(  287) ZYMW  = ZYMW / ZWSUM
(  288) ZSUM1 = 0.0_JPDBLR
(  289) ZSUM2 = 0.0_JPDBLR






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 14

(  290) !
(  291) !     Perform a least square fit for the equation
(  292) DO JN = INMIN, INMAX
(  293)   IF (LLMLAM) THEN
(  294)     ZX =  LOG(REAL(ITAB2(JN),JPDBLR))
(  295)   ELSE
(  296)     ZX =  LOG(REAL(JN*(JN+1),JPDBLR))
(  297)   ENDIF
(  298)   ZY    = LOG(ZNORM(JN))
(  299)   ZSUM1 = ZSUM1+ZW(JN)*(ZY-ZYMW)*(ZX-ZXMW)
(  300)   ZSUM2 = ZSUM2+ZW(JN)*(ZX-ZXMW)**2
(  301) ENDDO
(  302) !
(  303) !
(  304) DEALLOCATE ( ZW, ZNORM )
(  305) IF (LLMLAM) DEALLOCATE ( ITAB2 )
(  306) !
(  307) !     On peut en tirer la pente recherchee:
(  308) ZBETA1 = ZSUM1 / ZSUM2
(  309) !
(  310) !     Et finalement, la puissance de laplacien, arrondie en un
(  311) !     nombre entier de milliemes.
(  312) ZP = -ZBETA1
(  313) ZP = MAX(-9.999_JPDBLR, MIN(9.999_JPDBLR, ZP))
(  314) KPULAP = NINT( ZP * 1000.0_JPDBLR, KIND=JPLIKB )
(  315) !**
(  316) !    10.  -  PHASE TERMINALE : MESSAGERIE EVENTUELLE,
(  317) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  318) !-----------------------------------------------------------------------
(  319) !
(  320) 1001 CONTINUE
(  321) LLFATA=LLMOER (KREP,KRANG)
(  322) !
(  323) IF (FA%LFAMOP.OR.LLFATA) THEN
(  324)   INIMES=2
(  325)   CLNSPR='FAPULA'
(  326)   INUMER=JPNIIL
(  327)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I4,  &
(  328) &         '', ISTRON='',I4,'', KPULAP='',I6)')            &
(  329) &         KREP,KRANG,ISTRON,KPULAP
(  330)   CALL FAIPAR_MT64                                        &
(  331) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  332) &                  CLNSPR,CLNSPR,.FALSE.)
(  333) ENDIF
(  334) !
(  335) IF (LHOOK) CALL DR_HOOK('FAPULA_MT',1,ZHOOK_HANDLE)
(  336) # 337 "fapula.F90"
(  337) CONTAINS
(  338) # 339 "fapula.F90"
(  339) # 1 ".D[27]/facom2.llmoer.h"
(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,
(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:24      page 15

(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 340 "fapula.F90"
(  340) # 341 "fapula.F90"
(  341) END SUBROUTINE
(  342) # 343 "fapula.F90"
(  343) !INTF KREP            OUT                               
(  344) !INTF KRANG         IN                                  
(  345) !INTF PSPEC         IN    DIMS=*                        
(  346) !INTF KPULAP          OUT                               
