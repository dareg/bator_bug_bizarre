


NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: facodx.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FACODX_MT64                                              &
(    4) &                     (FA,  KREP,   KRANG,  CDPREF, KNIVAU, CDSUFF, &
(    5) &                      PSEC4, LDCOSP, KVALCO, KLONGD,               &
(    6) &                      LDUNDF, PUNDF, YDGR1TAB)
(    7) USE FA_MOD, ONLY : FA_COM, JPNIIL, NUNDEF, FAGR1TAB
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   14) !      PREPARATION (codage GRIBEX) d'un CHAMP HORIZONTAL
(   15) !      destine a etre ecrit sur un fichier ARPEGE/ALADIN.
(   16) !       ( CODage d'un champ a l'aide de gribeX )
(   17) !**
(   18) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   19) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   20) !                CDPREF (Entree) ==> Prefixe eventuel du nom d'article;
(   21) !                KNIVAU (Entree) ==> Niveau vertical eventuel;
(   22) !                CDSUFF (Entree) ==> Suffixe eventuel du nom d'article;
(   23) !    ( Tableau ) PSEC4  (Entree) ==> Valeurs REELLES du champ a ecrire;
(   24) !                LDCOSP (Entree) ==> Vrai si le champ est represente
(   25) !                                    par des coefficients spectraux;
(   26) !    ( Tableau ) KVALCO (Sortie) ==> Donnees destinees a l'ecriture;
(   27) !                KLONGD (Sortie) ==> Nombre de mots a ecrire;
(   28) !*
(   29) !       En mode multi-taches, il doit y avoir verrouillage du fichier
(   30) !     concerne avant l'appel au sous-programme.






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 3

(   31) !
(   32) !      Modifications
(   33) !      -------------
(   34) !         R. El Ouaraini : 03-Oct-06, introduire la nouvelle geometrie pour tester ERPK
(   35) !
(   36) !         JM AUDOIN  :  15 mai 2007 partie 5 changement unite 
(   37) !         R. El Khatib 22-May-2015 : Bypass errror message in case of underflows
(   38) !
(   39) !
(   40) !
(   41) TYPE(FA_COM)   :: FA
(   42) TYPE(FAGR1TAB) :: YDGR1TAB
(   43) INTEGER (KIND=JPLIKB) KREP, KRANG, KNIVAU, KLONGD
(   44) !
(   45) INTEGER (KIND=JPLIKB) KVALCO(*)
(   46) REAL (KIND=JPDBLR) PSEC4(*), PUNDF, ZUNDF
(   47) !
(   48) LOGICAL LDCOSP, LDUNDF, LLUNDF
(   49) !
(   50) CHARACTER CDPREF*(*), CDSUFF*(*)
(   51) !
(   52) #include "fagribex.h"
(   53) !
(   54) REAL (KIND=JPDBLR), ALLOCATABLE :: ZSEC4(:)
(   55) INTEGER (KIND=JPLIKB), ALLOCATABLE :: IVALCO(:)
(   56) REAL (KIND=JPDBLR) :: ZMIN, ZA
(   57) REAL (KIND=JPDBLR) :: ZSEC2(10+2*(FA%JPXNIV+1)), ZSEC3(2), ZPULAP
(   58) !
(   59) INTEGER (KIND=JPLIKB) ISEC0(2), ISEC1(FA%JPSEC1)
(   60) INTEGER (KIND=JPLIKB) ISEC2(FA%JPSEC2), ISEC3(2)
(   61) INTEGER (KIND=JPLIKB) ISEC4(FA%JPSEC4), ILONSEC2
(   62) INTEGER (KIND=JPLIKB) ILENG, IWORD, IRET, JM, IPULAP
(   63) INTEGER (KIND=JPLIKB) ILCHAM, JN, IDECAL, ICPACK
(   64) INTEGER (KIND=JPLIKB) ITRONC, ILOW, IHIGH, IDIMNC, INBITS
(   65) INTEGER (KIND=JPLIKB) IL, IADD, IRANGC, IILCHAM, INIMES
(   66) INTEGER (KIND=JPLIKB) INUMER,  IDX, JLAT, JLON, IDECOPT
(   67) INTEGER (KIND=JPLIKB) IFAORI, IFAMOD, INBIMO
(   68) !
(   69) LOGICAL LLMLAM
(   70) !
(   71) CHARACTER(LEN=1) CLOPER
(   72) !
(   73) INTRINSIC LEN_TRIM
(   74) !
(   75) CHARACTER(LEN=FA%JPXNOM) CLACTI 
(   76) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   77) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   78) LOGICAL                  LLFATA
(   79) LOGICAL                  LLFACDE
(   80) 
(   81) !**
(   82) !     1.  -  CONTROLES ET INITIALISATIONS.
(   83) !-----------------------------------------------------------------------
(   84) !
(   85) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   86) IF (LHOOK) CALL DR_HOOK('FACODX_MT',0,ZHOOK_HANDLE)
(   87) 
(   88) ISEC0 = 0






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 4

(   89) ISEC1 = 0
(   90) ISEC2 = 0
(   91) ISEC3 = 0
(   92) ISEC4 = 0
(   93) ZSEC2 = 0
(   94) ZSEC3 = 0
(   95) 
(   96) LLUNDF = LDUNDF
(   97) 
(   98) CLACTI=''
(   99) IF (KRANG.LE.0.OR.KRANG.GT.FA%JPNXFA) THEN
(  100)   KREP=-66
(  101)   GOTO 1001
(  102) ENDIF
(  103) ICPACK=FA%FICHIER(KRANG)%NSTROF
(  104) IRANGC=FA%FICHIER(KRANG)%NUCADR
(  105) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(  106) ITRONC=FA%CADRE(IRANGC)%MTRONC
(  107) !
(  108) IF (LLMLAM) THEN
(  109)   IF (LDCOSP) THEN
(  110)     ILONSEC2=21+FA%CADRE(IRANGC)%NOMPAR(2)
(  111)   ELSE
(  112)     ILONSEC2=22
(  113)   ENDIF
(  114) ELSE
(  115)   IF (LDCOSP) THEN
(  116)     ILONSEC2=22
(  117)   ELSE
(  118)     ILONSEC2=22+FA%CADRE(IRANGC)%NLATIT
(  119)   ENDIF
(  120) ENDIF
(  121) !
(  122) KVALCO(1)=FA%FICHIER(KRANG)%NFGRIB
(  123) IDECAL=3
(  124) IF (LDCOSP) THEN
(  125)   IF (LLMLAM) THEN
(  126)     ILCHAM=FA%CADRE(IRANGC)%NSFLAM
(  127)   ELSE
(  128)     ILCHAM=(1+ITRONC)*(2+ITRONC)
(  129)   ENDIF
(  130)   KVALCO(2)=1
(  131)   INBITS=FA%FICHIER(KRANG)%NBFCSP 
(  132)   IDECAL=IDECAL+2
(  133) ELSE
(  134)   ILCHAM=FA%CADRE(IRANGC)%NVAPDG
(  135)   KVALCO(2)=0
(  136)   INBITS=FA%FICHIER(KRANG)%NBFPDG
(  137) ENDIF
(  138) KVALCO(3)=INBITS
(  139) IILCHAM = ILCHAM
(  140) IDECOPT = 0
(  141) LLFACDE = FA%FICHIER(KRANG)%NCOGRIF(11) /= 0
(  142) !**
(  143) !     2.  -  PREPARATION DU TABLEAU DE DONNEES A ECRIRE SUR LE FICHIER.
(  144) !-----------------------------------------------------------------------
(  145) !
(  146) ALLOCATE (ZSEC4 (ILCHAM))






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 5

(  147) !
(  148) IF (LDCOSP .AND. LLMLAM) THEN
(  149) !
(  150) !       Champ ALADIN en coefficients spectraux... traitement particulier,
(  151) !     car non prevu dans GRIBEX (il y sera considere comme un champ lat-lon)
(  152) !     mais on a la possibilite de compacter une (pseudo-)puissance de
(  153) !     laplacien du champ a la place du champ, de maniere a augmenter
(  154) !     la precision du champ en "aplanissant" le spectre.
(  155) !
(  156) !     Determination de la puissance de Laplacien (en 1/1000 ieme)
(  157) !
(  158)   CALL FAPULA_MT64                                 &
(  159) &                 (FA,  KREP, KRANG, PSEC4, IPULAP )
(  160)   ZPULAP=REAL(IPULAP,JPDBLR)/1000._JPDBLR
(  161) !       ZPULAP=0.
(  162) !       IPULAP=0
(  163)   IF (FA%LFAMOP) THEN
(  164)     PRINT *,'FACODX: puissance de laplacien selectionee ',ZPULAP, &
(  165) &          ' pour une sous-tronc de ',ICPACK
(  166)   ENDIF
(  167)   IF (KREP.NE.0) GOTO 1001
(  168) !
(  169) ! Transfert des coeff spectraux devant etre compactes de PSEC4 a ZSEC4
(  170) ! avec prise en compte du coefficient (n**2+m**2)**zpulap. Les coefficients
(  171) ! concernes sont ceux inclus dans le quart de l'ellipse, hors axes (coeff
(  172) ! nuls), et hors du triangle non-compacte (sous-troncature).
(  173)   IILCHAM=0
(  174) !
(  175)   DO JM=1,FA%CADRE(IRANGC)%NOMPAR(2)
(  176)     ILOW=2+2*JM+1
(  177)     IADD=4* MAX(ICPACK+1-JM,1_JPLIKB )
(  178) !
(  179)     DO IDX=FA%CADRE(IRANGC)%NOMPAR(ILOW)+IADD,FA%CADRE(IRANGC)%NOMPAR(ILOW+1)
(  180)       IILCHAM=IILCHAM+1
(  181)       JN=(IDX-FA%CADRE(IRANGC)%NOMPAR(ILOW))/4
(  182)       ZSEC4(IILCHAM)=PSEC4(IDX) *              &
(  183) &         ((REAL(JN**2+JM**2, JPDBLR))**ZPULAP)
(  184)     ENDDO
(  185)   ENDDO
(  186) 
(  187) ! Number of elements in sub-triangle+axes:IDIMNC
(  188)   IDIMNC=ILCHAM-IILCHAM
(  189) ! Recherche de l'amplitude et du min du champ
(  190)   ZMIN = MINVAL(ZSEC4(1:IILCHAM))
(  191)   ZA   = MAXVAL(ZSEC4(1:IILCHAM)) - ZMIN
(  192) ! Recherche du facteur decimal optimal pour utiliser
(  193) ! au mieux les INBITS dans le codage de ce champ
(  194)   IF (FA%LFAMOP) THEN
(  195)     WRITE (UNIT=FA%NULOUT,FMT=*)'FACODX: traitement du champ: ', &
(  196) &          CDPREF,KNIVAU,CDSUFF
(  197)   ENDIF
(  198)   KREP = 0
(  199)   IF (LLFACDE) CALL FACDEC_MT64 (FA, KREP, ZA, ZMIN, INBITS, IDECOPT)
(  200)   IF (KREP.NE.0) THEN
(  201)     KREP = 0
(  202)   ENDIF
(  203) ELSEIF(LDCOSP .AND. .NOT.LLMLAM) THEN
(  204) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 6

(  205) !          Transfert du tableau d'entree dans un tableau local
(  206) !     de maniere a eviter l'ecrasement du tableau d'entree par "GRIBEX".
(  207) !
(  208)   ZSEC4(1:IILCHAM) = PSEC4(1:IILCHAM)
(  209)   IDIMNC=(1+ICPACK)*(2+ICPACK)
(  210) ELSE
(  211) !
(  212) !    CHAMPS NON SPECTRAUX: transfert du tableau d'entree dans un
(  213) !    tableau local de maniere a eviter son ecrasement par "GRIBEX".
(  214) !
(  215) !
(  216)   IDIMNC=0
(  217) ! Tester si Nouvelle ou ancienne geometrie Aladin
(  218) IF (FA%CADRE(IRANGC)%SINLAT(1) .GE. 0) THEN
(  219)   IF (LLMLAM .AND. FA%CADRE(IRANGC)%SINLAT(10).LT.0) THEN
(  220) !  Parametre de projection negatif, donc pas de projection:
(  221) !  Il s'agit d'une grille lat-lon reguliere du type Full-Pos
(  222) !  (pour champ ARPEGE ou Aladin). Il faut donc renverser
(  223) !  le champ afin de ranger Nord-Sud les valeurs plutot que Sud-Nord
(  224) !  (on conserve le rangt W-E consecutif).
(  225) !  Le but est de satisfaire la BDAP qui attend un rangt NW-->SE.
(  226) !
(  227)     IF (FA%LFAMOP) THEN
(  228)       WRITE (UNIT=FA%NULOUT,FMT=*)                              &
(  229) &              ' FACODX: Grille LAT-LON pour BDAP -> ',         &
(  230) &              ' renversement des valeurs pour etre rangees NS'
(  231)     ENDIF
(  232)     DO JLAT=1,FA%CADRE(IRANGC)%NLATIT
(  233)     DO JLON=1,FA%CADRE(IRANGC)%NXLOPA
(  234)       JN=JLON+FA%CADRE(IRANGC)%NXLOPA*(JLAT-1)
(  235)       IDX=JLON+FA%CADRE(IRANGC)%NXLOPA*(FA%CADRE(IRANGC)%NLATIT-JLAT)
(  236)       ZSEC4(IDX) = PSEC4(JN)
(  237)     ENDDO
(  238)     ENDDO
(  239)   ELSE
(  240)     ZSEC4(1:IILCHAM) = PSEC4(1:IILCHAM)
(  241)   ENDIF
(  242) ELSE
(  243)   IF (LLMLAM .AND. FA%CADRE(IRANGC)%SINLAT(2).LT.0) THEN
(  244)     IF (FA%LFAMOP) THEN
(  245)       WRITE (UNIT=FA%NULOUT,FMT=*)                              &
(  246) &              ' FACODX: Grille LAT-LON pour BDAP -> ',         &
(  247) &              ' renversement des valeurs pour etre rangees NS'
(  248)     ENDIF
(  249)     DO JLAT=1,FA%CADRE(IRANGC)%NLATIT
(  250)     DO JLON=1,FA%CADRE(IRANGC)%NXLOPA
(  251)       JN=JLON+FA%CADRE(IRANGC)%NXLOPA*(JLAT-1)
(  252)       IDX=JLON+FA%CADRE(IRANGC)%NXLOPA*(FA%CADRE(IRANGC)%NLATIT-JLAT)
(  253)       ZSEC4(IDX) = PSEC4(JN)
(  254)     ENDDO
(  255)     ENDDO
(  256)   ELSE
(  257)     ZSEC4(1:IILCHAM) = PSEC4(1:IILCHAM)
(  258)   ENDIF
(  259) ENDIF
(  260) ! Recherche de l'amplitude et du min du champ
(  261)   ZMIN=ZSEC4(1)
(  262)   ZA=0._JPDBLR






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 7

(  263)   ZMIN = MINVAL(ZSEC4(1:IILCHAM))
(  264)   ZA   = MAXVAL(ZSEC4(1:IILCHAM)) - ZMIN
(  265) ! Recherche du facteur decimal optimal pour utiliser
(  266) ! au mieux les INBITS dans le codage de ce champ
(  267)   IF (FA%LFAMOP) THEN 
(  268)   WRITE (UNIT=FA%NULOUT,FMT=*)'FACODX: traitement du champ: ', &
(  269) &          CDPREF,KNIVAU,CDSUFF
(  270)   ENDIF
(  271)   KREP = 0
(  272)   IF (LLFACDE) THEN
(  273)     IF (ABS(ZA) <= EPSILON(ZA)) THEN
(  274) !     On anticipe le retour d'erreur de facdec dans le cas ou le champs est quasi-constant
(  275) !     (cad : son amplitude est inferieur a la precision de la machine).
(  276)       IDECOPT = 0
(  277)       KREP = 0
(  278)     ELSEIF (ZMIN /= 0_JPDBLR .AND. ABS(ZMIN) < EPSILON(ZMIN)) THEN
(  279) !     On anticipe le retour d'erreur de facdec dans le cas ou le champ contient un "underflow"
(  280)       IDECOPT = 0
(  281)       KREP = 0
(  282)     ELSE 
(  283)       CALL FACDEC_MT64 (FA, KREP, ZA, ZMIN, INBITS, IDECOPT)
(  284)       IF (KREP.NE.0) THEN
(  285)         WRITE (UNIT=FA%NULOUT,FMT=*)'FACODX: field incriminated by FACDEC was ', CDPREF,KNIVAU,CDSUFF
(  286)         IDECOPT = 0
(  287)         KREP = 0
(  288)       ENDIF
(  289)     ENDIF
(  290)   ENDIF
(  291) ENDIF
(  292) !*
(  293) !     3.  -  INITIALISATION DE L'ENROBAGE GRIB
(  294) !-----------------------------------------------------------------------
(  295) !
(  296) !     3.1 -  Sections 1, 2, 3 et 4 (sf la partie reelle pour 4)
(  297) !
(  298) CALL FAINIG_MT64                                                   &
(  299) &               (FA,  KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP, &
(  300) &                IILCHAM, ISEC1, ISEC2, ZSEC2, ISEC3, ZSEC3, ISEC4,&
(  301) &                YDGR1TAB)
(  302) 
(  303) IF (KREP.NE.0) THEN
(  304)   GOTO 1001
(  305) ENDIF
(  306) ! Prise en compte du facteur decimal
(  307) IF (LLFACDE .AND. ISEC1(23) == 0) THEN
(  308)   ISEC1(23) = IDECOPT
(  309) ENDIF
(  310) !
(  311) !     3.2 -  Definition du type de codage
(  312) !
(  313) CLOPER='C'
(  314) IF (FA%FICHIER(KRANG)%NCOGRIF(1)==1) CLOPER='K'
(  315) !*
(  316) !     4.  -  CHANGEMENT D'UNITE DE CERTAINS CHAMPS.
(  317) !            Il s'agit de champs dont les valeurs sont comprises
(  318) !            entre 0 et 1 dans le modele mais dont l'unite
(  319) !            conventionnelle dans le GRIB est le %.
(  320) !---------------------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 8

(  321) !
(  322) ZUNDF = PUNDF
(  323) IF (YDGR1TAB%LMULTI) THEN
(  324)   ZSEC4 = ZSEC4 * YDGR1TAB%FMULTI
(  325)   ZUNDF = ZUNDF * YDGR1TAB%FMULTI
(  326) ENDIF
(  327) !
(  328) ! Traitement des valeurs indefinies; on verifie d'abord que le champ
(  329) ! contient de telles valeurs afin d'eviter de polluer le resultat
(  330) ! final avec un bitmap inutile
(  331) !
(  332) IF (LLUNDF) THEN
(  333)   LLUNDF = ANY (ZSEC4 == ZUNDF)
(  334) ENDIF
(  335) !
(  336) ! Ajustement des parametres d'encodage
(  337) !
(  338) IF (LLUNDF) THEN
(  339)   ISEC1(5)=192
(  340)   ZSEC3(2)=ZUNDF
(  341)   ISEC3(1)=0
(  342)   ISEC3(2)=INT (ZUNDF)
(  343) ENDIF
(  344) !*
(  345) !     5.  -  CODAGE GRIB PROPREMENT DIT
(  346) !-----------------------------------------------------------------------
(  347) !
(  348) IRET=-1
(  349) ! ILENG=longueur disponible en nb d'"entiers declares INTEGER" dans KVALCO.
(  350) ! On part de l'hypothese ou le dimensionnement de KVALCO se fait
(  351) ! dans la routine appelante a ILCHAM+2 (cas de l'absence de compactage).
(  352) ILENG=(KIND(KVALCO)/4)*(ILCHAM+2-IDECAL)
(  353) IWORD=0
(  354) !DP
(  355) !DP  TEST AVEC UNE PUISSANCE DE LAPLACIEN IMPOSEE
(  356) !DP
(  357) !DP   CALL GRSMKP(0)
(  358) !DP ISEC4(17) = 2000
(  359) !DP
(  360) IF (FA%LFAMOP) THEN
(  361)   WRITE (UNIT=FA%NULOUT,FMT=*)' FACODX: CLOPER = ',CLOPER
(  362)   WRITE (UNIT=FA%NULOUT,FMT=*)                                     &
(  363) &                    ' FACODX: IILCHAM, ILCHAM, IDECAL, ILENG = ', &
(  364) &                    IILCHAM, ILCHAM, IDECAL, ILENG
(  365)   WRITE (UNIT=FA%NULOUT,FMT=*)'       * ISEC1 = ',ISEC1
(  366)   WRITE (UNIT=FA%NULOUT,FMT=*)                                   &
(  367) &                    '       * ILONSEC2 ! ISEC2(1:ILONSEC2) = ', &
(  368) &                    ILONSEC2,' ! ', ISEC2(1:ILONSEC2)
(  369)   WRITE (UNIT=FA%NULOUT,FMT=*) '       * ZSEC2(1:2) = ',ZSEC2(1:2)
(  370)   IF (ISEC2(12).GT.0) WRITE (UNIT=FA%NULOUT,FMT=*)            &
(  371) &          '       * ISEC2(12) ! ZSEC2(11:10+ISEC2(12)) = ',  &
(  372) &                    ISEC2(12), ' ! ', ZSEC2(11:10+ISEC2(12))
(  373)   WRITE (UNIT=FA%NULOUT,FMT=*)'       * FA%JPSEC4 ! ISEC4 = ', &
(  374) &                              FA%JPSEC4,' ! ',ISEC4
(  375)   WRITE (UNIT=FA%NULOUT,FMT=*)'       * ZSEC4(1:20) = ', &
(  376) &                              ZSEC4(1:20)
(  377) ENDIF
(  378) 






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 9

(  379) !     WARNING GRIBEX ENLEVE 
(  380) CALL GRSDBG (0)
(  381) CALL GRSVCK (0)
(  382) 
(  383) ! Defauts
(  384) 
(  385) CALL GRSX2O (1)
(  386) CALL GRSN2O (1)
(  387) 
(  388) ! Defaults FA
(  389) 
(  390) IF (FA%IOPTGRSX2O /= NUNDEF) &
(  391) & CALL GRSX2O(INT (FA%IOPTGRSX2O, JPLIKM))
(  392) 
(  393) IF (FA%IOPTGRSN2O /= NUNDEF) &
(  394) & CALL GRSN2O(INT (FA%IOPTGRSN2O, JPLIKB))
(  395) 
(  396) ! Defauts pour cette unite
(  397) 
(  398) IF (FA%FICHIER(KRANG)%IOPTGRSX2O /= NUNDEF) &
(  399) & CALL GRSX2O(INT (FA%FICHIER(KRANG)%IOPTGRSX2O, JPLIKM))
(  400) 
(  401) IF (FA%FICHIER(KRANG)%IOPTGRSN2O /= NUNDEF) &
(  402) & CALL GRSN2O(INT (FA%FICHIER(KRANG)%IOPTGRSN2O, JPLIKB))
(  403) 
(  404) !  1/ On force GRIBEX a calculer la puissance de laplacien
(  405) CALL GRSMKP(1)
(  406) !  2/ On retire l'arrondi du message GRIB a un multiple de 120 octets
(  407) CALL GRSRND(0)
(  408) 
(  409) CALL FAGRIBEX(ISEC0,ISEC1,ISEC2,ZSEC2,ISEC3,ZSEC3,ISEC4,  &
(  410) &             ZSEC4,IILCHAM,KVALCO(IDECAL+1),ILENG,IWORD, &
(  411) &             CLOPER,IRET)
(  412) !
(  413) IF (IRET.GT.0) THEN
(  414) ! Erreur rapportee par GRIBEX
(  415)   KREP=-1000-IRET
(  416)   GOTO 1001
(  417) ELSEIF (IRET.LT.0) THEN
(  418) ! Warning rapporte par GRIBEX
(  419)   WRITE (UNIT=FA%NULOUT,FMT=*)
(  420)   WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  421) &               '!------------------------------------------'
(  422)   WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  423) &               '!           FACODX:   WARNING !!!         !'
(  424)   WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  425) &               '!------------------------------------------'
(  426)   WRITE (UNIT=FA%NULOUT,FMT=*) ' Code retour de GRIBEX = ', &
(  427) &        IRET,' pour le champ: ',CDPREF,KNIVAU,CDSUFF
(  428)   WRITE (UNIT=FA%NULOUT,FMT=*)
(  429) ENDIF
(  430) !
(  431) ! ISEC0(1) = nb d'octets dans le message GRIB
(  432) ! IWORD    = nb de mots de JBDBLE octets (64 bits) du message GRIB
(  433) IWORD=1+(ISEC0(1)-1)/JPLIKB
(  434) KLONGD=IDECAL+IWORD+IDIMNC
(  435) IF (FA%LFAMOP) THEN
(  436)   WRITE (UNIT=FA%NULOUT,FMT=*)                                    &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 10

(  437) &         ' FACODX: longueur du GRIB en nb octets et en mots = ', &
(  438) &         ISEC0(1), IWORD
(  439)   WRITE (UNIT=FA%NULOUT,FMT=*)                             &
(  440) &         ' FACODX: longueur de l''article FA en mots = ', &
(  441) &         KLONGD
(  442)   IF (ISEC4(4).EQ.64 .AND. ISEC4(3).EQ.128) THEN
(  443)     WRITE (UNIT=FA%NULOUT,FMT=*)                          &
(  444) &           ' FACODX: complex packing with P=',ISEC4(17), &
(  445) &           ' and sub trunc = ',ISEC4(18)
(  446)   ENDIF
(  447) ENDIF
(  448) !
(  449) !  CAS D'UN DEPASSEMENT DE LA TAILLE MAX DE L'ARTICLE FINAL
(  450) !  On ramene ce cas a celui d'un tableau trop petit dans GRIBEX.
(  451) !
(  452) IF (KLONGD.GT.ILCHAM+2) THEN
(  453)   IF (FA%LFAMOP) THEN
(  454)     WRITE (UNIT=FA%NULOUT,FMT=*)                           &
(  455) &            ' FACODX: article FA + long avec compactage', &
(  456) &            ' que sans => on le supprime'
(  457)   ENDIF
(  458)   IRET=710
(  459)   KREP=-1000-IRET
(  460)   GOTO 1001
(  461) ENDIF
(  462) !
(  463) !*
(  464) !     6.  -  TRANSFERT DES COEFFICIENTS SPECTRAUX NON COMPACTES.
(  465) !-----------------------------------------------------------------------
(  466) !        (et non traites par GRIBEX) en fin d'article.
(  467) !
(  468) IF (LDCOSP) THEN
(  469)   KVALCO(4)=ICPACK
(  470)   IF (LLMLAM) THEN
(  471)     KVALCO(5)=IPULAP
(  472) ! Copy nonpacked part of PSEC4 (sub-triangle+axes) into KVALCO
(  473)     IILCHAM=0
(  474)     DO JM=0,FA%CADRE(IRANGC)%NOMPAR(2)
(  475)       IL=2+2*JM+1
(  476)       ILOW=FA%CADRE(IRANGC)%NOMPAR(IL)
(  477) !
(  478)       IF (JM.EQ.0) THEN
(  479)         IHIGH=FA%CADRE(IRANGC)%NOMPAR(IL+1)
(  480)       ELSE
(  481)         IHIGH=ILOW+4*(ICPACK+1-JM)-1
(  482)         IF (IHIGH.LE.ILOW) IHIGH=ILOW+3
(  483)       ENDIF     
(  484) !
(  485)       DO IDX=ILOW,IHIGH
(  486)         IILCHAM=IILCHAM+1
(  487)         ZSEC4(IILCHAM)=PSEC4(IDX)
(  488)       ENDDO
(  489)     ENDDO
(  490)     IF (IILCHAM.NE.IDIMNC) THEN
(  491)       WRITE (UNIT=FA%NULOUT,FMT='(A35,I10,A11,I10)')        &
(  492) &            'FACODX: incoherence entre IILCHAM= ',IILCHAM, &
(  493) &            'et IDIMNC= ',IDIMNC
(  494)       KREP=-126






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 11

(  495)       GOTO 1001
(  496)     ENDIF
(  497)   ELSE
(  498)     KVALCO(5)=ISEC4(17)
(  499) ! Recuperation des coeff spectraux non compactes sachant que le
(  500) ! rangement est fait par colonnes de JM=cst juxtaposees
(  501)     ZSEC4(1:2*(ICPACK+1))=PSEC4(1:2*(ICPACK+1))
(  502)     IILCHAM=2*(ICPACK+1)-1
(  503)     IDX=2*(ITRONC+1)-1
(  504)     DO JM=1,ICPACK
(  505)     DO JN=JM,ITRONC
(  506)       IDX=IDX+2
(  507)       IF (JN.LE.ICPACK) THEN
(  508)         IILCHAM=IILCHAM+2
(  509)         ZSEC4(IILCHAM) = PSEC4(IDX)
(  510)         ZSEC4(IILCHAM+1) = PSEC4(IDX+1)
(  511)       ENDIF
(  512)     ENDDO
(  513)     ENDDO
(  514)     IF (IILCHAM+1.NE.IDIMNC) THEN
(  515)       WRITE (UNIT=FA%NULOUT,FMT='(A35,I10,A11,I10)')            &
(  516) &            'FACODX: incoherence entre IILCHAM+1= ',IILCHAM+1, &
(  517) &            'et IDIMNC= ',IDIMNC
(  518)       KREP=-126
(  519)       GOTO 1001
(  520)     ENDIF
(  521)   ENDIF
(  522) ! Les IDIMNC coeff spectraux non compactes doivent etre transferes
(  523) ! sur le tableau d'entiers KVALCO apres le IDECAL+IWORD ieme elt.
(  524) !
(  525) !       KVALCO(IDECAL+IWORD+1:KLONGD)=TRANSFER(ZSEC4,KVALCO,IDIMNC)
(  526)   ALLOCATE (IVALCO(IDIMNC))
(  527)   IVALCO(1:IDIMNC)=TRANSFER(ZSEC4,IVALCO,IDIMNC)
(  528)   KVALCO(IDECAL+IWORD+1:KLONGD)=IVALCO(1:IDIMNC)
(  529)   DEALLOCATE (IVALCO)
(  530) ENDIF
(  531) !**
(  532) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  533) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  534) !-----------------------------------------------------------------------
(  535) !
(  536) 1001 CONTINUE
(  537) IF (ALLOCATED(ZSEC4)) DEALLOCATE ( ZSEC4 )
(  538) !
(  539) ! Cas particulier de l'erreur GRIBEX num 710: OUTPUT ARRAY TOO SMALL
(  540) ! On s'en sert pour detecter un probleme de compactage lie a ce que
(  541) ! le champ compacte+les descripteurs prennent plus de place que le
(  542) ! champ non compacte...
(  543) ! On sort donc du compactage (FACODX) pour demander un codage sans
(  544) ! compactage (FACINE) avec rangement des valeurs selon le modele:
(  545) ! FA%NFGRIB=-1.
(  546) !
(  547) IF (IRET==710) THEN
(  548)   CLNSPR='FACODX'
(  549)   INIMES=2
(  550)   INUMER=JPNIIL
(  551) !
(  552)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I5,'', KRANG='',I4,  &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 12

(  553) &         '', CDPREF='''''',A,'''''', KNIVAU='',I6,       &
(  554) &         '', CDSUFF='''''',A,'''''', LDCOSP= '',L1,      &
(  555) &         '', KLONGD='',I6)')                             &
(  556) &     KREP, KRANG, CDPREF(1:LEN_TRIM(CDPREF)), KNIVAU,    &
(  557) &     CDSUFF(1:LEN_TRIM(CDSUFF)), LDCOSP, KLONGD
(  558)   CALL FAIPAR_MT64                                        &
(  559) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  560) &                  CLNSPR,CLACTI,.FALSE.)
(  561)   CLMESS=                                                          &
(  562) & ' CAUTION: this field is not packed or it will occupy more space'
(  563)   CALL FAIPAR_MT64                                        &
(  564) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  565) &                  CLNSPR,CLACTI,.FALSE.)
(  566)   IF (LHOOK) CALL DR_HOOK('FACODX_MT',1,ZHOOK_HANDLE)
(  567)   RETURN
(  568) ENDIF
(  569) !
(  570) !
(  571) !
(  572) LLFATA=LLMOER (KREP,KRANG)
(  573) !
(  574) IF (FA%LFAMOP.OR.LLFATA) THEN
(  575)   INIMES=2
(  576)   CLNSPR='FACODX'
(  577)   INUMER=JPNIIL
(  578) !
(  579)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I5,'', KRANG='',I4,  &
(  580) &         '', CDPREF='''''',A,'''''', KNIVAU='',I6,       &
(  581) &         '', CDSUFF='''''',A,'''''', LDCOSP= '',L1,      &
(  582) &         '', KLONGD='',I6)')                             &
(  583) &     KREP, KRANG, CDPREF(1:LEN_TRIM(CDPREF)), KNIVAU,    &
(  584) &     CDSUFF(1:LEN_TRIM(CDSUFF)), LDCOSP, KLONGD
(  585)   CALL FAIPAR_MT64                                        &
(  586) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  587) &                  CLNSPR,CLACTI,.FALSE.)
(  588) ENDIF
(  589) !
(  590) IF (LHOOK) CALL DR_HOOK('FACODX_MT',1,ZHOOK_HANDLE)
(  591) 
(  592) CONTAINS
(  593) 
(  594) #include "facom2.llmoer.h"
(  595) 
(  596) END SUBROUTINE FACODX_MT64
(  597) 
(  598) !INTF KREP            OUT                                                              
(  599) !INTF KRANG         IN                                                                 
(  600) !INTF CDPREF        IN                                                                 
(  601) !INTF KNIVAU        IN                                                                 
(  602) !INTF CDSUFF        IN                                                                 
(  603) !INTF PSEC4         IN    DIMS=*                                                       
(  604) !INTF LDCOSP        IN                                                                 
(  605) !INTF KVALCO          OUT DIMS=*                         KIND=JPLIKB                   
(  606) !INTF KLONGD          OUT                                                              
(  607) !INTF LDUNDF        IN                                                                 
(  608) !INTF PUNDF         IN                                                                 
(  609) !INTF YDGR1TAB      IN                                                                 







NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 13

(    1) # 1 "facodx.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) SUBROUTINE FACODX_MT64                                              &
(    4) &                     (FA,  KREP,   KRANG,  CDPREF, KNIVAU, CDSUFF, &
(    5) &                      PSEC4, LDCOSP, KVALCO, KLONGD,               &
(    6) &                      LDUNDF, PUNDF, YDGR1TAB)
(    7) USE FA_MOD, ONLY : FA_COM, JPNIIL, NUNDEF, FAGR1TAB
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   14) !      PREPARATION (codage GRIBEX) d'un CHAMP HORIZONTAL
(   15) !      destine a etre ecrit sur un fichier ARPEGE/ALADIN.
(   16) !       ( CODage d'un champ a l'aide de gribeX )
(   17) !**
(   18) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   19) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   20) !                CDPREF (Entree) ==> Prefixe eventuel du nom d'article;
(   21) !                KNIVAU (Entree) ==> Niveau vertical eventuel;
(   22) !                CDSUFF (Entree) ==> Suffixe eventuel du nom d'article;
(   23) !    ( Tableau ) PSEC4  (Entree) ==> Valeurs REELLES du champ a ecrire;
(   24) !                LDCOSP (Entree) ==> Vrai si le champ est represente
(   25) !                                    par des coefficients spectraux;
(   26) !    ( Tableau ) KVALCO (Sortie) ==> Donnees destinees a l'ecriture;
(   27) !                KLONGD (Sortie) ==> Nombre de mots a ecrire;
(   28) !*
(   29) !       En mode multi-taches, il doit y avoir verrouillage du fichier
(   30) !     concerne avant l'appel au sous-programme.
(   31) !
(   32) !      Modifications
(   33) !      -------------
(   34) !         R. El Ouaraini : 03-Oct-06, introduire la nouvelle geometrie pour tester ERPK
(   35) !
(   36) !         JM AUDOIN  :  15 mai 2007 partie 5 changement unite 
(   37) !         R. El Khatib 22-May-2015 : Bypass errror message in case of underflows
(   38) !
(   39) !
(   40) !
(   41) TYPE(FA_COM)   :: FA
(   42) TYPE(FAGR1TAB) :: YDGR1TAB
(   43) INTEGER (KIND=JPLIKB) KREP, KRANG, KNIVAU, KLONGD
(   44) !
(   45) INTEGER (KIND=JPLIKB) KVALCO(*)
(   46) REAL (KIND=JPDBLR) PSEC4(*), PUNDF, ZUNDF
(   47) !
(   48) LOGICAL LDCOSP, LDUNDF, LLUNDF
(   49) !
(   50) CHARACTER CDPREF*(*), CDSUFF*(*)
(   51) !
(   52) # 52 "facodx.F90"
(   52) # 1 ".D[27]/fagribex.h"
(    1) INTERFACE
(    2) SUBROUTINE FAGRIBEX (KSEC0,KSEC1,KSEC2,PSEC2,KSEC3,PSEC3,KSEC4, &
(    3) &                    PSEC4,KLENP,KGRIB,KLENG,KWORD,HOPER,KRET)
(    4) USE LFI_PRECISION






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 14

(    5) IMPLICIT NONE
(    6) INTEGER (KIND=JPLIKB) :: KSEC0 (:)
(    7) INTEGER (KIND=JPLIKB) :: KSEC1 (:)
(    8) INTEGER (KIND=JPLIKB) :: KSEC2 (:)
(    9) INTEGER (KIND=JPLIKB) :: KSEC3 (:)
(   10) INTEGER (KIND=JPLIKB) :: KSEC4 (:)
(   11) INTEGER (KIND=JPLIKB) :: KGRIB (*)
(   12) INTEGER (KIND=JPLIKB) :: KLENP
(   13) INTEGER (KIND=JPLIKB) :: KLENG
(   14) INTEGER (KIND=JPLIKB) :: KWORD 
(   15) INTEGER (KIND=JPLIKB) :: KRET
(   16) REAL (KIND=JPDBLR)    :: PSEC2 (:) 
(   17) REAL (KIND=JPDBLR)    :: PSEC3 (:) 
(   18) REAL (KIND=JPDBLR)    :: PSEC4 (*)
(   19) CHARACTER(LEN=*)      :: HOPER
(   20) END SUBROUTINE
(   21) END INTERFACE
(   22) # 53 "facodx.F90"
(   53) # 53 "facodx.F90"
(   53) !
(   54) REAL (KIND=JPDBLR), ALLOCATABLE :: ZSEC4(:)
(   55) INTEGER (KIND=JPLIKB), ALLOCATABLE :: IVALCO(:)
(   56) REAL (KIND=JPDBLR) :: ZMIN, ZA
(   57) REAL (KIND=JPDBLR) :: ZSEC2(10+2*(FA%JPXNIV+1)), ZSEC3(2), ZPULAP
(   58) !
(   59) INTEGER (KIND=JPLIKB) ISEC0(2), ISEC1(FA%JPSEC1)
(   60) INTEGER (KIND=JPLIKB) ISEC2(FA%JPSEC2), ISEC3(2)
(   61) INTEGER (KIND=JPLIKB) ISEC4(FA%JPSEC4), ILONSEC2
(   62) INTEGER (KIND=JPLIKB) ILENG, IWORD, IRET, JM, IPULAP
(   63) INTEGER (KIND=JPLIKB) ILCHAM, JN, IDECAL, ICPACK
(   64) INTEGER (KIND=JPLIKB) ITRONC, ILOW, IHIGH, IDIMNC, INBITS
(   65) INTEGER (KIND=JPLIKB) IL, IADD, IRANGC, IILCHAM, INIMES
(   66) INTEGER (KIND=JPLIKB) INUMER,  IDX, JLAT, JLON, IDECOPT
(   67) INTEGER (KIND=JPLIKB) IFAORI, IFAMOD, INBIMO
(   68) !
(   69) LOGICAL LLMLAM
(   70) !
(   71) CHARACTER(LEN=1) CLOPER
(   72) !
(   73) INTRINSIC LEN_TRIM
(   74) !
(   75) CHARACTER(LEN=FA%JPXNOM) CLACTI 
(   76) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   77) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   78) LOGICAL                  LLFATA
(   79) LOGICAL                  LLFACDE
(   80) # 81 "facodx.F90"
(   81) !**
(   82) !     1.  -  CONTROLES ET INITIALISATIONS.
(   83) !-----------------------------------------------------------------------
(   84) !
(   85) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   86) IF (LHOOK) CALL DR_HOOK('FACODX_MT',0,ZHOOK_HANDLE)
(   87) # 88 "facodx.F90"
(   88) ISEC0 = 0
(   89) ISEC1 = 0
(   90) ISEC2 = 0
(   91) ISEC3 = 0






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 15

(   92) ISEC4 = 0
(   93) ZSEC2 = 0
(   94) ZSEC3 = 0
(   95) # 96 "facodx.F90"
(   96) LLUNDF = LDUNDF
(   97) # 98 "facodx.F90"
(   98) CLACTI=''
(   99) IF (KRANG.LE.0.OR.KRANG.GT.FA%JPNXFA) THEN
(  100)   KREP=-66
(  101)   GOTO 1001
(  102) ENDIF
(  103) ICPACK=FA%FICHIER(KRANG)%NSTROF
(  104) IRANGC=FA%FICHIER(KRANG)%NUCADR
(  105) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(  106) ITRONC=FA%CADRE(IRANGC)%MTRONC
(  107) !
(  108) IF (LLMLAM) THEN
(  109)   IF (LDCOSP) THEN
(  110)     ILONSEC2=21+FA%CADRE(IRANGC)%NOMPAR(2)
(  111)   ELSE
(  112)     ILONSEC2=22
(  113)   ENDIF
(  114) ELSE
(  115)   IF (LDCOSP) THEN
(  116)     ILONSEC2=22
(  117)   ELSE
(  118)     ILONSEC2=22+FA%CADRE(IRANGC)%NLATIT
(  119)   ENDIF
(  120) ENDIF
(  121) !
(  122) KVALCO(1)=FA%FICHIER(KRANG)%NFGRIB
(  123) IDECAL=3
(  124) IF (LDCOSP) THEN
(  125)   IF (LLMLAM) THEN
(  126)     ILCHAM=FA%CADRE(IRANGC)%NSFLAM
(  127)   ELSE
(  128)     ILCHAM=(1+ITRONC)*(2+ITRONC)
(  129)   ENDIF
(  130)   KVALCO(2)=1
(  131)   INBITS=FA%FICHIER(KRANG)%NBFCSP 
(  132)   IDECAL=IDECAL+2
(  133) ELSE
(  134)   ILCHAM=FA%CADRE(IRANGC)%NVAPDG
(  135)   KVALCO(2)=0
(  136)   INBITS=FA%FICHIER(KRANG)%NBFPDG
(  137) ENDIF
(  138) KVALCO(3)=INBITS
(  139) IILCHAM = ILCHAM
(  140) IDECOPT = 0
(  141) LLFACDE = FA%FICHIER(KRANG)%NCOGRIF(11) /= 0
(  142) !**
(  143) !     2.  -  PREPARATION DU TABLEAU DE DONNEES A ECRIRE SUR LE FICHIER.
(  144) !-----------------------------------------------------------------------
(  145) !
(  146) ALLOCATE (ZSEC4 (ILCHAM))
(  147) !
(  148) IF (LDCOSP .AND. LLMLAM) THEN
(  149) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 16

(  150) !       Champ ALADIN en coefficients spectraux... traitement particulier,
(  151) !     car non prevu dans GRIBEX (il y sera considere comme un champ lat-lon)
(  152) !     mais on a la possibilite de compacter une (pseudo-)puissance de
(  153) !     laplacien du champ a la place du champ, de maniere a augmenter
(  154) !     la precision du champ en "aplanissant" le spectre.
(  155) !
(  156) !     Determination de la puissance de Laplacien (en 1/1000 ieme)
(  157) !
(  158)   CALL FAPULA_MT64                                 &
(  159) &                 (FA,  KREP, KRANG, PSEC4, IPULAP )
(  160)   ZPULAP=REAL(IPULAP,JPDBLR)/1000._JPDBLR
(  161) !       ZPULAP=0.
(  162) !       IPULAP=0
(  163)   IF (FA%LFAMOP) THEN
(  164)     PRINT *,'FACODX: puissance de laplacien selectionee ',ZPULAP, &
(  165) &          ' pour une sous-tronc de ',ICPACK
(  166)   ENDIF
(  167)   IF (KREP.NE.0) GOTO 1001
(  168) !
(  169) ! Transfert des coeff spectraux devant etre compactes de PSEC4 a ZSEC4
(  170) ! avec prise en compte du coefficient (n**2+m**2)**zpulap. Les coefficients
(  171) ! concernes sont ceux inclus dans le quart de l'ellipse, hors axes (coeff
(  172) ! nuls), et hors du triangle non-compacte (sous-troncature).
(  173)   IILCHAM=0
(  174) !
(  175)   DO JM=1,FA%CADRE(IRANGC)%NOMPAR(2)
(  176)     ILOW=2+2*JM+1
(  177)     IADD=4* MAX(ICPACK+1-JM,1_JPLIKB )
(  178) !
(  179)     DO IDX=FA%CADRE(IRANGC)%NOMPAR(ILOW)+IADD,FA%CADRE(IRANGC)%NOMPAR(ILOW+1)
(  180)       IILCHAM=IILCHAM+1
(  181)       JN=(IDX-FA%CADRE(IRANGC)%NOMPAR(ILOW))/4
(  182)       ZSEC4(IILCHAM)=PSEC4(IDX) *              &
(  183) &         ((REAL(JN**2+JM**2, JPDBLR))**ZPULAP)
(  184)     ENDDO
(  185)   ENDDO
(  186) # 187 "facodx.F90"
(  187) ! Number of elements in sub-triangle+axes:IDIMNC
(  188)   IDIMNC=ILCHAM-IILCHAM
(  189) ! Recherche de l'amplitude et du min du champ
(  190)   ZMIN = MINVAL(ZSEC4(1:IILCHAM))
(  191)   ZA   = MAXVAL(ZSEC4(1:IILCHAM)) - ZMIN
(  192) ! Recherche du facteur decimal optimal pour utiliser
(  193) ! au mieux les INBITS dans le codage de ce champ
(  194)   IF (FA%LFAMOP) THEN
(  195)     WRITE (UNIT=FA%NULOUT,FMT=*)'FACODX: traitement du champ: ', &
(  196) &          CDPREF,KNIVAU,CDSUFF
(  197)   ENDIF
(  198)   KREP = 0
(  199)   IF (LLFACDE) CALL FACDEC_MT64 (FA, KREP, ZA, ZMIN, INBITS, IDECOPT)
(  200)   IF (KREP.NE.0) THEN
(  201)     KREP = 0
(  202)   ENDIF
(  203) ELSEIF(LDCOSP .AND. .NOT.LLMLAM) THEN
(  204) !
(  205) !          Transfert du tableau d'entree dans un tableau local
(  206) !     de maniere a eviter l'ecrasement du tableau d'entree par "GRIBEX".
(  207) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 17

(  208)   ZSEC4(1:IILCHAM) = PSEC4(1:IILCHAM)
(  209)   IDIMNC=(1+ICPACK)*(2+ICPACK)
(  210) ELSE
(  211) !
(  212) !    CHAMPS NON SPECTRAUX: transfert du tableau d'entree dans un
(  213) !    tableau local de maniere a eviter son ecrasement par "GRIBEX".
(  214) !
(  215) !
(  216)   IDIMNC=0
(  217) ! Tester si Nouvelle ou ancienne geometrie Aladin
(  218) IF (FA%CADRE(IRANGC)%SINLAT(1) .GE. 0) THEN
(  219)   IF (LLMLAM .AND. FA%CADRE(IRANGC)%SINLAT(10).LT.0) THEN
(  220) !  Parametre de projection negatif, donc pas de projection:
(  221) !  Il s'agit d'une grille lat-lon reguliere du type Full-Pos
(  222) !  (pour champ ARPEGE ou Aladin). Il faut donc renverser
(  223) !  le champ afin de ranger Nord-Sud les valeurs plutot que Sud-Nord
(  224) !  (on conserve le rangt W-E consecutif).
(  225) !  Le but est de satisfaire la BDAP qui attend un rangt NW-->SE.
(  226) !
(  227)     IF (FA%LFAMOP) THEN
(  228)       WRITE (UNIT=FA%NULOUT,FMT=*)                              &
(  229) &              ' FACODX: Grille LAT-LON pour BDAP -> ',         &
(  230) &              ' renversement des valeurs pour etre rangees NS'
(  231)     ENDIF
(  232)     DO JLAT=1,FA%CADRE(IRANGC)%NLATIT
(  233)     DO JLON=1,FA%CADRE(IRANGC)%NXLOPA
(  234)       JN=JLON+FA%CADRE(IRANGC)%NXLOPA*(JLAT-1)
(  235)       IDX=JLON+FA%CADRE(IRANGC)%NXLOPA*(FA%CADRE(IRANGC)%NLATIT-JLAT)
(  236)       ZSEC4(IDX) = PSEC4(JN)
(  237)     ENDDO
(  238)     ENDDO
(  239)   ELSE
(  240)     ZSEC4(1:IILCHAM) = PSEC4(1:IILCHAM)
(  241)   ENDIF
(  242) ELSE
(  243)   IF (LLMLAM .AND. FA%CADRE(IRANGC)%SINLAT(2).LT.0) THEN
(  244)     IF (FA%LFAMOP) THEN
(  245)       WRITE (UNIT=FA%NULOUT,FMT=*)                              &
(  246) &              ' FACODX: Grille LAT-LON pour BDAP -> ',         &
(  247) &              ' renversement des valeurs pour etre rangees NS'
(  248)     ENDIF
(  249)     DO JLAT=1,FA%CADRE(IRANGC)%NLATIT
(  250)     DO JLON=1,FA%CADRE(IRANGC)%NXLOPA
(  251)       JN=JLON+FA%CADRE(IRANGC)%NXLOPA*(JLAT-1)
(  252)       IDX=JLON+FA%CADRE(IRANGC)%NXLOPA*(FA%CADRE(IRANGC)%NLATIT-JLAT)
(  253)       ZSEC4(IDX) = PSEC4(JN)
(  254)     ENDDO
(  255)     ENDDO
(  256)   ELSE
(  257)     ZSEC4(1:IILCHAM) = PSEC4(1:IILCHAM)
(  258)   ENDIF
(  259) ENDIF
(  260) ! Recherche de l'amplitude et du min du champ
(  261)   ZMIN=ZSEC4(1)
(  262)   ZA=0._JPDBLR
(  263)   ZMIN = MINVAL(ZSEC4(1:IILCHAM))
(  264)   ZA   = MAXVAL(ZSEC4(1:IILCHAM)) - ZMIN
(  265) ! Recherche du facteur decimal optimal pour utiliser






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 18

(  266) ! au mieux les INBITS dans le codage de ce champ
(  267)   IF (FA%LFAMOP) THEN 
(  268)   WRITE (UNIT=FA%NULOUT,FMT=*)'FACODX: traitement du champ: ', &
(  269) &          CDPREF,KNIVAU,CDSUFF
(  270)   ENDIF
(  271)   KREP = 0
(  272)   IF (LLFACDE) THEN
(  273)     IF (ABS(ZA) <= EPSILON(ZA)) THEN
(  274) !     On anticipe le retour d'erreur de facdec dans le cas ou le champs est quasi-constant
(  275) !     (cad : son amplitude est inferieur a la precision de la machine).
(  276)       IDECOPT = 0
(  277)       KREP = 0
(  278)     ELSEIF (ZMIN /= 0_JPDBLR .AND. ABS(ZMIN) < EPSILON(ZMIN)) THEN
(  279) !     On anticipe le retour d'erreur de facdec dans le cas ou le champ contient un "underflow"
(  280)       IDECOPT = 0
(  281)       KREP = 0
(  282)     ELSE 
(  283)       CALL FACDEC_MT64 (FA, KREP, ZA, ZMIN, INBITS, IDECOPT)
(  284)       IF (KREP.NE.0) THEN
(  285)         WRITE (UNIT=FA%NULOUT,FMT=*)'FACODX: field incriminated by FACDEC was ', CDPREF,KNIVAU,CDSUFF
(  286)         IDECOPT = 0
(  287)         KREP = 0
(  288)       ENDIF
(  289)     ENDIF
(  290)   ENDIF
(  291) ENDIF
(  292) !*
(  293) !     3.  -  INITIALISATION DE L'ENROBAGE GRIB
(  294) !-----------------------------------------------------------------------
(  295) !
(  296) !     3.1 -  Sections 1, 2, 3 et 4 (sf la partie reelle pour 4)
(  297) !
(  298) CALL FAINIG_MT64                                                   &
(  299) &               (FA,  KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP, &
(  300) &                IILCHAM, ISEC1, ISEC2, ZSEC2, ISEC3, ZSEC3, ISEC4,&
(  301) &                YDGR1TAB)
(  302) # 303 "facodx.F90"
(  303) IF (KREP.NE.0) THEN
(  304)   GOTO 1001
(  305) ENDIF
(  306) ! Prise en compte du facteur decimal
(  307) IF (LLFACDE .AND. ISEC1(23) == 0) THEN
(  308)   ISEC1(23) = IDECOPT
(  309) ENDIF
(  310) !
(  311) !     3.2 -  Definition du type de codage
(  312) !
(  313) CLOPER='C'
(  314) IF (FA%FICHIER(KRANG)%NCOGRIF(1)==1) CLOPER='K'
(  315) !*
(  316) !     4.  -  CHANGEMENT D'UNITE DE CERTAINS CHAMPS.
(  317) !            Il s'agit de champs dont les valeurs sont comprises
(  318) !            entre 0 et 1 dans le modele mais dont l'unite
(  319) !            conventionnelle dans le GRIB est le %.
(  320) !---------------------------------------------------------------
(  321) !
(  322) ZUNDF = PUNDF
(  323) IF (YDGR1TAB%LMULTI) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 19

(  324)   ZSEC4 = ZSEC4 * YDGR1TAB%FMULTI
(  325)   ZUNDF = ZUNDF * YDGR1TAB%FMULTI
(  326) ENDIF
(  327) !
(  328) ! Traitement des valeurs indefinies; on verifie d'abord que le champ
(  329) ! contient de telles valeurs afin d'eviter de polluer le resultat
(  330) ! final avec un bitmap inutile
(  331) !
(  332) IF (LLUNDF) THEN
(  333)   LLUNDF = ANY (ZSEC4 == ZUNDF)
(  334) ENDIF
(  335) !
(  336) ! Ajustement des parametres d'encodage
(  337) !
(  338) IF (LLUNDF) THEN
(  339)   ISEC1(5)=192
(  340)   ZSEC3(2)=ZUNDF
(  341)   ISEC3(1)=0
(  342)   ISEC3(2)=INT (ZUNDF)
(  343) ENDIF
(  344) !*
(  345) !     5.  -  CODAGE GRIB PROPREMENT DIT
(  346) !-----------------------------------------------------------------------
(  347) !
(  348) IRET=-1
(  349) ! ILENG=longueur disponible en nb d'"entiers declares INTEGER" dans KVALCO.
(  350) ! On part de l'hypothese ou le dimensionnement de KVALCO se fait
(  351) ! dans la routine appelante a ILCHAM+2 (cas de l'absence de compactage).
(  352) ILENG=(KIND(KVALCO)/4)*(ILCHAM+2-IDECAL)
(  353) IWORD=0
(  354) !DP
(  355) !DP  TEST AVEC UNE PUISSANCE DE LAPLACIEN IMPOSEE
(  356) !DP
(  357) !DP   CALL GRSMKP(0)
(  358) !DP ISEC4(17) = 2000
(  359) !DP
(  360) IF (FA%LFAMOP) THEN
(  361)   WRITE (UNIT=FA%NULOUT,FMT=*)' FACODX: CLOPER = ',CLOPER
(  362)   WRITE (UNIT=FA%NULOUT,FMT=*)                                     &
(  363) &                    ' FACODX: IILCHAM, ILCHAM, IDECAL, ILENG = ', &
(  364) &                    IILCHAM, ILCHAM, IDECAL, ILENG
(  365)   WRITE (UNIT=FA%NULOUT,FMT=*)'       * ISEC1 = ',ISEC1
(  366)   WRITE (UNIT=FA%NULOUT,FMT=*)                                   &
(  367) &                    '       * ILONSEC2 ! ISEC2(1:ILONSEC2) = ', &
(  368) &                    ILONSEC2,' ! ', ISEC2(1:ILONSEC2)
(  369)   WRITE (UNIT=FA%NULOUT,FMT=*) '       * ZSEC2(1:2) = ',ZSEC2(1:2)
(  370)   IF (ISEC2(12).GT.0) WRITE (UNIT=FA%NULOUT,FMT=*)            &
(  371) &          '       * ISEC2(12) ! ZSEC2(11:10+ISEC2(12)) = ',  &
(  372) &                    ISEC2(12), ' ! ', ZSEC2(11:10+ISEC2(12))
(  373)   WRITE (UNIT=FA%NULOUT,FMT=*)'       * FA%JPSEC4 ! ISEC4 = ', &
(  374) &                              FA%JPSEC4,' ! ',ISEC4
(  375)   WRITE (UNIT=FA%NULOUT,FMT=*)'       * ZSEC4(1:20) = ', &
(  376) &                              ZSEC4(1:20)
(  377) ENDIF
(  378) # 379 "facodx.F90"
(  379) !     WARNING GRIBEX ENLEVE 
(  380) CALL GRSDBG (0)
(  381) CALL GRSVCK (0)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 20

(  382) # 383 "facodx.F90"
(  383) ! Defauts
(  384) # 385 "facodx.F90"
(  385) CALL GRSX2O (1)
(  386) CALL GRSN2O (1)
(  387) # 388 "facodx.F90"
(  388) ! Defaults FA
(  389) # 390 "facodx.F90"
(  390) IF (FA%IOPTGRSX2O /= NUNDEF) &
(  391) & CALL GRSX2O(INT (FA%IOPTGRSX2O, JPLIKM))
(  392) # 393 "facodx.F90"
(  393) IF (FA%IOPTGRSN2O /= NUNDEF) &
(  394) & CALL GRSN2O(INT (FA%IOPTGRSN2O, JPLIKB))
(  395) # 396 "facodx.F90"
(  396) ! Defauts pour cette unite
(  397) # 398 "facodx.F90"
(  398) IF (FA%FICHIER(KRANG)%IOPTGRSX2O /= NUNDEF) &
(  399) & CALL GRSX2O(INT (FA%FICHIER(KRANG)%IOPTGRSX2O, JPLIKM))
(  400) # 401 "facodx.F90"
(  401) IF (FA%FICHIER(KRANG)%IOPTGRSN2O /= NUNDEF) &
(  402) & CALL GRSN2O(INT (FA%FICHIER(KRANG)%IOPTGRSN2O, JPLIKB))
(  403) # 404 "facodx.F90"
(  404) !  1/ On force GRIBEX a calculer la puissance de laplacien
(  405) CALL GRSMKP(1)
(  406) !  2/ On retire l'arrondi du message GRIB a un multiple de 120 octets
(  407) CALL GRSRND(0)
(  408) # 409 "facodx.F90"
(  409) CALL FAGRIBEX(ISEC0,ISEC1,ISEC2,ZSEC2,ISEC3,ZSEC3,ISEC4,  &
(  410) &             ZSEC4,IILCHAM,KVALCO(IDECAL+1),ILENG,IWORD, &
(  411) &             CLOPER,IRET)
(  412) !
(  413) IF (IRET.GT.0) THEN
(  414) ! Erreur rapportee par GRIBEX
(  415)   KREP=-1000-IRET
(  416)   GOTO 1001
(  417) ELSEIF (IRET.LT.0) THEN
(  418) ! Warning rapporte par GRIBEX
(  419)   WRITE (UNIT=FA%NULOUT,FMT=*)
(  420)   WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  421) &               '!------------------------------------------'
(  422)   WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  423) &               '!           FACODX:   WARNING !!!         !'
(  424)   WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  425) &               '!------------------------------------------'
(  426)   WRITE (UNIT=FA%NULOUT,FMT=*) ' Code retour de GRIBEX = ', &
(  427) &        IRET,' pour le champ: ',CDPREF,KNIVAU,CDSUFF
(  428)   WRITE (UNIT=FA%NULOUT,FMT=*)
(  429) ENDIF
(  430) !
(  431) ! ISEC0(1) = nb d'octets dans le message GRIB
(  432) ! IWORD    = nb de mots de JBDBLE octets (64 bits) du message GRIB
(  433) IWORD=1+(ISEC0(1)-1)/JPLIKB
(  434) KLONGD=IDECAL+IWORD+IDIMNC
(  435) IF (FA%LFAMOP) THEN
(  436)   WRITE (UNIT=FA%NULOUT,FMT=*)                                    &
(  437) &         ' FACODX: longueur du GRIB en nb octets et en mots = ', &
(  438) &         ISEC0(1), IWORD
(  439)   WRITE (UNIT=FA%NULOUT,FMT=*)                             &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 21

(  440) &         ' FACODX: longueur de l''article FA en mots = ', &
(  441) &         KLONGD
(  442)   IF (ISEC4(4).EQ.64 .AND. ISEC4(3).EQ.128) THEN
(  443)     WRITE (UNIT=FA%NULOUT,FMT=*)                          &
(  444) &           ' FACODX: complex packing with P=',ISEC4(17), &
(  445) &           ' and sub trunc = ',ISEC4(18)
(  446)   ENDIF
(  447) ENDIF
(  448) !
(  449) !  CAS D'UN DEPASSEMENT DE LA TAILLE MAX DE L'ARTICLE FINAL
(  450) !  On ramene ce cas a celui d'un tableau trop petit dans GRIBEX.
(  451) !
(  452) IF (KLONGD.GT.ILCHAM+2) THEN
(  453)   IF (FA%LFAMOP) THEN
(  454)     WRITE (UNIT=FA%NULOUT,FMT=*)                           &
(  455) &            ' FACODX: article FA + long avec compactage', &
(  456) &            ' que sans => on le supprime'
(  457)   ENDIF
(  458)   IRET=710
(  459)   KREP=-1000-IRET
(  460)   GOTO 1001
(  461) ENDIF
(  462) !
(  463) !*
(  464) !     6.  -  TRANSFERT DES COEFFICIENTS SPECTRAUX NON COMPACTES.
(  465) !-----------------------------------------------------------------------
(  466) !        (et non traites par GRIBEX) en fin d'article.
(  467) !
(  468) IF (LDCOSP) THEN
(  469)   KVALCO(4)=ICPACK
(  470)   IF (LLMLAM) THEN
(  471)     KVALCO(5)=IPULAP
(  472) ! Copy nonpacked part of PSEC4 (sub-triangle+axes) into KVALCO
(  473)     IILCHAM=0
(  474)     DO JM=0,FA%CADRE(IRANGC)%NOMPAR(2)
(  475)       IL=2+2*JM+1
(  476)       ILOW=FA%CADRE(IRANGC)%NOMPAR(IL)
(  477) !
(  478)       IF (JM.EQ.0) THEN
(  479)         IHIGH=FA%CADRE(IRANGC)%NOMPAR(IL+1)
(  480)       ELSE
(  481)         IHIGH=ILOW+4*(ICPACK+1-JM)-1
(  482)         IF (IHIGH.LE.ILOW) IHIGH=ILOW+3
(  483)       ENDIF     
(  484) !
(  485)       DO IDX=ILOW,IHIGH
(  486)         IILCHAM=IILCHAM+1
(  487)         ZSEC4(IILCHAM)=PSEC4(IDX)
(  488)       ENDDO
(  489)     ENDDO
(  490)     IF (IILCHAM.NE.IDIMNC) THEN
(  491)       WRITE (UNIT=FA%NULOUT,FMT='(A35,I10,A11,I10)')        &
(  492) &            'FACODX: incoherence entre IILCHAM= ',IILCHAM, &
(  493) &            'et IDIMNC= ',IDIMNC
(  494)       KREP=-126
(  495)       GOTO 1001
(  496)     ENDIF
(  497)   ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 22

(  498)     KVALCO(5)=ISEC4(17)
(  499) ! Recuperation des coeff spectraux non compactes sachant que le
(  500) ! rangement est fait par colonnes de JM=cst juxtaposees
(  501)     ZSEC4(1:2*(ICPACK+1))=PSEC4(1:2*(ICPACK+1))
(  502)     IILCHAM=2*(ICPACK+1)-1
(  503)     IDX=2*(ITRONC+1)-1
(  504)     DO JM=1,ICPACK
(  505)     DO JN=JM,ITRONC
(  506)       IDX=IDX+2
(  507)       IF (JN.LE.ICPACK) THEN
(  508)         IILCHAM=IILCHAM+2
(  509)         ZSEC4(IILCHAM) = PSEC4(IDX)
(  510)         ZSEC4(IILCHAM+1) = PSEC4(IDX+1)
(  511)       ENDIF
(  512)     ENDDO
(  513)     ENDDO
(  514)     IF (IILCHAM+1.NE.IDIMNC) THEN
(  515)       WRITE (UNIT=FA%NULOUT,FMT='(A35,I10,A11,I10)')            &
(  516) &            'FACODX: incoherence entre IILCHAM+1= ',IILCHAM+1, &
(  517) &            'et IDIMNC= ',IDIMNC
(  518)       KREP=-126
(  519)       GOTO 1001
(  520)     ENDIF
(  521)   ENDIF
(  522) ! Les IDIMNC coeff spectraux non compactes doivent etre transferes
(  523) ! sur le tableau d'entiers KVALCO apres le IDECAL+IWORD ieme elt.
(  524) !
(  525) !       KVALCO(IDECAL+IWORD+1:KLONGD)=TRANSFER(ZSEC4,KVALCO,IDIMNC)
(  526)   ALLOCATE (IVALCO(IDIMNC))
(  527)   IVALCO(1:IDIMNC)=TRANSFER(ZSEC4,IVALCO,IDIMNC)
(  528)   KVALCO(IDECAL+IWORD+1:KLONGD)=IVALCO(1:IDIMNC)
(  529)   DEALLOCATE (IVALCO)
(  530) ENDIF
(  531) !**
(  532) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  533) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  534) !-----------------------------------------------------------------------
(  535) !
(  536) 1001 CONTINUE
(  537) IF (ALLOCATED(ZSEC4)) DEALLOCATE ( ZSEC4 )
(  538) !
(  539) ! Cas particulier de l'erreur GRIBEX num 710: OUTPUT ARRAY TOO SMALL
(  540) ! On s'en sert pour detecter un probleme de compactage lie a ce que
(  541) ! le champ compacte+les descripteurs prennent plus de place que le
(  542) ! champ non compacte...
(  543) ! On sort donc du compactage (FACODX) pour demander un codage sans
(  544) ! compactage (FACINE) avec rangement des valeurs selon le modele:
(  545) ! FA%NFGRIB=-1.
(  546) !
(  547) IF (IRET==710) THEN
(  548)   CLNSPR='FACODX'
(  549)   INIMES=2
(  550)   INUMER=JPNIIL
(  551) !
(  552)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I5,'', KRANG='',I4,  &
(  553) &         '', CDPREF='''''',A,'''''', KNIVAU='',I6,       &
(  554) &         '', CDSUFF='''''',A,'''''', LDCOSP= '',L1,      &
(  555) &         '', KLONGD='',I6)')                             &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 23

(  556) &     KREP, KRANG, CDPREF(1:LEN_TRIM(CDPREF)), KNIVAU,    &
(  557) &     CDSUFF(1:LEN_TRIM(CDSUFF)), LDCOSP, KLONGD
(  558)   CALL FAIPAR_MT64                                        &
(  559) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  560) &                  CLNSPR,CLACTI,.FALSE.)
(  561)   CLMESS=                                                          &
(  562) & ' CAUTION: this field is not packed or it will occupy more space'
(  563)   CALL FAIPAR_MT64                                        &
(  564) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  565) &                  CLNSPR,CLACTI,.FALSE.)
(  566)   IF (LHOOK) CALL DR_HOOK('FACODX_MT',1,ZHOOK_HANDLE)
(  567)   RETURN
(  568) ENDIF
(  569) !
(  570) !
(  571) !
(  572) LLFATA=LLMOER (KREP,KRANG)
(  573) !
(  574) IF (FA%LFAMOP.OR.LLFATA) THEN
(  575)   INIMES=2
(  576)   CLNSPR='FACODX'
(  577)   INUMER=JPNIIL
(  578) !
(  579)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I5,'', KRANG='',I4,  &
(  580) &         '', CDPREF='''''',A,'''''', KNIVAU='',I6,       &
(  581) &         '', CDSUFF='''''',A,'''''', LDCOSP= '',L1,      &
(  582) &         '', KLONGD='',I6)')                             &
(  583) &     KREP, KRANG, CDPREF(1:LEN_TRIM(CDPREF)), KNIVAU,    &
(  584) &     CDSUFF(1:LEN_TRIM(CDSUFF)), LDCOSP, KLONGD
(  585)   CALL FAIPAR_MT64                                        &
(  586) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  587) &                  CLNSPR,CLACTI,.FALSE.)
(  588) ENDIF
(  589) !
(  590) IF (LHOOK) CALL DR_HOOK('FACODX_MT',1,ZHOOK_HANDLE)
(  591) # 592 "facodx.F90"
(  592) CONTAINS
(  593) # 594 "facodx.F90"
(  594) # 1 ".D[27]/facom2.llmoer.h"
(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,
(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 595 "facodx.F90"
(  595) # 596 "facodx.F90"
(  596) END SUBROUTINE FACODX_MT64
(  597) # 598 "facodx.F90"
(  598) !INTF KREP            OUT                                                              
(  599) !INTF KRANG         IN                                                                 
(  600) !INTF CDPREF        IN                                                                 






NVFORTRAN (Version     23.1)          02/24/2023  13:54:16      page 24

(  601) !INTF KNIVAU        IN                                                                 
(  602) !INTF CDSUFF        IN                                                                 
(  603) !INTF PSEC4         IN    DIMS=*                                                       
(  604) !INTF LDCOSP        IN                                                                 
(  605) !INTF KVALCO          OUT DIMS=*                         KIND=JPLIKB                   
(  606) !INTF KLONGD          OUT                                                              
(  607) !INTF LDUNDF        IN                                                                 
(  608) !INTF PUNDF         IN                                                                 
(  609) !INTF YDGR1TAB      IN                                                                 
