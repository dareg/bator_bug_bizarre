


NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: facine.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) ! Sep-2012 P. Marguinaud Fix uninitialized variables
(    4) SUBROUTINE FACINE_MT64                                              &
(    5) &                     (FA,  KREP,   KRANG,  CDNOMA, PCHAMP, LDCOSP, &
(    6) &                      PVALCO, KLONGD, KB1PAR, LDUNDF, PUNDF)
(    7) USE FA_MOD, ONLY : FA_COM, JPNIIL, JPPRCM
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   14) !      PREPARATION (codage GRIB ou non) d'un CHAMP HORIZONTAL
(   15) !      destine a etre ecrit sur un fichier ARPEGE/ALADIN.
(   16) !       ( Codage Interne d'un (Nouveau ?) champ a Ecrire )
(   17) !**
(   18) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   19) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   20) !                CDNOMA (Entree) ==> Nom d'article (prefabrique);
(   21) !    ( Tableau ) PCHAMP (Entree) ==> Valeurs REELLES du champ a ecrire;
(   22) !                LDCOSP (Entree) ==> Vrai si le champ est represente
(   23) !                                    par des coefficients spectraux;
(   24) !    ( Tableau ) PVALCO (Sortie) ==> Donnees destinees a l'ecriture;
(   25) !                KLONGD (Sortie) ==> Nombre de mots a ecrire;
(   26) !    ( Tableau ) KB1PAR (Entree+ ==> Image des parametres de la section
(   27) !                        Sortie)     1 de GRIB.
(   28) !*
(   29) !       En mode multi-taches, il doit y avoir verrouillage du fichier
(   30) !     concerne avant l'appel au sous-programme.






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 3

(   31) !
(   32) !     Modifications
(   33) !     -------------
(   34) !  Juin 2001, D. Paradis, DT/DSI/DEV:
(   35) !
(   36) !    -retrait du compactage lorsqu'il conduit a un article de longueur
(   37) !     superieure a celle obtenue sans le compactage (permet aussi de
(   38) !     dimensionner PVALCO a ILCHAM+2 sans risquer un debordement)
(   39) !
(   40) !  Avril 2004, D. Paradis, DT/DSI/DEV:
(   41) !
(   42) !    -declaration de ZCHAMP et ZCHAUX en ALLOCATABLE (gain memoire)
(   43) !
(   44) ! January 2010 Trygve Aspelien & Ryad El Khatib : 
(   45) !    - workaround against memory leak on IBM
(   46) !
(   47) !
(   48) !
(   49) TYPE(FA_COM) :: FA
(   50) INTEGER (KIND=JPLIKB) KREP, KRANG, KLONGD
(   51) !
(   52) REAL (KIND=JPDBLR) PCHAMP (*)
(   53) REAL (KIND=JPDBLD) PVALCO (*)
(   54) INTEGER (KIND=JPLIKB) KB1PAR (FA%JPLB1P)
(   55) REAL (KIND=JPDBLR) PUNDF
(   56) !
(   57) LOGICAL LDCOSP, LDUNDF
(   58) !
(   59) CHARACTER CDNOMA*(*)
(   60) !
(   61) INTEGER (KIND=JPLIKB) ILCHAM, ISTRIA, IVALC1, IVALC2
(   62) INTEGER (KIND=JPLIKB) J, IDECAL, ICPACK, IPUILA
(   63) INTEGER (KIND=JPLIKB) ITRONC, IIND, ILOW, IHIGH, JTRON
(   64) INTEGER (KIND=JPLIKB) IDIMNC, ILDISP, INBITS, INBITSMAX
(   65) INTEGER (KIND=JPLIKB) IL, IADD, IRANGC, IARR, IILCHAM
(   66) INTEGER (KIND=JPLIKB) INMOCC, IERR, INIMES
(   67) INTEGER (KIND=JPLIKB) INUMER, ITRONC2, ILONGFA
(   68) INTEGER (KIND=JPLIKB) ILONGSEC, ILONGDATA
(   69) INTEGER (KIND=JPLIKB) ILONGD
(   70) !
(   71) INTEGER (KIND=JPLIKB) IB2PAR (FA%JPLB2P)
(   72) !
(   73) LOGICAL LLARPE, LLMLAM
(   74) !
(   75) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   76) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   77) LOGICAL                  LLFATA
(   78) REAL (KIND=JPDBLR) :: ZTEMP (2)
(   79) !
(   80) REAL (KIND=JPDBLR), ALLOCATABLE :: ZCHAMP (:), ZCHAUX (:)
(   81) REAL (KIND=JPDBLR) ZAVG
(   82) INTEGER (KIND=JPLIKB) IAVG
(   83) 
(   84) !**
(   85) !     1.  -  CONTROLES ET INITIALISATIONS.
(   86) !-----------------------------------------------------------------------
(   87) !
(   88) REAL(KIND=JPRB) :: ZHOOK_HANDLE






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 4

(   89) IF (LHOOK) CALL DR_HOOK('FACINE_MT',0,ZHOOK_HANDLE)
(   90) ICPACK=0
(   91) IF (KRANG.LE.0.OR.KRANG.GT.FA%JPNXFA) THEN
(   92)   KREP=-66
(   93)   GOTO 1001
(   94) ENDIF
(   95) !**
(   96) !     2.  -  FABRICATION DE L'ARTICLE A ECRIRE SUR LE FICHIER.
(   97) !-----------------------------------------------------------------------
(   98) !
(   99) IVALC1=FA%FICHIER(KRANG)%NFGRIB
(  100) LLARPE=IVALC1.EQ.2
(  101) IRANGC=FA%FICHIER(KRANG)%NUCADR
(  102) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(  103) IB2PAR=0
(  104) !
(  105) !  Initialisation du nombre de valeurs du champ (ILCHAM)
(  106) !                 du type de champ (IVALC2): spectral/pdg
(  107) !                 du type de representation de donnees (IB2PAR(1))
(  108) !                 du nombre de bits utilises pour le compactage
(  109) !                 de la longueur (en mots de 64 bits) de l'enrobage de l'article
(  110) !                          FA (ILONGFA) + les donnees non compactees (en spectral)
(  111) !                 de la longueur (en octets) des sections 0, 1 et 5 du GRIB
(  112) !                          devant apparaitre dans l'article FA (ILONGSEC)
(  113) !                 de la longueur (en bits) de la section 4 du GRIB (ILONGDATA),
(  114) !                          devant etre un multiple de 16 bits.
(  115) !
(  116) IF (JPDBLD == JPDBLR) THEN
(  117)   INBITSMAX = 64
(  118) ELSE
(  119)   INBITSMAX = 32
(  120) ENDIF
(  121) !
(  122) ! ILONGSEC= 4 (S0) + 24 (S1) + 4 (S5) pour le GRIB version 0
(  123) ILONGSEC=32
(  124) IF (LDCOSP) THEN
(  125) !
(  126)   IVALC2=1
(  127)   INBITS=MIN (FA%FICHIER(KRANG)%NBFCSP, INBITSMAX)
(  128) !
(  129)   IF (LLMLAM) THEN
(  130)     IB2PAR(1)=34
(  131)     ILCHAM=FA%CADRE(IRANGC)%NSFLAM
(  132)     IF (IVALC1.GT.0) THEN
(  133) ! calcul du nombre de coefficients non compactes ISTRIA
(  134)       ICPACK=FA%FICHIER(KRANG)%NSTROF
(  135)       ITRONC=FA%CADRE(IRANGC)%MTRONC
(  136)       ITRONC2=-FA%CADRE(IRANGC)%NTYPTR
(  137)       ISTRIA=4*(1+ITRONC+ITRONC2+(ICPACK*(ICPACK-1)/2))
(  138) !
(  139)       ILONGFA=3+2*IVALC1+ISTRIA
(  140) !  Les 88 bits correspondent aux 11 octets d'enrobage GRIB V0 de la section 4
(  141)       ILONGDATA=(ILCHAM-ISTRIA)*INBITS + 88
(  142)     ENDIF
(  143)   ELSE
(  144)     IF (IVALC1.EQ.-1) THEN
(  145)       ILCHAM=(1+FA%CADRE(IRANGC)%MTRONC)*(2+FA%CADRE(IRANGC)%MTRONC)
(  146)     ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 5

(  147)       ILCHAM=(1+FA%CADRE(IRANGC)%MTRONC)**2
(  148)     ENDIF
(  149)     IB2PAR(1)=80
(  150)     IF (IVALC1.GT.0) THEN
(  151)       ICPACK=FA%FICHIER(KRANG)%NSTROF
(  152) ! calcul du nombre de coefficients non compactes IDIMNC
(  153)       IDIMNC=(1+ICPACK)**2
(  154)       ILONGFA=3+2*IVALC1+IDIMNC
(  155) !  Les 144 bits correspondent aux 18 octets d'enrobage GRIB V0 de la section 4
(  156)       ILONGDATA=ILCHAM*INBITS + IDIMNC*(32-INBITS) + 144
(  157)     ENDIF
(  158)   ENDIF
(  159) !
(  160) ELSE
(  161) !
(  162)   ILCHAM=FA%CADRE(IRANGC)%NVAPDG
(  163)   IVALC2=0
(  164)   IB2PAR(1)=34
(  165)   INBITS=MIN (FA%FICHIER(KRANG)%NBFPDG, INBITSMAX)
(  166)   IF (IVALC1.GT.0) THEN
(  167)     ILONGFA=1+2*IVALC1
(  168) !  Les 88 bits correspondent aux 11 octets d'enrobage GRIB V0 de la section 4
(  169)     ILONGDATA=ILCHAM*INBITS + 88
(  170)   ENDIF
(  171) !
(  172) ENDIF
(  173) !
(  174) !  Retrait du compactage si celui-ci s'avere conduire
(  175) !  a un article plus long qu'en l'absence de compactage:
(  176) !
(  177) IF (IVALC1.GT.0) THEN
(  178) ! Arrondi de ILONGDATA au premier multiple de 16 superieur ou egal
(  179)   ILONGDATA=16*(1+(ILONGDATA-1)/16)
(  180) ! Calcul du nombre de mots (64 bits) de la partie GRIB
(  181)   ILONGD=1+(ILONGDATA+8*ILONGSEC-1)/64
(  182) ! On ajoute l'enrobage FA et les eventuelles donnees non compactees
(  183)   ILONGD=ILONGD+ILONGFA
(  184)   IF (ILONGD .GT. ((ILCHAM+JPPRCM-1)/JPPRCM+2)) THEN ! Should work both for simple & double precision
(  185) !          WRITE (FA%NULOUT,*)
(  186) !     S    '///// FACINE:  the packing of article ',CDNOMA,
(  187) !     S    ' is not done because it will generate'
(  188) !          WRITE (FA%NULOUT,*)
(  189) !     S    '         a size ( ',ILONGD,' words ) bigger than',
(  190) !     S    ' the one ( ',ILCHAM+2,' words ) obtained without packing.'
(  191)     IVALC1=0
(  192) !          WRITE (FA%NULOUT,*)
(  193)   ENDIF
(  194) ENDIF
(  195) !
(  196) IF (INBITS == INBITSMAX) THEN
(  197)   IVALC1 = 0
(  198) ENDIF
(  199) !
(  200) ISTRIA = 0
(  201) !
(  202) IF (IVALC1.EQ.-1.OR.IVALC1.EQ.0) THEN
(  203) !
(  204) !          Cas ou il n'y a aucun codage...






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 6

(  205) !     transfert du tableau d'entree a la suite des 2 valeurs
(  206) !     documentaires stockees ci-dessus dans PVALCO.
(  207) !
(  208)   IF (JPDBLR == JPDBLD) THEN
(  209)     DO J = 1, ILCHAM
(  210)       PVALCO (2+J) = REAL (PCHAMP (J), JPDBLD)
(  211)     ENDDO
(  212)     KLONGD=2+ILCHAM
(  213)   ELSE
(  214)     DO J = 1, ILCHAM, 2
(  215)       ZTEMP (1) = PCHAMP (J+0)
(  216)       IF (J+1 <= ILCHAM) THEN
(  217)         ZTEMP (2) = PCHAMP (J+1)
(  218)       ELSE
(  219)         ZTEMP (2) = 0._JPDBLR
(  220)       ENDIF
(  221)       PVALCO (2+1+(J-1)/2) = TRANSFER (ZTEMP (1:2), PVALCO (2+1+(J-1)/2))
(  222)     ENDDO
(  223)     KLONGD=2+(ILCHAM+1)/2
(  224)   ENDIF
(  225) !
(  226) ELSE
(  227) !
(  228) !          Cas avec codage GRIB (standard ou non).
(  229) !
(  230)   ALLOCATE (ZCHAMP (ILCHAM))
(  231) !
(  232)   IDECAL=1+2*IVALC1
(  233)   KB1PAR(1)=98
(  234)   KB1PAR(2)=1
(  235)   KB1PAR(3)=254
(  236)   KB1PAR(4)=0
(  237)   KB1PAR(5)=255
(  238)   KB1PAR(9)=MOD (FA%FICHIER(KRANG)%MADATE(1),100_JPLIKB )
(  239) !
(  240)   DO J=2,FA%JPLDAT
(  241)   KB1PAR(8+J)=FA%FICHIER(KRANG)%MADATE(J)
(  242)   ENDDO
(  243) !
(  244)   IB2PAR(6)=2
(  245)   IPUILA=FA%FICHIER(KRANG)%NPUFLA
(  246)   ITRONC=FA%CADRE(IRANGC)%MTRONC
(  247) !
(  248)   IF (LDCOSP) THEN
(  249) !
(  250) !           Champ en coefficients spectraux... traitement particulier,
(  251) !     lie a la possibilite de compacter une (pseudo-)puissance de
(  252) !     laplacien du champ a la place du champ, de maniere a augmenter
(  253) !     la precision du champ en "aplanissant" le spectre.
(  254) !
(  255)     CALL FACSIM_MT64 (FA, KREP,KRANG,PCHAMP,ZCHAMP,IPUILA,ICPACK)
(  256)     IF (FA%LFAMOP) THEN
(  257)       print *,'FACINE: puissance Dolby selectionnee ',IPUILA
(  258)     ENDIF
(  259)     IF (KREP.NE.0) GOTO 1001
(  260)     IF (LLMLAM) THEN
(  261) ! Copy the elements to be compacted from ZCHAMP to a work array
(  262) ! This is that part of the quarter-ellipse which is out of the triangle of no compacting.






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 7

(  263) ! In addition, the axes of ellipse are also excluded because of zero-coefficients
(  264)       ALLOCATE (ZCHAUX (ILCHAM))
(  265)       IIND=0
(  266) !
(  267)       DO JTRON=1,ITRONC
(  268)         ILOW=2+2*JTRON+1
(  269)         IADD=4* MAX(ICPACK+1-JTRON,1_JPLIKB )
(  270) !
(  271)         DO J=FA%CADRE(IRANGC)%NOZPAR(ILOW)+IADD, &
(  272) &                    FA%CADRE(IRANGC)%NOZPAR(ILOW+1)
(  273)           IIND=IIND+1
(  274)           ZCHAUX(IIND)=ZCHAMP(J)
(  275)         ENDDO
(  276)       ENDDO
(  277) ! Number of elements in sub-triangle+axes:ISTRIA
(  278)       ISTRIA=ILCHAM-IIND
(  279)       IDIMNC=0
(  280)     ELSE
(  281)       ISTRIA=IDIMNC
(  282)     ENDIF
(  283) !
(  284)     IDECAL=IDECAL+2
(  285)     ILDISP=ILCHAM+2-IDECAL-(IVALC1-1)*ISTRIA
(  286) !
(  287)     IF (.NOT.LLARPE) THEN
(  288) !
(  289) !            Recopie des coefficients spectraux "non compactes",
(  290) !     qui sont codes en fait sur 32 bits dans le cas standard de GRIB.
(  291) !
(  292)       DO J=1,IDIMNC
(  293)       ZCHAMP(J)=PCHAMP(J)
(  294)       ENDDO
(  295) !
(  296)     ENDIF
(  297) !
(  298)   ELSE
(  299) !
(  300) !          Transfert du tableau d'entree dans un tableau local
(  301) !     de maniere a eviter l'ecrasement du tableau d'entree par "CODEGA".
(  302) !
(  303)     DO J=1,ILCHAM
(  304)     ZCHAMP(J)=PCHAMP(J)
(  305)     ENDDO
(  306) !
(  307) !   Si des valeurs indefinies sont presentes, alors on les remplace 
(  308) !   par la moyenne des valeurs definies
(  309) !
(  310)     IF (LDUNDF) THEN
(  311)       ZAVG = 0._JPDBLR
(  312)       IAVG = 0
(  313)       DO J = 1, ILCHAM
(  314)         IF (PCHAMP (J) /= PUNDF) THEN
(  315)           ZAVG = ZAVG + PCHAMP (J)
(  316)           IAVG = IAVG + 1
(  317)         ENDIF
(  318)       ENDDO
(  319)       IF (IAVG > 0) THEN
(  320)         ZAVG = ZAVG / IAVG






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 8

(  321)       ELSE
(  322)         ZAVG = 0._JPDBLR
(  323)       ENDIF
(  324)       DO J = 1, ILCHAM
(  325)         IF (PCHAMP (J) == PUNDF) THEN
(  326)           ZCHAMP (J) = ZAVG
(  327)         ENDIF
(  328)       ENDDO
(  329)     ENDIF
(  330) 
(  331) !
(  332)     IDIMNC=0
(  333)     ILDISP=ILCHAM+2-IDECAL
(  334)   ENDIF
(  335) !*
(  336) !     3.1 -  CODAGE GRIB PROPREMENT DIT.
(  337) !-----------------------------------------------------------------------
(  338) !
(  339)   IARR=0
(  340) !
(  341)   IF (LDCOSP.AND.LLMLAM) THEN
(  342)     IILCHAM=ILCHAM-ISTRIA
(  343)     CALL FACODEGA(ZCHAUX,IILCHAM,INBITS,FA%NBIMAC,KB1PAR,        &
(  344) &                 IB2PAR,FA%CADRE(IRANGC)%SFOHYB(1,0),2_JPLIKB , &
(  345) &                 PVALCO(IDECAL+1),ILDISP,INMOCC,IARR,           &
(  346) &                 0_JPLIKB ,IPUILA,IERR,PVALCO(IDECAL-1),        &
(  347) &                 PVALCO(IDECAL),LLARPE)
(  348)   ELSE
(  349)     CALL FACODEGA(ZCHAMP,ILCHAM,INBITS,FA%NBIMAC,KB1PAR,IB2PAR, &
(  350) &                 FA%CADRE(IRANGC)%SFOHYB(1,0),2_JPLIKB ,       &
(  351) &                 PVALCO(IDECAL+1),ILDISP,INMOCC,IARR,ICPACK,   &
(  352) &                 IPUILA,IERR,PVALCO(IDECAL-1),PVALCO(IDECAL),  &
(  353) &                 LLARPE)
(  354)   ENDIF
(  355) !
(  356)   IF (IERR.NE.0) THEN
(  357)     KREP=-200+IERR
(  358)     GOTO 1001
(  359)   ELSEIF (LDCOSP) THEN
(  360)     PVALCO(4)=TRANSFER (ICPACK, PVALCO(4))
(  361)     PVALCO(5)=TRANSFER (IPUILA, PVALCO(5))
(  362) !
(  363)     IF (LLARPE) THEN
(  364) !*
(  365) !     3.2 -  TRANSFERT DES COEFFICIENTS SPECTRAUX NON COMPACTES.
(  366) !-----------------------------------------------------------------------
(  367) !        (et non traites par CODEGA) en fin d'article.
(  368) !
(  369)       IF (LLMLAM) THEN
(  370) ! Copy nonpacked part of kchamp (sub-triangle+axes) into zchaux
(  371)         IIND=0
(  372) !
(  373)         DO JTRON=0,ITRONC
(  374)           IL=2+2*JTRON+1
(  375)           ILOW=FA%CADRE(IRANGC)%NOZPAR(IL)
(  376) !
(  377)           IF (JTRON.EQ.0) THEN
(  378)             IHIGH=FA%CADRE(IRANGC)%NOZPAR(IL+1)






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 9

(  379)           ELSE
(  380)             IHIGH=ILOW+4*(ICPACK+1-JTRON)-1
(  381)             IF (IHIGH.LE.ILOW) IHIGH=ILOW+3
(  382)           ENDIF
(  383) !
(  384)           DO J=ILOW,IHIGH
(  385)             IIND=IIND+1
(  386)             ZCHAUX(IIND)=PCHAMP(J)
(  387)           ENDDO
(  388)         ENDDO
(  389) !
(  390)         DO J=1,ISTRIA
(  391)           PVALCO(IDECAL+INMOCC+J)=ZCHAUX(J)
(  392)         ENDDO
(  393) !
(  394)       ELSE
(  395) !
(  396)         DO J=1,IDIMNC
(  397)           PVALCO(IDECAL+INMOCC+J)=REAL (PCHAMP(J), JPDBLD)
(  398)         ENDDO
(  399) !
(  400)       ENDIF
(  401) !
(  402)     ENDIF
(  403) !
(  404)   ENDIF
(  405) !
(  406)   PVALCO(3)=TRANSFER (INBITS, PVALCO(3))
(  407) !
(  408)   IF (LLMLAM) THEN
(  409)      KLONGD=IDECAL+INMOCC+ISTRIA
(  410)   ELSE
(  411)      KLONGD=IDECAL+INMOCC+IDIMNC
(  412)   ENDIF
(  413) !
(  414) ENDIF
(  415) !
(  416) IF (IVALC1 == 0 .AND. (JPDBLR /= JPDBLD)) IVALC1 = -2
(  417) PVALCO(1)=TRANSFER (IVALC1, PVALCO(1))
(  418) PVALCO(2)=TRANSFER (IVALC2, PVALCO(2))
(  419) !**
(  420) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  421) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  422) !-----------------------------------------------------------------------
(  423) !
(  424) 1001 CONTINUE
(  425) LLFATA=LLMOER (KREP,KRANG)
(  426) !
(  427) IF (FA%LFAMOP.OR.LLFATA) THEN
(  428)   INIMES=2
(  429)   CLNSPR='FACINE'
(  430)   INUMER=JPNIIL
(  431) !
(  432)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I4,  &
(  433) &         '', CDNOMA='''''',A,'''''', LDCOSP= '',L1,      &
(  434) &         '', KLONGD='',I8)')                             &
(  435) &     KREP, KRANG, CDNOMA, LDCOSP, KLONGD
(  436)   CALL FAIPAR_MT64                                        &






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 10

(  437) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  438) &                  CLNSPR, CDNOMA,.FALSE.)
(  439) ENDIF
(  440) !
(  441) IF (LHOOK) CALL DR_HOOK('FACINE_MT',1,ZHOOK_HANDLE)
(  442) 
(  443) CONTAINS
(  444) 
(  445) #include "facom2.llmoer.h"
(  446) 
(  447) END SUBROUTINE FACINE_MT64
(  448) !INTF KREP            OUT                                                              
(  449) !INTF KRANG         IN                                                                 
(  450) !INTF CDNOMA        IN                                                                 
(  451) !INTF PCHAMP        IN    DIMS=*                                                       
(  452) !INTF LDCOSP        IN                                                                 
(  453) !INTF PVALCO          OUT DIMS=*                                                       
(  454) !INTF KLONGD          OUT                                                              
(  455) !INTF KB1PAR        INOUT DIMS=FA%JPLB1P                                               
(  456) !INTF LDUNDF        IN                                                                 
(  457) !INTF PUNDF         IN                                                                 
(  458) 










































NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 11

(    1) # 1 "facine.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) ! Sep-2012 P. Marguinaud Fix uninitialized variables
(    4) SUBROUTINE FACINE_MT64                                              &
(    5) &                     (FA,  KREP,   KRANG,  CDNOMA, PCHAMP, LDCOSP, &
(    6) &                      PVALCO, KLONGD, KB1PAR, LDUNDF, PUNDF)
(    7) USE FA_MOD, ONLY : FA_COM, JPNIIL, JPPRCM
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   14) !      PREPARATION (codage GRIB ou non) d'un CHAMP HORIZONTAL
(   15) !      destine a etre ecrit sur un fichier ARPEGE/ALADIN.
(   16) !       ( Codage Interne d'un (Nouveau ?) champ a Ecrire )
(   17) !**
(   18) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   19) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   20) !                CDNOMA (Entree) ==> Nom d'article (prefabrique);
(   21) !    ( Tableau ) PCHAMP (Entree) ==> Valeurs REELLES du champ a ecrire;
(   22) !                LDCOSP (Entree) ==> Vrai si le champ est represente
(   23) !                                    par des coefficients spectraux;
(   24) !    ( Tableau ) PVALCO (Sortie) ==> Donnees destinees a l'ecriture;
(   25) !                KLONGD (Sortie) ==> Nombre de mots a ecrire;
(   26) !    ( Tableau ) KB1PAR (Entree+ ==> Image des parametres de la section
(   27) !                        Sortie)     1 de GRIB.
(   28) !*
(   29) !       En mode multi-taches, il doit y avoir verrouillage du fichier
(   30) !     concerne avant l'appel au sous-programme.
(   31) !
(   32) !     Modifications
(   33) !     -------------
(   34) !  Juin 2001, D. Paradis, DT/DSI/DEV:
(   35) !
(   36) !    -retrait du compactage lorsqu'il conduit a un article de longueur
(   37) !     superieure a celle obtenue sans le compactage (permet aussi de
(   38) !     dimensionner PVALCO a ILCHAM+2 sans risquer un debordement)
(   39) !
(   40) !  Avril 2004, D. Paradis, DT/DSI/DEV:
(   41) !
(   42) !    -declaration de ZCHAMP et ZCHAUX en ALLOCATABLE (gain memoire)
(   43) !
(   44) ! January 2010 Trygve Aspelien & Ryad El Khatib : 
(   45) !    - workaround against memory leak on IBM
(   46) !
(   47) !
(   48) !
(   49) TYPE(FA_COM) :: FA
(   50) INTEGER (KIND=JPLIKB) KREP, KRANG, KLONGD
(   51) !
(   52) REAL (KIND=JPDBLR) PCHAMP (*)
(   53) REAL (KIND=JPDBLD) PVALCO (*)
(   54) INTEGER (KIND=JPLIKB) KB1PAR (FA%JPLB1P)
(   55) REAL (KIND=JPDBLR) PUNDF
(   56) !
(   57) LOGICAL LDCOSP, LDUNDF






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 12

(   58) !
(   59) CHARACTER CDNOMA*(*)
(   60) !
(   61) INTEGER (KIND=JPLIKB) ILCHAM, ISTRIA, IVALC1, IVALC2
(   62) INTEGER (KIND=JPLIKB) J, IDECAL, ICPACK, IPUILA
(   63) INTEGER (KIND=JPLIKB) ITRONC, IIND, ILOW, IHIGH, JTRON
(   64) INTEGER (KIND=JPLIKB) IDIMNC, ILDISP, INBITS, INBITSMAX
(   65) INTEGER (KIND=JPLIKB) IL, IADD, IRANGC, IARR, IILCHAM
(   66) INTEGER (KIND=JPLIKB) INMOCC, IERR, INIMES
(   67) INTEGER (KIND=JPLIKB) INUMER, ITRONC2, ILONGFA
(   68) INTEGER (KIND=JPLIKB) ILONGSEC, ILONGDATA
(   69) INTEGER (KIND=JPLIKB) ILONGD
(   70) !
(   71) INTEGER (KIND=JPLIKB) IB2PAR (FA%JPLB2P)
(   72) !
(   73) LOGICAL LLARPE, LLMLAM
(   74) !
(   75) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   76) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   77) LOGICAL                  LLFATA
(   78) REAL (KIND=JPDBLR) :: ZTEMP (2)
(   79) !
(   80) REAL (KIND=JPDBLR), ALLOCATABLE :: ZCHAMP (:), ZCHAUX (:)
(   81) REAL (KIND=JPDBLR) ZAVG
(   82) INTEGER (KIND=JPLIKB) IAVG
(   83) # 84 "facine.F90"
(   84) !**
(   85) !     1.  -  CONTROLES ET INITIALISATIONS.
(   86) !-----------------------------------------------------------------------
(   87) !
(   88) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   89) IF (LHOOK) CALL DR_HOOK('FACINE_MT',0,ZHOOK_HANDLE)
(   90) ICPACK=0
(   91) IF (KRANG.LE.0.OR.KRANG.GT.FA%JPNXFA) THEN
(   92)   KREP=-66
(   93)   GOTO 1001
(   94) ENDIF
(   95) !**
(   96) !     2.  -  FABRICATION DE L'ARTICLE A ECRIRE SUR LE FICHIER.
(   97) !-----------------------------------------------------------------------
(   98) !
(   99) IVALC1=FA%FICHIER(KRANG)%NFGRIB
(  100) LLARPE=IVALC1.EQ.2
(  101) IRANGC=FA%FICHIER(KRANG)%NUCADR
(  102) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(  103) IB2PAR=0
(  104) !
(  105) !  Initialisation du nombre de valeurs du champ (ILCHAM)
(  106) !                 du type de champ (IVALC2): spectral/pdg
(  107) !                 du type de representation de donnees (IB2PAR(1))
(  108) !                 du nombre de bits utilises pour le compactage
(  109) !                 de la longueur (en mots de 64 bits) de l'enrobage de l'article
(  110) !                          FA (ILONGFA) + les donnees non compactees (en spectral)
(  111) !                 de la longueur (en octets) des sections 0, 1 et 5 du GRIB
(  112) !                          devant apparaitre dans l'article FA (ILONGSEC)
(  113) !                 de la longueur (en bits) de la section 4 du GRIB (ILONGDATA),
(  114) !                          devant etre un multiple de 16 bits.
(  115) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 13

(  116) IF (JPDBLD == JPDBLR) THEN
(  117)   INBITSMAX = 64
(  118) ELSE
(  119)   INBITSMAX = 32
(  120) ENDIF
(  121) !
(  122) ! ILONGSEC= 4 (S0) + 24 (S1) + 4 (S5) pour le GRIB version 0
(  123) ILONGSEC=32
(  124) IF (LDCOSP) THEN
(  125) !
(  126)   IVALC2=1
(  127)   INBITS=MIN (FA%FICHIER(KRANG)%NBFCSP, INBITSMAX)
(  128) !
(  129)   IF (LLMLAM) THEN
(  130)     IB2PAR(1)=34
(  131)     ILCHAM=FA%CADRE(IRANGC)%NSFLAM
(  132)     IF (IVALC1.GT.0) THEN
(  133) ! calcul du nombre de coefficients non compactes ISTRIA
(  134)       ICPACK=FA%FICHIER(KRANG)%NSTROF
(  135)       ITRONC=FA%CADRE(IRANGC)%MTRONC
(  136)       ITRONC2=-FA%CADRE(IRANGC)%NTYPTR
(  137)       ISTRIA=4*(1+ITRONC+ITRONC2+(ICPACK*(ICPACK-1)/2))
(  138) !
(  139)       ILONGFA=3+2*IVALC1+ISTRIA
(  140) !  Les 88 bits correspondent aux 11 octets d'enrobage GRIB V0 de la section 4
(  141)       ILONGDATA=(ILCHAM-ISTRIA)*INBITS + 88
(  142)     ENDIF
(  143)   ELSE
(  144)     IF (IVALC1.EQ.-1) THEN
(  145)       ILCHAM=(1+FA%CADRE(IRANGC)%MTRONC)*(2+FA%CADRE(IRANGC)%MTRONC)
(  146)     ELSE
(  147)       ILCHAM=(1+FA%CADRE(IRANGC)%MTRONC)**2
(  148)     ENDIF
(  149)     IB2PAR(1)=80
(  150)     IF (IVALC1.GT.0) THEN
(  151)       ICPACK=FA%FICHIER(KRANG)%NSTROF
(  152) ! calcul du nombre de coefficients non compactes IDIMNC
(  153)       IDIMNC=(1+ICPACK)**2
(  154)       ILONGFA=3+2*IVALC1+IDIMNC
(  155) !  Les 144 bits correspondent aux 18 octets d'enrobage GRIB V0 de la section 4
(  156)       ILONGDATA=ILCHAM*INBITS + IDIMNC*(32-INBITS) + 144
(  157)     ENDIF
(  158)   ENDIF
(  159) !
(  160) ELSE
(  161) !
(  162)   ILCHAM=FA%CADRE(IRANGC)%NVAPDG
(  163)   IVALC2=0
(  164)   IB2PAR(1)=34
(  165)   INBITS=MIN (FA%FICHIER(KRANG)%NBFPDG, INBITSMAX)
(  166)   IF (IVALC1.GT.0) THEN
(  167)     ILONGFA=1+2*IVALC1
(  168) !  Les 88 bits correspondent aux 11 octets d'enrobage GRIB V0 de la section 4
(  169)     ILONGDATA=ILCHAM*INBITS + 88
(  170)   ENDIF
(  171) !
(  172) ENDIF
(  173) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 14

(  174) !  Retrait du compactage si celui-ci s'avere conduire
(  175) !  a un article plus long qu'en l'absence de compactage:
(  176) !
(  177) IF (IVALC1.GT.0) THEN
(  178) ! Arrondi de ILONGDATA au premier multiple de 16 superieur ou egal
(  179)   ILONGDATA=16*(1+(ILONGDATA-1)/16)
(  180) ! Calcul du nombre de mots (64 bits) de la partie GRIB
(  181)   ILONGD=1+(ILONGDATA+8*ILONGSEC-1)/64
(  182) ! On ajoute l'enrobage FA et les eventuelles donnees non compactees
(  183)   ILONGD=ILONGD+ILONGFA
(  184)   IF (ILONGD .GT. ((ILCHAM+JPPRCM-1)/JPPRCM+2)) THEN ! Should work both for simple & double precision
(  185) !          WRITE (FA%NULOUT,*)
(  186) !     S    '///// FACINE:  the packing of article ',CDNOMA,
(  187) !     S    ' is not done because it will generate'
(  188) !          WRITE (FA%NULOUT,*)
(  189) !     S    '         a size ( ',ILONGD,' words ) bigger than',
(  190) !     S    ' the one ( ',ILCHAM+2,' words ) obtained without packing.'
(  191)     IVALC1=0
(  192) !          WRITE (FA%NULOUT,*)
(  193)   ENDIF
(  194) ENDIF
(  195) !
(  196) IF (INBITS == INBITSMAX) THEN
(  197)   IVALC1 = 0
(  198) ENDIF
(  199) !
(  200) ISTRIA = 0
(  201) !
(  202) IF (IVALC1.EQ.-1.OR.IVALC1.EQ.0) THEN
(  203) !
(  204) !          Cas ou il n'y a aucun codage...
(  205) !     transfert du tableau d'entree a la suite des 2 valeurs
(  206) !     documentaires stockees ci-dessus dans PVALCO.
(  207) !
(  208)   IF (JPDBLR == JPDBLD) THEN
(  209)     DO J = 1, ILCHAM
(  210)       PVALCO (2+J) = REAL (PCHAMP (J), JPDBLD)
(  211)     ENDDO
(  212)     KLONGD=2+ILCHAM
(  213)   ELSE
(  214)     DO J = 1, ILCHAM, 2
(  215)       ZTEMP (1) = PCHAMP (J+0)
(  216)       IF (J+1 <= ILCHAM) THEN
(  217)         ZTEMP (2) = PCHAMP (J+1)
(  218)       ELSE
(  219)         ZTEMP (2) = 0._JPDBLR
(  220)       ENDIF
(  221)       PVALCO (2+1+(J-1)/2) = TRANSFER (ZTEMP (1:2), PVALCO (2+1+(J-1)/2))
(  222)     ENDDO
(  223)     KLONGD=2+(ILCHAM+1)/2
(  224)   ENDIF
(  225) !
(  226) ELSE
(  227) !
(  228) !          Cas avec codage GRIB (standard ou non).
(  229) !
(  230)   ALLOCATE (ZCHAMP (ILCHAM))
(  231) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 15

(  232)   IDECAL=1+2*IVALC1
(  233)   KB1PAR(1)=98
(  234)   KB1PAR(2)=1
(  235)   KB1PAR(3)=254
(  236)   KB1PAR(4)=0
(  237)   KB1PAR(5)=255
(  238)   KB1PAR(9)=MOD (FA%FICHIER(KRANG)%MADATE(1),100_JPLIKB )
(  239) !
(  240)   DO J=2,FA%JPLDAT
(  241)   KB1PAR(8+J)=FA%FICHIER(KRANG)%MADATE(J)
(  242)   ENDDO
(  243) !
(  244)   IB2PAR(6)=2
(  245)   IPUILA=FA%FICHIER(KRANG)%NPUFLA
(  246)   ITRONC=FA%CADRE(IRANGC)%MTRONC
(  247) !
(  248)   IF (LDCOSP) THEN
(  249) !
(  250) !           Champ en coefficients spectraux... traitement particulier,
(  251) !     lie a la possibilite de compacter une (pseudo-)puissance de
(  252) !     laplacien du champ a la place du champ, de maniere a augmenter
(  253) !     la precision du champ en "aplanissant" le spectre.
(  254) !
(  255)     CALL FACSIM_MT64 (FA, KREP,KRANG,PCHAMP,ZCHAMP,IPUILA,ICPACK)
(  256)     IF (FA%LFAMOP) THEN
(  257)       print *,'FACINE: puissance Dolby selectionnee ',IPUILA
(  258)     ENDIF
(  259)     IF (KREP.NE.0) GOTO 1001
(  260)     IF (LLMLAM) THEN
(  261) ! Copy the elements to be compacted from ZCHAMP to a work array
(  262) ! This is that part of the quarter-ellipse which is out of the triangle of no compacting.
(  263) ! In addition, the axes of ellipse are also excluded because of zero-coefficients
(  264)       ALLOCATE (ZCHAUX (ILCHAM))
(  265)       IIND=0
(  266) !
(  267)       DO JTRON=1,ITRONC
(  268)         ILOW=2+2*JTRON+1
(  269)         IADD=4* MAX(ICPACK+1-JTRON,1_JPLIKB )
(  270) !
(  271)         DO J=FA%CADRE(IRANGC)%NOZPAR(ILOW)+IADD, &
(  272) &                    FA%CADRE(IRANGC)%NOZPAR(ILOW+1)
(  273)           IIND=IIND+1
(  274)           ZCHAUX(IIND)=ZCHAMP(J)
(  275)         ENDDO
(  276)       ENDDO
(  277) ! Number of elements in sub-triangle+axes:ISTRIA
(  278)       ISTRIA=ILCHAM-IIND
(  279)       IDIMNC=0
(  280)     ELSE
(  281)       ISTRIA=IDIMNC
(  282)     ENDIF
(  283) !
(  284)     IDECAL=IDECAL+2
(  285)     ILDISP=ILCHAM+2-IDECAL-(IVALC1-1)*ISTRIA
(  286) !
(  287)     IF (.NOT.LLARPE) THEN
(  288) !
(  289) !            Recopie des coefficients spectraux "non compactes",






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 16

(  290) !     qui sont codes en fait sur 32 bits dans le cas standard de GRIB.
(  291) !
(  292)       DO J=1,IDIMNC
(  293)       ZCHAMP(J)=PCHAMP(J)
(  294)       ENDDO
(  295) !
(  296)     ENDIF
(  297) !
(  298)   ELSE
(  299) !
(  300) !          Transfert du tableau d'entree dans un tableau local
(  301) !     de maniere a eviter l'ecrasement du tableau d'entree par "CODEGA".
(  302) !
(  303)     DO J=1,ILCHAM
(  304)     ZCHAMP(J)=PCHAMP(J)
(  305)     ENDDO
(  306) !
(  307) !   Si des valeurs indefinies sont presentes, alors on les remplace 
(  308) !   par la moyenne des valeurs definies
(  309) !
(  310)     IF (LDUNDF) THEN
(  311)       ZAVG = 0._JPDBLR
(  312)       IAVG = 0
(  313)       DO J = 1, ILCHAM
(  314)         IF (PCHAMP (J) /= PUNDF) THEN
(  315)           ZAVG = ZAVG + PCHAMP (J)
(  316)           IAVG = IAVG + 1
(  317)         ENDIF
(  318)       ENDDO
(  319)       IF (IAVG > 0) THEN
(  320)         ZAVG = ZAVG / IAVG
(  321)       ELSE
(  322)         ZAVG = 0._JPDBLR
(  323)       ENDIF
(  324)       DO J = 1, ILCHAM
(  325)         IF (PCHAMP (J) == PUNDF) THEN
(  326)           ZCHAMP (J) = ZAVG
(  327)         ENDIF
(  328)       ENDDO
(  329)     ENDIF
(  330) # 331 "facine.F90"
(  331) !
(  332)     IDIMNC=0
(  333)     ILDISP=ILCHAM+2-IDECAL
(  334)   ENDIF
(  335) !*
(  336) !     3.1 -  CODAGE GRIB PROPREMENT DIT.
(  337) !-----------------------------------------------------------------------
(  338) !
(  339)   IARR=0
(  340) !
(  341)   IF (LDCOSP.AND.LLMLAM) THEN
(  342)     IILCHAM=ILCHAM-ISTRIA
(  343)     CALL FACODEGA(ZCHAUX,IILCHAM,INBITS,FA%NBIMAC,KB1PAR,        &
(  344) &                 IB2PAR,FA%CADRE(IRANGC)%SFOHYB(1,0),2_JPLIKB , &
(  345) &                 PVALCO(IDECAL+1),ILDISP,INMOCC,IARR,           &
(  346) &                 0_JPLIKB ,IPUILA,IERR,PVALCO(IDECAL-1),        &
(  347) &                 PVALCO(IDECAL),LLARPE)






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 17

(  348)   ELSE
(  349)     CALL FACODEGA(ZCHAMP,ILCHAM,INBITS,FA%NBIMAC,KB1PAR,IB2PAR, &
(  350) &                 FA%CADRE(IRANGC)%SFOHYB(1,0),2_JPLIKB ,       &
(  351) &                 PVALCO(IDECAL+1),ILDISP,INMOCC,IARR,ICPACK,   &
(  352) &                 IPUILA,IERR,PVALCO(IDECAL-1),PVALCO(IDECAL),  &
(  353) &                 LLARPE)
(  354)   ENDIF
(  355) !
(  356)   IF (IERR.NE.0) THEN
(  357)     KREP=-200+IERR
(  358)     GOTO 1001
(  359)   ELSEIF (LDCOSP) THEN
(  360)     PVALCO(4)=TRANSFER (ICPACK, PVALCO(4))
(  361)     PVALCO(5)=TRANSFER (IPUILA, PVALCO(5))
(  362) !
(  363)     IF (LLARPE) THEN
(  364) !*
(  365) !     3.2 -  TRANSFERT DES COEFFICIENTS SPECTRAUX NON COMPACTES.
(  366) !-----------------------------------------------------------------------
(  367) !        (et non traites par CODEGA) en fin d'article.
(  368) !
(  369)       IF (LLMLAM) THEN
(  370) ! Copy nonpacked part of kchamp (sub-triangle+axes) into zchaux
(  371)         IIND=0
(  372) !
(  373)         DO JTRON=0,ITRONC
(  374)           IL=2+2*JTRON+1
(  375)           ILOW=FA%CADRE(IRANGC)%NOZPAR(IL)
(  376) !
(  377)           IF (JTRON.EQ.0) THEN
(  378)             IHIGH=FA%CADRE(IRANGC)%NOZPAR(IL+1)
(  379)           ELSE
(  380)             IHIGH=ILOW+4*(ICPACK+1-JTRON)-1
(  381)             IF (IHIGH.LE.ILOW) IHIGH=ILOW+3
(  382)           ENDIF
(  383) !
(  384)           DO J=ILOW,IHIGH
(  385)             IIND=IIND+1
(  386)             ZCHAUX(IIND)=PCHAMP(J)
(  387)           ENDDO
(  388)         ENDDO
(  389) !
(  390)         DO J=1,ISTRIA
(  391)           PVALCO(IDECAL+INMOCC+J)=ZCHAUX(J)
(  392)         ENDDO
(  393) !
(  394)       ELSE
(  395) !
(  396)         DO J=1,IDIMNC
(  397)           PVALCO(IDECAL+INMOCC+J)=REAL (PCHAMP(J), JPDBLD)
(  398)         ENDDO
(  399) !
(  400)       ENDIF
(  401) !
(  402)     ENDIF
(  403) !
(  404)   ENDIF
(  405) !






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 18

(  406)   PVALCO(3)=TRANSFER (INBITS, PVALCO(3))
(  407) !
(  408)   IF (LLMLAM) THEN
(  409)      KLONGD=IDECAL+INMOCC+ISTRIA
(  410)   ELSE
(  411)      KLONGD=IDECAL+INMOCC+IDIMNC
(  412)   ENDIF
(  413) !
(  414) ENDIF
(  415) !
(  416) IF (IVALC1 == 0 .AND. (JPDBLR /= JPDBLD)) IVALC1 = -2
(  417) PVALCO(1)=TRANSFER (IVALC1, PVALCO(1))
(  418) PVALCO(2)=TRANSFER (IVALC2, PVALCO(2))
(  419) !**
(  420) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  421) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  422) !-----------------------------------------------------------------------
(  423) !
(  424) 1001 CONTINUE
(  425) LLFATA=LLMOER (KREP,KRANG)
(  426) !
(  427) IF (FA%LFAMOP.OR.LLFATA) THEN
(  428)   INIMES=2
(  429)   CLNSPR='FACINE'
(  430)   INUMER=JPNIIL
(  431) !
(  432)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I4,  &
(  433) &         '', CDNOMA='''''',A,'''''', LDCOSP= '',L1,      &
(  434) &         '', KLONGD='',I8)')                             &
(  435) &     KREP, KRANG, CDNOMA, LDCOSP, KLONGD
(  436)   CALL FAIPAR_MT64                                        &
(  437) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  438) &                  CLNSPR, CDNOMA,.FALSE.)
(  439) ENDIF
(  440) !
(  441) IF (LHOOK) CALL DR_HOOK('FACINE_MT',1,ZHOOK_HANDLE)
(  442) # 443 "facine.F90"
(  443) CONTAINS
(  444) # 445 "facine.F90"
(  445) # 1 ".D[27]/facom2.llmoer.h"
(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,
(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 446 "facine.F90"
(  446) # 447 "facine.F90"
(  447) END SUBROUTINE FACINE_MT64
(  448) !INTF KREP            OUT                                                              
(  449) !INTF KRANG         IN                                                                 
(  450) !INTF CDNOMA        IN                                                                 






NVFORTRAN (Version     23.1)          02/24/2023  13:55:00      page 19

(  451) !INTF PCHAMP        IN    DIMS=*                                                       
(  452) !INTF LDCOSP        IN                                                                 
(  453) !INTF PVALCO          OUT DIMS=*                                                       
(  454) !INTF KLONGD          OUT                                                              
(  455) !INTF KB1PAR        INOUT DIMS=FA%JPLB1P                                               
(  456) !INTF LDUNDF        IN                                                                 
(  457) !INTF PUNDF         IN                                                                 
