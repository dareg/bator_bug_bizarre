


NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: fadeci.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) ! Sep-2012 P. Marguinaud Fix unitialized variables
(    4) SUBROUTINE FADECI_MT64                                              &
(    5) &                     (FA,  KREP,   KRANG,  CDNOMA, KVALCO, KLONGA, &
(    6) &                      PCHAMP, LDCOSP)
(    7) USE FA_MOD, ONLY : FA_COM, JPNIIL
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   14) !      Controle de coherence et decodage d'un CHAMP HORIZONTAL
(   15) !      venant d'etre lu sur un fichier ARPEGE/ALADIN.
(   16) !       ( DECodage Interne d'un champ lu )
(   17) !**
(   18) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   19) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   20) !                CDNOMA (Entree) ==> Nom d'article (prefabrique);
(   21) !    ( Tableau ) KVALCO (Entree) ==> Donnees issues de la lecture;
(   22) !                KLONGA (Entree) ==> Nombre de mots lus;
(   23) !    ( Tableau ) PCHAMP (Sortie) ==> Valeurs REELLES du champ lu;
(   24) !                LDCOSP (Entree) ==> Vrai si le champ est represente
(   25) !                                    par des coefficients spectraux;
(   26) !*
(   27) !       En mode multi-taches, il doit y avoir verrouillage du fichier
(   28) !     concerne avant l'appel au sous-programme.
(   29) !
(   30) !     Modifications






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 3

(   31) !     -------------
(   32) !
(   33) !  Avril 2004, D. Paradis, DSI/DEV:
(   34) !
(   35) !    -Declaration ICHAUX en ALLOCATABLE, PCHAMP en profil implicite (gain mem.)
(   36) !
(   37) !
(   38) !
(   39) TYPE(FA_COM) :: FA
(   40) INTEGER (KIND=JPLIKB) KREP, KRANG, KLONGA
(   41) !
(   42) INTEGER (KIND=JPLIKB) KVALCO(*)
(   43) REAL (KIND=JPDBLR)    PCHAMP(*)
(   44) !
(   45) LOGICAL LDCOSP
(   46) !
(   47) CHARACTER CDNOMA*(*)
(   48) !
(   49) REAL (KIND=JPDBLR) ZFOHYB (2)
(   50) !
(   51) INTEGER (KIND=JPLIKB) ILCHAM, ISTRIA, J, IDECAL, ICPACK
(   52) INTEGER (KIND=JPLIKB) IPUILA, IPOFIN
(   53) INTEGER (KIND=JPLIKB) ITRONC, IIND, ILOW, IHIGH, JTRON
(   54) INTEGER (KIND=JPLIKB) IDIMNC, INBITS
(   55) INTEGER (KIND=JPLIKB) IL, IADD, IRANGC, IILCHAM, INDECO
(   56) INTEGER (KIND=JPLIKB) IERR, INIMES
(   57) INTEGER (KIND=JPLIKB) IVALC3, IVALC4, IVALC5, IJLENV
(   58) INTEGER (KIND=JPLIKB) IJLENF, IDIZAI, IUNITE
(   59) INTEGER (KIND=JPLIKB) INUMER
(   60) !
(   61) REAL (KIND=JPDBLD)    ZCHAMP
(   62) REAL (KIND=JPDBLM)    ZTEMP (2)
(   63) !
(   64) REAL (KIND=JPDBLR), ALLOCATABLE :: ZCHAUX(:)
(   65) INTEGER (KIND=JPLIKB) IB1PAR (FA%JPLB1P), IB2PAR (FA%JPLB2P)
(   66) !
(   67) LOGICAL LLARPE, LLMLAM, LLCOSP
(   68) !
(   69) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   70) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   71) LOGICAL                  LLFATA
(   72) 
(   73) !**
(   74) !     1.  -  CONTROLES ET INITIALISATIONS.
(   75) !-----------------------------------------------------------------------
(   76) !
(   77) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   78) IF (LHOOK) CALL DR_HOOK('FADECI_MT',0,ZHOOK_HANDLE)
(   79) KREP=0
(   80) IF (KRANG.LE.0.OR.KRANG.GT.FA%JPNXFA) THEN
(   81)   KREP=-66
(   82)   GOTO 1001
(   83) ENDIF
(   84) !
(   85) ISTRIA=0
(   86) INBITS=0
(   87) ICPACK=0
(   88) IPUILA=0






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 4

(   89) IVALC3=0
(   90) IVALC4=0
(   91) IVALC5=0
(   92) !**
(   93) !     2.  -  CONTROLE DES DONNEES DE L'ARTICLE
(   94) !-----------------------------------------------------------------------
(   95) !
(   96) IF (KVALCO(1).LT.-2.OR.KVALCO(1).GT.2.OR.                        &
(   97) &   KVALCO(2).LT. 0.OR.KVALCO(2).GT.1.OR.                        &
(   98) &  (KVALCO(1).GT. 0.AND.KVALCO(2).EQ.1.AND.KVALCO(4).LT.0)) THEN
(   99)   KREP=-91
(  100)   GOTO 1001
(  101) ENDIF
(  102) !
(  103) LLARPE=KVALCO(1).EQ.2
(  104) LLCOSP=KVALCO(2).EQ.1
(  105) !
(  106) IF ((LLCOSP.AND..NOT.LDCOSP).OR.(.NOT.LLCOSP.AND.LDCOSP)) THEN
(  107)   KREP=-92
(  108)   GOTO 1001
(  109) ENDIF
(  110) !
(  111) IRANGC=FA%FICHIER(KRANG)%NUCADR
(  112) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(  113) !
(  114) IF (LDCOSP) THEN
(  115)   IF (LLMLAM) THEN
(  116)      ILCHAM=FA%CADRE(IRANGC)%NSFLAM
(  117)   ELSE    
(  118)     IF (KVALCO(1).EQ.-1) THEN
(  119)       ILCHAM=(1+FA%CADRE(IRANGC)%MTRONC)*(2+FA%CADRE(IRANGC)%MTRONC)
(  120)     ELSE
(  121)       ILCHAM=(1+FA%CADRE(IRANGC)%MTRONC)**2
(  122)     ENDIF
(  123)   ENDIF   
(  124) ELSE
(  125)   ILCHAM=FA%CADRE(IRANGC)%NVAPDG
(  126) ENDIF
(  127) !
(  128) !**
(  129) !     3.  -  DECODAGE DES DONNEES DE L'ARTICLE
(  130) !-----------------------------------------------------------------------
(  131) !
(  132) IF (KVALCO(1) == -2) THEN
(  133) !
(  134) !          Cas ou les donnees sont codees en IEEE 32 bits; controle longueur d'article
(  135) !
(  136)   IF (KLONGA.LT.((ILCHAM+1)/2+2)) THEN
(  137)     KREP=-93
(  138)     GOTO 1001
(  139)   ELSEIF (KLONGA.GT.((ILCHAM+1)/2+2)) THEN
(  140)     KREP=-94
(  141)     IF (LLMOER(KREP,KRANG)) GOTO 1001
(  142)   ENDIF
(  143) !
(  144) !           Transfert du tableau d'entree a la suite des 2 valeurs
(  145) !     documentaires stockees en debut d'article.
(  146) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 5

(  147)   DO J = 1, ILCHAM, 2
(  148)     ZTEMP (1:2)  = TRANSFER (KVALCO (2+1+(J-1)/2), ZTEMP (1:2))
(  149)     PCHAMP (J+0) = ZTEMP (1)
(  150)     IF (J+1 <= ILCHAM) THEN
(  151)       PCHAMP (J+1) = REAL (ZTEMP (2), JPDBLR)
(  152)     ENDIF
(  153)   ENDDO
(  154) !
(  155) ELSEIF (KVALCO(1) == -1 .OR. KVALCO(1) == 0) THEN
(  156) !
(  157) !          Cas ou les donnes sont codees en IEEE 64 bits; controle longueur d'article
(  158) !
(  159)   IF (KLONGA.LT.(ILCHAM+2)) THEN
(  160)     KREP=-93
(  161)     GOTO 1001
(  162)   ELSEIF (KLONGA.GT.(ILCHAM+2)) THEN
(  163)     KREP=-94
(  164)     IF (LLMOER(KREP,KRANG)) GOTO 1001
(  165)   ENDIF
(  166) !
(  167) !           Transfert du tableau d'entree a la suite des 2 valeurs
(  168) !     documentaires stockees en debut d'article.
(  169) !
(  170)   DO J = 1, ILCHAM
(  171)     ZCHAMP    = TRANSFER (KVALCO(2+J), ZCHAMP)
(  172)     PCHAMP(J) = REAL (ZCHAMP, JPDBLR)
(  173)   ENDDO
(  174) !
(  175) ELSE
(  176) !*
(  177) !     3.1 -  DECODAGE GRIB PROPREMENT DIT (STANDARD OU NON).
(  178) !-----------------------------------------------------------------------
(  179) !
(  180)   IDECAL=1+2*KVALCO(1)
(  181)   IF (LDCOSP) IDECAL=IDECAL+2
(  182)   IVALC3=KVALCO(3)
(  183)   IVALC4=KVALCO(4)
(  184)   IVALC5=KVALCO(5)
(  185)   IF (LDCOSP.AND.LLMLAM) THEN
(  186) !
(  187)     ALLOCATE (ZCHAUX (ILCHAM))
(  188) !
(  189)     ITRONC=FA%CADRE(IRANGC)%MTRONC
(  190)     ISTRIA=FA%CADRE(IRANGC)%NOZPAR(4)-FA%CADRE(IRANGC)%NOZPAR(3)+1
(  191)     DO JTRON=1,ITRONC 
(  192)       IADD=4*(IVALC4+1-JTRON)
(  193)       IF (IADD.LE.0) IADD=4
(  194)       ISTRIA=ISTRIA+IADD
(  195)     ENDDO
(  196)     IILCHAM=ILCHAM-ISTRIA
(  197)     CALL FADECOGA(ZCHAUX,IILCHAM,INBITS,FA%NBIMAC,IB1PAR,IB2PAR, &
(  198) &                 ZFOHYB(1),2_JPLIKB ,KVALCO(IDECAL+1),           &
(  199) &                 KLONGA-IDECAL,INDECO,IJLENV,IJLENF,ICPACK,      &
(  200) &                 IPUILA,IERR,KVALCO(IDECAL-1),KVALCO(IDECAL),    &
(  201) &                 LLARPE)
(  202) 
(  203) !
(  204) !  Controle de l'adequation entre nb de valeurs attendues/lues






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 6

(  205) !
(  206)     IF (IJLENF.LT.IILCHAM) THEN
(  207)       KREP=-93
(  208)       IF (FA%LFAMOP) THEN
(  209)         WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  210) &                 'FADECI: erreur !!! Nbre de valeurs decodees = ', &
(  211) &                 IJLENF,' et nbre de valeurs attendues = ',IILCHAM
(  212)       ENDIF
(  213)       GOTO 1001
(  214)     ELSEIF (IJLENF.GT.IILCHAM) THEN
(  215)       KREP=-94
(  216)       IF (FA%LFAMOP) THEN
(  217)         WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  218) &                 'FADECI: erreur !!! Nbre de valeurs decodees = ', &
(  219) &                 IJLENF,' et nbre de valeurs attendues = ',IILCHAM
(  220)       ENDIF
(  221)       IF (LLMOER(KREP,KRANG)) GOTO 1001
(  222)     ENDIF
(  223)     IIND=0
(  224)     DO JTRON=1,ITRONC      
(  225)       ILOW=2+2*JTRON+1
(  226)       IADD=4*(IVALC4+1-JTRON)
(  227)       IF (IADD.LE.0) IADD=4  
(  228)       DO J=FA%CADRE(IRANGC)%NOZPAR(ILOW)+IADD,FA%CADRE(IRANGC)%NOZPAR(ILOW+1)
(  229)         IIND=IIND+1        
(  230)         PCHAMP(J)=ZCHAUX (IIND)
(  231)       ENDDO
(  232)     ENDDO
(  233) !
(  234)     IF (ALLOCATED( ZCHAUX )) DEALLOCATE ( ZCHAUX )
(  235) !
(  236)   ELSE                         
(  237)     CALL FADECOGA (PCHAMP,ILCHAM,INBITS,FA%NBIMAC,IB1PAR,IB2PAR, &
(  238) &                  ZFOHYB(1),2_JPLIKB ,KVALCO(IDECAL+1),          &
(  239) &                  KLONGA-IDECAL,INDECO,IJLENV,IJLENF,ICPACK,     &
(  240) &                  IPUILA,IERR,KVALCO(IDECAL-1),KVALCO(IDECAL),   &
(  241) &                  LLARPE)
(  242) !
(  243) !  Controle de l'adequation entre nb de valeurs attendues/lues
(  244) !
(  245)     IF (IJLENF.LT.ILCHAM) THEN
(  246)       KREP=-93
(  247)       IF (FA%LFAMOP) THEN
(  248)         WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  249) &                 'FADECI: erreur !!! Nbre de valeurs decodees = ', &
(  250) &                 IJLENF,' et nbre de valeurs attendues = ',ILCHAM
(  251)       ENDIF
(  252)       GOTO 1001
(  253)     ELSEIF (IJLENF.GT.ILCHAM) THEN
(  254)       KREP=-94
(  255)       IF (FA%LFAMOP) THEN
(  256)         WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  257) &                 'FADECI: erreur !!! Nbre de valeurs decodees = ', &
(  258) &                 IJLENF,' et nbre de valeurs attendues = ',ILCHAM
(  259)       ENDIF
(  260)       IF (LLMOER(KREP,KRANG)) GOTO 1001
(  261)     ENDIF
(  262)   ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 7

(  263) !
(  264)   IF (IERR.EQ.-2) THEN
(  265)     KREP=-93
(  266)     GOTO 1001
(  267)   ELSEIF (IERR.NE.0) THEN
(  268)     KREP=-200+IERR
(  269)     GOTO 1001
(  270)   ELSEIF (IVALC3.NE.INBITS.OR.(LDCOSP.AND.        &
(  271) &          ((ICPACK.NE.IVALC4.AND..NOT.LLMLAM)     &
(  272) &   .OR.(.NOT.LLMLAM.AND.IPUILA.NE.IVALC5)))) THEN                 
(  273)     KREP=-95
(  274)     GOTO 1001
(  275)   ELSEIF (IB1PAR(4).GT.64) THEN
(  276) !
(  277) !     Controle effectue s'il y a un bloc 2 en retour du decodage.
(  278) !
(  279)     IDIZAI=IB2PAR(1)/10
(  280)     IUNITE=IB2PAR(1)-IDIZAI*10
(  281) !
(  282)     IF ((LDCOSP.AND..NOT.LLMLAM.AND.                        &
(  283) &     (IUNITE.NE.0.OR.IDIZAI.LT.5.OR.IDIZAI.GT.8))           &
(  284) &    .OR.(.NOT.LDCOSP.AND.                                   &
(  285) &         (IUNITE.NE.4.OR.IDIZAI.LT.0.OR.IDIZAI.GT.3))) THEN
(  286)       KREP=-95
(  287)       GOTO 1001
(  288)     ENDIF
(  289) !
(  290)   ENDIF
(  291)   IF (LDCOSP.AND.LLMLAM) THEN
(  292)     ICPACK=IVALC4
(  293)     IPUILA=IVALC5
(  294)   ENDIF          
(  295) !
(  296)   IF (LDCOSP) THEN
(  297) !
(  298)     IF (LLARPE) THEN
(  299)       IF (LLMLAM) THEN
(  300)         IPOFIN=IDECAL+INDECO+ISTRIA
(  301)       ELSE   
(  302)         IDIMNC=(1+ICPACK)**2
(  303)         IPOFIN=IDECAL+INDECO+IDIMNC
(  304)       ENDIF            
(  305) !
(  306)       IF (KLONGA.LT.IPOFIN) THEN
(  307)         KREP=-93
(  308)         GOTO 1001
(  309)       ELSEIF (KLONGA.GT.IPOFIN) THEN
(  310)         KREP=-94
(  311)         IF (LLMOER(KREP,KRANG)) GOTO 1001
(  312)       ENDIF
(  313) !*
(  314) !     3.2 -  TRANSFERT DES COEFFICIENTS SPECTRAUX NON COMPACTES.
(  315) !-----------------------------------------------------------------------
(  316) !        (et non fournis par DECOGA) stockes en fin d'article.
(  317) !
(  318)       IF (LLMLAM) THEN
(  319)         IIND=0
(  320)         DO JTRON=0,ITRONC






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 8

(  321)           IL=2+2*JTRON+1
(  322)           ILOW=FA%CADRE(IRANGC)%NOZPAR(IL)
(  323)           IF (JTRON.EQ.0) THEN
(  324)              IHIGH=FA%CADRE(IRANGC)%NOZPAR(IL+1)
(  325)           ELSE
(  326)              IHIGH=ILOW+4*(ICPACK+1-JTRON)-1
(  327)              IF (IHIGH.LE.ILOW) IHIGH=ILOW+3
(  328)           ENDIF     
(  329)           DO J=ILOW,IHIGH
(  330)             IIND=IIND+1
(  331)             ZCHAMP=TRANSFER (KVALCO(IDECAL+INDECO+IIND), ZCHAMP)
(  332)             PCHAMP(J)=ZCHAMP
(  333)           ENDDO
(  334)         ENDDO
(  335)       ELSE
(  336)         DO J=1,IDIMNC
(  337)           ZCHAMP=TRANSFER (KVALCO(IDECAL+INDECO+J), ZCHAMP)
(  338)           PCHAMP(J)=ZCHAMP
(  339)         ENDDO
(  340)       ENDIF
(  341) !
(  342)     ENDIF
(  343) !*
(  344) !     3.3 -  SI NECESSAIRE, RECONSTITUTION DU SPECTRE.
(  345) !-----------------------------------------------------------------------
(  346) !
(  347)     IF (IPUILA.NE.0) THEN
(  348)       CALL FARCIS_MT64                                    &
(  349) &                     (FA, KREP,KRANG,PCHAMP,ICPACK,IPUILA)
(  350)       IF (KREP.NE.0) GOTO 1001
(  351)     ENDIF
(  352) !
(  353)   ENDIF
(  354) !
(  355) ENDIF
(  356) !**
(  357) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  358) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  359) !-----------------------------------------------------------------------
(  360) !
(  361) 1001 CONTINUE
(  362) LLFATA=LLMOER (KREP,KRANG)
(  363) !
(  364) IF (FA%LFAMOP.OR.LLFATA) THEN
(  365)   INIMES=2
(  366)   CLNSPR='FADECI'
(  367)   INUMER=JPNIIL
(  368) !
(  369)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I4, &
(  370) &         '', CDNOMA='''''',A,'''''', LDCOSP= '',L1,      &
(  371) &         '', KLONGA='',I8)')                             &
(  372) &     KREP, KRANG, CDNOMA, LDCOSP, KLONGA
(  373)   CALL FAIPAR_MT64                                      &
(  374) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  375) &                  CLNSPR,CDNOMA,.FALSE.)
(  376) ENDIF
(  377) !
(  378) IF (LHOOK) CALL DR_HOOK('FADECI_MT',1,ZHOOK_HANDLE)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 9

(  379) 
(  380) CONTAINS
(  381) 
(  382) #include "facom2.llmoer.h"
(  383) 
(  384) END SUBROUTINE FADECI_MT64
(  385) 

























































NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 10

(    1) # 1 "fadeci.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) ! Sep-2012 P. Marguinaud Fix unitialized variables
(    4) SUBROUTINE FADECI_MT64                                              &
(    5) &                     (FA,  KREP,   KRANG,  CDNOMA, KVALCO, KLONGA, &
(    6) &                      PCHAMP, LDCOSP)
(    7) USE FA_MOD, ONLY : FA_COM, JPNIIL
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   14) !      Controle de coherence et decodage d'un CHAMP HORIZONTAL
(   15) !      venant d'etre lu sur un fichier ARPEGE/ALADIN.
(   16) !       ( DECodage Interne d'un champ lu )
(   17) !**
(   18) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   19) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   20) !                CDNOMA (Entree) ==> Nom d'article (prefabrique);
(   21) !    ( Tableau ) KVALCO (Entree) ==> Donnees issues de la lecture;
(   22) !                KLONGA (Entree) ==> Nombre de mots lus;
(   23) !    ( Tableau ) PCHAMP (Sortie) ==> Valeurs REELLES du champ lu;
(   24) !                LDCOSP (Entree) ==> Vrai si le champ est represente
(   25) !                                    par des coefficients spectraux;
(   26) !*
(   27) !       En mode multi-taches, il doit y avoir verrouillage du fichier
(   28) !     concerne avant l'appel au sous-programme.
(   29) !
(   30) !     Modifications
(   31) !     -------------
(   32) !
(   33) !  Avril 2004, D. Paradis, DSI/DEV:
(   34) !
(   35) !    -Declaration ICHAUX en ALLOCATABLE, PCHAMP en profil implicite (gain mem.)
(   36) !
(   37) !
(   38) !
(   39) TYPE(FA_COM) :: FA
(   40) INTEGER (KIND=JPLIKB) KREP, KRANG, KLONGA
(   41) !
(   42) INTEGER (KIND=JPLIKB) KVALCO(*)
(   43) REAL (KIND=JPDBLR)    PCHAMP(*)
(   44) !
(   45) LOGICAL LDCOSP
(   46) !
(   47) CHARACTER CDNOMA*(*)
(   48) !
(   49) REAL (KIND=JPDBLR) ZFOHYB (2)
(   50) !
(   51) INTEGER (KIND=JPLIKB) ILCHAM, ISTRIA, J, IDECAL, ICPACK
(   52) INTEGER (KIND=JPLIKB) IPUILA, IPOFIN
(   53) INTEGER (KIND=JPLIKB) ITRONC, IIND, ILOW, IHIGH, JTRON
(   54) INTEGER (KIND=JPLIKB) IDIMNC, INBITS
(   55) INTEGER (KIND=JPLIKB) IL, IADD, IRANGC, IILCHAM, INDECO
(   56) INTEGER (KIND=JPLIKB) IERR, INIMES
(   57) INTEGER (KIND=JPLIKB) IVALC3, IVALC4, IVALC5, IJLENV






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 11

(   58) INTEGER (KIND=JPLIKB) IJLENF, IDIZAI, IUNITE
(   59) INTEGER (KIND=JPLIKB) INUMER
(   60) !
(   61) REAL (KIND=JPDBLD)    ZCHAMP
(   62) REAL (KIND=JPDBLM)    ZTEMP (2)
(   63) !
(   64) REAL (KIND=JPDBLR), ALLOCATABLE :: ZCHAUX(:)
(   65) INTEGER (KIND=JPLIKB) IB1PAR (FA%JPLB1P), IB2PAR (FA%JPLB2P)
(   66) !
(   67) LOGICAL LLARPE, LLMLAM, LLCOSP
(   68) !
(   69) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   70) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   71) LOGICAL                  LLFATA
(   72) # 73 "fadeci.F90"
(   73) !**
(   74) !     1.  -  CONTROLES ET INITIALISATIONS.
(   75) !-----------------------------------------------------------------------
(   76) !
(   77) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   78) IF (LHOOK) CALL DR_HOOK('FADECI_MT',0,ZHOOK_HANDLE)
(   79) KREP=0
(   80) IF (KRANG.LE.0.OR.KRANG.GT.FA%JPNXFA) THEN
(   81)   KREP=-66
(   82)   GOTO 1001
(   83) ENDIF
(   84) !
(   85) ISTRIA=0
(   86) INBITS=0
(   87) ICPACK=0
(   88) IPUILA=0
(   89) IVALC3=0
(   90) IVALC4=0
(   91) IVALC5=0
(   92) !**
(   93) !     2.  -  CONTROLE DES DONNEES DE L'ARTICLE
(   94) !-----------------------------------------------------------------------
(   95) !
(   96) IF (KVALCO(1).LT.-2.OR.KVALCO(1).GT.2.OR.                        &
(   97) &   KVALCO(2).LT. 0.OR.KVALCO(2).GT.1.OR.                        &
(   98) &  (KVALCO(1).GT. 0.AND.KVALCO(2).EQ.1.AND.KVALCO(4).LT.0)) THEN
(   99)   KREP=-91
(  100)   GOTO 1001
(  101) ENDIF
(  102) !
(  103) LLARPE=KVALCO(1).EQ.2
(  104) LLCOSP=KVALCO(2).EQ.1
(  105) !
(  106) IF ((LLCOSP.AND..NOT.LDCOSP).OR.(.NOT.LLCOSP.AND.LDCOSP)) THEN
(  107)   KREP=-92
(  108)   GOTO 1001
(  109) ENDIF
(  110) !
(  111) IRANGC=FA%FICHIER(KRANG)%NUCADR
(  112) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(  113) !
(  114) IF (LDCOSP) THEN
(  115)   IF (LLMLAM) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 12

(  116)      ILCHAM=FA%CADRE(IRANGC)%NSFLAM
(  117)   ELSE    
(  118)     IF (KVALCO(1).EQ.-1) THEN
(  119)       ILCHAM=(1+FA%CADRE(IRANGC)%MTRONC)*(2+FA%CADRE(IRANGC)%MTRONC)
(  120)     ELSE
(  121)       ILCHAM=(1+FA%CADRE(IRANGC)%MTRONC)**2
(  122)     ENDIF
(  123)   ENDIF   
(  124) ELSE
(  125)   ILCHAM=FA%CADRE(IRANGC)%NVAPDG
(  126) ENDIF
(  127) !
(  128) !**
(  129) !     3.  -  DECODAGE DES DONNEES DE L'ARTICLE
(  130) !-----------------------------------------------------------------------
(  131) !
(  132) IF (KVALCO(1) == -2) THEN
(  133) !
(  134) !          Cas ou les donnees sont codees en IEEE 32 bits; controle longueur d'article
(  135) !
(  136)   IF (KLONGA.LT.((ILCHAM+1)/2+2)) THEN
(  137)     KREP=-93
(  138)     GOTO 1001
(  139)   ELSEIF (KLONGA.GT.((ILCHAM+1)/2+2)) THEN
(  140)     KREP=-94
(  141)     IF (LLMOER(KREP,KRANG)) GOTO 1001
(  142)   ENDIF
(  143) !
(  144) !           Transfert du tableau d'entree a la suite des 2 valeurs
(  145) !     documentaires stockees en debut d'article.
(  146) !
(  147)   DO J = 1, ILCHAM, 2
(  148)     ZTEMP (1:2)  = TRANSFER (KVALCO (2+1+(J-1)/2), ZTEMP (1:2))
(  149)     PCHAMP (J+0) = ZTEMP (1)
(  150)     IF (J+1 <= ILCHAM) THEN
(  151)       PCHAMP (J+1) = REAL (ZTEMP (2), JPDBLR)
(  152)     ENDIF
(  153)   ENDDO
(  154) !
(  155) ELSEIF (KVALCO(1) == -1 .OR. KVALCO(1) == 0) THEN
(  156) !
(  157) !          Cas ou les donnes sont codees en IEEE 64 bits; controle longueur d'article
(  158) !
(  159)   IF (KLONGA.LT.(ILCHAM+2)) THEN
(  160)     KREP=-93
(  161)     GOTO 1001
(  162)   ELSEIF (KLONGA.GT.(ILCHAM+2)) THEN
(  163)     KREP=-94
(  164)     IF (LLMOER(KREP,KRANG)) GOTO 1001
(  165)   ENDIF
(  166) !
(  167) !           Transfert du tableau d'entree a la suite des 2 valeurs
(  168) !     documentaires stockees en debut d'article.
(  169) !
(  170)   DO J = 1, ILCHAM
(  171)     ZCHAMP    = TRANSFER (KVALCO(2+J), ZCHAMP)
(  172)     PCHAMP(J) = REAL (ZCHAMP, JPDBLR)
(  173)   ENDDO






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 13

(  174) !
(  175) ELSE
(  176) !*
(  177) !     3.1 -  DECODAGE GRIB PROPREMENT DIT (STANDARD OU NON).
(  178) !-----------------------------------------------------------------------
(  179) !
(  180)   IDECAL=1+2*KVALCO(1)
(  181)   IF (LDCOSP) IDECAL=IDECAL+2
(  182)   IVALC3=KVALCO(3)
(  183)   IVALC4=KVALCO(4)
(  184)   IVALC5=KVALCO(5)
(  185)   IF (LDCOSP.AND.LLMLAM) THEN
(  186) !
(  187)     ALLOCATE (ZCHAUX (ILCHAM))
(  188) !
(  189)     ITRONC=FA%CADRE(IRANGC)%MTRONC
(  190)     ISTRIA=FA%CADRE(IRANGC)%NOZPAR(4)-FA%CADRE(IRANGC)%NOZPAR(3)+1
(  191)     DO JTRON=1,ITRONC 
(  192)       IADD=4*(IVALC4+1-JTRON)
(  193)       IF (IADD.LE.0) IADD=4
(  194)       ISTRIA=ISTRIA+IADD
(  195)     ENDDO
(  196)     IILCHAM=ILCHAM-ISTRIA
(  197)     CALL FADECOGA(ZCHAUX,IILCHAM,INBITS,FA%NBIMAC,IB1PAR,IB2PAR, &
(  198) &                 ZFOHYB(1),2_JPLIKB ,KVALCO(IDECAL+1),           &
(  199) &                 KLONGA-IDECAL,INDECO,IJLENV,IJLENF,ICPACK,      &
(  200) &                 IPUILA,IERR,KVALCO(IDECAL-1),KVALCO(IDECAL),    &
(  201) &                 LLARPE)
(  202) # 203 "fadeci.F90"
(  203) !
(  204) !  Controle de l'adequation entre nb de valeurs attendues/lues
(  205) !
(  206)     IF (IJLENF.LT.IILCHAM) THEN
(  207)       KREP=-93
(  208)       IF (FA%LFAMOP) THEN
(  209)         WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  210) &                 'FADECI: erreur !!! Nbre de valeurs decodees = ', &
(  211) &                 IJLENF,' et nbre de valeurs attendues = ',IILCHAM
(  212)       ENDIF
(  213)       GOTO 1001
(  214)     ELSEIF (IJLENF.GT.IILCHAM) THEN
(  215)       KREP=-94
(  216)       IF (FA%LFAMOP) THEN
(  217)         WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  218) &                 'FADECI: erreur !!! Nbre de valeurs decodees = ', &
(  219) &                 IJLENF,' et nbre de valeurs attendues = ',IILCHAM
(  220)       ENDIF
(  221)       IF (LLMOER(KREP,KRANG)) GOTO 1001
(  222)     ENDIF
(  223)     IIND=0
(  224)     DO JTRON=1,ITRONC      
(  225)       ILOW=2+2*JTRON+1
(  226)       IADD=4*(IVALC4+1-JTRON)
(  227)       IF (IADD.LE.0) IADD=4  
(  228)       DO J=FA%CADRE(IRANGC)%NOZPAR(ILOW)+IADD,FA%CADRE(IRANGC)%NOZPAR(ILOW+1)
(  229)         IIND=IIND+1        
(  230)         PCHAMP(J)=ZCHAUX (IIND)
(  231)       ENDDO






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 14

(  232)     ENDDO
(  233) !
(  234)     IF (ALLOCATED( ZCHAUX )) DEALLOCATE ( ZCHAUX )
(  235) !
(  236)   ELSE                         
(  237)     CALL FADECOGA (PCHAMP,ILCHAM,INBITS,FA%NBIMAC,IB1PAR,IB2PAR, &
(  238) &                  ZFOHYB(1),2_JPLIKB ,KVALCO(IDECAL+1),          &
(  239) &                  KLONGA-IDECAL,INDECO,IJLENV,IJLENF,ICPACK,     &
(  240) &                  IPUILA,IERR,KVALCO(IDECAL-1),KVALCO(IDECAL),   &
(  241) &                  LLARPE)
(  242) !
(  243) !  Controle de l'adequation entre nb de valeurs attendues/lues
(  244) !
(  245)     IF (IJLENF.LT.ILCHAM) THEN
(  246)       KREP=-93
(  247)       IF (FA%LFAMOP) THEN
(  248)         WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  249) &                 'FADECI: erreur !!! Nbre de valeurs decodees = ', &
(  250) &                 IJLENF,' et nbre de valeurs attendues = ',ILCHAM
(  251)       ENDIF
(  252)       GOTO 1001
(  253)     ELSEIF (IJLENF.GT.ILCHAM) THEN
(  254)       KREP=-94
(  255)       IF (FA%LFAMOP) THEN
(  256)         WRITE (UNIT=FA%NULOUT,FMT=*)                               &
(  257) &                 'FADECI: erreur !!! Nbre de valeurs decodees = ', &
(  258) &                 IJLENF,' et nbre de valeurs attendues = ',ILCHAM
(  259)       ENDIF
(  260)       IF (LLMOER(KREP,KRANG)) GOTO 1001
(  261)     ENDIF
(  262)   ENDIF
(  263) !
(  264)   IF (IERR.EQ.-2) THEN
(  265)     KREP=-93
(  266)     GOTO 1001
(  267)   ELSEIF (IERR.NE.0) THEN
(  268)     KREP=-200+IERR
(  269)     GOTO 1001
(  270)   ELSEIF (IVALC3.NE.INBITS.OR.(LDCOSP.AND.        &
(  271) &          ((ICPACK.NE.IVALC4.AND..NOT.LLMLAM)     &
(  272) &   .OR.(.NOT.LLMLAM.AND.IPUILA.NE.IVALC5)))) THEN                 
(  273)     KREP=-95
(  274)     GOTO 1001
(  275)   ELSEIF (IB1PAR(4).GT.64) THEN
(  276) !
(  277) !     Controle effectue s'il y a un bloc 2 en retour du decodage.
(  278) !
(  279)     IDIZAI=IB2PAR(1)/10
(  280)     IUNITE=IB2PAR(1)-IDIZAI*10
(  281) !
(  282)     IF ((LDCOSP.AND..NOT.LLMLAM.AND.                        &
(  283) &     (IUNITE.NE.0.OR.IDIZAI.LT.5.OR.IDIZAI.GT.8))           &
(  284) &    .OR.(.NOT.LDCOSP.AND.                                   &
(  285) &         (IUNITE.NE.4.OR.IDIZAI.LT.0.OR.IDIZAI.GT.3))) THEN
(  286)       KREP=-95
(  287)       GOTO 1001
(  288)     ENDIF
(  289) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 15

(  290)   ENDIF
(  291)   IF (LDCOSP.AND.LLMLAM) THEN
(  292)     ICPACK=IVALC4
(  293)     IPUILA=IVALC5
(  294)   ENDIF          
(  295) !
(  296)   IF (LDCOSP) THEN
(  297) !
(  298)     IF (LLARPE) THEN
(  299)       IF (LLMLAM) THEN
(  300)         IPOFIN=IDECAL+INDECO+ISTRIA
(  301)       ELSE   
(  302)         IDIMNC=(1+ICPACK)**2
(  303)         IPOFIN=IDECAL+INDECO+IDIMNC
(  304)       ENDIF            
(  305) !
(  306)       IF (KLONGA.LT.IPOFIN) THEN
(  307)         KREP=-93
(  308)         GOTO 1001
(  309)       ELSEIF (KLONGA.GT.IPOFIN) THEN
(  310)         KREP=-94
(  311)         IF (LLMOER(KREP,KRANG)) GOTO 1001
(  312)       ENDIF
(  313) !*
(  314) !     3.2 -  TRANSFERT DES COEFFICIENTS SPECTRAUX NON COMPACTES.
(  315) !-----------------------------------------------------------------------
(  316) !        (et non fournis par DECOGA) stockes en fin d'article.
(  317) !
(  318)       IF (LLMLAM) THEN
(  319)         IIND=0
(  320)         DO JTRON=0,ITRONC
(  321)           IL=2+2*JTRON+1
(  322)           ILOW=FA%CADRE(IRANGC)%NOZPAR(IL)
(  323)           IF (JTRON.EQ.0) THEN
(  324)              IHIGH=FA%CADRE(IRANGC)%NOZPAR(IL+1)
(  325)           ELSE
(  326)              IHIGH=ILOW+4*(ICPACK+1-JTRON)-1
(  327)              IF (IHIGH.LE.ILOW) IHIGH=ILOW+3
(  328)           ENDIF     
(  329)           DO J=ILOW,IHIGH
(  330)             IIND=IIND+1
(  331)             ZCHAMP=TRANSFER (KVALCO(IDECAL+INDECO+IIND), ZCHAMP)
(  332)             PCHAMP(J)=ZCHAMP
(  333)           ENDDO
(  334)         ENDDO
(  335)       ELSE
(  336)         DO J=1,IDIMNC
(  337)           ZCHAMP=TRANSFER (KVALCO(IDECAL+INDECO+J), ZCHAMP)
(  338)           PCHAMP(J)=ZCHAMP
(  339)         ENDDO
(  340)       ENDIF
(  341) !
(  342)     ENDIF
(  343) !*
(  344) !     3.3 -  SI NECESSAIRE, RECONSTITUTION DU SPECTRE.
(  345) !-----------------------------------------------------------------------
(  346) !
(  347)     IF (IPUILA.NE.0) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:15      page 16

(  348)       CALL FARCIS_MT64                                    &
(  349) &                     (FA, KREP,KRANG,PCHAMP,ICPACK,IPUILA)
(  350)       IF (KREP.NE.0) GOTO 1001
(  351)     ENDIF
(  352) !
(  353)   ENDIF
(  354) !
(  355) ENDIF
(  356) !**
(  357) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  358) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  359) !-----------------------------------------------------------------------
(  360) !
(  361) 1001 CONTINUE
(  362) LLFATA=LLMOER (KREP,KRANG)
(  363) !
(  364) IF (FA%LFAMOP.OR.LLFATA) THEN
(  365)   INIMES=2
(  366)   CLNSPR='FADECI'
(  367)   INUMER=JPNIIL
(  368) !
(  369)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I4, &
(  370) &         '', CDNOMA='''''',A,'''''', LDCOSP= '',L1,      &
(  371) &         '', KLONGA='',I8)')                             &
(  372) &     KREP, KRANG, CDNOMA, LDCOSP, KLONGA
(  373)   CALL FAIPAR_MT64                                      &
(  374) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  375) &                  CLNSPR,CDNOMA,.FALSE.)
(  376) ENDIF
(  377) !
(  378) IF (LHOOK) CALL DR_HOOK('FADECI_MT',1,ZHOOK_HANDLE)
(  379) # 380 "fadeci.F90"
(  380) CONTAINS
(  381) # 382 "fadeci.F90"
(  382) # 1 ".D[27]/facom2.llmoer.h"
(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,
(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 383 "fadeci.F90"
(  383) # 384 "fadeci.F90"
(  384) END SUBROUTINE FADECI_MT64
