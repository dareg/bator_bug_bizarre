


NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: fainig.F90

(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) ! Jun-2015 R. El Khatib Allow an unlimited number of vertical levels
(    4) SUBROUTINE FAINIG_MT64                                                &
(    5) &                     (FA,  KREP,   KRANG,  CDPREF, KNIVAU, CDSUFF,   &
(    6) &                      LDCOSP, KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3,    &
(    7) &                      PSEC3, KSEC4, YDGR1TAB)
(    8) USE FA_MOD, ONLY : FA_COM, JPNIIL, FAGR1TAB, JD_SET, JD_CE1, JD_DEX, JD_FMT
(    9) USE PARKIND1, ONLY : JPRB
(   10) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   11) USE LFI_PRECISION
(   12) IMPLICIT NONE
(   13) !****
(   14) !      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   15) !      INItialisation de l'entete Gribex d'un champ.
(   16) !**
(   17) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   18) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   19) !                CDPREF (Entree) ==> Prefixe eventuel du nom d'article;
(   20) !                KNIVAU (Entree) ==> Niveau vertical eventuel;
(   21) !                CDSUFF (Entree) ==> Suffixe eventuel du nom d'article;
(   22) !                LDCOSP (Entree) ==> Vrai si le champ est represente
(   23) !                                    par des coefficients spectraux;
(   24) !                KLCHAM (Entree) ==> Longueur totale du champ;
(   25) !    ( Tableau ) KSEC1  (Sortie) ==> Image des parametres de la section 1
(   26) !                                    de GRIBEX;
(   27) !                KSEC2  (Sortie) ==> Image des parametres de la section 2
(   28) !                                    de GRIBEX, partie entiere;
(   29) !                PSEC2  (Sortie) ==> Image des parametres de la section 2
(   30) !                                    de GRIBEX, partie reelle;






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 3

(   31) !                KSEC3  (Sortie) ==> Image des parametres de la section 3
(   32) !                                    de GRIBEX, partie entiere;
(   33) !                PSEC3  (Sortie) ==> Image des parametres de la section 3
(   34) !                                    de GRIBEX, partie reelle;
(   35) !                KSEC4  (Sortie) ==> Image des parametres de la section 4
(   36) !                                    de GRIBEX, partie entiere;
(   37) !*
(   38) !     Modifications
(   39) !     -------------
(   40) !        R. El Ouaraini: 03-Oct-06 introduction du new EGGX pour tester ERPK
(   41) !        R. El Khatib : 11-Aug-2009 Bugfix for non-square geometries
(   42) !
(   43) !
(   44) !
(   45) !
(   46) !
(   47) TYPE(FA_COM) :: FA
(   48) REAL (KIND=JPDBLR) PSEC3(*), PSEC2(*)
(   49) !
(   50) INTEGER (KIND=JPLIKB) KREP, KRANG, KNIVAU, KLCHAM
(   51) INTEGER (KIND=JPLIKB) KSEC1(FA%JPSEC1)
(   52) INTEGER (KIND=JPLIKB) KSEC2(FA%JPSEC2), KSEC3(2)
(   53) INTEGER (KIND=JPLIKB) KSEC4(FA%JPSEC4)
(   54) !
(   55) CHARACTER CDPREF*(*), CDSUFF*(*)
(   56) !
(   57) LOGICAL LDCOSP
(   58) !
(   59) TYPE (FAGR1TAB) :: YDGR1TAB
(   60) !
(   61) INTEGER (KIND=JPLIKB) IRANGC, INIMES, INUMER
(   62) INTEGER (KIND=JPLIKB) INLAT, INIVAU, INBITS
(   63) INTEGER (KIND=JPLIKB) INIPAR(8), ICPACK
(   64) !
(   65) LOGICAL LLMLAM
(   66) !
(   67) INTRINSIC LEN_TRIM
(   68) !
(   69) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   70) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   71) LOGICAL                  LLFATA
(   72) !
(   73) 
(   74) !**
(   75) !     0.  -  CONTROLES ET INITIALISATIONS PREALABLES
(   76) !-----------------------------------------------------------------------
(   77) !
(   78) !  Controle de la bonne initialisation de la date
(   79) !
(   80) !
(   81) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   82) 
(   83) IF (LHOOK) CALL DR_HOOK('FAINIG_MT',0,ZHOOK_HANDLE)
(   84) 
(   85) IF (FA%FICHIER(KRANG)%LCREAF) THEN
(   86)   KREP=-85
(   87)   GOTO 1001
(   88) ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 4

(   89) 
(   90) INUMER=FA%FICHIER(KRANG)%NULOGI
(   91) 
(   92) ICPACK=FA%FICHIER(KRANG)%NSTROF
(   93) IRANGC=FA%FICHIER(KRANG)%NUCADR
(   94) INLAT=FA%CADRE(IRANGC)%NLATIT
(   95) INIVAU=FA%CADRE(IRANGC)%NNIVER
(   96) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(   97) 
(   98) IF (LDCOSP) THEN
(   99)   INBITS=FA%FICHIER(KRANG)%NBFCSP
(  100) ELSE
(  101)   INBITS=FA%FICHIER(KRANG)%NBFPDG
(  102) ENDIF
(  103) !
(  104) !**
(  105) !     1.  -  SECTION 1: the product definition section
(  106) !-----------------------------------------------------------------------
(  107) !
(  108) ! Appel a FAISC1 une seule fois pour un fichier: initialisation
(  109) ! du tableau FA%NSEC1(2:21,KRANG) qui va servir comme base pour KSEC1:
(  110) !
(  111) IF (FA%FICHIER(KRANG)%LISEC1) THEN
(  112)   CALL FAISC1_MT64              &
(  113) &                (FA, KREP,KRANG)
(  114)   IF (KREP.NE.0) GOTO 1001
(  115)   FA%FICHIER(KRANG)%LISEC1=.FALSE.
(  116) ENDIF
(  117) KSEC1(1:FA%JPSEC1)=0
(  118) KSEC1(2:21)=FA%FICHIER(KRANG)%NSEC1(2:21)
(  119) !
(  120) !  Initialisation de INIPAR (5 elts de KSEC1 (1 et 6:9) et un indicateur
(  121) !  de type de champ: 0->RAS; 2->min/max; 4->cumul)
(  122) CALL FAIPAG_MT64                                                   &
(  123) &               (FA,  KREP, INUMER, CDPREF, KNIVAU, CDSUFF, INIPAR,&
(  124) &                YDGR1TAB)
(  125) IF (KREP.NE.0) GOTO 1001
(  126) !  Element 1: version number of code table 2
(  127) KSEC1(1) = INIPAR(1)
(  128) !  Element 6: parameter indicator
(  129) KSEC1(6) = INIPAR(2)
(  130) IF (INIPAR(2).LT.0.OR.INIPAR(2).GT.254.AND.FA%LFAMOP) THEN
(  131)   WRITE (UNIT=FA%NULOUT,FMT=*)                                  &
(  132) &         '----------------------------------------------------'
(  133)   WRITE (UNIT=FA%NULOUT,FMT=*)                                  &
(  134) &         '    FAINIG: warning, parameter indicator not defined'
(  135)   WRITE (UNIT=FA%NULOUT,FMT=*)                                 &
(  136) &         'for: ',CDPREF,'  ',CDSUFF,'. Set to 255, by default'
(  137)   WRITE (UNIT=FA%NULOUT,FMT=*)                                  &
(  138) &         '----------------------------------------------------'
(  139)   KSEC1(6) = 255
(  140) ENDIF
(  141) !  Element 7: type of level indicator
(  142) KSEC1(7) = INIPAR(3)
(  143) !  Element 8: height, pressure, etc of level or top of level
(  144) KSEC1(8) = INIPAR(4)
(  145) !  Element 9: height, pressure, etc of level or bottom of level
(  146) KSEC1(9) = INIPAR(5)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 5

(  147) 
(  148) IF (FA%FICHIER(KRANG)%MADATX(JD_FMT-11) == 0) THEN
(  149) 
(  150) ! Cas de la periode de reference
(  151)   IF (INIPAR(6)==2) THEN
(  152) ! Convention dans FA (depuis fin 2000): l'echeance precedente
(  153) ! est stockee dans FA%MADATE(10,KRANG).
(  154)     KSEC1(17)=KSEC1(16)
(  155)     KSEC1(16)=FA%FICHIER(KRANG)%MADATE(10)
(  156)     KSEC1(18)=2
(  157) ! Cas du cumul
(  158)   ELSEIF (INIPAR(6)==4) THEN
(  159)     KSEC1(17)=KSEC1(16)
(  160)     KSEC1(16)=FA%FICHIER(KRANG)%MADATE(10)
(  161)     KSEC1(18)=4
(  162) ! Nb de produits inclus dans le cumul: valeur bidon de 1
(  163)     KSEC1(19)=1
(  164)   ELSEIF (INIPAR(6)==8) THEN
(  165) ! Cumul depuis le depart
(  166)     KSEC1(17)=KSEC1(16)
(  167)     KSEC1(18)=4
(  168)     KSEC1(16)=0
(  169)     KSEC1(19)=0
(  170)   ENDIF
(  171) 
(  172) ELSEIF ((FA%FICHIER(KRANG)%MADATX(JD_FMT-11) == 1) .AND. &
(  173)       & (FA%FICHIER(KRANG)%MADATX(JD_DEX-11) == 1)) THEN
(  174) !
(  175) ! Cas d'une datation en minutes; on descend au quart d'heure
(  176) !
(  177)   KSEC1(15)=13
(  178)   KSEC1(16)=FA%FICHIER(KRANG)%MADATX(JD_SET-11)/(15 * 60)
(  179) 
(  180) ! Cas de la periode de reference
(  181)   IF (INIPAR(6)==2) THEN
(  182) ! Convention dans FA (depuis fin 2000): l'echeance precedente
(  183) ! est stockee dans FA%MADATE(10,KRANG).
(  184)     KSEC1(17)=KSEC1(16)
(  185)     KSEC1(16)=FA%FICHIER(KRANG)%MADATX(JD_CE1-11)/(15 * 60) 
(  186)     KSEC1(18)=2
(  187) ! Cas du cumul
(  188)   ELSEIF (INIPAR(6)==4) THEN
(  189)     KSEC1(17)=KSEC1(16)
(  190)     KSEC1(16)=FA%FICHIER(KRANG)%MADATX(JD_CE1-11)/(15 * 60)
(  191)     KSEC1(18)=4
(  192) ! Nb de produits inclus dans le cumul: valeur bidon de 1
(  193)     KSEC1(19)=1
(  194)   ELSEIF (INIPAR(6)==8) THEN
(  195) ! Cumul depuis le depart
(  196)     KSEC1(17)=KSEC1(16)
(  197)     KSEC1(18)=4
(  198)     KSEC1(16)=0
(  199)     KSEC1(19)=0
(  200)   ENDIF
(  201) 
(  202) ENDIF
(  203) 
(  204) ! Facteur decimal d'echelle






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 6

(  205) KSEC1(23)=INIPAR(7)
(  206) !**
(  207) !     2.  -  SECTION 2: the grid definition section
(  208) !-----------------------------------------------------------------------
(  209) !
(  210) ! Appel a FAISC2 une seule fois pour un cadre, pour initialiser
(  211) ! les tableaux NSEC2xxx et FA%XSEC2.
(  212) !
(  213) IF (FA%CADRE(IRANGC)%LISEC2) THEN
(  214)   CALL FAISC2_MT64               &
(  215) &                (FA, KREP,IRANGC)
(  216)   IF (KREP.NE.0) GOTO 1001
(  217)   FA%CADRE(IRANGC)%LISEC2=.FALSE.
(  218) ENDIF
(  219) !
(  220) ! Appel a FAIS2F une seule fois pour un fichier Aladin,
(  221) ! pour initialiser le tableau FA%NSC2ALF (sauf redefinition
(  222) ! de la ss-tronc dans FAGOTE).
(  223) !
(  224) IF (LLMLAM.AND.FA%FICHIER(KRANG)%LISC2F) THEN
(  225)   CALL FAIS2F_MT64              &
(  226) &                (FA, KREP,KRANG)
(  227)   IF (KREP.NE.0) GOTO 1001
(  228)   FA%FICHIER(KRANG)%LISC2F=.FALSE.
(  229) ENDIF
(  230) 
(  231) KSEC2(1:FA%JPSEC2)=0
(  232) IF (LLMLAM) THEN
(  233)   IF (LDCOSP) THEN
(  234) !  Le champ spectral que l'on doit coder va etre represente sur une
(  235) !  grille lat-lon quasi-reguliere puisque ce type de coeff. spectraux
(  236) !  n'est pas pris en compte dans GRIBEX.
(  237)     KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2AL(1:22)
(  238)     KSEC2(23:21+FA%CADRE(IRANGC)%NOMPAR(2))=          &
(  239) &     FA%FICHIER(KRANG)%NSC2ALF(1:FA%CADRE(IRANGC)%NOMPAR(2)-1)
(  240)   ELSE
(  241)     IF (FA%CADRE(IRANGC)%SINLAT(1) .GE. 0) THEN
(  242) ! Old EGGX
(  243)       IF (FA%CADRE(IRANGC)%SINLAT(10).LT.0) THEN
(  244) !  Parametre de projection negatif, donc pas de projection
(  245) !  La grille de ce cadre est une grille lat-lon reguliere
(  246) !  du type Full-Pos (pour champ ARPEGE ou Aladin)
(  247)         KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2LL(1:22)
(  248)       ELSE
(  249) !  La grille de ce cadre est donc du type Lambert conforme
(  250) !  (cas general de la grille Aladin)
(  251)         KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2LA(1:22)
(  252)       ENDIF
(  253)     ELSE
(  254) ! New EGGX
(  255)       IF (FA%CADRE(IRANGC)%SINLAT(2).LT.0) THEN
(  256)         KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2LL(1:22)
(  257)       ELSE
(  258)         KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2LA(1:22)
(  259)       ENDIF
(  260)     ENDIF
(  261)   ENDIF
(  262) ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 7

(  263)   IF (LDCOSP) THEN
(  264)     KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2SP(1:22)
(  265)   ELSE
(  266)     KSEC2(1:22+INLAT)=FA%CADRE(IRANGC)%NSEC2GG(1:22+INLAT)
(  267)   ENDIF
(  268) ENDIF
(  269) !
(  270) ! Controle ultime: on regarde le prefixe pour s'assurer de la
(  271) ! presence ou non d'une coordonnee hybride sur la verticale,
(  272) ! seul cas qui impose une description dans la section 2 reelle.
(  273) !
(  274) ! Pour encoder un nombre illimite de niveaux, on ne decrit que le niveau courant
(  275) ! et pas l'integralite de la coordonnee. De toute facon l'en-tete grib n'est pas
(  276) ! utilisee en relecture. REK
(  277) IF (CDPREF=='S') THEN
(  278) !REK  KSEC2(12)=2*(INIVAU+1)
(  279)   KSEC2(12)=2
(  280)   PSEC2(1:10)=FA%CADRE(IRANGC)%XSEC2(1:10)
(  281)   PSEC2(11)=FA%CADRE(IRANGC)%XSEC2(10+KNIVAU)
(  282)   PSEC2(12)=FA%CADRE(IRANGC)%XSEC2(10+INIVAU+2+KNIVAU)
(  283) ELSE
(  284)   KSEC2(12)=0
(  285)   PSEC2(1:10+KSEC2(12))=FA%CADRE(IRANGC)%XSEC2(1:10+KSEC2(12))
(  286) ENDIF
(  287) 
(  288) !**
(  289) !     3.  -  SECTION 3: the bitmap section
(  290) !            As KSEC1(5)=128, the Section 3 is omitted => dummy values
(  291) !-----------------------------------------------------------------------
(  292) !
(  293) !     3.1  - INTEGER PART
(  294) !
(  295) ! Flag: 0->bitmap included in the GRIB message, 1->not included
(  296) KSEC3(1)=1
(  297) ! Value used at missing data points in an INTEGER data field
(  298) KSEC3(2)=0
(  299) !
(  300) !     3.2  - REAL PART
(  301) !
(  302) ! Ignored
(  303) PSEC3(1)=0._JPDBLR
(  304) ! Value used at missing data points in an REAL data field
(  305) PSEC3(2)=0._JPDBLR
(  306) !**
(  307) !     4.  -  SECTION 4: the binary data section (integer part only)
(  308) !-----------------------------------------------------------------------
(  309) !
(  310) ! 1: Nb of data values in array PSEC4 to be encoded
(  311) KSEC4(1)=KLCHAM
(  312) ! 2: Nb of bits used for each encoded value
(  313) KSEC4(2)=INBITS
(  314) ! 3: Type of data (0:grid point; 128:spherical harmonic coeff)
(  315) KSEC4(3)=0
(  316) ! 4: Type of packing, only for spectral fields
(  317) !    but also to allow 2nd-order packing for grid points fields
(  318) !    and for Aladin spectral fields (seen as lat-lon grid points
(  319) !    by GRIBEX).
(  320) !    (0:simple packing; 64:complex packing and 2nd-order packing) 






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 8

(  321) IF (FA%FICHIER(KRANG)%NCOGRIF(2)==0) THEN
(  322) ! If no Additional flags, then 2nd-order packing is not asked!
(  323)   KSEC4(4)=0
(  324) ELSE
(  325)   KSEC4(4)=64
(  326) ENDIF
(  327) IF (LDCOSP.AND..NOT.LLMLAM) THEN
(  328) ! For spherical harmonics coeff, complex packing is always done
(  329)   KSEC4(3)=128
(  330)   KSEC4(4)=64
(  331) ENDIF
(  332) ! 5: Data representation (0:float; 32:integer)
(  333) KSEC4(5)=0
(  334) ! 6: Additional flags indicator (0:no; 16:yes)
(  335) KSEC4(6)=FA%FICHIER(KRANG)%NCOGRIF(2)
(  336) IF (LDCOSP.AND..NOT.LLMLAM) THEN
(  337) ! For spherical harmonics coeff, additional flags indicator=0
(  338)   KSEC4(6)=0
(  339) ENDIF
(  340) ! 7: Reserved
(  341) KSEC4(7)=FA%FICHIER(KRANG)%NCOGRIF(3)
(  342) ! 8: Nb of values indicator (0:single datum at each grid point; 64:matrix)
(  343) KSEC4(8)=0
(  344) ! 9: Secondary bitmaps indicator (0:no; 32:yes)
(  345) KSEC4(9)=FA%FICHIER(KRANG)%NCOGRIF(4)
(  346) ! 10: Values width indicator (0:2nd order values have constant width; 16:not)
(  347) KSEC4(10)=FA%FICHIER(KRANG)%NCOGRIF(5)
(  348) ! 11: Nb of bits for 2nd order values when these have constant width
(  349) KSEC4(11)=FA%FICHIER(KRANG)%NCOGRIF(6)
(  350) IF (KSEC4(11).EQ.-99) KSEC4(11)=1-INBITS
(  351) ! 12: General extended 2nd order packing (0:no; 8:yes)
(  352) ! 13: Boustrophedonic ordering (0:no; 4:yes)
(  353) ! 14,15: give the order of spatial differencing; if 0,0 then option rejected
(  354) KSEC4(12:15)=FA%FICHIER(KRANG)%NCOGRIF(7:10)
(  355) ! 16: For complex packing, a pointer to the start of packed data values (octet nb)
(  356) KSEC4(16)=0
(  357) ! 17: For complex packing, the scaling factor factor P, stored as the INTEGER
(  358) !     value P*1000 (in the range -10000,+10000): defined later
(  359) KSEC4(17)=0
(  360) ! 18: For complex packing, the pentagonal resolution parameter J specifying
(  361) !     the truncation of the subset of the data not packed (32 bits)
(  362) KSEC4(18)=0
(  363) ! 19-20: Idem 18 for resolution parameters K and M
(  364) KSEC4(19)=0
(  365) KSEC4(20)=0
(  366) IF (LDCOSP.AND..NOT.LLMLAM) THEN
(  367) ! For spherical harmonics coeff (ARPEGE) only
(  368)   KSEC4(18)=ICPACK
(  369)   KSEC4(19)=ICPACK
(  370)   KSEC4(20)=ICPACK
(  371) ENDIF
(  372) ! 21-33: Reserved
(  373) ! 34-42: 'X' decoding option
(  374) KSEC4(21:FA%JPSEC4)=0
(  375) !**
(  376) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  377) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  378) !-----------------------------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 9

(  379) !
(  380) 1001 CONTINUE
(  381) LLFATA=LLMOER (KREP,KRANG)
(  382) !
(  383) IF (FA%LFAMOP.OR.LLFATA) THEN
(  384)   INIMES=2
(  385)   CLNSPR='FAINIG'
(  386) !
(  387)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I4,  &
(  388) &       '', CDPREF='''''',A,'''''', KNIVAU='',I6,         &
(  389) &       '', CDSUFF='''''',A,'''''', LDCOSP= '',L1)')      &
(  390) &         KREP,KRANG,CDPREF(1:LEN_TRIM(CDPREF)),KNIVAU,   &
(  391) &         CDSUFF(1:LEN_TRIM(CDSUFF)),LDCOSP
(  392)   CALL FAIPAR_MT64                                        &
(  393) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  394) &                  CLNSPR,                                &
(  395) &                  CLNSPR,.FALSE.)
(  396) ENDIF
(  397) !
(  398) IF (LHOOK) CALL DR_HOOK('FAINIG_MT',1,ZHOOK_HANDLE)
(  399) 
(  400) CONTAINS
(  401) 
(  402) #include "facom2.llmoer.h"
(  403) 
(  404) END SUBROUTINE FAINIG_MT64
(  405) 
(  406) 
(  407) 
(  408) ! Oct-2012 P. Marguinaud 64b LFI
(  409) SUBROUTINE FAINIG64                                           &
(  410) &           (KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP,     &
(  411) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  412) &            YDGR1TAB)
(  413) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  414) &                  FA_COM_DEFAULT_INIT,  &
(  415) &                  NEW_FA_DEFAULT,       &
(  416) &                  FAGR1TAB
(  417) USE LFI_PRECISION
(  418) IMPLICIT NONE
(  419) ! Arguments
(  420) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  421) INTEGER (KIND=JPLIKB)  KRANG                                  ! IN   
(  422) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  423) INTEGER (KIND=JPLIKB)  KNIVAU                                 ! IN   
(  424) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  425) LOGICAL                LDCOSP                                 ! IN   
(  426) INTEGER (KIND=JPLIKB)  KLCHAM                                 ! IN   
(  427) INTEGER (KIND=JPLIKB)  KSEC1      (FA%JPSEC1)                 !   OUT
(  428) INTEGER (KIND=JPLIKB)  KSEC2      (FA%JPSEC2)                 !   OUT
(  429) REAL (KIND=JPDBLR)     PSEC2      (*)                         !   OUT
(  430) INTEGER (KIND=JPLIKB)  KSEC3      (2)                         !   OUT
(  431) REAL (KIND=JPDBLR)     PSEC3      (*)                         !   OUT
(  432) INTEGER (KIND=JPLIKB)  KSEC4      (FA%JPSEC4)                 !   OUT
(  433) TYPE (FAGR1TAB)        YDGR1TAB                               !   OUT
(  434) 
(  435) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  436) 






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 10

(  437) CALL FAINIG_MT64                                              &
(  438) &           (FA, KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP, &
(  439) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  440) &            YDGR1TAB)
(  441) 
(  442) END SUBROUTINE FAINIG64
(  443) 
(  444) SUBROUTINE FAINIG                                             &
(  445) &           (KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP,     &
(  446) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  447) &            YDGR1TAB)
(  448) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  449) &                  FA_COM_DEFAULT_INIT,  &
(  450) &                  NEW_FA_DEFAULT,       &
(  451) &                  FAGR1TAB
(  452) USE LFI_PRECISION
(  453) IMPLICIT NONE
(  454) ! Arguments
(  455) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  456) INTEGER (KIND=JPLIKM)  KRANG                                  ! IN   
(  457) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  458) INTEGER (KIND=JPLIKM)  KNIVAU                                 ! IN   
(  459) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  460) LOGICAL                LDCOSP                                 ! IN   
(  461) INTEGER (KIND=JPLIKM)  KLCHAM                                 ! IN   
(  462) INTEGER (KIND=JPLIKM)  KSEC1      (FA%JPSEC1)                 !   OUT
(  463) INTEGER (KIND=JPLIKM)  KSEC2      (FA%JPSEC2)                 !   OUT
(  464) REAL (KIND=JPDBLR)     PSEC2      (*)                         !   OUT
(  465) INTEGER (KIND=JPLIKM)  KSEC3      (2)                         !   OUT
(  466) REAL (KIND=JPDBLR)     PSEC3      (*)                         !   OUT
(  467) INTEGER (KIND=JPLIKM)  KSEC4      (FA%JPSEC4)                 !   OUT
(  468) TYPE (FAGR1TAB)        YDGR1TAB                               !   OUT
(  469) 
(  470) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  471) 
(  472) CALL FAINIG_MT                                                &
(  473) &           (FA, KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP, &
(  474) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  475) &            YDGR1TAB)
(  476) 
(  477) END SUBROUTINE FAINIG
(  478) 
(  479) SUBROUTINE FAINIG_MT                                          &
(  480) &           (FA, KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP, &
(  481) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  482) &            YDGR1TAB)
(  483) USE FA_MOD, ONLY : FA_COM, FAGR1TAB
(  484) USE LFI_PRECISION
(  485) IMPLICIT NONE
(  486) ! Arguments
(  487) TYPE (FA_COM)          FA                                     ! INOUT
(  488) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  489) INTEGER (KIND=JPLIKM)  KRANG                                  ! IN   
(  490) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  491) INTEGER (KIND=JPLIKM)  KNIVAU                                 ! IN   
(  492) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  493) LOGICAL                LDCOSP                                 ! IN   
(  494) INTEGER (KIND=JPLIKM)  KLCHAM                                 ! IN   






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 11

(  495) INTEGER (KIND=JPLIKM)  KSEC1      (FA%JPSEC1)                 !   OUT
(  496) INTEGER (KIND=JPLIKM)  KSEC2      (FA%JPSEC2)                 !   OUT
(  497) REAL (KIND=JPDBLR)     PSEC2      (*)                         !   OUT
(  498) INTEGER (KIND=JPLIKM)  KSEC3      (2)                         !   OUT
(  499) REAL (KIND=JPDBLR)     PSEC3      (*)                         !   OUT
(  500) INTEGER (KIND=JPLIKM)  KSEC4      (FA%JPSEC4)                 !   OUT
(  501) TYPE (FAGR1TAB)        YDGR1TAB                               !   OUT
(  502) ! Local integers
(  503) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  504) INTEGER (KIND=JPLIKB)  IRANG                                  ! IN   
(  505) INTEGER (KIND=JPLIKB)  INIVAU                                 ! IN   
(  506) INTEGER (KIND=JPLIKB)  ILCHAM                                 ! IN   
(  507) INTEGER (KIND=JPLIKB)  ISEC1      (FA%JPSEC1)                 !   OUT
(  508) INTEGER (KIND=JPLIKB)  ISEC2      (FA%JPSEC2)                 !   OUT
(  509) INTEGER (KIND=JPLIKB)  ISEC3      (2)                         !   OUT
(  510) INTEGER (KIND=JPLIKB)  ISEC4      (FA%JPSEC4)                 !   OUT
(  511) ! Convert arguments
(  512) 
(  513) IRANG      = INT (     KRANG, JPLIKB)
(  514) INIVAU     = INT (    KNIVAU, JPLIKB)
(  515) ILCHAM     = INT (    KLCHAM, JPLIKB)
(  516) 
(  517) CALL FAINIG_MT64                                              &
(  518) &           (FA, IREP, IRANG, CDPREF, INIVAU, CDSUFF, LDCOSP, &
(  519) &            ILCHAM, ISEC1, ISEC2, PSEC2, ISEC3, PSEC3, ISEC4,&
(  520) &            YDGR1TAB)
(  521) 
(  522) KREP       = INT (      IREP, JPLIKM)
(  523) KSEC1      = INT (     ISEC1, JPLIKM)
(  524) KSEC2      = INT (     ISEC2, JPLIKM)
(  525) KSEC3      = INT (     ISEC3, JPLIKM)
(  526) KSEC4      = INT (     ISEC4, JPLIKM)
(  527) 
(  528) END SUBROUTINE FAINIG_MT
(  529) 
(  530) !INTF KREP            OUT                               
(  531) !INTF KRANG         IN                                  
(  532) !INTF CDPREF        IN                                  
(  533) !INTF KNIVAU        IN                                  
(  534) !INTF CDSUFF        IN                                  
(  535) !INTF LDCOSP        IN                                  
(  536) !INTF KLCHAM        IN                                  
(  537) !INTF KSEC1           OUT DIMS=FA%JPSEC1                
(  538) !INTF KSEC2           OUT DIMS=FA%JPSEC2                
(  539) !INTF PSEC2           OUT DIMS=*                        
(  540) !INTF KSEC3           OUT DIMS=2                        
(  541) !INTF PSEC3           OUT DIMS=*                        
(  542) !INTF KSEC4           OUT DIMS=FA%JPSEC4                
(  543) !INTF YDGR1TAB        OUT















NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 12

(    1) # 1 "fainig.F90"
(    1) ! Oct-2012 P. Marguinaud 64b LFI
(    2) ! Jan-2011 P. Marguinaud Thread-safe FA
(    3) ! Jun-2015 R. El Khatib Allow an unlimited number of vertical levels
(    4) SUBROUTINE FAINIG_MT64                                                &
(    5) &                     (FA,  KREP,   KRANG,  CDPREF, KNIVAU, CDSUFF,   &
(    6) &                      LDCOSP, KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3,    &
(    7) &                      PSEC3, KSEC4, YDGR1TAB)
(    8) USE FA_MOD, ONLY : FA_COM, JPNIIL, FAGR1TAB, JD_SET, JD_CE1, JD_DEX, JD_FMT
(    9) USE PARKIND1, ONLY : JPRB
(   10) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   11) USE LFI_PRECISION
(   12) IMPLICIT NONE
(   13) !****
(   14) !      Sous-programme INTERNE du logiciel de Fichiers ARPEGE:
(   15) !      INItialisation de l'entete Gribex d'un champ.
(   16) !**
(   17) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   18) !                KRANG  (Entree) ==> Rang de l'unite logique;
(   19) !                CDPREF (Entree) ==> Prefixe eventuel du nom d'article;
(   20) !                KNIVAU (Entree) ==> Niveau vertical eventuel;
(   21) !                CDSUFF (Entree) ==> Suffixe eventuel du nom d'article;
(   22) !                LDCOSP (Entree) ==> Vrai si le champ est represente
(   23) !                                    par des coefficients spectraux;
(   24) !                KLCHAM (Entree) ==> Longueur totale du champ;
(   25) !    ( Tableau ) KSEC1  (Sortie) ==> Image des parametres de la section 1
(   26) !                                    de GRIBEX;
(   27) !                KSEC2  (Sortie) ==> Image des parametres de la section 2
(   28) !                                    de GRIBEX, partie entiere;
(   29) !                PSEC2  (Sortie) ==> Image des parametres de la section 2
(   30) !                                    de GRIBEX, partie reelle;
(   31) !                KSEC3  (Sortie) ==> Image des parametres de la section 3
(   32) !                                    de GRIBEX, partie entiere;
(   33) !                PSEC3  (Sortie) ==> Image des parametres de la section 3
(   34) !                                    de GRIBEX, partie reelle;
(   35) !                KSEC4  (Sortie) ==> Image des parametres de la section 4
(   36) !                                    de GRIBEX, partie entiere;
(   37) !*
(   38) !     Modifications
(   39) !     -------------
(   40) !        R. El Ouaraini: 03-Oct-06 introduction du new EGGX pour tester ERPK
(   41) !        R. El Khatib : 11-Aug-2009 Bugfix for non-square geometries
(   42) !
(   43) !
(   44) !
(   45) !
(   46) !
(   47) TYPE(FA_COM) :: FA
(   48) REAL (KIND=JPDBLR) PSEC3(*), PSEC2(*)
(   49) !
(   50) INTEGER (KIND=JPLIKB) KREP, KRANG, KNIVAU, KLCHAM
(   51) INTEGER (KIND=JPLIKB) KSEC1(FA%JPSEC1)
(   52) INTEGER (KIND=JPLIKB) KSEC2(FA%JPSEC2), KSEC3(2)
(   53) INTEGER (KIND=JPLIKB) KSEC4(FA%JPSEC4)
(   54) !
(   55) CHARACTER CDPREF*(*), CDSUFF*(*)
(   56) !
(   57) LOGICAL LDCOSP






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 13

(   58) !
(   59) TYPE (FAGR1TAB) :: YDGR1TAB
(   60) !
(   61) INTEGER (KIND=JPLIKB) IRANGC, INIMES, INUMER
(   62) INTEGER (KIND=JPLIKB) INLAT, INIVAU, INBITS
(   63) INTEGER (KIND=JPLIKB) INIPAR(8), ICPACK
(   64) !
(   65) LOGICAL LLMLAM
(   66) !
(   67) INTRINSIC LEN_TRIM
(   68) !
(   69) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   70) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   71) LOGICAL                  LLFATA
(   72) !
(   73) # 74 "fainig.F90"
(   74) !**
(   75) !     0.  -  CONTROLES ET INITIALISATIONS PREALABLES
(   76) !-----------------------------------------------------------------------
(   77) !
(   78) !  Controle de la bonne initialisation de la date
(   79) !
(   80) !
(   81) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   82) # 83 "fainig.F90"
(   83) IF (LHOOK) CALL DR_HOOK('FAINIG_MT',0,ZHOOK_HANDLE)
(   84) # 85 "fainig.F90"
(   85) IF (FA%FICHIER(KRANG)%LCREAF) THEN
(   86)   KREP=-85
(   87)   GOTO 1001
(   88) ENDIF
(   89) # 90 "fainig.F90"
(   90) INUMER=FA%FICHIER(KRANG)%NULOGI
(   91) # 92 "fainig.F90"
(   92) ICPACK=FA%FICHIER(KRANG)%NSTROF
(   93) IRANGC=FA%FICHIER(KRANG)%NUCADR
(   94) INLAT=FA%CADRE(IRANGC)%NLATIT
(   95) INIVAU=FA%CADRE(IRANGC)%NNIVER
(   96) LLMLAM=FA%CADRE(IRANGC)%LIMLAM
(   97) # 98 "fainig.F90"
(   98) IF (LDCOSP) THEN
(   99)   INBITS=FA%FICHIER(KRANG)%NBFCSP
(  100) ELSE
(  101)   INBITS=FA%FICHIER(KRANG)%NBFPDG
(  102) ENDIF
(  103) !
(  104) !**
(  105) !     1.  -  SECTION 1: the product definition section
(  106) !-----------------------------------------------------------------------
(  107) !
(  108) ! Appel a FAISC1 une seule fois pour un fichier: initialisation
(  109) ! du tableau FA%NSEC1(2:21,KRANG) qui va servir comme base pour KSEC1:
(  110) !
(  111) IF (FA%FICHIER(KRANG)%LISEC1) THEN
(  112)   CALL FAISC1_MT64              &
(  113) &                (FA, KREP,KRANG)
(  114)   IF (KREP.NE.0) GOTO 1001
(  115)   FA%FICHIER(KRANG)%LISEC1=.FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 14

(  116) ENDIF
(  117) KSEC1(1:FA%JPSEC1)=0
(  118) KSEC1(2:21)=FA%FICHIER(KRANG)%NSEC1(2:21)
(  119) !
(  120) !  Initialisation de INIPAR (5 elts de KSEC1 (1 et 6:9) et un indicateur
(  121) !  de type de champ: 0->RAS; 2->min/max; 4->cumul)
(  122) CALL FAIPAG_MT64                                                   &
(  123) &               (FA,  KREP, INUMER, CDPREF, KNIVAU, CDSUFF, INIPAR,&
(  124) &                YDGR1TAB)
(  125) IF (KREP.NE.0) GOTO 1001
(  126) !  Element 1: version number of code table 2
(  127) KSEC1(1) = INIPAR(1)
(  128) !  Element 6: parameter indicator
(  129) KSEC1(6) = INIPAR(2)
(  130) IF (INIPAR(2).LT.0.OR.INIPAR(2).GT.254.AND.FA%LFAMOP) THEN
(  131)   WRITE (UNIT=FA%NULOUT,FMT=*)                                  &
(  132) &         '----------------------------------------------------'
(  133)   WRITE (UNIT=FA%NULOUT,FMT=*)                                  &
(  134) &         '    FAINIG: warning, parameter indicator not defined'
(  135)   WRITE (UNIT=FA%NULOUT,FMT=*)                                 &
(  136) &         'for: ',CDPREF,'  ',CDSUFF,'. Set to 255, by default'
(  137)   WRITE (UNIT=FA%NULOUT,FMT=*)                                  &
(  138) &         '----------------------------------------------------'
(  139)   KSEC1(6) = 255
(  140) ENDIF
(  141) !  Element 7: type of level indicator
(  142) KSEC1(7) = INIPAR(3)
(  143) !  Element 8: height, pressure, etc of level or top of level
(  144) KSEC1(8) = INIPAR(4)
(  145) !  Element 9: height, pressure, etc of level or bottom of level
(  146) KSEC1(9) = INIPAR(5)
(  147) # 148 "fainig.F90"
(  148) IF (FA%FICHIER(KRANG)%MADATX(JD_FMT-11) == 0) THEN
(  149) # 150 "fainig.F90"
(  150) ! Cas de la periode de reference
(  151)   IF (INIPAR(6)==2) THEN
(  152) ! Convention dans FA (depuis fin 2000): l'echeance precedente
(  153) ! est stockee dans FA%MADATE(10,KRANG).
(  154)     KSEC1(17)=KSEC1(16)
(  155)     KSEC1(16)=FA%FICHIER(KRANG)%MADATE(10)
(  156)     KSEC1(18)=2
(  157) ! Cas du cumul
(  158)   ELSEIF (INIPAR(6)==4) THEN
(  159)     KSEC1(17)=KSEC1(16)
(  160)     KSEC1(16)=FA%FICHIER(KRANG)%MADATE(10)
(  161)     KSEC1(18)=4
(  162) ! Nb de produits inclus dans le cumul: valeur bidon de 1
(  163)     KSEC1(19)=1
(  164)   ELSEIF (INIPAR(6)==8) THEN
(  165) ! Cumul depuis le depart
(  166)     KSEC1(17)=KSEC1(16)
(  167)     KSEC1(18)=4
(  168)     KSEC1(16)=0
(  169)     KSEC1(19)=0
(  170)   ENDIF
(  171) # 172 "fainig.F90"
(  172) ELSEIF ((FA%FICHIER(KRANG)%MADATX(JD_FMT-11) == 1) .AND. &
(  173)       & (FA%FICHIER(KRANG)%MADATX(JD_DEX-11) == 1)) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 15

(  174) !
(  175) ! Cas d'une datation en minutes; on descend au quart d'heure
(  176) !
(  177)   KSEC1(15)=13
(  178)   KSEC1(16)=FA%FICHIER(KRANG)%MADATX(JD_SET-11)/(15 * 60)
(  179) # 180 "fainig.F90"
(  180) ! Cas de la periode de reference
(  181)   IF (INIPAR(6)==2) THEN
(  182) ! Convention dans FA (depuis fin 2000): l'echeance precedente
(  183) ! est stockee dans FA%MADATE(10,KRANG).
(  184)     KSEC1(17)=KSEC1(16)
(  185)     KSEC1(16)=FA%FICHIER(KRANG)%MADATX(JD_CE1-11)/(15 * 60) 
(  186)     KSEC1(18)=2
(  187) ! Cas du cumul
(  188)   ELSEIF (INIPAR(6)==4) THEN
(  189)     KSEC1(17)=KSEC1(16)
(  190)     KSEC1(16)=FA%FICHIER(KRANG)%MADATX(JD_CE1-11)/(15 * 60)
(  191)     KSEC1(18)=4
(  192) ! Nb de produits inclus dans le cumul: valeur bidon de 1
(  193)     KSEC1(19)=1
(  194)   ELSEIF (INIPAR(6)==8) THEN
(  195) ! Cumul depuis le depart
(  196)     KSEC1(17)=KSEC1(16)
(  197)     KSEC1(18)=4
(  198)     KSEC1(16)=0
(  199)     KSEC1(19)=0
(  200)   ENDIF
(  201) # 202 "fainig.F90"
(  202) ENDIF
(  203) # 204 "fainig.F90"
(  204) ! Facteur decimal d'echelle
(  205) KSEC1(23)=INIPAR(7)
(  206) !**
(  207) !     2.  -  SECTION 2: the grid definition section
(  208) !-----------------------------------------------------------------------
(  209) !
(  210) ! Appel a FAISC2 une seule fois pour un cadre, pour initialiser
(  211) ! les tableaux NSEC2xxx et FA%XSEC2.
(  212) !
(  213) IF (FA%CADRE(IRANGC)%LISEC2) THEN
(  214)   CALL FAISC2_MT64               &
(  215) &                (FA, KREP,IRANGC)
(  216)   IF (KREP.NE.0) GOTO 1001
(  217)   FA%CADRE(IRANGC)%LISEC2=.FALSE.
(  218) ENDIF
(  219) !
(  220) ! Appel a FAIS2F une seule fois pour un fichier Aladin,
(  221) ! pour initialiser le tableau FA%NSC2ALF (sauf redefinition
(  222) ! de la ss-tronc dans FAGOTE).
(  223) !
(  224) IF (LLMLAM.AND.FA%FICHIER(KRANG)%LISC2F) THEN
(  225)   CALL FAIS2F_MT64              &
(  226) &                (FA, KREP,KRANG)
(  227)   IF (KREP.NE.0) GOTO 1001
(  228)   FA%FICHIER(KRANG)%LISC2F=.FALSE.
(  229) ENDIF
(  230) # 231 "fainig.F90"
(  231) KSEC2(1:FA%JPSEC2)=0






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 16

(  232) IF (LLMLAM) THEN
(  233)   IF (LDCOSP) THEN
(  234) !  Le champ spectral que l'on doit coder va etre represente sur une
(  235) !  grille lat-lon quasi-reguliere puisque ce type de coeff. spectraux
(  236) !  n'est pas pris en compte dans GRIBEX.
(  237)     KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2AL(1:22)
(  238)     KSEC2(23:21+FA%CADRE(IRANGC)%NOMPAR(2))=          &
(  239) &     FA%FICHIER(KRANG)%NSC2ALF(1:FA%CADRE(IRANGC)%NOMPAR(2)-1)
(  240)   ELSE
(  241)     IF (FA%CADRE(IRANGC)%SINLAT(1) .GE. 0) THEN
(  242) ! Old EGGX
(  243)       IF (FA%CADRE(IRANGC)%SINLAT(10).LT.0) THEN
(  244) !  Parametre de projection negatif, donc pas de projection
(  245) !  La grille de ce cadre est une grille lat-lon reguliere
(  246) !  du type Full-Pos (pour champ ARPEGE ou Aladin)
(  247)         KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2LL(1:22)
(  248)       ELSE
(  249) !  La grille de ce cadre est donc du type Lambert conforme
(  250) !  (cas general de la grille Aladin)
(  251)         KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2LA(1:22)
(  252)       ENDIF
(  253)     ELSE
(  254) ! New EGGX
(  255)       IF (FA%CADRE(IRANGC)%SINLAT(2).LT.0) THEN
(  256)         KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2LL(1:22)
(  257)       ELSE
(  258)         KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2LA(1:22)
(  259)       ENDIF
(  260)     ENDIF
(  261)   ENDIF
(  262) ELSE
(  263)   IF (LDCOSP) THEN
(  264)     KSEC2(1:22)=FA%CADRE(IRANGC)%NSEC2SP(1:22)
(  265)   ELSE
(  266)     KSEC2(1:22+INLAT)=FA%CADRE(IRANGC)%NSEC2GG(1:22+INLAT)
(  267)   ENDIF
(  268) ENDIF
(  269) !
(  270) ! Controle ultime: on regarde le prefixe pour s'assurer de la
(  271) ! presence ou non d'une coordonnee hybride sur la verticale,
(  272) ! seul cas qui impose une description dans la section 2 reelle.
(  273) !
(  274) ! Pour encoder un nombre illimite de niveaux, on ne decrit que le niveau courant
(  275) ! et pas l'integralite de la coordonnee. De toute facon l'en-tete grib n'est pas
(  276) ! utilisee en relecture. REK
(  277) IF (CDPREF=='S') THEN
(  278) !REK  KSEC2(12)=2*(INIVAU+1)
(  279)   KSEC2(12)=2
(  280)   PSEC2(1:10)=FA%CADRE(IRANGC)%XSEC2(1:10)
(  281)   PSEC2(11)=FA%CADRE(IRANGC)%XSEC2(10+KNIVAU)
(  282)   PSEC2(12)=FA%CADRE(IRANGC)%XSEC2(10+INIVAU+2+KNIVAU)
(  283) ELSE
(  284)   KSEC2(12)=0
(  285)   PSEC2(1:10+KSEC2(12))=FA%CADRE(IRANGC)%XSEC2(1:10+KSEC2(12))
(  286) ENDIF
(  287) # 288 "fainig.F90"
(  288) !**
(  289) !     3.  -  SECTION 3: the bitmap section






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 17

(  290) !            As KSEC1(5)=128, the Section 3 is omitted => dummy values
(  291) !-----------------------------------------------------------------------
(  292) !
(  293) !     3.1  - INTEGER PART
(  294) !
(  295) ! Flag: 0->bitmap included in the GRIB message, 1->not included
(  296) KSEC3(1)=1
(  297) ! Value used at missing data points in an INTEGER data field
(  298) KSEC3(2)=0
(  299) !
(  300) !     3.2  - REAL PART
(  301) !
(  302) ! Ignored
(  303) PSEC3(1)=0._JPDBLR
(  304) ! Value used at missing data points in an REAL data field
(  305) PSEC3(2)=0._JPDBLR
(  306) !**
(  307) !     4.  -  SECTION 4: the binary data section (integer part only)
(  308) !-----------------------------------------------------------------------
(  309) !
(  310) ! 1: Nb of data values in array PSEC4 to be encoded
(  311) KSEC4(1)=KLCHAM
(  312) ! 2: Nb of bits used for each encoded value
(  313) KSEC4(2)=INBITS
(  314) ! 3: Type of data (0:grid point; 128:spherical harmonic coeff)
(  315) KSEC4(3)=0
(  316) ! 4: Type of packing, only for spectral fields
(  317) !    but also to allow 2nd-order packing for grid points fields
(  318) !    and for Aladin spectral fields (seen as lat-lon grid points
(  319) !    by GRIBEX).
(  320) !    (0:simple packing; 64:complex packing and 2nd-order packing) 
(  321) IF (FA%FICHIER(KRANG)%NCOGRIF(2)==0) THEN
(  322) ! If no Additional flags, then 2nd-order packing is not asked!
(  323)   KSEC4(4)=0
(  324) ELSE
(  325)   KSEC4(4)=64
(  326) ENDIF
(  327) IF (LDCOSP.AND..NOT.LLMLAM) THEN
(  328) ! For spherical harmonics coeff, complex packing is always done
(  329)   KSEC4(3)=128
(  330)   KSEC4(4)=64
(  331) ENDIF
(  332) ! 5: Data representation (0:float; 32:integer)
(  333) KSEC4(5)=0
(  334) ! 6: Additional flags indicator (0:no; 16:yes)
(  335) KSEC4(6)=FA%FICHIER(KRANG)%NCOGRIF(2)
(  336) IF (LDCOSP.AND..NOT.LLMLAM) THEN
(  337) ! For spherical harmonics coeff, additional flags indicator=0
(  338)   KSEC4(6)=0
(  339) ENDIF
(  340) ! 7: Reserved
(  341) KSEC4(7)=FA%FICHIER(KRANG)%NCOGRIF(3)
(  342) ! 8: Nb of values indicator (0:single datum at each grid point; 64:matrix)
(  343) KSEC4(8)=0
(  344) ! 9: Secondary bitmaps indicator (0:no; 32:yes)
(  345) KSEC4(9)=FA%FICHIER(KRANG)%NCOGRIF(4)
(  346) ! 10: Values width indicator (0:2nd order values have constant width; 16:not)
(  347) KSEC4(10)=FA%FICHIER(KRANG)%NCOGRIF(5)






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 18

(  348) ! 11: Nb of bits for 2nd order values when these have constant width
(  349) KSEC4(11)=FA%FICHIER(KRANG)%NCOGRIF(6)
(  350) IF (KSEC4(11).EQ.-99) KSEC4(11)=1-INBITS
(  351) ! 12: General extended 2nd order packing (0:no; 8:yes)
(  352) ! 13: Boustrophedonic ordering (0:no; 4:yes)
(  353) ! 14,15: give the order of spatial differencing; if 0,0 then option rejected
(  354) KSEC4(12:15)=FA%FICHIER(KRANG)%NCOGRIF(7:10)
(  355) ! 16: For complex packing, a pointer to the start of packed data values (octet nb)
(  356) KSEC4(16)=0
(  357) ! 17: For complex packing, the scaling factor factor P, stored as the INTEGER
(  358) !     value P*1000 (in the range -10000,+10000): defined later
(  359) KSEC4(17)=0
(  360) ! 18: For complex packing, the pentagonal resolution parameter J specifying
(  361) !     the truncation of the subset of the data not packed (32 bits)
(  362) KSEC4(18)=0
(  363) ! 19-20: Idem 18 for resolution parameters K and M
(  364) KSEC4(19)=0
(  365) KSEC4(20)=0
(  366) IF (LDCOSP.AND..NOT.LLMLAM) THEN
(  367) ! For spherical harmonics coeff (ARPEGE) only
(  368)   KSEC4(18)=ICPACK
(  369)   KSEC4(19)=ICPACK
(  370)   KSEC4(20)=ICPACK
(  371) ENDIF
(  372) ! 21-33: Reserved
(  373) ! 34-42: 'X' decoding option
(  374) KSEC4(21:FA%JPSEC4)=0
(  375) !**
(  376) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  377) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  378) !-----------------------------------------------------------------------
(  379) !
(  380) 1001 CONTINUE
(  381) LLFATA=LLMOER (KREP,KRANG)
(  382) !
(  383) IF (FA%LFAMOP.OR.LLFATA) THEN
(  384)   INIMES=2
(  385)   CLNSPR='FAINIG'
(  386) !
(  387)   WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KRANG='',I4,  &
(  388) &       '', CDPREF='''''',A,'''''', KNIVAU='',I6,         &
(  389) &       '', CDSUFF='''''',A,'''''', LDCOSP= '',L1)')      &
(  390) &         KREP,KRANG,CDPREF(1:LEN_TRIM(CDPREF)),KNIVAU,   &
(  391) &         CDSUFF(1:LEN_TRIM(CDSUFF)),LDCOSP
(  392)   CALL FAIPAR_MT64                                        &
(  393) &                 (FA, INUMER,INIMES,KREP,.FALSE.,CLMESS, &
(  394) &                  CLNSPR,                                &
(  395) &                  CLNSPR,.FALSE.)
(  396) ENDIF
(  397) !
(  398) IF (LHOOK) CALL DR_HOOK('FAINIG_MT',1,ZHOOK_HANDLE)
(  399) # 400 "fainig.F90"
(  400) CONTAINS
(  401) # 402 "fainig.F90"
(  402) # 1 ".D[27]/facom2.llmoer.h"
(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 19

(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 403 "fainig.F90"
(  403) # 404 "fainig.F90"
(  404) END SUBROUTINE FAINIG_MT64
(  405) # 408 "fainig.F90"
(  408) ! Oct-2012 P. Marguinaud 64b LFI
(  409) SUBROUTINE FAINIG64                                           &
(  410) &           (KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP,     &
(  411) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  412) &            YDGR1TAB)
(  413) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  414) &                  FA_COM_DEFAULT_INIT,  &
(  415) &                  NEW_FA_DEFAULT,       &
(  416) &                  FAGR1TAB
(  417) USE LFI_PRECISION
(  418) IMPLICIT NONE
(  419) ! Arguments
(  420) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  421) INTEGER (KIND=JPLIKB)  KRANG                                  ! IN   
(  422) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  423) INTEGER (KIND=JPLIKB)  KNIVAU                                 ! IN   
(  424) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  425) LOGICAL                LDCOSP                                 ! IN   
(  426) INTEGER (KIND=JPLIKB)  KLCHAM                                 ! IN   
(  427) INTEGER (KIND=JPLIKB)  KSEC1      (FA%JPSEC1)                 !   OUT
(  428) INTEGER (KIND=JPLIKB)  KSEC2      (FA%JPSEC2)                 !   OUT
(  429) REAL (KIND=JPDBLR)     PSEC2      (*)                         !   OUT
(  430) INTEGER (KIND=JPLIKB)  KSEC3      (2)                         !   OUT
(  431) REAL (KIND=JPDBLR)     PSEC3      (*)                         !   OUT
(  432) INTEGER (KIND=JPLIKB)  KSEC4      (FA%JPSEC4)                 !   OUT
(  433) TYPE (FAGR1TAB)        YDGR1TAB                               !   OUT
(  434) # 435 "fainig.F90"
(  435) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  436) # 437 "fainig.F90"
(  437) CALL FAINIG_MT64                                              &
(  438) &           (FA, KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP, &
(  439) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  440) &            YDGR1TAB)
(  441) # 442 "fainig.F90"
(  442) END SUBROUTINE FAINIG64
(  443) # 444 "fainig.F90"
(  444) SUBROUTINE FAINIG                                             &
(  445) &           (KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP,     &
(  446) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  447) &            YDGR1TAB)
(  448) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  449) &                  FA_COM_DEFAULT_INIT,  &
(  450) &                  NEW_FA_DEFAULT,       &
(  451) &                  FAGR1TAB
(  452) USE LFI_PRECISION






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 20

(  453) IMPLICIT NONE
(  454) ! Arguments
(  455) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  456) INTEGER (KIND=JPLIKM)  KRANG                                  ! IN   
(  457) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  458) INTEGER (KIND=JPLIKM)  KNIVAU                                 ! IN   
(  459) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  460) LOGICAL                LDCOSP                                 ! IN   
(  461) INTEGER (KIND=JPLIKM)  KLCHAM                                 ! IN   
(  462) INTEGER (KIND=JPLIKM)  KSEC1      (FA%JPSEC1)                 !   OUT
(  463) INTEGER (KIND=JPLIKM)  KSEC2      (FA%JPSEC2)                 !   OUT
(  464) REAL (KIND=JPDBLR)     PSEC2      (*)                         !   OUT
(  465) INTEGER (KIND=JPLIKM)  KSEC3      (2)                         !   OUT
(  466) REAL (KIND=JPDBLR)     PSEC3      (*)                         !   OUT
(  467) INTEGER (KIND=JPLIKM)  KSEC4      (FA%JPSEC4)                 !   OUT
(  468) TYPE (FAGR1TAB)        YDGR1TAB                               !   OUT
(  469) # 470 "fainig.F90"
(  470) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  471) # 472 "fainig.F90"
(  472) CALL FAINIG_MT                                                &
(  473) &           (FA, KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP, &
(  474) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  475) &            YDGR1TAB)
(  476) # 477 "fainig.F90"
(  477) END SUBROUTINE FAINIG
(  478) # 479 "fainig.F90"
(  479) SUBROUTINE FAINIG_MT                                          &
(  480) &           (FA, KREP, KRANG, CDPREF, KNIVAU, CDSUFF, LDCOSP, &
(  481) &            KLCHAM, KSEC1, KSEC2, PSEC2, KSEC3, PSEC3, KSEC4,&
(  482) &            YDGR1TAB)
(  483) USE FA_MOD, ONLY : FA_COM, FAGR1TAB
(  484) USE LFI_PRECISION
(  485) IMPLICIT NONE
(  486) ! Arguments
(  487) TYPE (FA_COM)          FA                                     ! INOUT
(  488) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  489) INTEGER (KIND=JPLIKM)  KRANG                                  ! IN   
(  490) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  491) INTEGER (KIND=JPLIKM)  KNIVAU                                 ! IN   
(  492) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  493) LOGICAL                LDCOSP                                 ! IN   
(  494) INTEGER (KIND=JPLIKM)  KLCHAM                                 ! IN   
(  495) INTEGER (KIND=JPLIKM)  KSEC1      (FA%JPSEC1)                 !   OUT
(  496) INTEGER (KIND=JPLIKM)  KSEC2      (FA%JPSEC2)                 !   OUT
(  497) REAL (KIND=JPDBLR)     PSEC2      (*)                         !   OUT
(  498) INTEGER (KIND=JPLIKM)  KSEC3      (2)                         !   OUT
(  499) REAL (KIND=JPDBLR)     PSEC3      (*)                         !   OUT
(  500) INTEGER (KIND=JPLIKM)  KSEC4      (FA%JPSEC4)                 !   OUT
(  501) TYPE (FAGR1TAB)        YDGR1TAB                               !   OUT
(  502) ! Local integers
(  503) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  504) INTEGER (KIND=JPLIKB)  IRANG                                  ! IN   
(  505) INTEGER (KIND=JPLIKB)  INIVAU                                 ! IN   
(  506) INTEGER (KIND=JPLIKB)  ILCHAM                                 ! IN   
(  507) INTEGER (KIND=JPLIKB)  ISEC1      (FA%JPSEC1)                 !   OUT
(  508) INTEGER (KIND=JPLIKB)  ISEC2      (FA%JPSEC2)                 !   OUT
(  509) INTEGER (KIND=JPLIKB)  ISEC3      (2)                         !   OUT
(  510) INTEGER (KIND=JPLIKB)  ISEC4      (FA%JPSEC4)                 !   OUT






NVFORTRAN (Version     23.1)          02/24/2023  13:54:33      page 21

(  511) ! Convert arguments
(  512) # 513 "fainig.F90"
(  513) IRANG      = INT (     KRANG, JPLIKB)
(  514) INIVAU     = INT (    KNIVAU, JPLIKB)
(  515) ILCHAM     = INT (    KLCHAM, JPLIKB)
(  516) # 517 "fainig.F90"
(  517) CALL FAINIG_MT64                                              &
(  518) &           (FA, IREP, IRANG, CDPREF, INIVAU, CDSUFF, LDCOSP, &
(  519) &            ILCHAM, ISEC1, ISEC2, PSEC2, ISEC3, PSEC3, ISEC4,&
(  520) &            YDGR1TAB)
(  521) # 522 "fainig.F90"
(  522) KREP       = INT (      IREP, JPLIKM)
(  523) KSEC1      = INT (     ISEC1, JPLIKM)
(  524) KSEC2      = INT (     ISEC2, JPLIKM)
(  525) KSEC3      = INT (     ISEC3, JPLIKM)
(  526) KSEC4      = INT (     ISEC4, JPLIKM)
(  527) # 528 "fainig.F90"
(  528) END SUBROUTINE FAINIG_MT
(  529) # 530 "fainig.F90"
(  530) !INTF KREP            OUT                               
(  531) !INTF KRANG         IN                                  
(  532) !INTF CDPREF        IN                                  
(  533) !INTF KNIVAU        IN                                  
(  534) !INTF CDSUFF        IN                                  
(  535) !INTF LDCOSP        IN                                  
(  536) !INTF KLCHAM        IN                                  
(  537) !INTF KSEC1           OUT DIMS=FA%JPSEC1                
(  538) !INTF KSEC2           OUT DIMS=FA%JPSEC2                
(  539) !INTF PSEC2           OUT DIMS=*                        
(  540) !INTF KSEC3           OUT DIMS=2                        
(  541) !INTF PSEC3           OUT DIMS=*                        
(  542) !INTF KSEC4           OUT DIMS=FA%JPSEC4                
(  543) !INTF YDGR1TAB        OUT
