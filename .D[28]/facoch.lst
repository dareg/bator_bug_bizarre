


NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: facoch.F90

(    1) ! Oct-2012 P. Marguinaud Use JNGEOM & JNEXPL parameters
(    2) ! Oct-2012 P. Marguinaud 64b LFI
(    3) ! Jan-2011 P. Marguinaud Thread-safe FA
(    4) SUBROUTINE FACOCH_MT64                           &
(    5) &                     (FA,  KREP, KNUME1, KNUME2,  &
(    6) &                      CDPREF, KNIVAU, CDSUFF )
(    7) USE FA_MOD, ONLY : FA_COM, JPNIIL, JNGEOM, JNEXPL
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !      Sous-programme de reCOpie d'un Champ Horizontal d'un fichier
(   14) !     ARPEGE sur un autre.
(   15) !**
(   16) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   17) !                KNUME1 (Entree) ==> Numero d'unite logique en entree;
(   18) !                KNUME2 (Entree) ==> Numero d'unite logique en sortie;
(   19) !                CDPREF (Entree) ==> Prefixe eventuel du nom d'article;
(   20) !                KNIVAU (Entree) ==> Niveau vertical eventuel;
(   21) !                CDSUFF (Entree) ==> Suffixe eventuel du nom d'article.
(   22) !
(   23) !     Modifications
(   24) !     -------------
(   25) !
(   26) !  Avril 2004, D. Paradis, DSI/DEV:
(   27) !    -Declaration IVALCO en ALLOCATABLE (gain memoire)
(   28) !  Juin  2004, D. Paradis, DSI/DEV:
(   29) !    -Prise en compte des codages type -1 et 3
(   30) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 3

(   31) !
(   32) !
(   33) TYPE(FA_COM) :: FA
(   34) INTEGER (KIND=JPLIKB) KREP, KNUME1, KNUME2, KNIVAU
(   35) !
(   36) INTEGER (KIND=JPLIKB) IREP, ILPRFU, ILSUFU, ILNOMU
(   37) INTEGER (KIND=JPLIKB) ILONGA, IRANC1, IRANC2
(   38) INTEGER (KIND=JPLIKB) INIMES, J, INUMFI, IPOSEX, INPAHE
(   39) INTEGER (KIND=JPLIKB) INPAHEL, JLAT, IZPAHEL
(   40) INTEGER (KIND=JPLIKB) ISPAHEL, JNIV, ILPREF, ILSUFF
(   41) INTEGER (KIND=JPLIKB) INUMRO, IRANG2, IGRIB
(   42) !
(   43) INTEGER (KIND=JPLIKB), ALLOCATABLE :: IVALCO(:)
(   44) INTEGER (KIND=JPLIKB) IRANG (2), INUMER (2), IB1PAR (3)
(   45) !
(   46) LOGICAL LLVERF (2), LLRLFI, LLCOSP, LLMESS, LLNOMU
(   47) LOGICAL LLMLAM1, LLMLAM2
(   48) !
(   49) CHARACTER CDPREF*(*), CDSUFF*(*)
(   50) CHARACTER CLPREF*(FA%JPXNOM),  &
(   51) &          CLSUFF*(FA%JPXSUF)
(   52) !
(   53) CHARACTER(LEN=FA%JPXNOM) CLACTI 
(   54) CHARACTER(LEN=FA%JPXNOM) CLNOMA
(   55) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   56) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   57) LOGICAL                  LLFATA
(   58) 
(   59) !**
(   60) !     1.  -  CONTROLES ET INITIALISATIONS.
(   61) !-----------------------------------------------------------------------
(   62) !
(   63) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   64) IF (LHOOK) CALL DR_HOOK('FACOCH_MT',0,ZHOOK_HANDLE)
(   65) CLACTI=''
(   66) LLRLFI=.FALSE.
(   67) LLMESS=.FALSE.
(   68) LLNOMU=.FALSE.
(   69) ILPRFU=INT (LEN (CDPREF), JPLIKB)
(   70) ILSUFU=INT (LEN (CDSUFF), JPLIKB)
(   71) IRANC1=0
(   72) IRANC2=0
(   73) INUMER(1)=KNUME1
(   74) INUMER(2)=KNUME2
(   75) LLVERF(1)=.FALSE.
(   76) LLVERF(2)=.FALSE.
(   77) IRANG(2)=0
(   78) !
(   79) DO J=1,2
(   80) INUMFI=J
(   81) CALL FANUMU_MT64                       &
(   82) &               (FA, INUMER(J),IRANG(J))
(   83) !
(   84) IF (IRANG(J).EQ.0) THEN
(   85)   IREP=-51
(   86)   GOTO 1001
(   87) ENDIF
(   88) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 4

(   89) !         Verrouillage eventuel du fichier.
(   90) !
(   91) IF (FA%LFAMUL) CALL LFIVER_MT64                                  &
(   92) &                              (FA%LFI, FA%FICHIER(IRANG(J))%VRFICH,'ON')
(   93) LLVERF(J)=FA%LFAMUL
(   94) !
(   95) IF (FA%FICHIER(IRANG(J))%LCREAF) THEN
(   96)   IREP=-85
(   97)   GOTO 1001
(   98) ENDIF
(   99) !*
(  100) !       FABRICATION DU NOM D'ARTICLE VIA LE SOUS-PROGRAMME "FANFAR"
(  101) !            ( controles de CDPREF, KNIVAU, CDSUFF inclus )
(  102) !
(  103) CALL FANFAR_MT64                                &
(  104) &               (FA, IREP,IRANG(J),CDPREF,KNIVAU, &
(  105) &             CDSUFF,CLNOMA,IB1PAR,               &
(  106) &             ILPRFU,ILSUFU,ILNOMU)
(  107) IF (IREP.NE.0) GOTO 1001
(  108) ENDDO
(  109) !
(  110) LLNOMU=.TRUE.
(  111) !**
(  112) !     2.  -  LECTURE DE L'ARTICLE SUR LE FICHIER, CONTROLES.
(  113) !-----------------------------------------------------------------------
(  114) !
(  115) CALL LFINFO_MT64                                      &
(  116) &               (FA%LFI, IREP,KNUME1,CLNOMA(1:ILNOMU), &
(  117) &             ILONGA,IPOSEX)
(  118) !
(  119) IF (IREP.NE.0) THEN
(  120)   LLRLFI=.TRUE.
(  121)   GOTO 1001
(  122) ELSEIF (ILONGA.EQ.0) THEN
(  123)   IREP=-89
(  124)   GOTO 1001
(  125) ELSEIF (ILONGA.GT.FA%JPXCHA+2) THEN
(  126)   IREP=-90
(  127)   GOTO 1001
(  128) ENDIF
(  129) !
(  130) ALLOCATE (IVALCO (ILONGA))
(  131) CALL LFILEC_MT64                             &
(  132) &               (FA%LFI, IREP,KNUME1,         &
(  133) &             CLNOMA(1:ILNOMU),IVALCO,ILONGA)
(  134) LLRLFI=IREP.NE.0
(  135) IF (LLRLFI) GOTO 1001
(  136) !
(  137) IF ((IVALCO(1).LT.-1.OR.IVALCO(1).GT.3).AND.(.NOT.FALGRA(IVALCO(1))).OR.                        &
(  138) &    IVALCO(2).LT.0 .OR.IVALCO(2).GT.1.OR.                        &
(  139) &    (IVALCO(1).GT.0.AND.IVALCO(2).EQ.1.AND.IVALCO(4).LT.0)) THEN
(  140)   IREP=-91
(  141)   GOTO 1001
(  142) ELSE
(  143)   LLCOSP=IVALCO(2).EQ.1
(  144) ENDIF
(  145) !**
(  146) !     3.  -  CONTROLE DE COHERENCE ENTRE LES FICHIERS, VIS-A-VIS DU TYPE






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 5

(  147) !            DE DONNEES LUES (points de grille/coefficients spectraux).
(  148) !-----------------------------------------------------------------------
(  149) !
(  150) IRANC1=FA%FICHIER(IRANG(1))%NUCADR
(  151) IRANC2=FA%FICHIER(IRANG(2))%NUCADR
(  152) INPAHE=(1+FA%CADRE(IRANC1)%NLATIT)/2
(  153) LLMLAM1=FA%CADRE(IRANC1)%NTYPTR.LE. -1
(  154) LLMLAM2=FA%CADRE(IRANC2)%NTYPTR.LE. -1
(  155) !
(  156) IF (IRANC1.NE.IRANC2) THEN
(  157) !
(  158) !         On a pris ici une optique souple: n'est fatale qu'une erreur
(  159) !     vraiment grossiere. Toute autre discordance est signalee par un
(  160) !     message global de niveau 1.
(  161) !
(  162)   IF ( (LLMLAM1.AND..NOT.LLMLAM2).OR.                             &
(  163) &       (LLMLAM2.AND..NOT.LLMLAM1).OR.                             &
(  164) &       (LLCOSP.AND.((.NOT.LLMLAM1.AND..NOT.LLMLAM2.AND.           &
(  165) &                     FA%CADRE(IRANC1)%MTRONC.NE.FA%CADRE(IRANC2)%MTRONC) .OR. &
(  166) &                    (LLMLAM1.AND.LLMLAM2.AND.                     &
(  167) &                     FA%CADRE(IRANC1)%MTRONC.NE.FA%CADRE(IRANC2)%MTRONC.AND.  &
(  168) &                     FA%CADRE(IRANC1)%NTYPTR.NE.FA%CADRE(IRANC2)%NTYPTR ))    &
(  169) &                    ).OR.                                         &
(  170) &       (.NOT.LLCOSP.AND.(FA%CADRE(IRANC1)%NLATIT.NE.                    &
(  171) &                         FA%CADRE(IRANC2)%NLATIT.OR.                    &
(  172) &                         FA%CADRE(IRANC1)%NVAPDG.NE.FA%CADRE(IRANC2)%NVAPDG)) &
(  173) &     ) THEN
(  174)     IREP=-112
(  175)     GOTO 1001
(  176) !
(  177)   ELSEIF (.NOT.LLCOSP) THEN
(  178) !
(  179)     IF (.NOT.LLMLAM1.AND..NOT.LLMLAM2) THEN
(  180)        INPAHEL=INPAHE
(  181)     ELSE
(  182)        INPAHEL=8
(  183)     ENDIF
(  184)     DO JLAT=1,INPAHEL
(  185)     LLMESS=LLMESS.OR.FA%CADRE(IRANC1)%NLOPAR(JLAT).NE. &
(  186) &           FA%CADRE(IRANC2)%NLOPAR(JLAT)
(  187)     ENDDO
(  188) !
(  189)     IF (LLMESS) THEN
(  190)       IREP=-112
(  191)       GOTO 1001
(  192)     ENDIF
(  193) !
(  194)   ENDIF
(  195) !
(  196)   LLMESS=FA%CADRE(IRANC1)%MTRONC.NE.FA%CADRE(IRANC2)%MTRONC.OR. &
(  197) &         FA%CADRE(IRANC1)%NTYPTR.NE.FA%CADRE(IRANC2)%NTYPTR.OR. &
(  198) &       (KNIVAU.GT.0.AND.(FA%CADRE(IRANC1)%NNIVER.NE.      &
(  199) &                         FA%CADRE(IRANC2)%NNIVER).OR.     &
(  200) &                        (FA%CADRE(IRANC1)%SPREFE.NE.      &
(  201) &                         FA%CADRE(IRANC2)%SPREFE)).OR.    &
(  202) &         FA%CADRE(IRANC1)%NLATIT.NE.FA%CADRE(IRANC2)%NLATIT.OR. &
(  203) &         FA%CADRE(IRANC1)%SSLAPO.NE.FA%CADRE(IRANC2)%SSLAPO.OR. &
(  204) &         FA%CADRE(IRANC1)%SCLOPO.NE.FA%CADRE(IRANC2)%SCLOPO.OR. &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 6

(  205) &         FA%CADRE(IRANC1)%SSLOPO.NE.FA%CADRE(IRANC2)%SSLOPO.OR. &
(  206) &         FA%CADRE(IRANC1)%SCODIL.NE.FA%CADRE(IRANC2)%SCODIL
(  207) !
(  208)   IF (.NOT.LLMESS) THEN
(  209) !
(  210)     IF (.NOT.LLMLAM1.AND..NOT.LLMLAM2) THEN
(  211)        INPAHEL=INPAHE
(  212)        IZPAHEL=INPAHE
(  213)        ISPAHEL=INPAHE
(  214)     ELSE
(  215)        INPAHEL=JNEXPL
(  216)        IZPAHEL=0
(  217)        ISPAHEL=JNGEOM
(  218)     ENDIF
(  219)     DO JLAT=1,INPAHEL
(  220)     LLMESS=FA%CADRE(IRANC1)%NLOPAR(JLAT).NE.FA%CADRE(IRANC2)%NLOPAR(JLAT) &
(  221) &           .OR.LLMESS
(  222)     ENDDO
(  223)     DO JLAT=1,IZPAHEL
(  224)     LLMESS=FA%CADRE(IRANC1)%NOZPAR(JLAT).NE.FA%CADRE(IRANC2)%NOZPAR(JLAT) &
(  225) &           .OR.LLMESS
(  226)     ENDDO
(  227)     DO JLAT=1,ISPAHEL
(  228)     LLMESS=FA%CADRE(IRANC1)%SINLAT(JLAT).NE.FA%CADRE(IRANC2)%SINLAT(JLAT) &
(  229) &           .OR.LLMESS
(  230)     ENDDO
(  231) !
(  232)     IF (.NOT.LLMESS.AND.KNIVAU.GT.0) THEN
(  233) !
(  234)       DO JNIV=0,FA%CADRE(IRANC1)%NNIVER
(  235)       LLMESS=FA%CADRE(IRANC1)%SFOHYB(1,JNIV).NE.    &
(  236) &             FA%CADRE(IRANC2)%SFOHYB(1,JNIV).OR.    &
(  237) &      LLMESS.OR.FA%CADRE(IRANC1)%SFOHYB(2,JNIV).NE. &
(  238) &             FA%CADRE(IRANC2)%SFOHYB(2,JNIV)
(  239)       ENDDO
(  240) !
(  241)     ENDIF
(  242) !
(  243)   ENDIF
(  244) !
(  245) ENDIF
(  246) !**
(  247) !     4.  -  ECRITURE DE L'ARTICLE "CHAMP" SUR LE FICHIER.
(  248) !-----------------------------------------------------------------------
(  249) !
(  250) !        Deverrouillage eventuel de l'unite logique d'entree.
(  251) !
(  252) IF (LLVERF(1)) CALL LFIVER_MT64                                   &
(  253) &                              (FA%LFI, FA%FICHIER(IRANG(1))%VRFICH,'OFF')
(  254) LLVERF(1)=.FALSE.
(  255) !
(  256) CALL LFIECR_MT64                                      &
(  257) &               (FA%LFI, IREP,KNUME2,CLNOMA(1:ILNOMU), &
(  258) &             IVALCO,ILONGA)
(  259) INUMFI=2
(  260) LLRLFI=IREP.NE.0
(  261) IF (LLRLFI) GOTO 1001
(  262) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 7

(  263) !  Controle de l'homogeneite du type de rangement de coeff. spectraux
(  264) !  parmi les champs lus/ecrits: ces champs compactes avec
(  265) !  IGRIB=-1 ou 3 doivent etre ranges comme dans le modele ("verticalement"
(  266) !  soit selon des colonnes JM=cst consecutives) et contrairement si compactes
(  267) !  avec IGRIB= 0,1 ou 2.
(  268) !
(  269) IRANG2 = IRANG(2)
(  270) IGRIB = IVALCO(1)
(  271) IF (LLCOSP) THEN
(  272)   IF (IGRIB.EQ.-1 .OR. IGRIB.EQ.3) THEN
(  273)     FA%FICHIER(IRANG2)%NRASVE=FA%FICHIER(IRANG2)%NRASVE+1
(  274)     IF (FA%FICHIER(IRANG2)%NRASVE.EQ.1 .AND. FA%FICHIER(IRANG2)%NRASHO.GT.0) THEN
(  275)       WRITE(FA%NULOUT,*)                                 &
(  276) &      '------------------------------------------------'
(  277)       WRITE(FA%NULOUT,*)' FACOCH : WARNING !!!!!           '
(  278)       WRITE(FA%NULOUT,*)                                 &
(  279) &      ' Un champ de coef. spect. avec rangt type modele'
(  280)       WRITE(FA%NULOUT,*)' va etre ecrit sur l''unite ',KNUME2, &
(  281) &                ' alors que'
(  282)       WRITE(FA%NULOUT,*)                                &
(  283) &      ' d''autres champs y ont un rangement different.'
(  284)       WRITE(FA%NULOUT,*)                                 &
(  285) &      '------------------------------------------------'
(  286)     ENDIF
(  287)   ELSEIF (IGRIB.GE.0 .AND. IGRIB.LE.2) THEN
(  288)     FA%FICHIER(IRANG2)%NRASHO=FA%FICHIER(IRANG2)%NRASHO+1
(  289)     IF (FA%FICHIER(IRANG2)%NRASHO.EQ.1 .AND. FA%FICHIER(IRANG2)%NRASVE.GT.0) THEN
(  290)       WRITE(FA%NULOUT,*)                                 &
(  291) &      '------------------------------------------------'
(  292)       WRITE(FA%NULOUT,*)' FACOCH : WARNING !!!!!           '
(  293)       WRITE(FA%NULOUT,*)                               &
(  294) &      ' Un champ de coef. spect. avec rangt autre que'
(  295)       WRITE(FA%NULOUT,*)                                     &
(  296) &      ' celui du modele va etre ecrit sur l''unite ', KNUME2
(  297)       WRITE(FA%NULOUT,*)                                  &
(  298) &      ' alors que d''autres champs y ont le rangt modele'
(  299)       WRITE(FA%NULOUT,*)                                 &
(  300) &      '------------------------------------------------'
(  301)     ENDIF
(  302)   ENDIF
(  303) ENDIF
(  304) !
(  305) !**
(  306) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  307) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  308) !-----------------------------------------------------------------------
(  309) !
(  310) 1001 CONTINUE
(  311) IF (ALLOCATED( IVALCO )) DEALLOCATE ( IVALCO )
(  312) KREP=IREP
(  313) LLFATA=LLMOER (IREP,IRANG(INUMFI))
(  314) !
(  315) !        Deverrouillage eventuel des fichiers.
(  316) !
(  317) IF (LLVERF(1)) CALL LFIVER_MT64                                   &
(  318) &                              (FA%LFI, FA%FICHIER(IRANG(1))%VRFICH,'OFF')
(  319) IF (LLVERF(2)) CALL LFIVER_MT64                                   &
(  320) &                              (FA%LFI, FA%FICHIER(IRANG(2))%VRFICH,'OFF')






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 8

(  321) !
(  322) CLNSPR='FACOCH'
(  323) !
(  324) !        Messages d'avertissement eventuels.
(  325) !
(  326) IF (FA%NIMSGA.NE.0.AND.IREP.EQ.0) THEN
(  327) !
(  328)   IF (LLMESS) THEN
(  329)     INIMES=1
(  330)     WRITE (UNIT=CLMESS,FMT='(''*ATTENTION* - LES UNITES'',I3,      &
(  331) &   '' ET'',I3,'' ONT DES CARACTERISTIQUES "CADRE" DIFFERENTES'')') &
(  332) &    KNUME1,KNUME2
(  333)     CALL FAIPAR_MT64                                         &
(  334) &                   (FA, JPNIIL,INIMES,IREP,.FALSE.,CLMESS, &
(  335) &                 CLNSPR,CLACTI,.FALSE.)
(  336)   ELSEIF (IRANC1.NE.IRANC2) THEN
(  337)     INIMES=1
(  338)     WRITE (UNIT=CLMESS,FMT='(''REMARQUE: CADRES '''''',A,        &
(  339) &           '''''' ET '''''',A,                                   &
(  340) &           '''''' DISTINCTS MAIS DE CONTENU IDENTIQUE (UNITES'', &
(  341) &           I3,'' ET'',I3,'' )'')')                               &
(  342) &      FA%CADRE(IRANC1)%CNOMCA(1:FA%CADRE(IRANC1)%NLCCAD),                    &
(  343) &      FA%CADRE(IRANC2)%CNOMCA(1:FA%CADRE(IRANC2)%NLCCAD),KNUME1,KNUME2
(  344)     CALL FAIPAR_MT64                                         &
(  345) &                   (FA, JPNIIL,INIMES,IREP,.FALSE.,CLMESS, &
(  346) &                 CLNSPR,CLACTI,.FALSE.)
(  347)   ENDIF
(  348) !
(  349) ENDIF
(  350) !
(  351) IF (LLFATA) THEN
(  352)   INIMES=2
(  353) ELSE
(  354)   INIMES=IXNVMS(IRANG(INUMFI))
(  355) ENDIF
(  356) !
(  357) IF (.NOT.LLFATA.AND.INIMES.NE.2)  THEN 
(  358)   IF (LHOOK) CALL DR_HOOK('FACOCH_MT',1,ZHOOK_HANDLE)
(  359)   RETURN
(  360) ENDIF
(  361) !
(  362) IF (ILPRFU.GE.1) THEN
(  363)   ILPREF=MIN (ILPRFU,INT (LEN (CLPREF), JPLIKB))
(  364)   CLPREF(1:ILPREF)=CDPREF(1:ILPREF)
(  365) ELSE
(  366)   ILPREF=8
(  367)   CLPREF(1:ILPREF)=FA%CHAINC(:ILPREF)
(  368) ENDIF
(  369) !
(  370) IF (ILSUFU.GE.1) THEN
(  371)   ILSUFF=MIN (ILSUFU,INT (LEN (CLSUFF), JPLIKB))
(  372)   CLSUFF(1:ILSUFF)=CDSUFF(1:ILSUFF)
(  373) ELSE
(  374)   ILSUFF=8
(  375)   CLSUFF(1:ILSUFF)=FA%CHAINC(:ILSUFF)
(  376) ENDIF
(  377) !
(  378) IF (.NOT.LLNOMU) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 9

(  379)   ILNOMU=MIN (ILPREF,FA%NCPCAD)
(  380)   CLNOMA(1:ILNOMU)=CLPREF(1:ILPREF)
(  381) ENDIF
(  382) !
(  383) WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUME1='',I3,           &
(  384) &       '', KNUME2='',I3,'', CDPREF='''''',A,'''''', KNIVAU='',I6, &
(  385) &       '', CDSUFF='''''',A,'''''''')') KREP,KNUME1,KNUME2,        &
(  386) &   CLPREF(1:ILPREF),KNIVAU,CLSUFF(1:ILSUFF)
(  387) !
(  388) IF (IREP.EQ.-112) THEN
(  389)   INUMRO=1000*KNUME1+KNUME2
(  390) ELSE
(  391)   INUMRO=INUMER(INUMFI)
(  392) ENDIF
(  393) !
(  394) CALL FAIPAR_MT64                                     &
(  395) &               (FA, INUMRO,INIMES,IREP,LLFATA,CLMESS, &
(  396) &                CLNSPR, CLNOMA(1:ILNOMU),LLRLFI)
(  397) !
(  398) IF (LHOOK) CALL DR_HOOK('FACOCH_MT',1,ZHOOK_HANDLE)
(  399) 
(  400) CONTAINS
(  401) 
(  402) #include "facom2.llmoer.h"
(  403) #include "facom2.ixnvms.h"
(  404) #include "falgra.h"
(  405) 
(  406) END SUBROUTINE FACOCH_MT64
(  407) 
(  408) 
(  409) 
(  410) ! Oct-2012 P. Marguinaud 64b LFI
(  411) SUBROUTINE FACOCH64                                      &
(  412) &           (KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  413) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  414) &                   FA_COM_DEFAULT_INIT,  &
(  415) &                   NEW_FA_DEFAULT
(  416) USE LFI_PRECISION
(  417) IMPLICIT NONE
(  418) ! Arguments
(  419) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  420) INTEGER (KIND=JPLIKB)  KNUME1                                 ! IN   
(  421) INTEGER (KIND=JPLIKB)  KNUME2                                 ! IN   
(  422) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  423) INTEGER (KIND=JPLIKB)  KNIVAU                                 ! IN   
(  424) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  425) 
(  426) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  427) 
(  428) CALL FACOCH_MT64                                             &
(  429) &           (FA, KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  430) 
(  431) END SUBROUTINE FACOCH64
(  432) 
(  433) SUBROUTINE FACOCH                                        &
(  434) &           (KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  435) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  436) &                   FA_COM_DEFAULT_INIT,  &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 10

(  437) &                   NEW_FA_DEFAULT
(  438) USE LFI_PRECISION
(  439) IMPLICIT NONE
(  440) ! Arguments
(  441) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  442) INTEGER (KIND=JPLIKM)  KNUME1                                 ! IN   
(  443) INTEGER (KIND=JPLIKM)  KNUME2                                 ! IN   
(  444) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  445) INTEGER (KIND=JPLIKM)  KNIVAU                                 ! IN   
(  446) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  447) 
(  448) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  449) 
(  450) CALL FACOCH_MT                                               &
(  451) &           (FA, KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  452) 
(  453) END SUBROUTINE FACOCH
(  454) 
(  455) SUBROUTINE FACOCH_MT                                         &
(  456) &           (FA, KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  457) USE FA_MOD, ONLY : FA_COM
(  458) USE LFI_PRECISION
(  459) IMPLICIT NONE
(  460) ! Arguments
(  461) TYPE (FA_COM)          FA                                     ! INOUT
(  462) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  463) INTEGER (KIND=JPLIKM)  KNUME1                                 ! IN   
(  464) INTEGER (KIND=JPLIKM)  KNUME2                                 ! IN   
(  465) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  466) INTEGER (KIND=JPLIKM)  KNIVAU                                 ! IN   
(  467) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  468) ! Local integers
(  469) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  470) INTEGER (KIND=JPLIKB)  INUME1                                 ! IN   
(  471) INTEGER (KIND=JPLIKB)  INUME2                                 ! IN   
(  472) INTEGER (KIND=JPLIKB)  INIVAU                                 ! IN   
(  473) ! Convert arguments
(  474) 
(  475) INUME1     = INT (    KNUME1, JPLIKB)
(  476) INUME2     = INT (    KNUME2, JPLIKB)
(  477) INIVAU     = INT (    KNIVAU, JPLIKB)
(  478) 
(  479) CALL FACOCH_MT64                                             &
(  480) &           (FA, IREP, INUME1, INUME2, CDPREF, INIVAU, CDSUFF)
(  481) 
(  482) KREP       = INT (      IREP, JPLIKM)
(  483) 
(  484) END SUBROUTINE FACOCH_MT
(  485) 
(  486) !INTF KREP            OUT 
(  487) !INTF KNUME1        IN    
(  488) !INTF KNUME2        IN    
(  489) !INTF CDPREF        IN    
(  490) !INTF KNIVAU        IN    
(  491) !INTF CDSUFF        IN    









NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 11

(    1) # 1 "facoch.F90"
(    1) ! Oct-2012 P. Marguinaud Use JNGEOM & JNEXPL parameters
(    2) ! Oct-2012 P. Marguinaud 64b LFI
(    3) ! Jan-2011 P. Marguinaud Thread-safe FA
(    4) SUBROUTINE FACOCH_MT64                           &
(    5) &                     (FA,  KREP, KNUME1, KNUME2,  &
(    6) &                      CDPREF, KNIVAU, CDSUFF )
(    7) USE FA_MOD, ONLY : FA_COM, JPNIIL, JNGEOM, JNEXPL
(    8) USE PARKIND1, ONLY : JPRB
(    9) USE YOMHOOK , ONLY : LHOOK, DR_HOOK
(   10) USE LFI_PRECISION
(   11) IMPLICIT NONE
(   12) !****
(   13) !      Sous-programme de reCOpie d'un Champ Horizontal d'un fichier
(   14) !     ARPEGE sur un autre.
(   15) !**
(   16) !    Arguments : KREP   (Sortie) ==> Code-reponse du sous-programme;
(   17) !                KNUME1 (Entree) ==> Numero d'unite logique en entree;
(   18) !                KNUME2 (Entree) ==> Numero d'unite logique en sortie;
(   19) !                CDPREF (Entree) ==> Prefixe eventuel du nom d'article;
(   20) !                KNIVAU (Entree) ==> Niveau vertical eventuel;
(   21) !                CDSUFF (Entree) ==> Suffixe eventuel du nom d'article.
(   22) !
(   23) !     Modifications
(   24) !     -------------
(   25) !
(   26) !  Avril 2004, D. Paradis, DSI/DEV:
(   27) !    -Declaration IVALCO en ALLOCATABLE (gain memoire)
(   28) !  Juin  2004, D. Paradis, DSI/DEV:
(   29) !    -Prise en compte des codages type -1 et 3
(   30) !
(   31) !
(   32) !
(   33) TYPE(FA_COM) :: FA
(   34) INTEGER (KIND=JPLIKB) KREP, KNUME1, KNUME2, KNIVAU
(   35) !
(   36) INTEGER (KIND=JPLIKB) IREP, ILPRFU, ILSUFU, ILNOMU
(   37) INTEGER (KIND=JPLIKB) ILONGA, IRANC1, IRANC2
(   38) INTEGER (KIND=JPLIKB) INIMES, J, INUMFI, IPOSEX, INPAHE
(   39) INTEGER (KIND=JPLIKB) INPAHEL, JLAT, IZPAHEL
(   40) INTEGER (KIND=JPLIKB) ISPAHEL, JNIV, ILPREF, ILSUFF
(   41) INTEGER (KIND=JPLIKB) INUMRO, IRANG2, IGRIB
(   42) !
(   43) INTEGER (KIND=JPLIKB), ALLOCATABLE :: IVALCO(:)
(   44) INTEGER (KIND=JPLIKB) IRANG (2), INUMER (2), IB1PAR (3)
(   45) !
(   46) LOGICAL LLVERF (2), LLRLFI, LLCOSP, LLMESS, LLNOMU
(   47) LOGICAL LLMLAM1, LLMLAM2
(   48) !
(   49) CHARACTER CDPREF*(*), CDSUFF*(*)
(   50) CHARACTER CLPREF*(FA%JPXNOM),  &
(   51) &          CLSUFF*(FA%JPXSUF)
(   52) !
(   53) CHARACTER(LEN=FA%JPXNOM) CLACTI 
(   54) CHARACTER(LEN=FA%JPXNOM) CLNOMA
(   55) CHARACTER(LEN=FA%JPLMES) CLMESS 
(   56) CHARACTER(LEN=FA%JPLSPX) CLNSPR
(   57) LOGICAL                  LLFATA






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 12

(   58) # 59 "facoch.F90"
(   59) !**
(   60) !     1.  -  CONTROLES ET INITIALISATIONS.
(   61) !-----------------------------------------------------------------------
(   62) !
(   63) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(   64) IF (LHOOK) CALL DR_HOOK('FACOCH_MT',0,ZHOOK_HANDLE)
(   65) CLACTI=''
(   66) LLRLFI=.FALSE.
(   67) LLMESS=.FALSE.
(   68) LLNOMU=.FALSE.
(   69) ILPRFU=INT (LEN (CDPREF), JPLIKB)
(   70) ILSUFU=INT (LEN (CDSUFF), JPLIKB)
(   71) IRANC1=0
(   72) IRANC2=0
(   73) INUMER(1)=KNUME1
(   74) INUMER(2)=KNUME2
(   75) LLVERF(1)=.FALSE.
(   76) LLVERF(2)=.FALSE.
(   77) IRANG(2)=0
(   78) !
(   79) DO J=1,2
(   80) INUMFI=J
(   81) CALL FANUMU_MT64                       &
(   82) &               (FA, INUMER(J),IRANG(J))
(   83) !
(   84) IF (IRANG(J).EQ.0) THEN
(   85)   IREP=-51
(   86)   GOTO 1001
(   87) ENDIF
(   88) !
(   89) !         Verrouillage eventuel du fichier.
(   90) !
(   91) IF (FA%LFAMUL) CALL LFIVER_MT64                                  &
(   92) &                              (FA%LFI, FA%FICHIER(IRANG(J))%VRFICH,'ON')
(   93) LLVERF(J)=FA%LFAMUL
(   94) !
(   95) IF (FA%FICHIER(IRANG(J))%LCREAF) THEN
(   96)   IREP=-85
(   97)   GOTO 1001
(   98) ENDIF
(   99) !*
(  100) !       FABRICATION DU NOM D'ARTICLE VIA LE SOUS-PROGRAMME "FANFAR"
(  101) !            ( controles de CDPREF, KNIVAU, CDSUFF inclus )
(  102) !
(  103) CALL FANFAR_MT64                                &
(  104) &               (FA, IREP,IRANG(J),CDPREF,KNIVAU, &
(  105) &             CDSUFF,CLNOMA,IB1PAR,               &
(  106) &             ILPRFU,ILSUFU,ILNOMU)
(  107) IF (IREP.NE.0) GOTO 1001
(  108) ENDDO
(  109) !
(  110) LLNOMU=.TRUE.
(  111) !**
(  112) !     2.  -  LECTURE DE L'ARTICLE SUR LE FICHIER, CONTROLES.
(  113) !-----------------------------------------------------------------------
(  114) !
(  115) CALL LFINFO_MT64                                      &






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 13

(  116) &               (FA%LFI, IREP,KNUME1,CLNOMA(1:ILNOMU), &
(  117) &             ILONGA,IPOSEX)
(  118) !
(  119) IF (IREP.NE.0) THEN
(  120)   LLRLFI=.TRUE.
(  121)   GOTO 1001
(  122) ELSEIF (ILONGA.EQ.0) THEN
(  123)   IREP=-89
(  124)   GOTO 1001
(  125) ELSEIF (ILONGA.GT.FA%JPXCHA+2) THEN
(  126)   IREP=-90
(  127)   GOTO 1001
(  128) ENDIF
(  129) !
(  130) ALLOCATE (IVALCO (ILONGA))
(  131) CALL LFILEC_MT64                             &
(  132) &               (FA%LFI, IREP,KNUME1,         &
(  133) &             CLNOMA(1:ILNOMU),IVALCO,ILONGA)
(  134) LLRLFI=IREP.NE.0
(  135) IF (LLRLFI) GOTO 1001
(  136) !
(  137) IF ((IVALCO(1).LT.-1.OR.IVALCO(1).GT.3).AND.(.NOT.FALGRA(IVALCO(1))).OR.                        &
(  138) &    IVALCO(2).LT.0 .OR.IVALCO(2).GT.1.OR.                        &
(  139) &    (IVALCO(1).GT.0.AND.IVALCO(2).EQ.1.AND.IVALCO(4).LT.0)) THEN
(  140)   IREP=-91
(  141)   GOTO 1001
(  142) ELSE
(  143)   LLCOSP=IVALCO(2).EQ.1
(  144) ENDIF
(  145) !**
(  146) !     3.  -  CONTROLE DE COHERENCE ENTRE LES FICHIERS, VIS-A-VIS DU TYPE
(  147) !            DE DONNEES LUES (points de grille/coefficients spectraux).
(  148) !-----------------------------------------------------------------------
(  149) !
(  150) IRANC1=FA%FICHIER(IRANG(1))%NUCADR
(  151) IRANC2=FA%FICHIER(IRANG(2))%NUCADR
(  152) INPAHE=(1+FA%CADRE(IRANC1)%NLATIT)/2
(  153) LLMLAM1=FA%CADRE(IRANC1)%NTYPTR.LE. -1
(  154) LLMLAM2=FA%CADRE(IRANC2)%NTYPTR.LE. -1
(  155) !
(  156) IF (IRANC1.NE.IRANC2) THEN
(  157) !
(  158) !         On a pris ici une optique souple: n'est fatale qu'une erreur
(  159) !     vraiment grossiere. Toute autre discordance est signalee par un
(  160) !     message global de niveau 1.
(  161) !
(  162)   IF ( (LLMLAM1.AND..NOT.LLMLAM2).OR.                             &
(  163) &       (LLMLAM2.AND..NOT.LLMLAM1).OR.                             &
(  164) &       (LLCOSP.AND.((.NOT.LLMLAM1.AND..NOT.LLMLAM2.AND.           &
(  165) &                     FA%CADRE(IRANC1)%MTRONC.NE.FA%CADRE(IRANC2)%MTRONC) .OR. &
(  166) &                    (LLMLAM1.AND.LLMLAM2.AND.                     &
(  167) &                     FA%CADRE(IRANC1)%MTRONC.NE.FA%CADRE(IRANC2)%MTRONC.AND.  &
(  168) &                     FA%CADRE(IRANC1)%NTYPTR.NE.FA%CADRE(IRANC2)%NTYPTR ))    &
(  169) &                    ).OR.                                         &
(  170) &       (.NOT.LLCOSP.AND.(FA%CADRE(IRANC1)%NLATIT.NE.                    &
(  171) &                         FA%CADRE(IRANC2)%NLATIT.OR.                    &
(  172) &                         FA%CADRE(IRANC1)%NVAPDG.NE.FA%CADRE(IRANC2)%NVAPDG)) &
(  173) &     ) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 14

(  174)     IREP=-112
(  175)     GOTO 1001
(  176) !
(  177)   ELSEIF (.NOT.LLCOSP) THEN
(  178) !
(  179)     IF (.NOT.LLMLAM1.AND..NOT.LLMLAM2) THEN
(  180)        INPAHEL=INPAHE
(  181)     ELSE
(  182)        INPAHEL=8
(  183)     ENDIF
(  184)     DO JLAT=1,INPAHEL
(  185)     LLMESS=LLMESS.OR.FA%CADRE(IRANC1)%NLOPAR(JLAT).NE. &
(  186) &           FA%CADRE(IRANC2)%NLOPAR(JLAT)
(  187)     ENDDO
(  188) !
(  189)     IF (LLMESS) THEN
(  190)       IREP=-112
(  191)       GOTO 1001
(  192)     ENDIF
(  193) !
(  194)   ENDIF
(  195) !
(  196)   LLMESS=FA%CADRE(IRANC1)%MTRONC.NE.FA%CADRE(IRANC2)%MTRONC.OR. &
(  197) &         FA%CADRE(IRANC1)%NTYPTR.NE.FA%CADRE(IRANC2)%NTYPTR.OR. &
(  198) &       (KNIVAU.GT.0.AND.(FA%CADRE(IRANC1)%NNIVER.NE.      &
(  199) &                         FA%CADRE(IRANC2)%NNIVER).OR.     &
(  200) &                        (FA%CADRE(IRANC1)%SPREFE.NE.      &
(  201) &                         FA%CADRE(IRANC2)%SPREFE)).OR.    &
(  202) &         FA%CADRE(IRANC1)%NLATIT.NE.FA%CADRE(IRANC2)%NLATIT.OR. &
(  203) &         FA%CADRE(IRANC1)%SSLAPO.NE.FA%CADRE(IRANC2)%SSLAPO.OR. &
(  204) &         FA%CADRE(IRANC1)%SCLOPO.NE.FA%CADRE(IRANC2)%SCLOPO.OR. &
(  205) &         FA%CADRE(IRANC1)%SSLOPO.NE.FA%CADRE(IRANC2)%SSLOPO.OR. &
(  206) &         FA%CADRE(IRANC1)%SCODIL.NE.FA%CADRE(IRANC2)%SCODIL
(  207) !
(  208)   IF (.NOT.LLMESS) THEN
(  209) !
(  210)     IF (.NOT.LLMLAM1.AND..NOT.LLMLAM2) THEN
(  211)        INPAHEL=INPAHE
(  212)        IZPAHEL=INPAHE
(  213)        ISPAHEL=INPAHE
(  214)     ELSE
(  215)        INPAHEL=JNEXPL
(  216)        IZPAHEL=0
(  217)        ISPAHEL=JNGEOM
(  218)     ENDIF
(  219)     DO JLAT=1,INPAHEL
(  220)     LLMESS=FA%CADRE(IRANC1)%NLOPAR(JLAT).NE.FA%CADRE(IRANC2)%NLOPAR(JLAT) &
(  221) &           .OR.LLMESS
(  222)     ENDDO
(  223)     DO JLAT=1,IZPAHEL
(  224)     LLMESS=FA%CADRE(IRANC1)%NOZPAR(JLAT).NE.FA%CADRE(IRANC2)%NOZPAR(JLAT) &
(  225) &           .OR.LLMESS
(  226)     ENDDO
(  227)     DO JLAT=1,ISPAHEL
(  228)     LLMESS=FA%CADRE(IRANC1)%SINLAT(JLAT).NE.FA%CADRE(IRANC2)%SINLAT(JLAT) &
(  229) &           .OR.LLMESS
(  230)     ENDDO
(  231) !






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 15

(  232)     IF (.NOT.LLMESS.AND.KNIVAU.GT.0) THEN
(  233) !
(  234)       DO JNIV=0,FA%CADRE(IRANC1)%NNIVER
(  235)       LLMESS=FA%CADRE(IRANC1)%SFOHYB(1,JNIV).NE.    &
(  236) &             FA%CADRE(IRANC2)%SFOHYB(1,JNIV).OR.    &
(  237) &      LLMESS.OR.FA%CADRE(IRANC1)%SFOHYB(2,JNIV).NE. &
(  238) &             FA%CADRE(IRANC2)%SFOHYB(2,JNIV)
(  239)       ENDDO
(  240) !
(  241)     ENDIF
(  242) !
(  243)   ENDIF
(  244) !
(  245) ENDIF
(  246) !**
(  247) !     4.  -  ECRITURE DE L'ARTICLE "CHAMP" SUR LE FICHIER.
(  248) !-----------------------------------------------------------------------
(  249) !
(  250) !        Deverrouillage eventuel de l'unite logique d'entree.
(  251) !
(  252) IF (LLVERF(1)) CALL LFIVER_MT64                                   &
(  253) &                              (FA%LFI, FA%FICHIER(IRANG(1))%VRFICH,'OFF')
(  254) LLVERF(1)=.FALSE.
(  255) !
(  256) CALL LFIECR_MT64                                      &
(  257) &               (FA%LFI, IREP,KNUME2,CLNOMA(1:ILNOMU), &
(  258) &             IVALCO,ILONGA)
(  259) INUMFI=2
(  260) LLRLFI=IREP.NE.0
(  261) IF (LLRLFI) GOTO 1001
(  262) !
(  263) !  Controle de l'homogeneite du type de rangement de coeff. spectraux
(  264) !  parmi les champs lus/ecrits: ces champs compactes avec
(  265) !  IGRIB=-1 ou 3 doivent etre ranges comme dans le modele ("verticalement"
(  266) !  soit selon des colonnes JM=cst consecutives) et contrairement si compactes
(  267) !  avec IGRIB= 0,1 ou 2.
(  268) !
(  269) IRANG2 = IRANG(2)
(  270) IGRIB = IVALCO(1)
(  271) IF (LLCOSP) THEN
(  272)   IF (IGRIB.EQ.-1 .OR. IGRIB.EQ.3) THEN
(  273)     FA%FICHIER(IRANG2)%NRASVE=FA%FICHIER(IRANG2)%NRASVE+1
(  274)     IF (FA%FICHIER(IRANG2)%NRASVE.EQ.1 .AND. FA%FICHIER(IRANG2)%NRASHO.GT.0) THEN
(  275)       WRITE(FA%NULOUT,*)                                 &
(  276) &      '------------------------------------------------'
(  277)       WRITE(FA%NULOUT,*)' FACOCH : WARNING !!!!!           '
(  278)       WRITE(FA%NULOUT,*)                                 &
(  279) &      ' Un champ de coef. spect. avec rangt type modele'
(  280)       WRITE(FA%NULOUT,*)' va etre ecrit sur l''unite ',KNUME2, &
(  281) &                ' alors que'
(  282)       WRITE(FA%NULOUT,*)                                &
(  283) &      ' d''autres champs y ont un rangement different.'
(  284)       WRITE(FA%NULOUT,*)                                 &
(  285) &      '------------------------------------------------'
(  286)     ENDIF
(  287)   ELSEIF (IGRIB.GE.0 .AND. IGRIB.LE.2) THEN
(  288)     FA%FICHIER(IRANG2)%NRASHO=FA%FICHIER(IRANG2)%NRASHO+1
(  289)     IF (FA%FICHIER(IRANG2)%NRASHO.EQ.1 .AND. FA%FICHIER(IRANG2)%NRASVE.GT.0) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 16

(  290)       WRITE(FA%NULOUT,*)                                 &
(  291) &      '------------------------------------------------'
(  292)       WRITE(FA%NULOUT,*)' FACOCH : WARNING !!!!!           '
(  293)       WRITE(FA%NULOUT,*)                               &
(  294) &      ' Un champ de coef. spect. avec rangt autre que'
(  295)       WRITE(FA%NULOUT,*)                                     &
(  296) &      ' celui du modele va etre ecrit sur l''unite ', KNUME2
(  297)       WRITE(FA%NULOUT,*)                                  &
(  298) &      ' alors que d''autres champs y ont le rangt modele'
(  299)       WRITE(FA%NULOUT,*)                                 &
(  300) &      '------------------------------------------------'
(  301)     ENDIF
(  302)   ENDIF
(  303) ENDIF
(  304) !
(  305) !**
(  306) !    10.  -  PHASE TERMINALE : MESSAGERIE, AVEC "ABORT" EVENTUEL,
(  307) !            VIA LE SOUS-PROGRAMME "FAIPAR" .
(  308) !-----------------------------------------------------------------------
(  309) !
(  310) 1001 CONTINUE
(  311) IF (ALLOCATED( IVALCO )) DEALLOCATE ( IVALCO )
(  312) KREP=IREP
(  313) LLFATA=LLMOER (IREP,IRANG(INUMFI))
(  314) !
(  315) !        Deverrouillage eventuel des fichiers.
(  316) !
(  317) IF (LLVERF(1)) CALL LFIVER_MT64                                   &
(  318) &                              (FA%LFI, FA%FICHIER(IRANG(1))%VRFICH,'OFF')
(  319) IF (LLVERF(2)) CALL LFIVER_MT64                                   &
(  320) &                              (FA%LFI, FA%FICHIER(IRANG(2))%VRFICH,'OFF')
(  321) !
(  322) CLNSPR='FACOCH'
(  323) !
(  324) !        Messages d'avertissement eventuels.
(  325) !
(  326) IF (FA%NIMSGA.NE.0.AND.IREP.EQ.0) THEN
(  327) !
(  328)   IF (LLMESS) THEN
(  329)     INIMES=1
(  330)     WRITE (UNIT=CLMESS,FMT='(''*ATTENTION* - LES UNITES'',I3,      &
(  331) &   '' ET'',I3,'' ONT DES CARACTERISTIQUES "CADRE" DIFFERENTES'')') &
(  332) &    KNUME1,KNUME2
(  333)     CALL FAIPAR_MT64                                         &
(  334) &                   (FA, JPNIIL,INIMES,IREP,.FALSE.,CLMESS, &
(  335) &                 CLNSPR,CLACTI,.FALSE.)
(  336)   ELSEIF (IRANC1.NE.IRANC2) THEN
(  337)     INIMES=1
(  338)     WRITE (UNIT=CLMESS,FMT='(''REMARQUE: CADRES '''''',A,        &
(  339) &           '''''' ET '''''',A,                                   &
(  340) &           '''''' DISTINCTS MAIS DE CONTENU IDENTIQUE (UNITES'', &
(  341) &           I3,'' ET'',I3,'' )'')')                               &
(  342) &      FA%CADRE(IRANC1)%CNOMCA(1:FA%CADRE(IRANC1)%NLCCAD),                    &
(  343) &      FA%CADRE(IRANC2)%CNOMCA(1:FA%CADRE(IRANC2)%NLCCAD),KNUME1,KNUME2
(  344)     CALL FAIPAR_MT64                                         &
(  345) &                   (FA, JPNIIL,INIMES,IREP,.FALSE.,CLMESS, &
(  346) &                 CLNSPR,CLACTI,.FALSE.)
(  347)   ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 17

(  348) !
(  349) ENDIF
(  350) !
(  351) IF (LLFATA) THEN
(  352)   INIMES=2
(  353) ELSE
(  354)   INIMES=IXNVMS(IRANG(INUMFI))
(  355) ENDIF
(  356) !
(  357) IF (.NOT.LLFATA.AND.INIMES.NE.2)  THEN 
(  358)   IF (LHOOK) CALL DR_HOOK('FACOCH_MT',1,ZHOOK_HANDLE)
(  359)   RETURN
(  360) ENDIF
(  361) !
(  362) IF (ILPRFU.GE.1) THEN
(  363)   ILPREF=MIN (ILPRFU,INT (LEN (CLPREF), JPLIKB))
(  364)   CLPREF(1:ILPREF)=CDPREF(1:ILPREF)
(  365) ELSE
(  366)   ILPREF=8
(  367)   CLPREF(1:ILPREF)=FA%CHAINC(:ILPREF)
(  368) ENDIF
(  369) !
(  370) IF (ILSUFU.GE.1) THEN
(  371)   ILSUFF=MIN (ILSUFU,INT (LEN (CLSUFF), JPLIKB))
(  372)   CLSUFF(1:ILSUFF)=CDSUFF(1:ILSUFF)
(  373) ELSE
(  374)   ILSUFF=8
(  375)   CLSUFF(1:ILSUFF)=FA%CHAINC(:ILSUFF)
(  376) ENDIF
(  377) !
(  378) IF (.NOT.LLNOMU) THEN
(  379)   ILNOMU=MIN (ILPREF,FA%NCPCAD)
(  380)   CLNOMA(1:ILNOMU)=CLPREF(1:ILPREF)
(  381) ENDIF
(  382) !
(  383) WRITE (UNIT=CLMESS,FMT='(''KREP='',I4,'', KNUME1='',I3,           &
(  384) &       '', KNUME2='',I3,'', CDPREF='''''',A,'''''', KNIVAU='',I6, &
(  385) &       '', CDSUFF='''''',A,'''''''')') KREP,KNUME1,KNUME2,        &
(  386) &   CLPREF(1:ILPREF),KNIVAU,CLSUFF(1:ILSUFF)
(  387) !
(  388) IF (IREP.EQ.-112) THEN
(  389)   INUMRO=1000*KNUME1+KNUME2
(  390) ELSE
(  391)   INUMRO=INUMER(INUMFI)
(  392) ENDIF
(  393) !
(  394) CALL FAIPAR_MT64                                     &
(  395) &               (FA, INUMRO,INIMES,IREP,LLFATA,CLMESS, &
(  396) &                CLNSPR, CLNOMA(1:ILNOMU),LLRLFI)
(  397) !
(  398) IF (LHOOK) CALL DR_HOOK('FACOCH_MT',1,ZHOOK_HANDLE)
(  399) # 400 "facoch.F90"
(  400) CONTAINS
(  401) # 402 "facoch.F90"
(  402) # 1 ".D[27]/facom2.llmoer.h"
(    1) !
(    2) !       Fonction servant a rendre fatale ou non une erreur detectee,
(    3) !       a l'aide du code reponse courant, du niveau de filtrage global,






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 18

(    4) !       et de l'option d'erreur fatale propre au fichier.
(    5) !       s'il n'y a pas de fichier (I5678=0, d'ou dimensionnement de
(    6) !          *LERRFA*), le niveau de filtrage joue le role principal.
(    7) !
(    8) LOGICAL FUNCTION LLMOER (I1234,I5678)
(    9) INTEGER (KIND=JPLIKB) :: I1234,I5678
(   10) LLMOER=I1234.EQ.-66_JPLIKB .OR. (I1234.NE.0_JPLIKB .AND.(FA%NRFAGA.EQ.0_JPLIKB &
(   11)      & .OR. (FA%NRFAGA.EQ.1_JPLIKB .AND.FA%FICHIER(I5678)%LERRFA)))
(   12) END FUNCTION
(   13) # 403 "facoch.F90"
(  403) # 403 "facoch.F90"
(  403) # 1 ".D[27]/facom2.ixnvms.h"
(    1) !*
(    2) !       Fonction "en ligne" donnant le plus haut niveau de messagerie
(    3) !       acceptable pour l'unite logique de rang "I3456"
(    4) !       (utilisation des niveaux de messagerie global et propre au
(    5) !        fichier; s'il n'y a pas de fichier - I3456=0, d'ou le dimensio-
(    6) !        nnement de *NIVOMS* a partir de zero, le niveau de filtrage
(    7) !        global joue seul)
(    8) !
(    9) INTEGER (KIND=JPLIKB) FUNCTION IXNVMS (I3456)
(   10) INTEGER (KIND=JPLIKB) :: I3456
(   11) IXNVMS =MIN (2_JPLIKB ,2_JPLIKB *FA%NIMSGA,MAX (2_JPLIKB *FA%NIMSGA-2_JPLIKB ,FA%FICHIER(I3456)%NIVOMS))
(   12) END FUNCTION
(   13) # 404 "facoch.F90"
(  404) # 404 "facoch.F90"
(  404) # 1 ".D[27]/falgra.h"
(    1) LOGICAL FUNCTION FALGRA (KNGRIB)
(    2) !****
(    3) !    Cette fonction renvoie une valeur vraie si la methode d'encodage passee en argument fait appel a grib_api
(    4) !**
(    5) !    Arguments : KNGRIB (Entree) ==> Methode d'encodage
(    6) !
(    7) !
(    8) INTEGER (KIND=JPLIKB) KNGRIB
(    9) INTEGER (KIND=JPLIKB) INGRIB_SP, INGRIB_GP
(   10) LOGICAL LLFALGRA_SP, LLFALGRA_GP
(   11) # 12 ".D[27]/falgra.h"
(   12) FALGRA = .FALSE.
(   13) # 14 ".D[27]/falgra.h"
(   14) IF (100 <= KNGRIB .AND. KNGRIB <= 200) THEN
(   15) # 16 ".D[27]/falgra.h"
(   16)   INGRIB_SP = FALGRA_SP (KNGRIB)
(   17)   INGRIB_GP = FALGRA_GP (KNGRIB)
(   18)   
(   19)   LLFALGRA_SP = &
(   20)    & (INGRIB_SP - 100 ==  1) .OR. &      ! GRIB2 complex packing (bug)
(   21)    & (INGRIB_SP - 100 ==  2) .OR. &      ! GRIB0 
(   22)    & (INGRIB_SP - 100 ==  3)             ! GRIB2 complex packing
(   23)   
(   24)   LLFALGRA_GP = &
(   25)    & ((INGRIB_GP-100) / 20 ==  1) .OR. & ! GRIB2 simple packing
(   26)    & ((INGRIB_GP-100) / 20 ==  2) .OR. & ! GRIB2 second order packing
(   27)    & ((INGRIB_GP-100) / 20 ==  3) .OR. & ! GRIB1 simple packing
(   28)    & ((INGRIB_GP-100) / 20 ==  4) .OR. & ! GRIB1 second order packing
(   29)    & ((INGRIB_GP-100) / 20 ==  5)        ! GRIB2 complex packing
(   30)    
(   31) # 32 ".D[27]/falgra.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 19

(   32)   IF (LLFALGRA_GP .AND. LLFALGRA_SP) THEN
(   33)     FALGRA = .TRUE.
(   34)   ELSEIF (LLFALGRA_GP) THEN
(   35)     FALGRA = INGRIB_SP == 100
(   36)   ELSEIF (LLFALGRA_SP) THEN
(   37)     FALGRA = INGRIB_GP == 100
(   38)   ENDIF
(   39) # 40 ".D[27]/falgra.h"
(   40) ENDIF
(   41) # 42 ".D[27]/falgra.h"
(   42) END FUNCTION FALGRA
(   43) # 44 ".D[27]/falgra.h"
(   44) INTEGER (KIND=JPLIKB) FUNCTION FALGRA_SP (KNGRIB)
(   45) INTEGER (KIND=JPLIKB) KNGRIB
(   46) FALGRA_SP = 100+MODULO ((KNGRIB-100),20)
(   47) END FUNCTION FALGRA_SP
(   48) # 49 ".D[27]/falgra.h"
(   49) INTEGER (KIND=JPLIKB) FUNCTION FALGRA_GP (KNGRIB)
(   50) INTEGER (KIND=JPLIKB) KNGRIB
(   51) FALGRA_GP = 100+20*((KNGRIB-100)/20)
(   52) END FUNCTION FALGRA_GP
(   53) # 54 ".D[27]/falgra.h"
(   54) INTEGER (KIND=JPLIKB) FUNCTION FALGRA_ED (KNGRIB)
(   55) INTEGER (KIND=JPLIKB) KNGRIB
(   56) # 57 ".D[27]/falgra.h"
(   57) SELECT CASE (KNGRIB)
(   58)   CASE (160, 180)
(   59)     FALGRA_ED = 1
(   60)   CASE DEFAULT
(   61)     FALGRA_ED = 2
(   62) END SELECT 
(   63) # 64 ".D[27]/falgra.h"
(   64) END FUNCTION FALGRA_ED
(   65) # 405 "facoch.F90"
(  405) # 406 "facoch.F90"
(  406) END SUBROUTINE FACOCH_MT64
(  407) # 410 "facoch.F90"
(  410) ! Oct-2012 P. Marguinaud 64b LFI
(  411) SUBROUTINE FACOCH64                                      &
(  412) &           (KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  413) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  414) &                   FA_COM_DEFAULT_INIT,  &
(  415) &                   NEW_FA_DEFAULT
(  416) USE LFI_PRECISION
(  417) IMPLICIT NONE
(  418) ! Arguments
(  419) INTEGER (KIND=JPLIKB)  KREP                                   !   OUT
(  420) INTEGER (KIND=JPLIKB)  KNUME1                                 ! IN   
(  421) INTEGER (KIND=JPLIKB)  KNUME2                                 ! IN   
(  422) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  423) INTEGER (KIND=JPLIKB)  KNIVAU                                 ! IN   
(  424) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  425) # 426 "facoch.F90"
(  426) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  427) # 428 "facoch.F90"
(  428) CALL FACOCH_MT64                                             &
(  429) &           (FA, KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  430) # 431 "facoch.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 20

(  431) END SUBROUTINE FACOCH64
(  432) # 433 "facoch.F90"
(  433) SUBROUTINE FACOCH                                        &
(  434) &           (KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  435) USE FA_MOD, ONLY : FA => FA_COM_DEFAULT, &
(  436) &                   FA_COM_DEFAULT_INIT,  &
(  437) &                   NEW_FA_DEFAULT
(  438) USE LFI_PRECISION
(  439) IMPLICIT NONE
(  440) ! Arguments
(  441) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  442) INTEGER (KIND=JPLIKM)  KNUME1                                 ! IN   
(  443) INTEGER (KIND=JPLIKM)  KNUME2                                 ! IN   
(  444) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  445) INTEGER (KIND=JPLIKM)  KNIVAU                                 ! IN   
(  446) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  447) # 448 "facoch.F90"
(  448) IF (.NOT. FA_COM_DEFAULT_INIT) CALL NEW_FA_DEFAULT ()
(  449) # 450 "facoch.F90"
(  450) CALL FACOCH_MT                                               &
(  451) &           (FA, KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  452) # 453 "facoch.F90"
(  453) END SUBROUTINE FACOCH
(  454) # 455 "facoch.F90"
(  455) SUBROUTINE FACOCH_MT                                         &
(  456) &           (FA, KREP, KNUME1, KNUME2, CDPREF, KNIVAU, CDSUFF)
(  457) USE FA_MOD, ONLY : FA_COM
(  458) USE LFI_PRECISION
(  459) IMPLICIT NONE
(  460) ! Arguments
(  461) TYPE (FA_COM)          FA                                     ! INOUT
(  462) INTEGER (KIND=JPLIKM)  KREP                                   !   OUT
(  463) INTEGER (KIND=JPLIKM)  KNUME1                                 ! IN   
(  464) INTEGER (KIND=JPLIKM)  KNUME2                                 ! IN   
(  465) CHARACTER (LEN=*)      CDPREF                                 ! IN   
(  466) INTEGER (KIND=JPLIKM)  KNIVAU                                 ! IN   
(  467) CHARACTER (LEN=*)      CDSUFF                                 ! IN   
(  468) ! Local integers
(  469) INTEGER (KIND=JPLIKB)  IREP                                   !   OUT
(  470) INTEGER (KIND=JPLIKB)  INUME1                                 ! IN   
(  471) INTEGER (KIND=JPLIKB)  INUME2                                 ! IN   
(  472) INTEGER (KIND=JPLIKB)  INIVAU                                 ! IN   
(  473) ! Convert arguments
(  474) # 475 "facoch.F90"
(  475) INUME1     = INT (    KNUME1, JPLIKB)
(  476) INUME2     = INT (    KNUME2, JPLIKB)
(  477) INIVAU     = INT (    KNIVAU, JPLIKB)
(  478) # 479 "facoch.F90"
(  479) CALL FACOCH_MT64                                             &
(  480) &           (FA, IREP, INUME1, INUME2, CDPREF, INIVAU, CDSUFF)
(  481) # 482 "facoch.F90"
(  482) KREP       = INT (      IREP, JPLIKM)
(  483) # 484 "facoch.F90"
(  484) END SUBROUTINE FACOCH_MT
(  485) # 486 "facoch.F90"
(  486) !INTF KREP            OUT 
(  487) !INTF KNUME1        IN    
(  488) !INTF KNUME2        IN    






NVFORTRAN (Version     23.1)          02/24/2023  13:54:53      page 21

(  489) !INTF CDPREF        IN    
(  490) !INTF KNIVAU        IN    
(  491) !INTF CDSUFF        IN    
