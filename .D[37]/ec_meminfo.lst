


NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: ec_meminfo.F90

(    1) SUBROUTINE EC_MEMINFO(KU,CDSTRING,KCOMM,KBARR,KIOTASK,KCALL)
(    2) 
(    3) USE PARKIND1, ONLY : JPIM, JPIB, JPRD
(    4) USE MPL_MPIF
(    5) 
(    6) IMPLICIT NONE
(    7) 
(    8) !-- EC_MEMINFO:
(    9) !   Author   : Peter Towers (ECMWF)  : 2015-2016
(   10) !   Modified : Sami Saarinen (ECMWF) : 21-SEP-2016 : Added getenv EC_MEMINFO -- export EC_MEMINFO=0 disables any EC_MEMINFO 
(   11) !              Sami Saarinen (ECMWF) : 02-MAR-2017 : Enabled flexible number of sockets & lots of tidying
(   12) !              Sami Saarinen (ECMWF) : 09-MAR-2017 : Power monitoring added (via EC_PMON) -- works at least on Cray systems
(   13) !              Sami Saarinen (ECMWF) : 12-MAR-2017 : Gather core affinities via call to ec_coreid()
(   14) !              Sami Saarinen (ECMWF) : 12-DEC-2017 : Obtain MPI & OpenMP version information
(   15) 
(   16) #include "ec_pmon.intfb.h"
(   17) 
(   18) INTEGER(KIND=JPIM), INTENT(IN) :: KU,KCOMM,KBARR,KIOTASK,KCALL
(   19) CHARACTER(LEN=*), INTENT(IN) :: CDSTRING
(   20) INTEGER(KIND=JPIM), PARAMETER :: ITAG = 98765
(   21) INTEGER(KIND=JPIM) :: ID,KULOUT
(   22) INTEGER(KIND=JPIM) :: II,JJ,I,J,K,MYPROC,NPROC,LEN,ERROR,NODENUM,JID,IDX
(   23) INTEGER(KIND=JPIB) :: TASKSMALL,NODEHUGE,MEMFREE,CACHED,NFREE
(   24) INTEGER(KIND=JPIB),SAVE :: NODEHUGE_CACHED
(   25) INTEGER(KIND=JPIM), PARAMETER :: MAXNUMA_DEF = 4 ! Max number of "sockets" supported by default
(   26) INTEGER(KIND=JPIM), SAVE :: MAXNUMA = 0 ! Max number of "sockets" supported -- initialized to zero to enforce updated value 
(   27) INTEGER(KIND=JPIM) :: NNUMA ! Actual number of "sockets" (can be 0 ob systems that do not have /proc/buddyinfo, e.g. WSL)
(   28) !INTEGER(KIND=JPIB),DIMENSION(0:MAXNUMA-1) :: SMALLPAGE,HUGEPAGE
(   29) INTEGER(KIND=JPIB),DIMENSION(:),ALLOCATABLE,SAVE :: SMALLPAGE,HUGEPAGE
(   30) INTEGER(KIND=JPIB) :: GETMAXRSS,GETMAXHWM






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 3

(   31) INTEGER(KIND=JPIB) :: HEAP_SIZE
(   32) INTEGER(KIND=JPIB), PARAMETER :: ONEMEGA = 1024_JPIB * 1024_JPIB
(   33) INTEGER(KIND=JPIB) :: ENERGY, POWER
(   34) INTEGER(KIND=JPIB) :: TOT_ENERGY, MAXPOWER, AVGPOWER
(   35) INTEGER(KIND=JPIM),SAVE :: PAGESIZE = 0
(   36) INTEGER(KIND=JPIM),SAVE :: MAXTH = 0
(   37) INTEGER(KIND=JPIM),SAVE :: MAXTH_COMP = 0
(   38) INTEGER(KIND=JPIM),SAVE :: MAXTH_IO = 0
(   39) INTEGER(KIND=JPIM),PARAMETER :: MAXCOLS = 18 ! Max numerical columns in /proc/buddyinfo (often just 11, but Cray has 18 entr
(   40) INTEGER(KIND=JPIM) :: N18
(   41) !INTEGER(KIND=JPIB),DIMENSION(0:MAXCOLS-1,0:MAXNUMA-1) :: NODE, BUCKET
(   42) !INTEGER(KIND=JPIB),DIMENSION(7+2*MAXNUMA) :: SENDBUF,RECVBUF
(   43) INTEGER(KIND=JPIB),DIMENSION(:,:),ALLOCATABLE,SAVE :: NODE, BUCKET
(   44) INTEGER(KIND=JPIB),DIMENSION(:),ALLOCATABLE,SAVE :: SENDBUF,RECVBUF
(   45) REAL(KIND=JPRD) :: PERCENT_USED(2)
(   46) CHARACTER(LEN=256) :: CLSTR
(   47) CHARACTER(LEN=512) :: TMPDIR
(   48) CHARACTER(LEN=512), SAVE :: PROGRAM = ' '
(   49) CHARACTER(LEN=20)  :: NODENAME,LASTNODE,CLMAXNODE
(   50) CHARACTER(LEN=12)  :: VAL
(   51) CHARACTER(LEN=1)   :: M
(   52) CHARACTER(LEN=160) ::LINE
(   53) CHARACTER(LEN=56) :: FILENAME
(   54) CHARACTER(LEN=1) :: CLEC_MEMINFO
(   55) CHARACTER(LEN=5) :: CSTAR
(   56) CHARACTER(LEN=LEN(CSTAR)+1+LEN(CDSTRING)) :: ID_STRING
(   57) CHARACTER(LEN=10) ::  CLDATEOD,CLTIMEOD,CLZONEOD
(   58) CHARACTER(LEN=3), PARAMETER :: CLMON(1:12) = (/ &
(   59)      'Jan','Feb','Mar','Apr','May','Jun', &
(   60)      'Jul','Aug','Sep','Oct','Nov','Dec' /)
(   61) INTEGER(KIND=JPIM) :: IVALUES(8), IMON
(   62) INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
(   63) LOGICAL :: LLNOCOMM, LLNOHDR
(   64) INTEGER(KIND=JPIM), SAVE :: IAM_NODEMASTER = 0
(   65) LOGICAL, SAVE :: LLFIRST_TIME = .TRUE.
(   66) TYPE RANKNODE_T
(   67)    INTEGER(KIND=JPIM) :: NODENUM
(   68)    INTEGER(KIND=JPIM) :: RANK_WORLD
(   69)    INTEGER(KIND=JPIM) :: RANK
(   70)    INTEGER(KIND=JPIM) :: IORANK
(   71)    INTEGER(KIND=JPIM) :: NODEMASTER
(   72)    INTEGER(KIND=JPIM) :: NUMTH
(   73)    INTEGER(KIND=JPIM), ALLOCATABLE :: COREIDS(:)
(   74)    CHARACTER(LEN=LEN(NODENAME)) :: NODE
(   75)    CHARACTER(LEN=LEN(CLSTR)) :: STR
(   76) END TYPE
(   77) TYPE (RANKNODE_T), ALLOCATABLE, SAVE :: RN(:)
(   78) INTEGER(KIND=JPIM), ALLOCATABLE :: COREIDS(:)
(   79) LOGICAL, ALLOCATABLE :: DONE(:)
(   80) INTEGER(KIND=JPIM), SAVE :: NUMNODES = 0
(   81) INTEGER(KIND=JPIM) :: NN
(   82) INTEGER(KIND=JPIM), SAVE :: IOTASKS = 0
(   83) INTEGER(KIND=JPIM) :: IORANK, NSEND, NRECV
(   84) LOGICAL :: FILE_EXISTS
(   85) REAL(KIND=JPRD), EXTERNAL :: UTIL_WALLTIME
(   86) REAL(KIND=JPRD), SAVE :: WT0
(   87) REAL(KIND=JPRD) :: WT
(   88) CHARACTER(LEN=64) :: CLPFX






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 4

(   89) CHARACTER(LEN=3) :: ZUM
(   90) INTEGER(KIND=JPIM) :: IPFXLEN, NUMTH, MYTH
(   91) INTEGER(KIND=JPIM) :: NCOMM_MEMINFO = 0
(   92) COMMON /cmn_meminfo/ NCOMM_MEMINFO
(   93) INTEGER OMP_GET_MAX_THREADS, OMP_GET_THREAD_NUM
(   94) #ifdef _OPENMP
(   95) EXTERNAL OMP_GET_MAX_THREADS, OMP_GET_THREAD_NUM
(   96) #else
(   97) OMP_GET_MAX_THREADS() = 1
(   98) OMP_GET_THREAD_NUM() = 0
(   99) #endif
(  100) 
(  101) CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO',CLEC_MEMINFO)
(  102) IF (CLEC_MEMINFO == '0') RETURN
(  103) 
(  104) IF (LLFIRST_TIME) WT0 = UTIL_WALLTIME()
(  105) IF (MAXTH == 0) MAXTH = OMP_GET_MAX_THREADS()
(  106) 
(  107) LLNOCOMM = (KCOMM == -1 .or. KCOMM == -2)
(  108) LLNOHDR = (KCOMM == -2)
(  109) 
(  110) IF (LLNOCOMM) THEN
(  111)    ! Direct call to obtain EC_meminfo -output
(  112)    ERROR = 0
(  113)    MYPROC = 0
(  114)    NPROC = 1
(  115)    CLPFX = CDSTRING
(  116)    IPFXLEN = LEN_TRIM(CLPFX)
(  117)    ZUM = 'tsk'
(  118) ELSE
(  119)    CLPFX = ' '
(  120)    IPFXLEN = 0
(  121)    ZUM = 'sum'
(  122)    CALL MPI_COMM_RANK(KCOMM,MYPROC,ERROR)
(  123)    CALL CHECK_ERROR("from MPI_COMM_RANK",__FILE__,__LINE__)
(  124) 
(  125)    CALL MPI_COMM_SIZE(KCOMM,NPROC,ERROR)
(  126)    CALL CHECK_ERROR("from MPI_COMM_SIZE",__FILE__,__LINE__)
(  127) 
(  128)    IF (KCALL == 0) THEN
(  129)       CALL CONDBARR()
(  130)       CALL CHECK_ERROR("from MPI_BARRIER(at start)",__FILE__,__LINE__)
(  131)    ENDIF
(  132) ENDIF
(  133) 
(  134) IF (LLFIRST_TIME) THEN ! The *very* first time
(  135)    CALL EC_PMON(ENERGY,POWER)
(  136) 
(  137)    !-- Neither of these two may stop working when linking with C++ (like in OOPS) ...
(  138)    ! CALL GETARG(0,PROGRAM)
(  139)    ! CALL GET_COMMAND_ARGUMENT(0,PROGRAM)
(  140)    !... so using the old saviour from ifsaux/support/cargs.c:
(  141)    CALL GETARG_C(0,PROGRAM)
(  142) 
(  143)    CALL GET_ENVIRONMENT_VARIABLE("HUGETLB_DEFAULT_PAGE_SIZE",VAL)
(  144)    I=INDEX(VAL,"M")
(  145)    IF(I > 0) THEN
(  146)       READ(VAL(1:I-1),*) PAGESIZE






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 5

(  147)       PAGESIZE=PAGESIZE*1024
(  148)    ELSE
(  149)       PAGESIZE=0
(  150)    ENDIF
(  151) 
(  152)    NODEHUGE=0
(  153)    
(  154)    IF(PAGESIZE > 0) THEN
(  155)       !WRITE(FILENAME,'(a,i0,a)') "/sys/kernel/mm/hugepages/hugepages-", &
(  156)       !     PAGESIZE,"kB/nr_hugepages"
(  157)       FILENAME='/proc/sys/vm/nr_hugepages' ! more generic; contents the same as in /sys/kernel/mm/hugepages/hugepages-2048kB
(  158)       INQUIRE(FILE=FILENAME, EXIST=FILE_EXISTS)
(  159)       IF( FILE_EXISTS ) THEN
(  160)         OPEN(502,FILE=FILENAME,STATUS="old",ACTION="read",ERR=999)
(  161)         READ(502,*,ERR=998,END=998) NODEHUGE
(  162) 998     continue
(  163)         CLOSE(502)
(  164)       ENDIF
(  165) 999   continue
(  166)    ENDIF
(  167) 
(  168)    NODEHUGE=NODEHUGE*PAGESIZE
(  169)    NODEHUGE=NODEHUGE/1024
(  170)    NODEHUGE_CACHED = NODEHUGE
(  171) ENDIF
(  172) 
(  173) NODEHUGE=NODEHUGE_CACHED
(  174) 
(  175) CALL EC_GETHOSTNAME(NODENAME) ! from support/env.c
(  176) 
(  177) IF (MAXNUMA == 0) THEN
(  178)    CALL GET_ENVIRONMENT_VARIABLE("EC_MAXNUMA",VAL) ! Note: *not* export EC_MEMINFO_MAXNUMA=<value>, but EC_MAXNUMA=<value>
(  179)    IF (VAL /= "") READ(VAL,*) MAXNUMA
(  180)    IF (MAXNUMA < 1) MAXNUMA = MAXNUMA_DEF
(  181)    ALLOCATE(SMALLPAGE(0:MAXNUMA-1))
(  182)    ALLOCATE(HUGEPAGE(0:MAXNUMA-1))
(  183)    ALLOCATE(NODE(0:MAXCOLS-1,0:MAXNUMA-1))
(  184)    ALLOCATE(BUCKET(0:MAXCOLS-1,0:MAXNUMA-1))
(  185)    ALLOCATE(SENDBUF(7+2*MAXNUMA))
(  186)    ALLOCATE(RECVBUF(7+2*MAXNUMA))
(  187) ENDIF
(  188) 
(  189) IF (MYPROC == 0) THEN 
(  190) !
(  191) ! Use already open file for output or $EC_MEMINFO_TMPDIR/meminfo
(  192) ! We do not use $TMPDIR as it may have been inherited from mother superiour (MOMS) node
(  193) !
(  194)    IF(KU == -1) THEN
(  195)       CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_TMPDIR',TMPDIR)
(  196)       IF (TMPDIR == ' ') TMPDIR = '.'
(  197)       !    write(0,*) '## EC_MEMINFO: KCOMM=',KCOMM
(  198)       !    CALL LINUX_TRBK()
(  199)       KULOUT=501
(  200)       OPEN(UNIT=KULOUT,FILE=TRIM(TMPDIR)//"/"//"meminfo.txt",STATUS='unknown', &
(  201)            ACTION='write',POSITION='append')
(  202)    ELSE
(  203)       KULOUT=KU
(  204)    ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 6

(  205) ENDIF
(  206) 
(  207) IF (LLFIRST_TIME .and. .not. LLNOCOMM) THEN
(  208) ! Fetch affinities (over OpenMP threads)
(  209) ! Note: I/O-tasks may now have different number of threads than on computational tasks
(  210)    ALLOCATE(COREIDS(0:MAXTH-1))
(  211) #ifdef _OPENMP
(  212) !$OMP PARALLEL NUM_THREADS(MAXTH) SHARED(COREIDS) PRIVATE(MYTH)
(  213) #endif
(  214)    MYTH = OMP_GET_THREAD_NUM()
(  215)    CALL EC_COREID(COREIDS(MYTH))
(  216) #ifdef _OPENMP
(  217) !$OMP END PARALLEL
(  218) #endif
(  219) 
(  220) ! Store the communicator we are in upon entering EC_MEMINFO for the first time -- to be used in the EC_MPI_FINALIZE
(  221)    NCOMM_MEMINFO = KCOMM
(  222) ! Fetch node names & numbers per task
(  223)    IORANK = 0
(  224)    IF (KIOTASK > 0) IORANK = 1
(  225)    IF (MYPROC == 0) THEN
(  226)       CALL SLASH_PROC
(  227)       ALLOCATE(RN(0:NPROC-1))
(  228)       DO I=0,NPROC-1
(  229)          RN(I)%NODENUM = -1
(  230)          IF (I > 0) THEN ! Receive in the MPI-rank order of KCOMM (i.e. may not be the same as MPI_COMM_WORLD -order)
(  231)             CALL MPI_RECV(LASTNODE,LEN(LASTNODE),MPI_BYTE,I,ITAG,KCOMM,IRECV_STATUS,ERROR)
(  232)             CALL CHECK_ERROR("from MPI_RECV(LASTNODE)",__FILE__,__LINE__)
(  233)             CALL MPI_RECV(IORANK,1,MPI_INTEGER4,I,ITAG+1,KCOMM,IRECV_STATUS,ERROR)
(  234)             CALL CHECK_ERROR("from MPI_RECV(IORANK)",__FILE__,__LINE__)
(  235)             CALL MPI_RECV(K,1,MPI_INTEGER4,I,ITAG+2,KCOMM,IRECV_STATUS,ERROR)
(  236)             CALL CHECK_ERROR("from MPI_RECV(RANK_WORLD)",__FILE__,__LINE__)
(  237)             CALL MPI_RECV(NUMTH,1,MPI_INTEGER4,I,ITAG+3,KCOMM,IRECV_STATUS,ERROR)
(  238)             CALL CHECK_ERROR("from MPI_RECV(NUMTH)",__FILE__,__LINE__)
(  239)             CALL MPI_RECV(CLSTR,LEN(CLSTR),MPI_BYTE,I,ITAG+4,KCOMM,IRECV_STATUS,ERROR)
(  240)             CALL CHECK_ERROR("from MPI_RECV(CLSTR)",__FILE__,__LINE__)
(  241)             RN(I)%RANK = I
(  242)             RN(I)%STR = CLSTR
(  243)          ELSE
(  244)             LASTNODE=NODENAME
(  245)             NUMTH = MAXTH
(  246)             CALL MPI_COMM_RANK(MPI_COMM_WORLD,K,ERROR)
(  247)             RN(I)%RANK = 0 ! Itself
(  248)             RN(I)%STR = CDSTRING
(  249)          ENDIF
(  250)          RN(I)%RANK_WORLD = K
(  251)          RN(I)%IORANK = IORANK
(  252)          RN(I)%NODEMASTER = 0
(  253)          RN(I)%NODE = LASTNODE
(  254)          ! Affinities
(  255)          RN(I)%NUMTH = NUMTH
(  256)          ALLOCATE(RN(I)%COREIDS(0:NUMTH-1))
(  257)          IF (I > 0) THEN ! Receive in MPI-rank order
(  258)             CALL MPI_RECV(RN(I)%COREIDS,NUMTH,MPI_INTEGER4,I,ITAG+5,KCOMM,IRECV_STATUS,ERROR)
(  259)             CALL CHECK_ERROR("from MPI_RECV(COREIDS)",__FILE__,__LINE__)
(  260)          ELSE
(  261)             RN(I)%COREIDS = COREIDS
(  262)          ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 7

(  263)          IF (IORANK == 0) THEN
(  264)             MAXTH_COMP = MAX(MAXTH_COMP,NUMTH)
(  265)          ELSE
(  266)             MAXTH_IO = MAX(MAXTH_IO,NUMTH)
(  267)          ENDIF
(  268)       ENDDO
(  269)       
(  270)       CALL RNSORT(KULOUT) ! Output now goes to "meminfo.txt"
(  271) 
(  272)       IAM_NODEMASTER = RN(0)%NODEMASTER ! Itself
(  273)       DO I=1,NPROC-1
(  274)          CALL MPI_SEND(RN(I)%NODEMASTER,1,MPI_INTEGER4,I,ITAG+6,KCOMM,ERROR)
(  275)          CALL CHECK_ERROR("from MPI_SEND(IAM_NODEMASTER)",__FILE__,__LINE__)
(  276)       ENDDO
(  277)    ELSE
(  278)       CALL MPI_SEND(NODENAME,LEN(NODENAME),MPI_BYTE,0,ITAG,KCOMM,ERROR)
(  279)       CALL CHECK_ERROR("from MPI_SEND(NODENAME)",__FILE__,__LINE__)
(  280)       CALL MPI_SEND(IORANK,1,MPI_INTEGER4,0,ITAG+1,KCOMM,ERROR)
(  281)       CALL CHECK_ERROR("from MPI_SEND(IORANK)",__FILE__,__LINE__)
(  282)       CALL MPI_COMM_RANK(MPI_COMM_WORLD,K,ERROR)
(  283)       CALL MPI_SEND(K,1,MPI_INTEGER4,0,ITAG+2,KCOMM,ERROR)
(  284)       CALL CHECK_ERROR("from MPI_SEND(RANK_WORLD)",__FILE__,__LINE__)
(  285)       CALL MPI_SEND(MAXTH,1,MPI_INTEGER4,0,ITAG+3,KCOMM,ERROR)
(  286)       CALL CHECK_ERROR("from MPI_SEND(MAXTH)",__FILE__,__LINE__)
(  287)       CLSTR = CDSTRING
(  288)       CALL MPI_SEND(CLSTR,LEN(CLSTR),MPI_BYTE,0,ITAG+4,KCOMM,ERROR)
(  289)       CALL CHECK_ERROR("from MPI_SEND(CLSTR)",__FILE__,__LINE__)
(  290)       CALL MPI_SEND(COREIDS,MAXTH,MPI_INTEGER4,0,ITAG+5,KCOMM,ERROR)
(  291)       CALL CHECK_ERROR("from MPI_SEND(COREIDS)",__FILE__,__LINE__)
(  292)       CALL MPI_RECV(IAM_NODEMASTER,1,MPI_INTEGER4,0,ITAG+6,KCOMM,IRECV_STATUS,ERROR)
(  293)       CALL CHECK_ERROR("from MPI_RECV(IAM_NODEMASTER)",__FILE__,__LINE__)
(  294)    ENDIF
(  295)    DEALLOCATE(COREIDS)
(  296)    LLFIRST_TIME = .FALSE.
(  297)    CALL CONDBARR()
(  298)    CALL CHECK_ERROR("from MPI_BARRIER near LLFIRST_TIME=.FALSE.",__FILE__,__LINE__)
(  299) ENDIF
(  300) 
(  301) IF (MYPROC == 0 .or. IAM_NODEMASTER == 1) CALL SLASH_PROC
(  302) 
(  303) HEAP_SIZE=GETMAXHWM()/ONEMEGA
(  304) TASKSMALL=GETMAXRSS()/ONEMEGA
(  305) 
(  306) IF (MYPROC == 0) THEN
(  307)    CALL DATE_AND_TIME(CLDATEOD,CLTIMEOD,CLZONEOD,IVALUES)
(  308)    READ(CLDATEOD(5:6),'(I2)') IMON
(  309)    IF (.not.LLNOCOMM .AND. KCALL /= 1) CALL PRT_DETAIL(KULOUT)
(  310)    IF (.not.LLNOHDR)  CALL PRT_HDR(KULOUT)
(  311)    IF(KU == -1) THEN
(  312)       IF (KCALL /= 1) CALL PRT_DETAIL(0)
(  313)       CALL PRT_HDR(0)
(  314)    ENDIF
(  315) 
(  316)    ! Note: MYPROC == 0 is always at the RN(0) i.e. at the first NODENUM
(  317)    TOT_ENERGY = ENERGY
(  318)    MAXPOWER = POWER
(  319)    AVGPOWER = POWER
(  320)    CLMAXNODE = NODENAME






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 8

(  321)    LASTNODE = NODENAME
(  322) 
(  323)    NN = NUMNODES
(  324)    IF (LLNOCOMM) NN=1
(  325) 
(  326)    IF (NPROC > 1) THEN
(  327)       ALLOCATE(DONE(1:NPROC-1))
(  328)       DONE(:) = .FALSE.
(  329)    ENDIF
(  330) 
(  331)    DO NODENUM=1,NN
(  332)       JID = 0
(  333)       DO II=1,NPROC-1
(  334)          IF (.NOT.DONE(II)) THEN
(  335)             J = II ! Used to be REF(II) -- don't know why ?!
(  336)             IF (RN(J)%NODENUM == NODENUM) THEN
(  337)                I = RN(J)%RANK
(  338)                IF (RN(J)%NODEMASTER == 1) THEN ! Always the first task on particular NODENUM
(  339)                   LASTNODE = RN(J)%NODE
(  340)                   NRECV = SIZE(RECVBUF)
(  341)                   JID = J ! Always >= 1
(  342)                ELSE
(  343)                   NRECV = 2
(  344)                ENDIF
(  345)                CALL MPI_RECV(RECVBUF,NRECV,MPI_INTEGER8,I,ITAG+5,KCOMM,IRECV_STATUS,ERROR)
(  346)                CALL CHECK_ERROR("from MPI_RECV(RECVBUF)",__FILE__,__LINE__)
(  347)                IF (NRECV > 2) THEN
(  348)                   HEAP_SIZE=RECVBUF(1)
(  349)                   TASKSMALL=RECVBUF(2)
(  350)                   ENERGY=RECVBUF(3)
(  351)                   POWER=RECVBUF(4)
(  352)                   NODEHUGE=RECVBUF(5)
(  353)                   MEMFREE=RECVBUF(6)
(  354)                   CACHED=RECVBUF(7)
(  355)                   DO K=0,MAXNUMA-1
(  356)                      SMALLPAGE(K) = RECVBUF(7+2*K+1)
(  357)                      HUGEPAGE(K) = RECVBUF(7+2*K+2)
(  358)                   ENDDO
(  359)                   TOT_ENERGY = TOT_ENERGY + ENERGY
(  360)                   IF (POWER > MAXPOWER) THEN
(  361)                      MAXPOWER = POWER
(  362)                      CLMAXNODE = LASTNODE
(  363)                   ENDIF
(  364)                   AVGPOWER = AVGPOWER + POWER
(  365)                ELSE
(  366)                   HEAP_SIZE=HEAP_SIZE+RECVBUF(1)
(  367)                   TASKSMALL=TASKSMALL+RECVBUF(2)
(  368)                ENDIF
(  369)                DONE(II) = .TRUE.
(  370)             ENDIF
(  371)          ENDIF
(  372)       ENDDO
(  373)       
(  374)       PERCENT_USED(2) = 0
(  375)       IF (NODEHUGE == 0 .or. HEAP_SIZE >= NODEHUGE) THEN
(  376)          ! running with small pages
(  377)          IF (TASKSMALL+NODEHUGE+MEMFREE+CACHED > 0) THEN
(  378)             PERCENT_USED(1) = 100.0*(TASKSMALL+NODEHUGE)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 9

(  379)          ELSE
(  380)             PERCENT_USED(1) = 0
(  381)          ENDIF
(  382)          CSTAR = " Sm/p"
(  383)       ELSE
(  384)          ! running with huge pages
(  385)          PERCENT_USED(1) = 100.0*(HEAP_SIZE+TASKSMALL)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
(  386)          NFREE = 0
(  387)          IF (NNUMA > 0) NFREE = SUM(HUGEPAGE(0:NNUMA-1))
(  388)          PERCENT_USED(2) = (100.0*(NODEHUGE - NFREE))/NODEHUGE
(  389)          IF (PERCENT_USED(2) < 0) PERCENT_USED(2) = 0
(  390)          IF (PERCENT_USED(2) > 100) PERCENT_USED(2) = 100
(  391)          CSTAR = " Hg/p"
(  392)       ENDIF
(  393)    
(  394)       IF (LLNOCOMM) THEN
(  395)          ID_STRING = CSTAR
(  396)       ELSE IF (KCALL == 0 .AND. JID > 0) THEN
(  397)          ! This should signify the compute & I/O nodes (if they are separate)
(  398)          CLSTR = RN(JID)%STR
(  399)          ID_STRING = CSTAR//":"//TRIM(CLSTR)
(  400)       ELSE
(  401)          ID_STRING = CSTAR//":"//CDSTRING
(  402)       ENDIF
(  403) 
(  404)       CALL PRT_DATA(KULOUT)
(  405)       IF (KU == -1) THEN
(  406)          CALL PRT_DATA(0)
(  407)          IF (NODENUM == NN) THEN
(  408)             AVGPOWER = NINT(REAL(AVGPOWER)/REAL(NN))
(  409)             CALL PRT_TOTAL_ENERGIES(0)
(  410)             CALL PRT_TOTAL_ENERGIES(KULOUT)
(  411)             IF (KCALL == 1) THEN
(  412)                CALL DATE_AND_TIME(CLDATEOD,CLTIMEOD,CLZONEOD,IVALUES)
(  413)                READ(CLDATEOD(5:6),'(I2)') IMON
(  414)                CALL PRT_DETAIL(0)
(  415)                CALL PRT_DETAIL(KULOUT)
(  416)             ENDIF
(  417)             CALL PRT_EMPTY(KULOUT,1)
(  418)             CLOSE(KULOUT)
(  419)          ENDIF
(  420)       ENDIF
(  421)    ENDDO ! DO NODENUM=1,NN
(  422)    IF (ALLOCATED(DONE)) DEALLOCATE(DONE)
(  423) ELSE
(  424)     SENDBUF(1)=HEAP_SIZE
(  425)     SENDBUF(2)=TASKSMALL
(  426)     IF (IAM_NODEMASTER == 1) THEN
(  427)        SENDBUF(3)=ENERGY
(  428)        SENDBUF(4)=POWER
(  429)        SENDBUF(5)=NODEHUGE
(  430)        SENDBUF(6)=MEMFREE
(  431)        SENDBUF(7)=CACHED
(  432)        DO K=0,MAXNUMA-1
(  433)           SENDBUF(7+2*K+1)=SMALLPAGE(K)
(  434)           SENDBUF(7+2*K+2)=HUGEPAGE(K)
(  435)        ENDDO
(  436)        NSEND = SIZE(SENDBUF)






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 10

(  437)     ELSE
(  438)        NSEND = 2
(  439)     ENDIF
(  440)     CALL MPI_SEND(SENDBUF,NSEND,MPI_INTEGER8,0,ITAG+5,KCOMM,ERROR)
(  441)     CALL CHECK_ERROR("from MPI_SEND(SENDBUF)",__FILE__,__LINE__)
(  442) ENDIF
(  443) 
(  444) IF (.not.LLNOCOMM) THEN
(  445)    CALL CONDBARR()
(  446)    CALL CHECK_ERROR("from MPI_BARRIER(at end)",__FILE__,__LINE__)
(  447) ENDIF
(  448) 
(  449) CONTAINS
(  450) 
(  451) SUBROUTINE SLASH_PROC
(  452)   IMPLICIT NONE
(  453)   CALL EC_PMON(ENERGY,POWER)
(  454) 
(  455)   N18 = 0 ! number of buddy columns (up to MAXCOLS)
(  456)   NNUMA = 0 ! number of NUMA-nodes (up to MAXNUMA)
(  457) 
(  458)   OPEN(FILE="/proc/buddyinfo",UNIT=502,STATUS="old",ACTION="read",ERR=97)
(  459)   
(  460)   READ(502,'(a)',END=99) LINE
(  461)   READ(502,'(a)',END=99) LINE
(  462)   READ(502,'(a)',END=99) LINE
(  463)   NODE(:,0)=-1
(  464)   READ(LINE(22:),*,END=98) NODE(:,0)
(  465) 98 CONTINUE
(  466)   N18 = COUNT(NODE(:,0) >= 0)
(  467)   NNUMA = 1
(  468)   DO K=1,MAXNUMA-1
(  469)      NODE(:,K)=0
(  470)      READ(502,'(a)',END=99) LINE
(  471)      READ(LINE(22:),*) NODE(0:N18-1,K)
(  472)      NNUMA = NNUMA + 1
(  473)   ENDDO
(  474)   
(  475) 99 CONTINUE
(  476)   CLOSE(502)
(  477) 97 CONTINUE
(  478)   
(  479)   SMALLPAGE(:) = 0
(  480)   HUGEPAGE(:) = 0
(  481)   DO K=0,NNUMA-1
(  482)      BUCKET(:,K) = 0
(  483)      DO J=0,N18-1
(  484)         BUCKET(J,K) = 4096_JPIB * NODE(J,K) * (2_JPIB ** J)
(  485)      ENDDO
(  486)      SMALLPAGE(K) = SUM(BUCKET(0:8,K))/ONEMEGA
(  487)      HUGEPAGE(K) = SUM(BUCKET(9:N18-1,K))/ONEMEGA
(  488)   ENDDO
(  489)   
(  490)   MEMFREE = 0
(  491)   CACHED = 0
(  492)   
(  493)   INQUIRE(FILE="/proc/meminfo", EXIST=FILE_EXISTS)
(  494)   IF( FILE_EXISTS ) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 11

(  495)     OPEN(FILE="/proc/meminfo",UNIT=502,STATUS="old",ACTION="read",ERR=977)
(  496)     DO I=1,10
(  497)       READ(502,'(a)',ERR=988,END=988) LINE
(  498)       IF(LINE(1:7) == "MemFree") THEN
(  499)         READ(LINE(9:80),*) MEMFREE 
(  500)       ELSEIF(LINE(1:6) == "Cached") THEN
(  501)         READ(LINE(8:80),*) CACHED
(  502)       ENDIF
(  503)     ENDDO
(  504) 988 continue
(  505)     CLOSE(502)
(  506) 977 continue
(  507)   
(  508)     MEMFREE=MEMFREE/1024
(  509)     CACHED=CACHED/1024
(  510)   ENDIF
(  511) 
(  512) END SUBROUTINE SLASH_PROC
(  513) 
(  514) SUBROUTINE PRT_EMPTY(KUN,KOUNT)
(  515) IMPLICIT NONE
(  516) INTEGER(KIND=JPIM), INTENT(IN) :: KUN,KOUNT
(  517) INTEGER(KIND=JPIM) :: JJ
(  518) DO JJ=1,KOUNT
(  519)    WRITE(KUN,'(a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO "
(  520) ENDDO
(  521) END SUBROUTINE PRT_EMPTY
(  522) 
(  523) FUNCTION KWH(JOULES)
(  524) IMPLICIT NONE
(  525) INTEGER(KIND=JPIB), INTENT(IN) :: JOULES
(  526) REAL(KIND=JPRD) KWH
(  527) KWH = REAL(JOULES,JPRD) / 3600000.0_JPRD
(  528) END FUNCTION KWH
(  529) 
(  530) SUBROUTINE PRT_TOTAL_ENERGIES(KUN)
(  531) IMPLICIT NONE
(  532) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  533) IF (KCALL == 1) THEN ! last call
(  534)    WT = UTIL_WALLTIME() - WT0
(  535)    CALL PRT_EMPTY(KUN,2)
(  536)    WRITE(KUN,'(a,a,f12.3,a,i0,a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  537)         & " Total energy consumed : ",KWH(TOT_ENERGY), " kWh (",TOT_ENERGY," J)"
(  538) !-- Peak power below is misleading since based on values at sample points
(  539) !   WRITE(KUN,'(a,a,i0,a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  540) !        & " Peak power            : ",MAXPOWER," W (node "//trim(CLMAXNODE)//")"
(  541) !-- Avg power must be calculated based on total Joules divided by wall time and num nodes
(  542)    AVGPOWER = TOT_ENERGY / WT / NUMNODES
(  543)    WRITE(KUN,'(a,a,i0,a,i0,a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  544)         & " Avg. power / node     : ",AVGPOWER," W across ",NUMNODES," nodes"
(  545)    CALL PRT_EMPTY(KUN,1)
(  546) ENDIF
(  547) END SUBROUTINE PRT_TOTAL_ENERGIES
(  548) 
(  549) SUBROUTINE PRT_DETAIL(KUN)
(  550) IMPLICIT NONE
(  551) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  552) CHARACTER(LEN=128) :: JOBNAME






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 12

(  553) CHARACTER(LEN=128) :: JOBID
(  554) CALL GET_ENVIRONMENT_VARIABLE('EC_JOB_NAME',JOBNAME)
(  555) IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('PBS_JOBNAME',JOBNAME)
(  556) IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('SLURM_JOB_NAME',JOBNAME)
(  557) IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_JOBNAME',JOBNAME)
(  558) CALL GET_ENVIRONMENT_VARIABLE('PBS_JOBID',JOBID)
(  559) IF (JOBID == '') CALL GET_ENVIRONMENT_VARIABLE('SLURM_JOB_ID',JOBID)
(  560) IF (JOBID == '') CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_JOBID',JOBID)
(  561) CALL PRT_EMPTY(KUN,1)
(  562) WT = UTIL_WALLTIME() - WT0
(  563) WRITE(KUN,'(4a,f10.3,a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO Detailed memory information ", &
(  564)      "for program ",TRIM(PROGRAM)," -- wall-time : ",WT,"s"
(  565) WRITE(KUN,'(a,i0,a,i0,a,i0,a,i0,a,i0,a,i0,a,a,":",a,":",a,a,a,"-",a,"-",a)') &
(  566)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO Running on ",NUMNODES," nodes (",NNUMA,&
(  567)      "-numa) with ",NPROC-IOTASKS, &
(  568)      " compute + ",IOTASKS," I/O-tasks and ", MAXTH_COMP, "+", MAXTH_IO, " threads at ", &
(  569)      CLTIMEOD(1:2),CLTIMEOD(3:4),CLTIMEOD(5:10), &
(  570)      " on ",CLDATEOD(7:8),CLMON(IMON),CLDATEOD(1:4)
(  571) WRITE(KUN,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO The Job Name is ",TRIM(JOBNAME), &
(  572)      " and the Job ID is ",TRIM(JOBID)
(  573) CALL PRT_EMPTY(KUN,1)
(  574) END SUBROUTINE PRT_DETAIL
(  575) 
(  576) SUBROUTINE PRT_HDR(KUN)
(  577) IMPLICIT NONE
(  578) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  579) INTEGER(KIND=JPIM) :: INUMA, ILEN
(  580) CHARACTER(LEN=4096) :: CLBUF
(  581) INUMA = NNUMA
(  582) 
(  583) ILEN = 0
(  584) WRITE(CLBUF(ILEN+1:),'(A)') &
(  585)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO                           | TC    | MEMORY USED(MB) "
(  586) ILEN = LEN_TRIM(CLBUF)
(  587) DO K=0,INUMA-1
(  588)    IF (K == 0) THEN
(  589)       WRITE(CLBUF(ILEN+1:),'(A)') " | MEMORY FREE(MB)"
(  590)       ILEN = LEN_TRIM(CLBUF)
(  591)    ELSE
(  592)       WRITE(CLBUF(ILEN+1:),'(A)') "  -------------  "
(  593)       ILEN = LEN_TRIM(CLBUF) + 2
(  594)    ENDIF
(  595) ENDDO
(  596) IF (NNUMA > 0) THEN
(  597)    WRITE(CLBUF(ILEN+1:),'(A)') " INCLUDING CACHED|  %USED %HUGE  | Energy  Power"
(  598) ELSE
(  599)    WRITE(CLBUF(ILEN+1:),'(A)') "  MEMORY FREE(MB) |  %USED %HUGE  | Energy  Power"
(  600) ENDIF
(  601) WRITE(KUN,'(A)') TRIM(CLBUF)
(  602) 
(  603) ILEN=0
(  604) WRITE(CLBUF(ILEN+1:),'(A)') &
(  605)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO                           | Malloc| Inc Heap        |"
(  606) ILEN = LEN_TRIM(CLBUF)
(  607) DO K=0,INUMA-1
(  608)    WRITE(CLBUF(ILEN+1:),'(A,I2,A)') " Numa region ",K," |"
(  609)    ILEN = LEN_TRIM(CLBUF)
(  610) ENDDO






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 13

(  611) WRITE(CLBUF(ILEN+1:),'(A)')  "                |               |    (J)    (W)"
(  612) WRITE(KUN,'(A)') TRIM(CLBUF)
(  613) 
(  614) ILEN=0
(  615) WRITE(CLBUF(ILEN+1:),'(A)') &
(  616)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO Node Name                 | Heap  | RSS("//zum//")        |"
(  617) ILEN = LEN_TRIM(CLBUF)
(  618) DO K=0,INUMA-1
(  619)    WRITE(CLBUF(ILEN+1:),'(A)') " Small  Huge or |"
(  620)    ILEN = LEN_TRIM(CLBUF)
(  621) ENDDO
(  622) WRITE(CLBUF(ILEN+1:),'(A)') " Total          |"
(  623) WRITE(KUN,'(A)') TRIM(CLBUF)
(  624) 
(  625) ILEN=0
(  626) WRITE(CLBUF(ILEN+1:),'(A)') &
(  627)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO                           | (sum) | Small    Huge   |"
(  628) ILEN = LEN_TRIM(CLBUF)
(  629) DO K=0,INUMA-1
(  630)    WRITE(CLBUF(ILEN+1:),'(A)') "  Only   Small  |"
(  631)    ILEN = LEN_TRIM(CLBUF)
(  632) ENDDO
(  633) WRITE(CLBUF(ILEN+1:),'(A)') " Memfree+Cached |"
(  634) WRITE(KUN,'(A)') TRIM(CLBUF)
(  635) END SUBROUTINE PRT_HDR
(  636) 
(  637) SUBROUTINE PRT_DATA(KUN)
(  638) IMPLICIT NONE
(  639) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  640) INTEGER(KIND=JPIM) :: INUMA,ILEN
(  641) CHARACTER(LEN=4096) :: CLBUF
(  642) INUMA = NNUMA
(  643) 
(  644) ILEN=0
(  645) WRITE(CLBUF(ILEN+1:),'(a,i4,1x,a,3i8,1x)') &
(  646)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
(  647)      NODENUM-1,LASTNODE,HEAP_SIZE,TASKSMALL,NODEHUGE
(  648) ILEN = LEN_TRIM(CLBUF) + 1
(  649) DO K=0,INUMA-1
(  650)    WRITE(CLBUF(ILEN+1:),'(1x,2i8)') SMALLPAGE(K),HUGEPAGE(K)
(  651)    ILEN = LEN_TRIM(CLBUF)
(  652) ENDDO
(  653) WRITE(CLBUF(ILEN+1:),'(2x,2i8,3x,2f6.1,1x,i9,1x,i6,1x,a)') &
(  654)      MEMFREE,CACHED, &
(  655)      PERCENT_USED,&
(  656)      ENERGY,POWER,&
(  657)      trim(ID_STRING)
(  658) WRITE(KUN,'(A)') TRIM(CLBUF)
(  659) END SUBROUTINE PRT_DATA
(  660) 
(  661) SUBROUTINE CONDBARR()
(  662) IF (NPROC > 1 .and. KBARR /= 0) THEN
(  663)    CALL MPI_BARRIER(KCOMM,ERROR)
(  664) ELSE
(  665)    ERROR = 0
(  666) ENDIF
(  667) END SUBROUTINE CONDBARR
(  668) 






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 14

(  669) SUBROUTINE CHECK_ERROR(CLWHAT,SRCFILE,SRCLINE)
(  670) IMPLICIT NONE
(  671) CHARACTER(LEN=*), INTENT(IN) :: CLWHAT, SRCFILE
(  672) INTEGER(KIND=JPIM), INTENT(IN) :: SRCLINE
(  673) IF (ERROR /= 0) THEN
(  674)    WRITE(0,'(A,I0,1X,A,1X,"(",A,":",I0,")")') &
(  675)         & CLPFX(1:IPFXLEN)//"## EC_MEMINFO error code =",ERROR,CLWHAT,SRCFILE,SRCLINE
(  676)    CALL MPI_ABORT(KCOMM,-1,ERROR)
(  677) ENDIF
(  678) ERROR = 0
(  679) END SUBROUTINE CHECK_ERROR
(  680) 
(  681) SUBROUTINE RNSORT(KUN)
(  682) IMPLICIT NONE
(  683) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  684) INTEGER(KIND=JPIM) :: ILEN
(  685) CHARACTER(LEN=1) :: CLAST
(  686) CHARACTER(LEN=4) :: CLMASTER
(  687) CHARACTER(LEN=4096) :: CLBUF
(  688) INTEGER(KIND=JPIM) :: impi_vers, impi_subvers, ilibrary_version_len
(  689) INTEGER(KIND=JPIM) :: iomp_vers, iomp_subvers, iopenmp
(  690) CHARACTER(LEN=4096) :: clibrary_version
(  691) LOGICAL :: LLDONE(0:NPROC-1)
(  692) INTEGER(KIND=JPIM) :: REF(0:NPROC-1) ! Keep list of the order tasks been added
(  693) LLDONE(:) = .FALSE.
(  694) IOTASKS = 0
(  695) K = 0
(  696) NODENUM = 0
(  697) DO I=0,NPROC-1
(  698)    IF (RN(I)%NODENUM == -1) THEN
(  699)       IF (RN(I)%IORANK == 1) THEN
(  700)          IOTASKS = IOTASKS + 1
(  701)          RN(I)%IORANK = IOTASKS
(  702)       ELSE
(  703)          RN(I)%IORANK = 0
(  704)       ENDIF
(  705)       NODENUM = NODENUM + 1
(  706)       RN(I)%NODENUM = NODENUM
(  707)       RN(I)%NODEMASTER = 1
(  708)       LLDONE(I) = .TRUE.
(  709)       ! NB: Adjacent REF-elements allow us to operate with particular node's tasks that follow their the node-master
(  710)       REF(K) = I
(  711)       K = K + 1
(  712)       LASTNODE = RN(I)%NODE
(  713) !      DO J=I+1,NPROC-1 ! not valid anymore since ranks might have been reordered -- need to run through the whole list -- L
(  714)       DO J=0,NPROC-1
(  715)          IF (.NOT.LLDONE(J)) THEN
(  716)             IF (RN(J)%NODENUM == -1) THEN
(  717)                IF (RN(J)%NODE == LASTNODE) THEN
(  718)                   RN(J)%NODENUM = NODENUM
(  719)                   IF (RN(J)%IORANK == 1) THEN
(  720)                      IOTASKS = IOTASKS + 1
(  721)                      RN(J)%IORANK = IOTASKS
(  722)                   ELSE
(  723)                      RN(J)%IORANK = 0
(  724)                   ENDIF
(  725)                   RN(J)%NODEMASTER = 0
(  726)                   LLDONE(J) = .TRUE.






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 15

(  727)                   REF(K) = J
(  728)                   K = K + 1
(  729)                ENDIF
(  730)             ENDIF
(  731)          ENDIF
(  732)       ENDDO
(  733)    ENDIF
(  734) ENDDO
(  735) NUMNODES = NODENUM
(  736) CALL ecmpi_version(impi_vers, impi_subvers, clibrary_version, ilibrary_version_len)
(  737) call ecomp_version(iomp_vers, iomp_subvers, iopenmp)
(  738) CALL PRT_EMPTY(KUN,1)
(  739) WRITE(KUN,'(a,i0,".",i0)') &
(  740)      & CLPFX(1:IPFXLEN)//&
(  741)      & "## EC_MEMINFO : MPI-version ",impi_vers, impi_subvers
(  742) WRITE(KUN,'(a)')  &
(  743)      & CLPFX(1:IPFXLEN)//&
(  744)      & "## EC_MEMINFO : Start of MPI-library version"
(  745) WRITE(KUN,'(a)') trim(clibrary_version) ! This is could be a multiline, very long string
(  746) WRITE(KUN,'(a)')  &
(  747)      & CLPFX(1:IPFXLEN)//&
(  748)      & "## EC_MEMINFO : End of MPI-library version"
(  749) WRITE(KUN,'(a,i0,".",i0,".",i6.6)') &
(  750)      & CLPFX(1:IPFXLEN)//&
(  751)      & "## EC_MEMINFO : OpenMP-version ",iomp_vers, iomp_subvers, iopenmp
(  752) CALL PRT_EMPTY(KUN,2)
(  753) WRITE(KUN,1003) &
(  754)      & CLPFX(1:IPFXLEN)//&
(  755)      &"## EC_MEMINFO ********************************************************************************",&
(  756)      & CLPFX(1:IPFXLEN)//&
(  757)      &"## EC_MEMINFO *** Mapping of MPI & I/O-tasks to nodes and tasks' thread-to-core affinities ***", &
(  758)      & CLPFX(1:IPFXLEN)//&
(  759)      &"## EC_MEMINFO ********************************************************************************"
(  760) 1003 FORMAT((A))
(  761) CALL PRT_EMPTY(KUN,1)
(  762) WRITE(KUN,'(a,i0,a,i0,a,i0,a,i0,a,i0,a,i0,a)') &
(  763)      & CLPFX(1:IPFXLEN)//"## EC_MEMINFO Running on ",NUMNODES," nodes (",NNUMA,&
(  764)      & "-numa) with ",NPROC-IOTASKS, &
(  765)      & " compute + ",IOTASKS," I/O-tasks and ", MAXTH_COMP, "+", MAXTH_IO, " threads"
(  766) CALL PRT_EMPTY(KUN,1)
(  767) WRITE(KUN,1000) CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  768)      & "#","NODE#","NODENAME","MPI#","WORLD#","I/O#","MASTER","REF#","OMP#","Core affinities"
(  769) WRITE(KUN,1000) CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  770)      & "=","=====","========","====","======","====","======","====","====","==============="
(  771) 1000 FORMAT(A,2(1X,A5),1X,A20,6(1X,A6),2X,A)
(  772) CALL PRT_EMPTY(KUN,1)
(  773) DO K=0,NPROC-1 ! Loop over the task as they have been added (see few lines earlier how REF(K) has been getting its values I 
(  774)    ILEN = 0
(  775)    ! A formidable trick ? No need for a nested loop over 0:NPROC-1 to keep tasks within the same node together in the output
(  776)    I = REF(K)
(  777)    NUMTH = RN(I)%NUMTH
(  778)    CLMASTER = '[No]'
(  779)    IF (RN(I)%NODEMASTER == 1) CLMASTER = ' Yes'
(  780)    IF (RN(I)%IORANK > 0) THEN
(  781)       WRITE(CLBUF(ILEN+1:),1001) &
(  782)            & CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  783)            & K,RN(I)%NODENUM-1,TRIM(ADJUSTL(RN(I)%NODE)),RN(I)%RANK,RN(I)%RANK_WORLD,RN(I)%IORANK-1,&
(  784)            & CLMASTER,I,NUMTH,"{"






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 16

(  785) 1001  FORMAT(A,2(1X,I5),1X,A20,3(1X,I6),1X,A6,2(1X,I6),2X,A)
(  786)    ELSE
(  787)       WRITE(CLBUF(ILEN+1:),1002) &
(  788)            & CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  789)            & K,RN(I)%NODENUM-1,TRIM(ADJUSTL(RN(I)%NODE)),RN(I)%RANK,RN(I)%RANK_WORLD,"[No]",&
(  790)            & CLMASTER,I,NUMTH,"{"
(  791) 1002  FORMAT(A,2(1X,I5),1X,A20,2(1X,I6),2(1X,A6),2(1X,I6),2X,A)
(  792)    ENDIF
(  793)    ILEN = LEN_TRIM(CLBUF)
(  794)    CLAST = ','
(  795)    DO J=0,NUMTH-1
(  796)       IF (J == NUMTH-1) CLAST = '}'
(  797)       WRITE(CLBUF(ILEN+1:),'(I0,A1)') RN(I)%COREIDS(J),CLAST
(  798)       ILEN = LEN_TRIM(CLBUF)
(  799)    ENDDO
(  800)    WRITE(KUN,'(A,1X)') TRIM(CLBUF)
(  801) ENDDO
(  802) CALL PRT_EMPTY(KUN,1)
(  803) CALL FLUSH(KUN)
(  804) END SUBROUTINE RNSORT
(  805) 
(  806) END SUBROUTINE EC_MEMINFO
(  807) 
(  808) SUBROUTINE MEMINFO(KOUT,KSTEP)
(  809) USE PARKIND1, ONLY : JPIM, JPIB
(  810) IMPLICIT NONE
(  811) INTEGER(KIND=JPIM), INTENT(IN) :: KOUT, KSTEP
(  812) CHARACTER(LEN=32) CLSTEP
(  813) CHARACTER(LEN=160) :: LINE
(  814) CHARACTER(LEN=20) :: NODENAME
(  815) INTEGER(KIND=JPIB) :: NODE(0:17), ISMALL, IHUGE, ITOTAL
(  816) INTEGER(KIND=JPIM) :: I,INUMA,ICOMM
(  817) #include "ec_meminfo.intfb.h"
(  818) WRITE(CLSTEP,'(11X,"STEP",I5," :")') KSTEP
(  819) ICOMM = -2 ! No headers from EC_MEMINFO by default
(  820) IF (KSTEP == 0) ICOMM = -1 ! Do print headers, too
(  821) CALL EC_MEMINFO(KOUT,TRIM(CLSTEP),ICOMM,KBARR=0,KIOTASK=-1,KCALL=-1)
(  822) CALL FLUSH(KOUT)
(  823) RETURN ! For now
(  824) #if 0
(  825) CALL EC_GETHOSTNAME(NODENAME) ! from support/env.c
(  826) OPEN(FILE="/proc/buddyinfo",UNIT=502,ERR=98,STATUS="old",ACTION="read")
(  827) READ(502,'(a)',END=99) LINE
(  828) READ(502,'(a)',END=99) LINE
(  829) DO INUMA=0,1
(  830)    NODE(:)=0
(  831)    READ(502,'(a)',END=99) LINE
(  832)    READ(LINE(22:160),*,ERR=99,END=99) NODE
(  833)    ISMALL = 0
(  834)    DO I=0,8
(  835)       ISMALL = ISMALL + NODE(I) * (2**I)
(  836)    ENDDO
(  837)    ! Pages >= 2M
(  838)    IHUGE = 0
(  839)    DO I=9,SIZE(NODE)-1
(  840)       IHUGE = IHUGE + NODE(I) * (2**I)
(  841)    ENDDO
(  842)    ITOTAL = ISMALL + IHUGE






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 17

(  843)    ISMALL = (ISMALL * 4096)/ONEMEGA
(  844)    IHUGE = (IHUGE * 4096)/ONEMEGA
(  845)    ITOTAL = (ITOTAL * 4096)/ONEMEGA
(  846)    WRITE(KOUT,'("   MEMINFO: STEP=",I0," ",A," NUMA# ",I0," : Free Total = SMALL + HUGEPAGES in MB: ",I0," = ",I0," + ",I0)'
(  847)         & KSTEP, NODENAME, INUMA, ITOTAL, ISMALL, IHUGE
(  848)    WRITE(KOUT,'(" BUDDYINFO: STEP=",I0," ",A," NUMA# ",I0," : Count of free 2^(0..",I0,")*4096B blocks: ",A)') &
(  849)         & KSTEP, NODENAME, INUMA, SIZE(NODE)-1, LINE(22:160)
(  850) ENDDO
(  851) 99 CONTINUE
(  852) CLOSE(502)
(  853) 98 CONTINUE
(  854) CALL FLUSH(KOUT)
(  855) #endif
(  856) END SUBROUTINE MEMINFO
(  857) 
(  858) SUBROUTINE EC_MPI_FINALIZE(KERROR,LDCALLFINITO,LDMEMINFO,CALLER)
(  859) USE PARKIND1, ONLY : JPIM
(  860) USE MPL_MPIF
(  861) IMPLICIT NONE
(  862) INTEGER(KIND=JPIM), INTENT(OUT) :: KERROR
(  863) LOGICAL, INTENT(IN) :: LDCALLFINITO
(  864) LOGICAL, INTENT(IN) :: LDMEMINFO
(  865) CHARACTER(LEN=*), INTENT(IN) :: CALLER
(  866) LOGICAL :: LLINIT, LLFIN, LLNOTMPIWORLD
(  867) INTEGER(KIND=JPIM) :: IERR, ICOMM
(  868) INTEGER(KIND=JPIM) :: NCOMM_MEMINFO
(  869) COMMON /cmn_meminfo/ NCOMM_MEMINFO
(  870) #include "ec_meminfo.intfb.h"
(  871) KERROR = 0
(  872) IF (LDCALLFINITO) THEN !*** common MPI_Finalize()
(  873)   CALL MPI_INITIALIZED(LLINIT,IERR)
(  874)   IF (LLINIT .AND. IERR == 0) THEN
(  875)     CALL MPI_FINALIZED(LLFIN,IERR)
(  876)     IF (.NOT.LLFIN .AND. IERR == 0) THEN
(  877)       LLNOTMPIWORLD = (NCOMM_MEMINFO /= 0 .and. NCOMM_MEMINFO /= MPI_COMM_WORLD)
(  878)       IF (LLNOTMPIWORLD) THEN
(  879)         ICOMM = NCOMM_MEMINFO
(  880)       ELSE
(  881)         ICOMM = MPI_COMM_WORLD
(  882)       ENDIF
(  883)       IF( LDMEMINFO ) CALL EC_MEMINFO(-1,"ec_mpi_finalize:"//caller,ICOMM,KBARR=1,KIOTASK=-1,KCALL=1)
(  884)       CALL c_drhook_prof() ! ifsaux/support/drhook.c : Make sure DrHook output is produced before MPI_Finalize (in case it f
(  885)       CALL MPI_BARRIER(ICOMM,IERR)
(  886)       IF (LLNOTMPIWORLD) THEN
(  887)         ! CALL MPI_COMM_FREE(NCOMM_MEMINFO,IERR)
(  888)         NCOMM_MEMINFO = 0
(  889)       ENDIF
(  890)       CALL MPI_FINALIZE(KERROR)
(  891)     ENDIF
(  892)   ENDIF
(  893) ENDIF
(  894) END SUBROUTINE EC_MPI_FINALIZE
(  895) 
(  896) SUBROUTINE EC_PMON(ENERGY,POWER)
(  897) USE PARKIND1, ONLY : JPIM, JPIB
(  898) IMPLICIT NONE
(  899) INTEGER(KIND=JPIB),INTENT(OUT) :: ENERGY,POWER
(  900) INTEGER(KIND=JPIB),SAVE :: ENERGY_START = 0






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 18

(  901) INTEGER(KIND=JPIM),SAVE :: MONINIT = 0
(  902) INTEGER(KIND=JPIM) :: ISTAT
(  903) CHARACTER(LEN=1) :: CLEC_PMON
(  904) ENERGY = 0
(  905) IF (MONINIT >= 0) THEN
(  906)    IF (MONINIT == 0) THEN ! The very first time only
(  907)       CALL GET_ENVIRONMENT_VARIABLE('EC_PMON',CLEC_PMON)
(  908)       IF (CLEC_PMON == '0') MONINIT = -2 ! Never try again
(  909)    ENDIF
(  910)    IF (MONINIT >= 0) THEN
(  911)       OPEN(503,FILE='/sys/cray/pm_counters/energy',IOSTAT=ISTAT,STATUS='old',ACTION='read')
(  912)       IF (ISTAT == 0) THEN
(  913)          READ(503,*,IOSTAT=ISTAT) ENERGY
(  914)          CLOSE(503)
(  915)          IF (ISTAT == 0) THEN
(  916)             IF (MONINIT == 0) THEN
(  917)                ENERGY_START = ENERGY
(  918)                MONINIT = 1 ! Ok
(  919)             ENDIF
(  920)             ENERGY = ENERGY - ENERGY_START
(  921)          ENDIF
(  922)       ENDIF
(  923)       IF (ISTAT /= 0) THEN
(  924)          MONINIT = -1 ! Never try again
(  925)          ENERGY = 0
(  926)       ENDIF
(  927)    ENDIF
(  928) ENDIF
(  929) POWER = 0
(  930) IF (MONINIT > 0) THEN
(  931)    OPEN(504,FILE='/sys/cray/pm_counters/power',IOSTAT=ISTAT,STATUS='old',ACTION='read')
(  932)    IF (ISTAT == 0) THEN
(  933)       READ(504,*,IOSTAT=ISTAT) POWER
(  934)       CLOSE(504)
(  935)    ENDIF
(  936)    IF (ISTAT /= 0) POWER = 0
(  937) ENDIF
(  938) END SUBROUTINE EC_PMON


























NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 19

(    1) # 1 "ec_meminfo.F90"
(    1) SUBROUTINE EC_MEMINFO(KU,CDSTRING,KCOMM,KBARR,KIOTASK,KCALL)
(    2) # 3 "ec_meminfo.F90"
(    3) USE PARKIND1, ONLY : JPIM, JPIB, JPRD
(    4) USE MPL_MPIF
(    5) # 6 "ec_meminfo.F90"
(    6) IMPLICIT NONE
(    7) # 8 "ec_meminfo.F90"
(    8) !-- EC_MEMINFO:
(    9) !   Author   : Peter Towers (ECMWF)  : 2015-2016
(   10) !   Modified : Sami Saarinen (ECMWF) : 21-SEP-2016 : Added getenv EC_MEMINFO -- export EC_MEMINFO=0 disables any EC_MEMINFO output
(   11) !              Sami Saarinen (ECMWF) : 02-MAR-2017 : Enabled flexible number of sockets & lots of tidying
(   12) !              Sami Saarinen (ECMWF) : 09-MAR-2017 : Power monitoring added (via EC_PMON) -- works at least on Cray systems
(   13) !              Sami Saarinen (ECMWF) : 12-MAR-2017 : Gather core affinities via call to ec_coreid()
(   14) !              Sami Saarinen (ECMWF) : 12-DEC-2017 : Obtain MPI & OpenMP version information
(   15) # 16 "ec_meminfo.F90"
(   16) # 1 ".D[61]/ec_pmon.intfb.h"
(    1) INTERFACE
(    2) SUBROUTINE EC_PMON(ENERGY,POWER)
(    3) USE PARKIND1, ONLY : JPIB
(    4) INTEGER(KIND=JPIB),INTENT(OUT) :: ENERGY,POWER
(    5) END SUBROUTINE EC_PMON
(    6) END INTERFACE
(    7) # 17 "ec_meminfo.F90"
(   17) # 18 "ec_meminfo.F90"
(   18) INTEGER(KIND=JPIM), INTENT(IN) :: KU,KCOMM,KBARR,KIOTASK,KCALL
(   19) CHARACTER(LEN=*), INTENT(IN) :: CDSTRING
(   20) INTEGER(KIND=JPIM), PARAMETER :: ITAG = 98765
(   21) INTEGER(KIND=JPIM) :: ID,KULOUT
(   22) INTEGER(KIND=JPIM) :: II,JJ,I,J,K,MYPROC,NPROC,LEN,ERROR,NODENUM,JID,IDX
(   23) INTEGER(KIND=JPIB) :: TASKSMALL,NODEHUGE,MEMFREE,CACHED,NFREE
(   24) INTEGER(KIND=JPIB),SAVE :: NODEHUGE_CACHED
(   25) INTEGER(KIND=JPIM), PARAMETER :: MAXNUMA_DEF = 4 ! Max number of "sockets" supported by default
(   26) INTEGER(KIND=JPIM), SAVE :: MAXNUMA = 0 ! Max number of "sockets" supported -- initialized to zero to enforce updated value (env EC_MAXNUMA)
(   27) INTEGER(KIND=JPIM) :: NNUMA ! Actual number of "sockets" (can be 0 ob systems that do not have /proc/buddyinfo, e.g. WSL)
(   28) !INTEGER(KIND=JPIB),DIMENSION(0:MAXNUMA-1) :: SMALLPAGE,HUGEPAGE
(   29) INTEGER(KIND=JPIB),DIMENSION(:),ALLOCATABLE,SAVE :: SMALLPAGE,HUGEPAGE
(   30) INTEGER(KIND=JPIB) :: GETMAXRSS,GETMAXHWM
(   31) INTEGER(KIND=JPIB) :: HEAP_SIZE
(   32) INTEGER(KIND=JPIB), PARAMETER :: ONEMEGA = 1024_JPIB * 1024_JPIB
(   33) INTEGER(KIND=JPIB) :: ENERGY, POWER
(   34) INTEGER(KIND=JPIB) :: TOT_ENERGY, MAXPOWER, AVGPOWER
(   35) INTEGER(KIND=JPIM),SAVE :: PAGESIZE = 0
(   36) INTEGER(KIND=JPIM),SAVE :: MAXTH = 0
(   37) INTEGER(KIND=JPIM),SAVE :: MAXTH_COMP = 0
(   38) INTEGER(KIND=JPIM),SAVE :: MAXTH_IO = 0
(   39) INTEGER(KIND=JPIM),PARAMETER :: MAXCOLS = 18 ! Max numerical columns in /proc/buddyinfo (often just 11, but Cray has 18 entries)
(   40) INTEGER(KIND=JPIM) :: N18
(   41) !INTEGER(KIND=JPIB),DIMENSION(0:MAXCOLS-1,0:MAXNUMA-1) :: NODE, BUCKET
(   42) !INTEGER(KIND=JPIB),DIMENSION(7+2*MAXNUMA) :: SENDBUF,RECVBUF
(   43) INTEGER(KIND=JPIB),DIMENSION(:,:),ALLOCATABLE,SAVE :: NODE, BUCKET
(   44) INTEGER(KIND=JPIB),DIMENSION(:),ALLOCATABLE,SAVE :: SENDBUF,RECVBUF
(   45) REAL(KIND=JPRD) :: PERCENT_USED(2)
(   46) CHARACTER(LEN=256) :: CLSTR
(   47) CHARACTER(LEN=512) :: TMPDIR
(   48) CHARACTER(LEN=512), SAVE :: PROGRAM = ' '
(   49) CHARACTER(LEN=20)  :: NODENAME,LASTNODE,CLMAXNODE
(   50) CHARACTER(LEN=12)  :: VAL






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 20

(   51) CHARACTER(LEN=1)   :: M
(   52) CHARACTER(LEN=160) ::LINE
(   53) CHARACTER(LEN=56) :: FILENAME
(   54) CHARACTER(LEN=1) :: CLEC_MEMINFO
(   55) CHARACTER(LEN=5) :: CSTAR
(   56) CHARACTER(LEN=LEN(CSTAR)+1+LEN(CDSTRING)) :: ID_STRING
(   57) CHARACTER(LEN=10) ::  CLDATEOD,CLTIMEOD,CLZONEOD
(   58) CHARACTER(LEN=3), PARAMETER :: CLMON(1:12) = (/ &
(   59)      'Jan','Feb','Mar','Apr','May','Jun', &
(   60)      'Jul','Aug','Sep','Oct','Nov','Dec' /)
(   61) INTEGER(KIND=JPIM) :: IVALUES(8), IMON
(   62) INTEGER(KIND=JPIM) :: IRECV_STATUS(MPI_STATUS_SIZE)
(   63) LOGICAL :: LLNOCOMM, LLNOHDR
(   64) INTEGER(KIND=JPIM), SAVE :: IAM_NODEMASTER = 0
(   65) LOGICAL, SAVE :: LLFIRST_TIME = .TRUE.
(   66) TYPE RANKNODE_T
(   67)    INTEGER(KIND=JPIM) :: NODENUM
(   68)    INTEGER(KIND=JPIM) :: RANK_WORLD
(   69)    INTEGER(KIND=JPIM) :: RANK
(   70)    INTEGER(KIND=JPIM) :: IORANK
(   71)    INTEGER(KIND=JPIM) :: NODEMASTER
(   72)    INTEGER(KIND=JPIM) :: NUMTH
(   73)    INTEGER(KIND=JPIM), ALLOCATABLE :: COREIDS(:)
(   74)    CHARACTER(LEN=LEN(NODENAME)) :: NODE
(   75)    CHARACTER(LEN=LEN(CLSTR)) :: STR
(   76) END TYPE
(   77) TYPE (RANKNODE_T), ALLOCATABLE, SAVE :: RN(:)
(   78) INTEGER(KIND=JPIM), ALLOCATABLE :: COREIDS(:)
(   79) LOGICAL, ALLOCATABLE :: DONE(:)
(   80) INTEGER(KIND=JPIM), SAVE :: NUMNODES = 0
(   81) INTEGER(KIND=JPIM) :: NN
(   82) INTEGER(KIND=JPIM), SAVE :: IOTASKS = 0
(   83) INTEGER(KIND=JPIM) :: IORANK, NSEND, NRECV
(   84) LOGICAL :: FILE_EXISTS
(   85) REAL(KIND=JPRD), EXTERNAL :: UTIL_WALLTIME
(   86) REAL(KIND=JPRD), SAVE :: WT0
(   87) REAL(KIND=JPRD) :: WT
(   88) CHARACTER(LEN=64) :: CLPFX
(   89) CHARACTER(LEN=3) :: ZUM
(   90) INTEGER(KIND=JPIM) :: IPFXLEN, NUMTH, MYTH
(   91) INTEGER(KIND=JPIM) :: NCOMM_MEMINFO = 0
(   92) COMMON /cmn_meminfo/ NCOMM_MEMINFO
(   93) INTEGER OMP_GET_MAX_THREADS, OMP_GET_THREAD_NUM
(   94) # 95 "ec_meminfo.F90"
(   95) EXTERNAL OMP_GET_MAX_THREADS, OMP_GET_THREAD_NUM
(   96) # 101 "ec_meminfo.F90"
(  101) CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO',CLEC_MEMINFO)
(  102) IF (CLEC_MEMINFO == '0') RETURN
(  103) # 104 "ec_meminfo.F90"
(  104) IF (LLFIRST_TIME) WT0 = UTIL_WALLTIME()
(  105) IF (MAXTH == 0) MAXTH = OMP_GET_MAX_THREADS()
(  106) # 107 "ec_meminfo.F90"
(  107) LLNOCOMM = (KCOMM == -1 .or. KCOMM == -2)
(  108) LLNOHDR = (KCOMM == -2)
(  109) # 110 "ec_meminfo.F90"
(  110) IF (LLNOCOMM) THEN
(  111)    ! Direct call to obtain EC_meminfo -output
(  112)    ERROR = 0






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 21

(  113)    MYPROC = 0
(  114)    NPROC = 1
(  115)    CLPFX = CDSTRING
(  116)    IPFXLEN = LEN_TRIM(CLPFX)
(  117)    ZUM = 'tsk'
(  118) ELSE
(  119)    CLPFX = ' '
(  120)    IPFXLEN = 0
(  121)    ZUM = 'sum'
(  122)    CALL MPI_COMM_RANK(KCOMM,MYPROC,ERROR)
(  123)    CALL CHECK_ERROR("from MPI_COMM_RANK","ec_meminfo.F90",123)
(  124) # 125 "ec_meminfo.F90"
(  125)    CALL MPI_COMM_SIZE(KCOMM,NPROC,ERROR)
(  126)    CALL CHECK_ERROR("from MPI_COMM_SIZE","ec_meminfo.F90",126)
(  127) # 128 "ec_meminfo.F90"
(  128)    IF (KCALL == 0) THEN
(  129)       CALL CONDBARR()
(  130)       CALL CHECK_ERROR("from MPI_BARRIER(at start)","ec_meminfo.F90",130)
(  131)    ENDIF
(  132) ENDIF
(  133) # 134 "ec_meminfo.F90"
(  134) IF (LLFIRST_TIME) THEN ! The *very* first time
(  135)    CALL EC_PMON(ENERGY,POWER)
(  136) # 137 "ec_meminfo.F90"
(  137)    !-- Neither of these two may stop working when linking with C++ (like in OOPS) ...
(  138)    ! CALL GETARG(0,PROGRAM)
(  139)    ! CALL GET_COMMAND_ARGUMENT(0,PROGRAM)
(  140)    !... so using the old saviour from ifsaux/support/cargs.c:
(  141)    CALL GETARG_C(0,PROGRAM)
(  142) # 143 "ec_meminfo.F90"
(  143)    CALL GET_ENVIRONMENT_VARIABLE("HUGETLB_DEFAULT_PAGE_SIZE",VAL)
(  144)    I=INDEX(VAL,"M")
(  145)    IF(I > 0) THEN
(  146)       READ(VAL(1:I-1),*) PAGESIZE
(  147)       PAGESIZE=PAGESIZE*1024
(  148)    ELSE
(  149)       PAGESIZE=0
(  150)    ENDIF
(  151) # 152 "ec_meminfo.F90"
(  152)    NODEHUGE=0
(  153)    
(  154)    IF(PAGESIZE > 0) THEN
(  155)       !WRITE(FILENAME,'(a,i0,a)') "/sys/kernel/mm/hugepages/hugepages-", &
(  156)       !     PAGESIZE,"kB/nr_hugepages"
(  157)       FILENAME='/proc/sys/vm/nr_hugepages' ! more generic; contents the same as in /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages
(  158)       INQUIRE(FILE=FILENAME, EXIST=FILE_EXISTS)
(  159)       IF( FILE_EXISTS ) THEN
(  160)         OPEN(502,FILE=FILENAME,STATUS="old",ACTION="read",ERR=999)
(  161)         READ(502,*,ERR=998,END=998) NODEHUGE
(  162) 998     continue
(  163)         CLOSE(502)
(  164)       ENDIF
(  165) 999   continue
(  166)    ENDIF
(  167) # 168 "ec_meminfo.F90"
(  168)    NODEHUGE=NODEHUGE*PAGESIZE
(  169)    NODEHUGE=NODEHUGE/1024
(  170)    NODEHUGE_CACHED = NODEHUGE






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 22

(  171) ENDIF
(  172) # 173 "ec_meminfo.F90"
(  173) NODEHUGE=NODEHUGE_CACHED
(  174) # 175 "ec_meminfo.F90"
(  175) CALL EC_GETHOSTNAME(NODENAME) ! from support/env.c
(  176) # 177 "ec_meminfo.F90"
(  177) IF (MAXNUMA == 0) THEN
(  178)    CALL GET_ENVIRONMENT_VARIABLE("EC_MAXNUMA",VAL) ! Note: *not* export EC_MEMINFO_MAXNUMA=<value>, but EC_MAXNUMA=<value>
(  179)    IF (VAL /= "") READ(VAL,*) MAXNUMA
(  180)    IF (MAXNUMA < 1) MAXNUMA = MAXNUMA_DEF
(  181)    ALLOCATE(SMALLPAGE(0:MAXNUMA-1))
(  182)    ALLOCATE(HUGEPAGE(0:MAXNUMA-1))
(  183)    ALLOCATE(NODE(0:MAXCOLS-1,0:MAXNUMA-1))
(  184)    ALLOCATE(BUCKET(0:MAXCOLS-1,0:MAXNUMA-1))
(  185)    ALLOCATE(SENDBUF(7+2*MAXNUMA))
(  186)    ALLOCATE(RECVBUF(7+2*MAXNUMA))
(  187) ENDIF
(  188) # 189 "ec_meminfo.F90"
(  189) IF (MYPROC == 0) THEN 
(  190) !
(  191) ! Use already open file for output or $EC_MEMINFO_TMPDIR/meminfo
(  192) ! We do not use $TMPDIR as it may have been inherited from mother superiour (MOMS) node
(  193) !
(  194)    IF(KU == -1) THEN
(  195)       CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_TMPDIR',TMPDIR)
(  196)       IF (TMPDIR == ' ') TMPDIR = '.'
(  197)       !    write(0,*) '## EC_MEMINFO: KCOMM=',KCOMM
(  198)       !    CALL LINUX_TRBK()
(  199)       KULOUT=501
(  200)       OPEN(UNIT=KULOUT,FILE=TRIM(TMPDIR)//"/"//"meminfo.txt",STATUS='unknown', &
(  201)            ACTION='write',POSITION='append')
(  202)    ELSE
(  203)       KULOUT=KU
(  204)    ENDIF
(  205) ENDIF
(  206) # 207 "ec_meminfo.F90"
(  207) IF (LLFIRST_TIME .and. .not. LLNOCOMM) THEN
(  208) ! Fetch affinities (over OpenMP threads)
(  209) ! Note: I/O-tasks may now have different number of threads than on computational tasks
(  210)    ALLOCATE(COREIDS(0:MAXTH-1))
(  211) # 212 "ec_meminfo.F90"
(  212) !$OMP PARALLEL NUM_THREADS(MAXTH) SHARED(COREIDS) PRIVATE(MYTH)
(  213) # 214 "ec_meminfo.F90"
(  214)    MYTH = OMP_GET_THREAD_NUM()
(  215)    CALL EC_COREID(COREIDS(MYTH))
(  216) # 217 "ec_meminfo.F90"
(  217) !$OMP END PARALLEL
(  218) # 220 "ec_meminfo.F90"
(  220) ! Store the communicator we are in upon entering EC_MEMINFO for the first time -- to be used in the EC_MPI_FINALIZE
(  221)    NCOMM_MEMINFO = KCOMM
(  222) ! Fetch node names & numbers per task
(  223)    IORANK = 0
(  224)    IF (KIOTASK > 0) IORANK = 1
(  225)    IF (MYPROC == 0) THEN
(  226)       CALL SLASH_PROC
(  227)       ALLOCATE(RN(0:NPROC-1))
(  228)       DO I=0,NPROC-1
(  229)          RN(I)%NODENUM = -1






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 23

(  230)          IF (I > 0) THEN ! Receive in the MPI-rank order of KCOMM (i.e. may not be the same as MPI_COMM_WORLD -order)
(  231)             CALL MPI_RECV(LASTNODE,LEN(LASTNODE),MPI_BYTE,I,ITAG,KCOMM,IRECV_STATUS,ERROR)
(  232)             CALL CHECK_ERROR("from MPI_RECV(LASTNODE)","ec_meminfo.F90",232)
(  233)             CALL MPI_RECV(IORANK,1,MPI_INTEGER4,I,ITAG+1,KCOMM,IRECV_STATUS,ERROR)
(  234)             CALL CHECK_ERROR("from MPI_RECV(IORANK)","ec_meminfo.F90",234)
(  235)             CALL MPI_RECV(K,1,MPI_INTEGER4,I,ITAG+2,KCOMM,IRECV_STATUS,ERROR)
(  236)             CALL CHECK_ERROR("from MPI_RECV(RANK_WORLD)","ec_meminfo.F90",236)
(  237)             CALL MPI_RECV(NUMTH,1,MPI_INTEGER4,I,ITAG+3,KCOMM,IRECV_STATUS,ERROR)
(  238)             CALL CHECK_ERROR("from MPI_RECV(NUMTH)","ec_meminfo.F90",238)
(  239)             CALL MPI_RECV(CLSTR,LEN(CLSTR),MPI_BYTE,I,ITAG+4,KCOMM,IRECV_STATUS,ERROR)
(  240)             CALL CHECK_ERROR("from MPI_RECV(CLSTR)","ec_meminfo.F90",240)
(  241)             RN(I)%RANK = I
(  242)             RN(I)%STR = CLSTR
(  243)          ELSE
(  244)             LASTNODE=NODENAME
(  245)             NUMTH = MAXTH
(  246)             CALL MPI_COMM_RANK(MPI_COMM_WORLD,K,ERROR)
(  247)             RN(I)%RANK = 0 ! Itself
(  248)             RN(I)%STR = CDSTRING
(  249)          ENDIF
(  250)          RN(I)%RANK_WORLD = K
(  251)          RN(I)%IORANK = IORANK
(  252)          RN(I)%NODEMASTER = 0
(  253)          RN(I)%NODE = LASTNODE
(  254)          ! Affinities
(  255)          RN(I)%NUMTH = NUMTH
(  256)          ALLOCATE(RN(I)%COREIDS(0:NUMTH-1))
(  257)          IF (I > 0) THEN ! Receive in MPI-rank order
(  258)             CALL MPI_RECV(RN(I)%COREIDS,NUMTH,MPI_INTEGER4,I,ITAG+5,KCOMM,IRECV_STATUS,ERROR)
(  259)             CALL CHECK_ERROR("from MPI_RECV(COREIDS)","ec_meminfo.F90",259)
(  260)          ELSE
(  261)             RN(I)%COREIDS = COREIDS
(  262)          ENDIF
(  263)          IF (IORANK == 0) THEN
(  264)             MAXTH_COMP = MAX(MAXTH_COMP,NUMTH)
(  265)          ELSE
(  266)             MAXTH_IO = MAX(MAXTH_IO,NUMTH)
(  267)          ENDIF
(  268)       ENDDO
(  269)       
(  270)       CALL RNSORT(KULOUT) ! Output now goes to "meminfo.txt"
(  271) # 272 "ec_meminfo.F90"
(  272)       IAM_NODEMASTER = RN(0)%NODEMASTER ! Itself
(  273)       DO I=1,NPROC-1
(  274)          CALL MPI_SEND(RN(I)%NODEMASTER,1,MPI_INTEGER4,I,ITAG+6,KCOMM,ERROR)
(  275)          CALL CHECK_ERROR("from MPI_SEND(IAM_NODEMASTER)","ec_meminfo.F90",275)
(  276)       ENDDO
(  277)    ELSE
(  278)       CALL MPI_SEND(NODENAME,LEN(NODENAME),MPI_BYTE,0,ITAG,KCOMM,ERROR)
(  279)       CALL CHECK_ERROR("from MPI_SEND(NODENAME)","ec_meminfo.F90",279)
(  280)       CALL MPI_SEND(IORANK,1,MPI_INTEGER4,0,ITAG+1,KCOMM,ERROR)
(  281)       CALL CHECK_ERROR("from MPI_SEND(IORANK)","ec_meminfo.F90",281)
(  282)       CALL MPI_COMM_RANK(MPI_COMM_WORLD,K,ERROR)
(  283)       CALL MPI_SEND(K,1,MPI_INTEGER4,0,ITAG+2,KCOMM,ERROR)
(  284)       CALL CHECK_ERROR("from MPI_SEND(RANK_WORLD)","ec_meminfo.F90",284)
(  285)       CALL MPI_SEND(MAXTH,1,MPI_INTEGER4,0,ITAG+3,KCOMM,ERROR)
(  286)       CALL CHECK_ERROR("from MPI_SEND(MAXTH)","ec_meminfo.F90",286)
(  287)       CLSTR = CDSTRING






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 24

(  288)       CALL MPI_SEND(CLSTR,LEN(CLSTR),MPI_BYTE,0,ITAG+4,KCOMM,ERROR)
(  289)       CALL CHECK_ERROR("from MPI_SEND(CLSTR)","ec_meminfo.F90",289)
(  290)       CALL MPI_SEND(COREIDS,MAXTH,MPI_INTEGER4,0,ITAG+5,KCOMM,ERROR)
(  291)       CALL CHECK_ERROR("from MPI_SEND(COREIDS)","ec_meminfo.F90",291)
(  292)       CALL MPI_RECV(IAM_NODEMASTER,1,MPI_INTEGER4,0,ITAG+6,KCOMM,IRECV_STATUS,ERROR)
(  293)       CALL CHECK_ERROR("from MPI_RECV(IAM_NODEMASTER)","ec_meminfo.F90",293)
(  294)    ENDIF
(  295)    DEALLOCATE(COREIDS)
(  296)    LLFIRST_TIME = .FALSE.
(  297)    CALL CONDBARR()
(  298)    CALL CHECK_ERROR("from MPI_BARRIER near LLFIRST_TIME=.FALSE.","ec_meminfo.F90",298)
(  299) ENDIF
(  300) # 301 "ec_meminfo.F90"
(  301) IF (MYPROC == 0 .or. IAM_NODEMASTER == 1) CALL SLASH_PROC
(  302) # 303 "ec_meminfo.F90"
(  303) HEAP_SIZE=GETMAXHWM()/ONEMEGA
(  304) TASKSMALL=GETMAXRSS()/ONEMEGA
(  305) # 306 "ec_meminfo.F90"
(  306) IF (MYPROC == 0) THEN
(  307)    CALL DATE_AND_TIME(CLDATEOD,CLTIMEOD,CLZONEOD,IVALUES)
(  308)    READ(CLDATEOD(5:6),'(I2)') IMON
(  309)    IF (.not.LLNOCOMM .AND. KCALL /= 1) CALL PRT_DETAIL(KULOUT)
(  310)    IF (.not.LLNOHDR)  CALL PRT_HDR(KULOUT)
(  311)    IF(KU == -1) THEN
(  312)       IF (KCALL /= 1) CALL PRT_DETAIL(0)
(  313)       CALL PRT_HDR(0)
(  314)    ENDIF
(  315) # 316 "ec_meminfo.F90"
(  316)    ! Note: MYPROC == 0 is always at the RN(0) i.e. at the first NODENUM
(  317)    TOT_ENERGY = ENERGY
(  318)    MAXPOWER = POWER
(  319)    AVGPOWER = POWER
(  320)    CLMAXNODE = NODENAME
(  321)    LASTNODE = NODENAME
(  322) # 323 "ec_meminfo.F90"
(  323)    NN = NUMNODES
(  324)    IF (LLNOCOMM) NN=1
(  325) # 326 "ec_meminfo.F90"
(  326)    IF (NPROC > 1) THEN
(  327)       ALLOCATE(DONE(1:NPROC-1))
(  328)       DONE(:) = .FALSE.
(  329)    ENDIF
(  330) # 331 "ec_meminfo.F90"
(  331)    DO NODENUM=1,NN
(  332)       JID = 0
(  333)       DO II=1,NPROC-1
(  334)          IF (.NOT.DONE(II)) THEN
(  335)             J = II ! Used to be REF(II) -- don't know why ?!
(  336)             IF (RN(J)%NODENUM == NODENUM) THEN
(  337)                I = RN(J)%RANK
(  338)                IF (RN(J)%NODEMASTER == 1) THEN ! Always the first task on particular NODENUM
(  339)                   LASTNODE = RN(J)%NODE
(  340)                   NRECV = SIZE(RECVBUF)
(  341)                   JID = J ! Always >= 1
(  342)                ELSE
(  343)                   NRECV = 2
(  344)                ENDIF
(  345)                CALL MPI_RECV(RECVBUF,NRECV,MPI_INTEGER8,I,ITAG+5,KCOMM,IRECV_STATUS,ERROR)






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 25

(  346)                CALL CHECK_ERROR("from MPI_RECV(RECVBUF)","ec_meminfo.F90",346)
(  347)                IF (NRECV > 2) THEN
(  348)                   HEAP_SIZE=RECVBUF(1)
(  349)                   TASKSMALL=RECVBUF(2)
(  350)                   ENERGY=RECVBUF(3)
(  351)                   POWER=RECVBUF(4)
(  352)                   NODEHUGE=RECVBUF(5)
(  353)                   MEMFREE=RECVBUF(6)
(  354)                   CACHED=RECVBUF(7)
(  355)                   DO K=0,MAXNUMA-1
(  356)                      SMALLPAGE(K) = RECVBUF(7+2*K+1)
(  357)                      HUGEPAGE(K) = RECVBUF(7+2*K+2)
(  358)                   ENDDO
(  359)                   TOT_ENERGY = TOT_ENERGY + ENERGY
(  360)                   IF (POWER > MAXPOWER) THEN
(  361)                      MAXPOWER = POWER
(  362)                      CLMAXNODE = LASTNODE
(  363)                   ENDIF
(  364)                   AVGPOWER = AVGPOWER + POWER
(  365)                ELSE
(  366)                   HEAP_SIZE=HEAP_SIZE+RECVBUF(1)
(  367)                   TASKSMALL=TASKSMALL+RECVBUF(2)
(  368)                ENDIF
(  369)                DONE(II) = .TRUE.
(  370)             ENDIF
(  371)          ENDIF
(  372)       ENDDO
(  373)       
(  374)       PERCENT_USED(2) = 0
(  375)       IF (NODEHUGE == 0 .or. HEAP_SIZE >= NODEHUGE) THEN
(  376)          ! running with small pages
(  377)          IF (TASKSMALL+NODEHUGE+MEMFREE+CACHED > 0) THEN
(  378)             PERCENT_USED(1) = 100.0*(TASKSMALL+NODEHUGE)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
(  379)          ELSE
(  380)             PERCENT_USED(1) = 0
(  381)          ENDIF
(  382)          CSTAR = " Sm/p"
(  383)       ELSE
(  384)          ! running with huge pages
(  385)          PERCENT_USED(1) = 100.0*(HEAP_SIZE+TASKSMALL)/(TASKSMALL+NODEHUGE+MEMFREE+CACHED)
(  386)          NFREE = 0
(  387)          IF (NNUMA > 0) NFREE = SUM(HUGEPAGE(0:NNUMA-1))
(  388)          PERCENT_USED(2) = (100.0*(NODEHUGE - NFREE))/NODEHUGE
(  389)          IF (PERCENT_USED(2) < 0) PERCENT_USED(2) = 0
(  390)          IF (PERCENT_USED(2) > 100) PERCENT_USED(2) = 100
(  391)          CSTAR = " Hg/p"
(  392)       ENDIF
(  393)    
(  394)       IF (LLNOCOMM) THEN
(  395)          ID_STRING = CSTAR
(  396)       ELSE IF (KCALL == 0 .AND. JID > 0) THEN
(  397)          ! This should signify the compute & I/O nodes (if they are separate)
(  398)          CLSTR = RN(JID)%STR
(  399)          ID_STRING = CSTAR//":"//TRIM(CLSTR)
(  400)       ELSE
(  401)          ID_STRING = CSTAR//":"//CDSTRING
(  402)       ENDIF
(  403) # 404 "ec_meminfo.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 26

(  404)       CALL PRT_DATA(KULOUT)
(  405)       IF (KU == -1) THEN
(  406)          CALL PRT_DATA(0)
(  407)          IF (NODENUM == NN) THEN
(  408)             AVGPOWER = NINT(REAL(AVGPOWER)/REAL(NN))
(  409)             CALL PRT_TOTAL_ENERGIES(0)
(  410)             CALL PRT_TOTAL_ENERGIES(KULOUT)
(  411)             IF (KCALL == 1) THEN
(  412)                CALL DATE_AND_TIME(CLDATEOD,CLTIMEOD,CLZONEOD,IVALUES)
(  413)                READ(CLDATEOD(5:6),'(I2)') IMON
(  414)                CALL PRT_DETAIL(0)
(  415)                CALL PRT_DETAIL(KULOUT)
(  416)             ENDIF
(  417)             CALL PRT_EMPTY(KULOUT,1)
(  418)             CLOSE(KULOUT)
(  419)          ENDIF
(  420)       ENDIF
(  421)    ENDDO ! DO NODENUM=1,NN
(  422)    IF (ALLOCATED(DONE)) DEALLOCATE(DONE)
(  423) ELSE
(  424)     SENDBUF(1)=HEAP_SIZE
(  425)     SENDBUF(2)=TASKSMALL
(  426)     IF (IAM_NODEMASTER == 1) THEN
(  427)        SENDBUF(3)=ENERGY
(  428)        SENDBUF(4)=POWER
(  429)        SENDBUF(5)=NODEHUGE
(  430)        SENDBUF(6)=MEMFREE
(  431)        SENDBUF(7)=CACHED
(  432)        DO K=0,MAXNUMA-1
(  433)           SENDBUF(7+2*K+1)=SMALLPAGE(K)
(  434)           SENDBUF(7+2*K+2)=HUGEPAGE(K)
(  435)        ENDDO
(  436)        NSEND = SIZE(SENDBUF)
(  437)     ELSE
(  438)        NSEND = 2
(  439)     ENDIF
(  440)     CALL MPI_SEND(SENDBUF,NSEND,MPI_INTEGER8,0,ITAG+5,KCOMM,ERROR)
(  441)     CALL CHECK_ERROR("from MPI_SEND(SENDBUF)","ec_meminfo.F90",441)
(  442) ENDIF
(  443) # 444 "ec_meminfo.F90"
(  444) IF (.not.LLNOCOMM) THEN
(  445)    CALL CONDBARR()
(  446)    CALL CHECK_ERROR("from MPI_BARRIER(at end)","ec_meminfo.F90",446)
(  447) ENDIF
(  448) # 449 "ec_meminfo.F90"
(  449) CONTAINS
(  450) # 451 "ec_meminfo.F90"
(  451) SUBROUTINE SLASH_PROC
(  452)   IMPLICIT NONE
(  453)   CALL EC_PMON(ENERGY,POWER)
(  454) # 455 "ec_meminfo.F90"
(  455)   N18 = 0 ! number of buddy columns (up to MAXCOLS)
(  456)   NNUMA = 0 ! number of NUMA-nodes (up to MAXNUMA)
(  457) # 458 "ec_meminfo.F90"
(  458)   OPEN(FILE="/proc/buddyinfo",UNIT=502,STATUS="old",ACTION="read",ERR=97)
(  459)   
(  460)   READ(502,'(a)',END=99) LINE
(  461)   READ(502,'(a)',END=99) LINE






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 27

(  462)   READ(502,'(a)',END=99) LINE
(  463)   NODE(:,0)=-1
(  464)   READ(LINE(22:),*,END=98) NODE(:,0)
(  465) 98 CONTINUE
(  466)   N18 = COUNT(NODE(:,0) >= 0)
(  467)   NNUMA = 1
(  468)   DO K=1,MAXNUMA-1
(  469)      NODE(:,K)=0
(  470)      READ(502,'(a)',END=99) LINE
(  471)      READ(LINE(22:),*) NODE(0:N18-1,K)
(  472)      NNUMA = NNUMA + 1
(  473)   ENDDO
(  474)   
(  475) 99 CONTINUE
(  476)   CLOSE(502)
(  477) 97 CONTINUE
(  478)   
(  479)   SMALLPAGE(:) = 0
(  480)   HUGEPAGE(:) = 0
(  481)   DO K=0,NNUMA-1
(  482)      BUCKET(:,K) = 0
(  483)      DO J=0,N18-1
(  484)         BUCKET(J,K) = 4096_JPIB * NODE(J,K) * (2_JPIB ** J)
(  485)      ENDDO
(  486)      SMALLPAGE(K) = SUM(BUCKET(0:8,K))/ONEMEGA
(  487)      HUGEPAGE(K) = SUM(BUCKET(9:N18-1,K))/ONEMEGA
(  488)   ENDDO
(  489)   
(  490)   MEMFREE = 0
(  491)   CACHED = 0
(  492)   
(  493)   INQUIRE(FILE="/proc/meminfo", EXIST=FILE_EXISTS)
(  494)   IF( FILE_EXISTS ) THEN
(  495)     OPEN(FILE="/proc/meminfo",UNIT=502,STATUS="old",ACTION="read",ERR=977)
(  496)     DO I=1,10
(  497)       READ(502,'(a)',ERR=988,END=988) LINE
(  498)       IF(LINE(1:7) == "MemFree") THEN
(  499)         READ(LINE(9:80),*) MEMFREE 
(  500)       ELSEIF(LINE(1:6) == "Cached") THEN
(  501)         READ(LINE(8:80),*) CACHED
(  502)       ENDIF
(  503)     ENDDO
(  504) 988 continue
(  505)     CLOSE(502)
(  506) 977 continue
(  507)   
(  508)     MEMFREE=MEMFREE/1024
(  509)     CACHED=CACHED/1024
(  510)   ENDIF
(  511) # 512 "ec_meminfo.F90"
(  512) END SUBROUTINE SLASH_PROC
(  513) # 514 "ec_meminfo.F90"
(  514) SUBROUTINE PRT_EMPTY(KUN,KOUNT)
(  515) IMPLICIT NONE
(  516) INTEGER(KIND=JPIM), INTENT(IN) :: KUN,KOUNT
(  517) INTEGER(KIND=JPIM) :: JJ
(  518) DO JJ=1,KOUNT
(  519)    WRITE(KUN,'(a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO "






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 28

(  520) ENDDO
(  521) END SUBROUTINE PRT_EMPTY
(  522) # 523 "ec_meminfo.F90"
(  523) FUNCTION KWH(JOULES)
(  524) IMPLICIT NONE
(  525) INTEGER(KIND=JPIB), INTENT(IN) :: JOULES
(  526) REAL(KIND=JPRD) KWH
(  527) KWH = REAL(JOULES,JPRD) / 3600000.0_JPRD
(  528) END FUNCTION KWH
(  529) # 530 "ec_meminfo.F90"
(  530) SUBROUTINE PRT_TOTAL_ENERGIES(KUN)
(  531) IMPLICIT NONE
(  532) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  533) IF (KCALL == 1) THEN ! last call
(  534)    WT = UTIL_WALLTIME() - WT0
(  535)    CALL PRT_EMPTY(KUN,2)
(  536)    WRITE(KUN,'(a,a,f12.3,a,i0,a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  537)         & " Total energy consumed : ",KWH(TOT_ENERGY), " kWh (",TOT_ENERGY," J)"
(  538) !-- Peak power below is misleading since based on values at sample points
(  539) !   WRITE(KUN,'(a,a,i0,a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  540) !        & " Peak power            : ",MAXPOWER," W (node "//trim(CLMAXNODE)//")"
(  541) !-- Avg power must be calculated based on total Joules divided by wall time and num nodes
(  542)    AVGPOWER = TOT_ENERGY / WT / NUMNODES
(  543)    WRITE(KUN,'(a,a,i0,a,i0,a)')  CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  544)         & " Avg. power / node     : ",AVGPOWER," W across ",NUMNODES," nodes"
(  545)    CALL PRT_EMPTY(KUN,1)
(  546) ENDIF
(  547) END SUBROUTINE PRT_TOTAL_ENERGIES
(  548) # 549 "ec_meminfo.F90"
(  549) SUBROUTINE PRT_DETAIL(KUN)
(  550) IMPLICIT NONE
(  551) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  552) CHARACTER(LEN=128) :: JOBNAME
(  553) CHARACTER(LEN=128) :: JOBID
(  554) CALL GET_ENVIRONMENT_VARIABLE('EC_JOB_NAME',JOBNAME)
(  555) IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('PBS_JOBNAME',JOBNAME)
(  556) IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('SLURM_JOB_NAME',JOBNAME)
(  557) IF (JOBNAME == '') CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_JOBNAME',JOBNAME)
(  558) CALL GET_ENVIRONMENT_VARIABLE('PBS_JOBID',JOBID)
(  559) IF (JOBID == '') CALL GET_ENVIRONMENT_VARIABLE('SLURM_JOB_ID',JOBID)
(  560) IF (JOBID == '') CALL GET_ENVIRONMENT_VARIABLE('EC_MEMINFO_JOBID',JOBID)
(  561) CALL PRT_EMPTY(KUN,1)
(  562) WT = UTIL_WALLTIME() - WT0
(  563) WRITE(KUN,'(4a,f10.3,a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO Detailed memory information ", &
(  564)      "for program ",TRIM(PROGRAM)," -- wall-time : ",WT,"s"
(  565) WRITE(KUN,'(a,i0,a,i0,a,i0,a,i0,a,i0,a,i0,a,a,":",a,":",a,a,a,"-",a,"-",a)') &
(  566)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO Running on ",NUMNODES," nodes (",NNUMA,&
(  567)      "-numa) with ",NPROC-IOTASKS, &
(  568)      " compute + ",IOTASKS," I/O-tasks and ", MAXTH_COMP, "+", MAXTH_IO, " threads at ", &
(  569)      CLTIMEOD(1:2),CLTIMEOD(3:4),CLTIMEOD(5:10), &
(  570)      " on ",CLDATEOD(7:8),CLMON(IMON),CLDATEOD(1:4)
(  571) WRITE(KUN,'(4a)') CLPFX(1:IPFXLEN)//"## EC_MEMINFO The Job Name is ",TRIM(JOBNAME), &
(  572)      " and the Job ID is ",TRIM(JOBID)
(  573) CALL PRT_EMPTY(KUN,1)
(  574) END SUBROUTINE PRT_DETAIL
(  575) # 576 "ec_meminfo.F90"
(  576) SUBROUTINE PRT_HDR(KUN)
(  577) IMPLICIT NONE






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 29

(  578) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  579) INTEGER(KIND=JPIM) :: INUMA, ILEN
(  580) CHARACTER(LEN=4096) :: CLBUF
(  581) INUMA = NNUMA
(  582) # 583 "ec_meminfo.F90"
(  583) ILEN = 0
(  584) WRITE(CLBUF(ILEN+1:),'(A)') &
(  585)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO                           | TC    | MEMORY USED(MB) "
(  586) ILEN = LEN_TRIM(CLBUF)
(  587) DO K=0,INUMA-1
(  588)    IF (K == 0) THEN
(  589)       WRITE(CLBUF(ILEN+1:),'(A)') " | MEMORY FREE(MB)"
(  590)       ILEN = LEN_TRIM(CLBUF)
(  591)    ELSE
(  592)       WRITE(CLBUF(ILEN+1:),'(A)') "  -------------  "
(  593)       ILEN = LEN_TRIM(CLBUF) + 2
(  594)    ENDIF
(  595) ENDDO
(  596) IF (NNUMA > 0) THEN
(  597)    WRITE(CLBUF(ILEN+1:),'(A)') " INCLUDING CACHED|  %USED %HUGE  | Energy  Power"
(  598) ELSE
(  599)    WRITE(CLBUF(ILEN+1:),'(A)') "  MEMORY FREE(MB) |  %USED %HUGE  | Energy  Power"
(  600) ENDIF
(  601) WRITE(KUN,'(A)') TRIM(CLBUF)
(  602) # 603 "ec_meminfo.F90"
(  603) ILEN=0
(  604) WRITE(CLBUF(ILEN+1:),'(A)') &
(  605)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO                           | Malloc| Inc Heap        |"
(  606) ILEN = LEN_TRIM(CLBUF)
(  607) DO K=0,INUMA-1
(  608)    WRITE(CLBUF(ILEN+1:),'(A,I2,A)') " Numa region ",K," |"
(  609)    ILEN = LEN_TRIM(CLBUF)
(  610) ENDDO
(  611) WRITE(CLBUF(ILEN+1:),'(A)')  "                |               |    (J)    (W)"
(  612) WRITE(KUN,'(A)') TRIM(CLBUF)
(  613) # 614 "ec_meminfo.F90"
(  614) ILEN=0
(  615) WRITE(CLBUF(ILEN+1:),'(A)') &
(  616)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO Node Name                 | Heap  | RSS("//zum//")        |"
(  617) ILEN = LEN_TRIM(CLBUF)
(  618) DO K=0,INUMA-1
(  619)    WRITE(CLBUF(ILEN+1:),'(A)') " Small  Huge or |"
(  620)    ILEN = LEN_TRIM(CLBUF)
(  621) ENDDO
(  622) WRITE(CLBUF(ILEN+1:),'(A)') " Total          |"
(  623) WRITE(KUN,'(A)') TRIM(CLBUF)
(  624) # 625 "ec_meminfo.F90"
(  625) ILEN=0
(  626) WRITE(CLBUF(ILEN+1:),'(A)') &
(  627)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO                           | (sum) | Small    Huge   |"
(  628) ILEN = LEN_TRIM(CLBUF)
(  629) DO K=0,INUMA-1
(  630)    WRITE(CLBUF(ILEN+1:),'(A)') "  Only   Small  |"
(  631)    ILEN = LEN_TRIM(CLBUF)
(  632) ENDDO
(  633) WRITE(CLBUF(ILEN+1:),'(A)') " Memfree+Cached |"
(  634) WRITE(KUN,'(A)') TRIM(CLBUF)
(  635) END SUBROUTINE PRT_HDR






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 30

(  636) # 637 "ec_meminfo.F90"
(  637) SUBROUTINE PRT_DATA(KUN)
(  638) IMPLICIT NONE
(  639) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  640) INTEGER(KIND=JPIM) :: INUMA,ILEN
(  641) CHARACTER(LEN=4096) :: CLBUF
(  642) INUMA = NNUMA
(  643) # 644 "ec_meminfo.F90"
(  644) ILEN=0
(  645) WRITE(CLBUF(ILEN+1:),'(a,i4,1x,a,3i8,1x)') &
(  646)      CLPFX(1:IPFXLEN)//"## EC_MEMINFO ", &
(  647)      NODENUM-1,LASTNODE,HEAP_SIZE,TASKSMALL,NODEHUGE
(  648) ILEN = LEN_TRIM(CLBUF) + 1
(  649) DO K=0,INUMA-1
(  650)    WRITE(CLBUF(ILEN+1:),'(1x,2i8)') SMALLPAGE(K),HUGEPAGE(K)
(  651)    ILEN = LEN_TRIM(CLBUF)
(  652) ENDDO
(  653) WRITE(CLBUF(ILEN+1:),'(2x,2i8,3x,2f6.1,1x,i9,1x,i6,1x,a)') &
(  654)      MEMFREE,CACHED, &
(  655)      PERCENT_USED,&
(  656)      ENERGY,POWER,&
(  657)      trim(ID_STRING)
(  658) WRITE(KUN,'(A)') TRIM(CLBUF)
(  659) END SUBROUTINE PRT_DATA
(  660) # 661 "ec_meminfo.F90"
(  661) SUBROUTINE CONDBARR()
(  662) IF (NPROC > 1 .and. KBARR /= 0) THEN
(  663)    CALL MPI_BARRIER(KCOMM,ERROR)
(  664) ELSE
(  665)    ERROR = 0
(  666) ENDIF
(  667) END SUBROUTINE CONDBARR
(  668) # 669 "ec_meminfo.F90"
(  669) SUBROUTINE CHECK_ERROR(CLWHAT,SRCFILE,SRCLINE)
(  670) IMPLICIT NONE
(  671) CHARACTER(LEN=*), INTENT(IN) :: CLWHAT, SRCFILE
(  672) INTEGER(KIND=JPIM), INTENT(IN) :: SRCLINE
(  673) IF (ERROR /= 0) THEN
(  674)    WRITE(0,'(A,I0,1X,A,1X,"(",A,":",I0,")")') &
(  675)         & CLPFX(1:IPFXLEN)//"## EC_MEMINFO error code =",ERROR,CLWHAT,SRCFILE,SRCLINE
(  676)    CALL MPI_ABORT(KCOMM,-1,ERROR)
(  677) ENDIF
(  678) ERROR = 0
(  679) END SUBROUTINE CHECK_ERROR
(  680) # 681 "ec_meminfo.F90"
(  681) SUBROUTINE RNSORT(KUN)
(  682) IMPLICIT NONE
(  683) INTEGER(KIND=JPIM), INTENT(IN) :: KUN
(  684) INTEGER(KIND=JPIM) :: ILEN
(  685) CHARACTER(LEN=1) :: CLAST
(  686) CHARACTER(LEN=4) :: CLMASTER
(  687) CHARACTER(LEN=4096) :: CLBUF
(  688) INTEGER(KIND=JPIM) :: impi_vers, impi_subvers, ilibrary_version_len
(  689) INTEGER(KIND=JPIM) :: iomp_vers, iomp_subvers, iopenmp
(  690) CHARACTER(LEN=4096) :: clibrary_version
(  691) LOGICAL :: LLDONE(0:NPROC-1)
(  692) INTEGER(KIND=JPIM) :: REF(0:NPROC-1) ! Keep list of the order tasks been added
(  693) LLDONE(:) = .FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 31

(  694) IOTASKS = 0
(  695) K = 0
(  696) NODENUM = 0
(  697) DO I=0,NPROC-1
(  698)    IF (RN(I)%NODENUM == -1) THEN
(  699)       IF (RN(I)%IORANK == 1) THEN
(  700)          IOTASKS = IOTASKS + 1
(  701)          RN(I)%IORANK = IOTASKS
(  702)       ELSE
(  703)          RN(I)%IORANK = 0
(  704)       ENDIF
(  705)       NODENUM = NODENUM + 1
(  706)       RN(I)%NODENUM = NODENUM
(  707)       RN(I)%NODEMASTER = 1
(  708)       LLDONE(I) = .TRUE.
(  709)       ! NB: Adjacent REF-elements allow us to operate with particular node's tasks that follow their the node-master
(  710)       REF(K) = I
(  711)       K = K + 1
(  712)       LASTNODE = RN(I)%NODE
(  713) !      DO J=I+1,NPROC-1 ! not valid anymore since ranks might have been reordered -- need to run through the whole list -- LLNODE speeds up
(  714)       DO J=0,NPROC-1
(  715)          IF (.NOT.LLDONE(J)) THEN
(  716)             IF (RN(J)%NODENUM == -1) THEN
(  717)                IF (RN(J)%NODE == LASTNODE) THEN
(  718)                   RN(J)%NODENUM = NODENUM
(  719)                   IF (RN(J)%IORANK == 1) THEN
(  720)                      IOTASKS = IOTASKS + 1
(  721)                      RN(J)%IORANK = IOTASKS
(  722)                   ELSE
(  723)                      RN(J)%IORANK = 0
(  724)                   ENDIF
(  725)                   RN(J)%NODEMASTER = 0
(  726)                   LLDONE(J) = .TRUE.
(  727)                   REF(K) = J
(  728)                   K = K + 1
(  729)                ENDIF
(  730)             ENDIF
(  731)          ENDIF
(  732)       ENDDO
(  733)    ENDIF
(  734) ENDDO
(  735) NUMNODES = NODENUM
(  736) CALL ecmpi_version(impi_vers, impi_subvers, clibrary_version, ilibrary_version_len)
(  737) call ecomp_version(iomp_vers, iomp_subvers, iopenmp)
(  738) CALL PRT_EMPTY(KUN,1)
(  739) WRITE(KUN,'(a,i0,".",i0)') &
(  740)      & CLPFX(1:IPFXLEN)//&
(  741)      & "## EC_MEMINFO : MPI-version ",impi_vers, impi_subvers
(  742) WRITE(KUN,'(a)')  &
(  743)      & CLPFX(1:IPFXLEN)//&
(  744)      & "## EC_MEMINFO : Start of MPI-library version"
(  745) WRITE(KUN,'(a)') trim(clibrary_version) ! This is could be a multiline, very long string
(  746) WRITE(KUN,'(a)')  &
(  747)      & CLPFX(1:IPFXLEN)//&
(  748)      & "## EC_MEMINFO : End of MPI-library version"
(  749) WRITE(KUN,'(a,i0,".",i0,".",i6.6)') &
(  750)      & CLPFX(1:IPFXLEN)//&
(  751)      & "## EC_MEMINFO : OpenMP-version ",iomp_vers, iomp_subvers, iopenmp






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 32

(  752) CALL PRT_EMPTY(KUN,2)
(  753) WRITE(KUN,1003) &
(  754)      & CLPFX(1:IPFXLEN)//&
(  755)      &"## EC_MEMINFO ********************************************************************************",&
(  756)      & CLPFX(1:IPFXLEN)//&
(  757)      &"## EC_MEMINFO *** Mapping of MPI & I/O-tasks to nodes and tasks' thread-to-core affinities ***", &
(  758)      & CLPFX(1:IPFXLEN)//&
(  759)      &"## EC_MEMINFO ********************************************************************************"
(  760) 1003 FORMAT((A))
(  761) CALL PRT_EMPTY(KUN,1)
(  762) WRITE(KUN,'(a,i0,a,i0,a,i0,a,i0,a,i0,a,i0,a)') &
(  763)      & CLPFX(1:IPFXLEN)//"## EC_MEMINFO Running on ",NUMNODES," nodes (",NNUMA,&
(  764)      & "-numa) with ",NPROC-IOTASKS, &
(  765)      & " compute + ",IOTASKS," I/O-tasks and ", MAXTH_COMP, "+", MAXTH_IO, " threads"
(  766) CALL PRT_EMPTY(KUN,1)
(  767) WRITE(KUN,1000) CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  768)      & "#","NODE#","NODENAME","MPI#","WORLD#","I/O#","MASTER","REF#","OMP#","Core affinities"
(  769) WRITE(KUN,1000) CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  770)      & "=","=====","========","====","======","====","======","====","====","==============="
(  771) 1000 FORMAT(A,2(1X,A5),1X,A20,6(1X,A6),2X,A)
(  772) CALL PRT_EMPTY(KUN,1)
(  773) DO K=0,NPROC-1 ! Loop over the task as they have been added (see few lines earlier how REF(K) has been getting its values I or J)
(  774)    ILEN = 0
(  775)    ! A formidable trick ? No need for a nested loop over 0:NPROC-1 to keep tasks within the same node together in the output
(  776)    I = REF(K)
(  777)    NUMTH = RN(I)%NUMTH
(  778)    CLMASTER = '[No]'
(  779)    IF (RN(I)%NODEMASTER == 1) CLMASTER = ' Yes'
(  780)    IF (RN(I)%IORANK > 0) THEN
(  781)       WRITE(CLBUF(ILEN+1:),1001) &
(  782)            & CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  783)            & K,RN(I)%NODENUM-1,TRIM(ADJUSTL(RN(I)%NODE)),RN(I)%RANK,RN(I)%RANK_WORLD,RN(I)%IORANK-1,&
(  784)            & CLMASTER,I,NUMTH,"{"
(  785) 1001  FORMAT(A,2(1X,I5),1X,A20,3(1X,I6),1X,A6,2(1X,I6),2X,A)
(  786)    ELSE
(  787)       WRITE(CLBUF(ILEN+1:),1002) &
(  788)            & CLPFX(1:IPFXLEN)//"## EC_MEMINFO ",&
(  789)            & K,RN(I)%NODENUM-1,TRIM(ADJUSTL(RN(I)%NODE)),RN(I)%RANK,RN(I)%RANK_WORLD,"[No]",&
(  790)            & CLMASTER,I,NUMTH,"{"
(  791) 1002  FORMAT(A,2(1X,I5),1X,A20,2(1X,I6),2(1X,A6),2(1X,I6),2X,A)
(  792)    ENDIF
(  793)    ILEN = LEN_TRIM(CLBUF)
(  794)    CLAST = ','
(  795)    DO J=0,NUMTH-1
(  796)       IF (J == NUMTH-1) CLAST = '}'
(  797)       WRITE(CLBUF(ILEN+1:),'(I0,A1)') RN(I)%COREIDS(J),CLAST
(  798)       ILEN = LEN_TRIM(CLBUF)
(  799)    ENDDO
(  800)    WRITE(KUN,'(A,1X)') TRIM(CLBUF)
(  801) ENDDO
(  802) CALL PRT_EMPTY(KUN,1)
(  803) CALL FLUSH(KUN)
(  804) END SUBROUTINE RNSORT
(  805) # 806 "ec_meminfo.F90"
(  806) END SUBROUTINE EC_MEMINFO
(  807) # 808 "ec_meminfo.F90"
(  808) SUBROUTINE MEMINFO(KOUT,KSTEP)
(  809) USE PARKIND1, ONLY : JPIM, JPIB






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 33

(  810) IMPLICIT NONE
(  811) INTEGER(KIND=JPIM), INTENT(IN) :: KOUT, KSTEP
(  812) CHARACTER(LEN=32) CLSTEP
(  813) CHARACTER(LEN=160) :: LINE
(  814) CHARACTER(LEN=20) :: NODENAME
(  815) INTEGER(KIND=JPIB) :: NODE(0:17), ISMALL, IHUGE, ITOTAL
(  816) INTEGER(KIND=JPIM) :: I,INUMA,ICOMM
(  817) # 817 "ec_meminfo.F90"
(  817) # 1 ".D[61]/ec_meminfo.intfb.h"
(    1) INTERFACE
(    2) SUBROUTINE EC_MEMINFO(KU,CDSTRING,KCOMM,KBARR,KIOTASK,KCALL)
(    3) USE PARKIND1, ONLY : JPIM
(    4) INTEGER(KIND=JPIM), INTENT(IN) :: KU,KCOMM,KBARR,KIOTASK,KCALL
(    5) CHARACTER(LEN=*), INTENT(IN) :: CDSTRING
(    6) END SUBROUTINE EC_MEMINFO
(    7) END INTERFACE
(    8) # 818 "ec_meminfo.F90"
(  818) # 818 "ec_meminfo.F90"
(  818) WRITE(CLSTEP,'(11X,"STEP",I5," :")') KSTEP
(  819) ICOMM = -2 ! No headers from EC_MEMINFO by default
(  820) IF (KSTEP == 0) ICOMM = -1 ! Do print headers, too
(  821) CALL EC_MEMINFO(KOUT,TRIM(CLSTEP),ICOMM,KBARR=0,KIOTASK=-1,KCALL=-1)
(  822) CALL FLUSH(KOUT)
(  823) RETURN ! For now
(  824) # 856 "ec_meminfo.F90"
(  856) END SUBROUTINE MEMINFO
(  857) # 858 "ec_meminfo.F90"
(  858) SUBROUTINE EC_MPI_FINALIZE(KERROR,LDCALLFINITO,LDMEMINFO,CALLER)
(  859) USE PARKIND1, ONLY : JPIM
(  860) USE MPL_MPIF
(  861) IMPLICIT NONE
(  862) INTEGER(KIND=JPIM), INTENT(OUT) :: KERROR
(  863) LOGICAL, INTENT(IN) :: LDCALLFINITO
(  864) LOGICAL, INTENT(IN) :: LDMEMINFO
(  865) CHARACTER(LEN=*), INTENT(IN) :: CALLER
(  866) LOGICAL :: LLINIT, LLFIN, LLNOTMPIWORLD
(  867) INTEGER(KIND=JPIM) :: IERR, ICOMM
(  868) INTEGER(KIND=JPIM) :: NCOMM_MEMINFO
(  869) COMMON /cmn_meminfo/ NCOMM_MEMINFO
(  870) # 870 "ec_meminfo.F90"
(  870) # 1 ".D[61]/ec_meminfo.intfb.h"
(    1) INTERFACE
(    2) SUBROUTINE EC_MEMINFO(KU,CDSTRING,KCOMM,KBARR,KIOTASK,KCALL)
(    3) USE PARKIND1, ONLY : JPIM
(    4) INTEGER(KIND=JPIM), INTENT(IN) :: KU,KCOMM,KBARR,KIOTASK,KCALL
(    5) CHARACTER(LEN=*), INTENT(IN) :: CDSTRING
(    6) END SUBROUTINE EC_MEMINFO
(    7) END INTERFACE
(    8) # 871 "ec_meminfo.F90"
(  871) # 871 "ec_meminfo.F90"
(  871) KERROR = 0
(  872) IF (LDCALLFINITO) THEN !*** common MPI_Finalize()
(  873)   CALL MPI_INITIALIZED(LLINIT,IERR)
(  874)   IF (LLINIT .AND. IERR == 0) THEN
(  875)     CALL MPI_FINALIZED(LLFIN,IERR)
(  876)     IF (.NOT.LLFIN .AND. IERR == 0) THEN
(  877)       LLNOTMPIWORLD = (NCOMM_MEMINFO /= 0 .and. NCOMM_MEMINFO /= MPI_COMM_WORLD)
(  878)       IF (LLNOTMPIWORLD) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 34

(  879)         ICOMM = NCOMM_MEMINFO
(  880)       ELSE
(  881)         ICOMM = MPI_COMM_WORLD
(  882)       ENDIF
(  883)       IF( LDMEMINFO ) CALL EC_MEMINFO(-1,"ec_mpi_finalize:"//caller,ICOMM,KBARR=1,KIOTASK=-1,KCALL=1)
(  884)       CALL c_drhook_prof() ! ifsaux/support/drhook.c : Make sure DrHook output is produced before MPI_Finalize (in case it fails)
(  885)       CALL MPI_BARRIER(ICOMM,IERR)
(  886)       IF (LLNOTMPIWORLD) THEN
(  887)         ! CALL MPI_COMM_FREE(NCOMM_MEMINFO,IERR)
(  888)         NCOMM_MEMINFO = 0
(  889)       ENDIF
(  890)       CALL MPI_FINALIZE(KERROR)
(  891)     ENDIF
(  892)   ENDIF
(  893) ENDIF
(  894) END SUBROUTINE EC_MPI_FINALIZE
(  895) # 896 "ec_meminfo.F90"
(  896) SUBROUTINE EC_PMON(ENERGY,POWER)
(  897) USE PARKIND1, ONLY : JPIM, JPIB
(  898) IMPLICIT NONE
(  899) INTEGER(KIND=JPIB),INTENT(OUT) :: ENERGY,POWER
(  900) INTEGER(KIND=JPIB),SAVE :: ENERGY_START = 0
(  901) INTEGER(KIND=JPIM),SAVE :: MONINIT = 0
(  902) INTEGER(KIND=JPIM) :: ISTAT
(  903) CHARACTER(LEN=1) :: CLEC_PMON
(  904) ENERGY = 0
(  905) IF (MONINIT >= 0) THEN
(  906)    IF (MONINIT == 0) THEN ! The very first time only
(  907)       CALL GET_ENVIRONMENT_VARIABLE('EC_PMON',CLEC_PMON)
(  908)       IF (CLEC_PMON == '0') MONINIT = -2 ! Never try again
(  909)    ENDIF
(  910)    IF (MONINIT >= 0) THEN
(  911)       OPEN(503,FILE='/sys/cray/pm_counters/energy',IOSTAT=ISTAT,STATUS='old',ACTION='read')
(  912)       IF (ISTAT == 0) THEN
(  913)          READ(503,*,IOSTAT=ISTAT) ENERGY
(  914)          CLOSE(503)
(  915)          IF (ISTAT == 0) THEN
(  916)             IF (MONINIT == 0) THEN
(  917)                ENERGY_START = ENERGY
(  918)                MONINIT = 1 ! Ok
(  919)             ENDIF
(  920)             ENERGY = ENERGY - ENERGY_START
(  921)          ENDIF
(  922)       ENDIF
(  923)       IF (ISTAT /= 0) THEN
(  924)          MONINIT = -1 ! Never try again
(  925)          ENERGY = 0
(  926)       ENDIF
(  927)    ENDIF
(  928) ENDIF
(  929) POWER = 0
(  930) IF (MONINIT > 0) THEN
(  931)    OPEN(504,FILE='/sys/cray/pm_counters/power',IOSTAT=ISTAT,STATUS='old',ACTION='read')
(  932)    IF (ISTAT == 0) THEN
(  933)       READ(504,*,IOSTAT=ISTAT) POWER
(  934)       CLOSE(504)
(  935)    ENDIF
(  936)    IF (ISTAT /= 0) POWER = 0






NVFORTRAN (Version     23.1)          02/24/2023  13:34:36      page 35

(  937) ENDIF
(  938) END SUBROUTINE EC_PMON
