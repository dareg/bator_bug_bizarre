


NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: eggx.F90

(    1) SUBROUTINE EGGX (PRPI, PRA, KROTEQ, PLONR, PLATR, PBETA,&
(    2)  & PLON1, PLAT1, PLON2, PLAT2, PLON0, PLAT0, PRPK, KULOUT,&
(    3)  & KSOTRP, KGIV0,&
(    4)  & PGELAM, PGELAT, PGM, PGNORX, PGNORY,&
(    5)  & KDLSA, KDLSUR, KDGSA, KDGEN, KDLUN, KDLUX, KDGUN, KDGUX,&
(    6)  & PDELX, PDELY)  
(    7) !****
(    8) !----------------------------------------------------------------------
(    9) 
(   10) !     GEOGRAPHY OF GRID-POINTS
(   11) !     ARPEGE-ALADIN
(   12) !     -------------------------
(   13) 
(   14) !       -------------------------------------------------------
(   15) !     PURPOSE
(   16) !     -------
(   17) !      PROVIDES THE BASIC GEOGRAPHICAL PARAMETERS OF EACH GRID-POINT
(   18) !      IN THE WINDOW OF INTERNAL+COUPLING ZONE, DEFINING THE
(   19) !      GEOGRAPHICAL DOMAIN OF INTEREST.
(   20) !      SIMULTANEOUSLY, INITIALISES THE INTERNAL GEOGRAPHICAL COMMON
(   21) !      /YEMGGCM/ FOR POSSIBLE RE-USE OF POSITION INVERSION SUBROUTINE
(   22) !      EGGRVS.
(   23) 
(   24) !      THE GEOGRAPHICAL PARAMETERS ARE :
(   25) !       - GEOGRAPHIC LONGITUDE
(   26) !       - GEOGRAPHIC LATITUDE
(   27) !       - MAP FACTOR
(   28) !       - COMPONENTS OF VECTOR DIRECTED TOWARDS THE GEOGRAPHIC NORTH
(   29) !       POLE FOR PROJECTION OF VECTORS
(   30) !       - X GRID-SIZE (DISTANCE OR LONGITUDE INCREMENT)






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 3

(   31) !       - Y GRID-SIZE (DISTANCE OR LATITUDE INCREMENT)
(   32) !      THE LAST TWO DEPEND ON THE GEOMETRY. THE LATTER CAN BE
(   33) !       - SPHERICAL GEOMETRY, WITH ROTATION OF DOMAIN TO THE EQUATOR
(   34) !       - CARTESIAN GEOMETRY, WITH PROJECTION OF DOMAIN ON A PLANE
(   35) 
(   36) !      ROTATION AND PROJECTION CAN BE COMBINED. HOWEVER, PROJECTIONS
(   37) !      OTHER THAN MERCATOR SHOULD BE USED WITHOUT ROTATION.
(   38) 
(   39) !      EGGX CAN RUN UNDER FULL USER CONTROL OR IN MORE OR LESS
(   40) !      AUTOMATIC MODES
(   41) 
(   42) !      FROM THESE BASIC PARAMETERS, OTHER CAN EASILY BE DEDUCED, SUCH
(   43) !      AS THE CORIOLIS PARAMETER, ETC.
(   44) 
(   45) !      (GENERAL WARNING ABOUT AUTOMATIC MODE)
(   46) !      --------------------------------------
(   47) !       NOTE THAT AUTOMATIC MODE IS NOT SURE TO CONVERGE, AND MOREOVER,
(   48) !      IT MAY CONVERGE TOWARD A SOLUTION DIFFERENT FROM WHAT YOU EXPECTED
(   49) !      THIS IS SO IN PARTICULAR FOR A DOMAIN OVER THE POLE OR NEAR THE
(   50) !      EQUATOR. IT IS RECOMMENDED TO CHECK CAREFULLY A CHOICE OF
(   51) !      PARAMETERS BEFORE RUNNING A COMPLETE SUITE
(   52) 
(   53) !      (CONVENTIONS FOR LATITUDE, LONGITUDE)
(   54) !      -------------------------------------
(   55) !       THEY ARE IN RADIANS
(   56) !       LATITUDE VARY FROM  -PI/2  (SOUTH POLE) TO  PI/2  (NORTH POLE)
(   57) !       LONGITUDE VARY FROM  0 (GREENWICH OR EQUIVALENT) TO 2*PI
(   58) !         THE CONVENTION FOR A POLE IS THAT IT HAS LONGITUDE 0
(   59) 
(   60) !      (HANDLING OF PROJECTION IN SOUTHERN HEMISPHERE)
(   61) !      ------------------------------------------------
(   62) !       IT IS ASSUMED THAT DOMAINS NOT ROTATED AND ENTERELY CONTAINED
(   63) !       IN THE SOUTHERN HEMISPHERE WILL BE PROJECTED USING STEREO/LAMBERT
(   64) 
(   65) !       IN THAT CASE, AND IN THAT CASE ONLY,
(   66) !         HSUD IS SET TO -1. IN THE INTERNAL COMMON
(   67) 
(   68) !       THE SIGN OF LATITUDES IS CHANGED FOR ALL INTERNAL CALCULATIONS,
(   69) !       SO THAT ALL THE TRIGONOMETRY IS UNCHANGED, HOWEVER, THE RESPECTIVE
(   70) !       POSITIONS OF POLE AND GRID ARE REVERSED
(   71) 
(   72) !       WHEREVER THIS DIFFERENCE MATTERS, THAT IS:
(   73) !       - MAPPING POLAR COORDINATES TO (X,Y)
(   74) !       - VECTOR ROTATION
(   75) !       ALTERNATIVE LINES OR MULTIPLICATIONS BY HSUD ARE INCLUDED
(   76) 
(   77) !       THE SIGNS OF OUTGOING OR INCOMING LATITUDES ARE CHANGED AT THE LAST
(   78) !        MINUTE OR PRIOR TO ANY COMPUTATION
(   79) 
(   80) !      (CONVENTIONS FOR ARRAY ORGANISATION)
(   81) !      ------------------------------------
(   82) !       THE POINT (KDLUN,KDGUN) HAS GEOGRAPHIC COORDINATES (PLON1,PLAT1)
(   83) !       THE POINT (KDLUX,KDGUX)                            (PLON2,PLAT2)
(   84) !        THE FIRST INDEX (X DIRECTION) VARIES ROUGHLY
(   85) !        WITH INCREASING LONGITUDE
(   86) !        THE SECOND INDEX (Y DIRECTION) VARIES
(   87) !        ROUGHLY WITH INCREASING LATITUDE
(   88) !        THEY ARE ACTUAL LONGITUDE, LATITUDE ONLY IN THE CASE WITHOUT PROJ.






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 4

(   89) 
(   90) !     ONLY A PART OF THE ARRAYS IS INITIALIZED : THAT PART CORRESPONDING
(   91) !     TO INTERNAL + COUPLING ZONES. IT MIGHT BE NECESSARY TO COMPLETE
(   92) !     THE ARRAYS (SUCH AS GM) IN ORDER TO MAKE THEM DOUBLY-PERIODIC.
(   93) 
(   94) !     ONE TYPE OF ROTATION AND THREE TYPES OF PROJECTIONS ARE RECOGNISED
(   95) 
(   96) !      (CONVENTIONS FOR WIND AND OTHER VECTORS ROTATION)
(   97) !      --------------------------------------------------
(   98) !       GEOGRAPHIC U = PGNORY * U PROJ - PGNORX * V PROJ
(   99) !       GEOGRAPHIC V = PGNORX * U PROJ + PGNORY * V PROJ
(  100) 
(  101) !       WHEN USING THIS TRANSFORM, DO NOT FORGET THE MAP FACTOR EFFECT
(  102) 
(  103) !       THE INVERSE TRANSFORM IS EASY TO DEDUCE (IT IS A ROTATION)
(  104) 
(  105) !       (OVERVIEW OF ALGORITHM)
(  106) !       -----------------------
(  107) !     PARAMETERS ARE EDITED  AND POSSIBLY CHECKED
(  108) !     THEY ARE OPTIONNALLY ROTATED
(  109) !     SOME AUTOMATIC ADJUSTMENTS OF PROJECTION PARAMETER ARE OPTIONALLY
(  110) !     PERFORMED
(  111) !     PROJECTION IS PERFORMED (OPTIONNALLY) ON THE ROTATED SPHERE
(  112) !     AT THIS STAGE, INCREMENTS OR DISTANCE ON THE MAP ARE DEDUCED
(  113) !     COMPONENTS OF ROTATION UNDER PROJECTION ARE COMPUTED
(  114) !     INVERSE ROTATION BACK TO GEOGRAPHICAL VALUES IS OPTIONNALLY DONE
(  115) !     ON THE RESULTS, COMPONENTS OF ROTATION ARE COMPOSED WITH THOSE
(  116) !     OF PROJECTION
(  117) 
(  118) !     INPUT PARAMETERS
(  119) !     ----------------
(  120) !      PRPI : PI (3.14ETC AS GENERALLY DEFINED ELSEWHERE : YOMCST IN ARPEGE)
(  121) !      PRA  : A, RADIUS OF SPHERICAL PLANET (M)
(  122) !       WARNING :
(  123) !       ---------  DEPENDING ON OPTIONS, INPUT PARAMETERS MAY BECOME OUTPUT
(  124) !                  PARAMETERS. EVEN IF UNITIALISED, THE VARIABLES MUST BE
(  125) !                  DECLARE INDEPENDENTLY.
(  126) 
(  127) !      KROTEQ = 0 : NO ROTATION
(  128) !             = 1 : POINT (PLONR,PLATR) IS ROTATED TO EQUATOR, THE NORTH POLE
(  129) !                   IS ON THE NEW GREENWICH MERIDIAN
(  130) 
(  131) !      PLONR : GEOGRAPHIC LONGITUDE OF REFERENCE POINT OF ROTATION
(  132) !      PLATR : GEOGRAPHIC LATITUDE OF REFERENCE POINT OF ROTATION
(  133) 
(  134) !      PBETA : ANGLE (IN RD) BETWEEN X-AXIS AND ROTATED LATITUDE CIRCLES
(  135) !              AT THE REFERENCE LONGITUDE
(  136) !              (USUALLY, PBETA = 0. : GIVES PURE PROJECTIONS)
(  137) 
(  138) !      PLON1, PLAT1 : GEOGRAPHIC LONGITUDE, LATITUDE OF THE SOUTH-WEST
(  139) !                     CORNER OF USEFUL DOMAIN
(  140) !      PLON2, PLAT2 : GEOGRAPHIC LONGITUDE, LATITUDE OF THE NORTH-EAST
(  141) !                     CORNER OF USEFUL DOMAIN
(  142) !       IF ROTATION IS REQUIRED, (PLON1,PLAT1) IS SELF DETERMINED
(  143) !       FROM (PLONR,PLATR) AND (PLON2,PLAT2) WHEN KSOTRP = 2
(  144) !       IF PROJECTION IS REQUIRED, PLAT1 IS SEFL DETERMINED WHEN
(  145) !       KSOTRP = 2. PLON1 MUST BE GIVEN.
(  146) 






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 5

(  147) !       IF ROTATION IS REQUIRED, (PLON2,PLAT2) IS SELF DETERMINED
(  148) !       FROM (PLONR,PLATR) AND (PLON1,PLAT1) WHEN KSOTRP = 1
(  149) !       IF PROJECTION IS REQUIRED, PLAT2 IS SEFL DETERMINED WHEN
(  150) !       KSOTRP = 1. PLON2 MUST BE GIVEN.
(  151) 
(  152) !      PLON0 : GEOGRAPHIC LONGITUDE OF REFERENCE FOR THE PROJECTION
(  153) !              (THE VERTICAL ONE IN STEREO/LAMBERT)
(  154) !        WARNING :
(  155) !        ---------  STRANGE RESULTS MAIN OCCUR IF PLON0 IS OUT OF THE
(  156) !                   DOMAIN
(  157) !        PLON0 IS NOT REQUIRED WHEN KGIV0 =1 OR 3
(  158) !      PLAT0 : GEOGRAPHIC LATITUDE OF REFERENCE FOR THE PROJECTION
(  159) !              (WHERE M = 1)
(  160) !        PLAT0 IS NOT REQUIRED WHEN KGIV0 = 2 OR 3
(  161) !      PRPK  : PROJECTION PARAMETER AND DEFINITION
(  162) !              PRPK = 10. PROJECTION TYPE SELF DETERMINED
(  163) !                         BY MINIMIZING THE VARIATION OF THE MAP FACTOR
(  164) !              PRPK = 1.  POLAR STEREOGRAPHIC PROJECTION
(  165) !              0. < PRPK < 1.  LAMBERT CONFORMAL PROJECTION WITH
(  166) !                              CONE PARAMETER PRPK
(  167) !              PRPK = 0.  MERCATOR CONFORMAL PROJECTION
(  168) !              PRPK < 0.  NO PROJECTION
(  169) !             ON OUTPUT, PRPK CONTAINS THE EFFECTIVE PROJECTION
(  170) !             PARAMETER THAT HAS BEEN USED
(  171) !      KSOTRP : ISOTROPY PARAMETER UNDER PROJECTION
(  172) !               = 0, PLAT1, PLAT2 USED AS GIVEN. GRID SPACING ISOTROPY
(  173) !                    GENERALLY NOT AVAILABLE ( PDELX DIFFERENT FORM PDELY )
(  174) !               = 1, GRID SPACING ISOTROPIC, PLAT1 USED AS GIVEN,
(  175) !                    PLAT2 CHANGED (PLON2 SELF DETERMINED IF KROTEQ = 1)
(  176) !               = 2, GRID SPACING ISOTROPIC, PLAT2 USED AS GIVEN,
(  177) !                    PLAT1 CHANGED (PLON1 SELF DETERMINED IF KROTEQ = 1)
(  178) 
(  179) !      KGIV0 : CHOICE OF REFERENCE POINT FOR PROJECTION
(  180) !               = 0, PLAT0 AND PLON0 USED AS GIVEN
(  181) !               = 1, PLAT0 REQUIRED, PLON0 SELF DETERMINED
(  182) !               = 2, PLON0 REQUIRED, PLAT0 SELF DETERMINED
(  183) !               = 3, PLAT0 AND PLON0 SELF DETERMINED
(  184) 
(  185) !      KDLSA:KDLSUR : LOWER AND UPPER FIRST DIMENSIONS OF ARRAYS (X)
(  186) !      KDGSA:KDGEN  : LOWER AND UPPER SECOND DIMENSIONS OF ARRAYS (Y)
(  187) 
(  188) !      KDLUN:KDLUX  : LOWER AND UPPER FIRST DIMENSIONS OF
(  189) !                     THE DOMAIN OF INTEREST, WHERE ARRAYS ARE
(  190) !                     INITIALIZED.
(  191) !      KDGUN:KDGUX  : LOWER AND UPPER SECOND DIMENSIONS OF
(  192) !                     THE DOMAIN OF INTEREST, WHERE ARRAYS ARE
(  193) !                     INITIALIZED.
(  194) !                   TOGETHER WITH THE CORNERS OF THE DOMAIN, THESE
(  195) !                   DEFINE THE GRID RESOLUTION
(  196) 
(  197) !      KULOUT : UNIT OF OUTPUT FILE
(  198) 
(  199) !     IMPLICIT INPUT
(  200) !     --------------
(  201) !       NONE
(  202) !       THIS IS AN ENVIRONMENT INDEPENDENT SUBROUTINE
(  203) 
(  204) !     OTHER INPUT  OR EXTERNALS






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 6

(  205) !     -------------------------
(  206) !       ALL MANNER OF TRIGONOMETRIC FUNCTIONS AND LOGARITHMS
(  207) !       CALLS EGGMLT TO COMPUTE MISSING LATITUDE WHEN KSOTRP > 0
(  208) !       CALLS EGGRVS TO DEDUCE GEOGRAPHIC PARAMETERS FROM FINAL
(  209) !       PROJECTION AND ROTATION PARAMETERS.
(  210) 
(  211) !       AFTER A FIRST CALL TO EGGX, ROUTINE EGGRVS CAN BE RE-CALLED
(  212) !       EXTERNALLY WITH DIFFERENT (PROJECTED OR) ROTATED POSITIONS
(  213) 
(  214) !     OUTPUT PARAMETERS
(  215) !     -----------------
(  216) !       PGELAM(KDLSA:KDLSUR,KDGSA:KDGEN) :
(  217) !                          GEOGRAPHIC LONGITUDE
(  218) !       PGELAT(KDLSA:KDLSUR,KDGSA:KDGEN) :
(  219) !                          GEOGRAPHIC LATITUDE
(  220) !       PGM(KDLSA:KDLSUR,KDGSA:KDGSUR) : MAP FACTOR
(  221) !       PGNORX(KDLSA:KDLSUR,KDGSA:KDGEN) :
(  222) !              PROJECTION OF GEOGRAPHICAL NORTH UNIT VECTOR ON X AXIS
(  223) !       PGNORY(KDLSA:KDLSUR,KDGSA:KDGEN) :
(  224) !              PROJECTION OF GEOGRAPHICAL NORTH UNIT VECTOR ON Y AXIS
(  225) 
(  226) !       PDELX : GRID SIZE IN M ALONG X IF PROJECTION
(  227) !               LONGITUDE INCREMENT IN RD IF SPHERICAL GEOMETRY
(  228) !               NECESSARY TO COMPUTE PERIOD AND DERIVATIVES
(  229) !       PDELY : GRID SIZE IN M ALONG Y IF PROJECTION
(  230) !               LATITUDE INCREMENT IN RD IF SPEHRICAL GEOMETRY
(  231) 
(  232) !     WRITTEN BY
(  233) !     ---------- ALAIN JOLY
(  234) 
(  235) !     NEW NORTHERN HEMISPHERE VERSION : 27/2/92
(  236) !     SOUTHERN HEM ISPHERE VERSION : 27/1/93
(  237) 
(  238) !---------------------------------------------------------------------
(  239) 
(  240) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  241) USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  242) 
(  243) USE YEMGGCM  , ONLY : NYMGGI   ,NYMGGR   ,NYMGGWH  ,XLATR    ,&
(  244)  & XLONR    ,XGGPK    ,XRPKSM   ,XLAT0R   ,XLON0R   ,&
(  245)  & XLON0U   ,XIPORE   ,XJPORE   ,XGGM0    ,XLON1R   ,&
(  246)  & XLON1U   ,XLAT1R   ,XLON2R   ,HSUD     ,XBETA  
(  247) 
(  248) !---------------------------------------------------------------------
(  249) 
(  250) IMPLICIT NONE
(  251) 
(  252) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLSA 
(  253) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLSUR 
(  254) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGSA 
(  255) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGEN 
(  256) REAL(KIND=JPRB)   ,INTENT(IN)    :: PRPI
(  257) REAL(KIND=JPRB)   ,INTENT(IN)    :: PRA
(  258) INTEGER(KIND=JPIM),INTENT(IN)    :: KROTEQ 
(  259) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLONR 
(  260) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLATR 
(  261) REAL(KIND=JPRB)   ,INTENT(IN)    :: PBETA 
(  262) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLON1 






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 7

(  263) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAT1 
(  264) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLON2 
(  265) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAT2 
(  266) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLON0 
(  267) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAT0 
(  268) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PRPK
(  269) INTEGER(KIND=JPIM),INTENT(IN)    :: KULOUT
(  270) INTEGER(KIND=JPIM),INTENT(INOUT) :: KSOTRP
(  271) INTEGER(KIND=JPIM),INTENT(IN)    :: KGIV0 
(  272) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGELAM(KDLSA:KDLSUR,KDGSA:KDGEN)
(  273) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGELAT(KDLSA:KDLSUR,KDGSA:KDGEN)
(  274) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGM(KDLSA:KDLSUR,KDGSA:KDGEN)
(  275) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGNORX(KDLSA:KDLSUR,KDGSA:KDGEN)
(  276) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGNORY(KDLSA:KDLSUR,KDGSA:KDGEN)
(  277) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLUN
(  278) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLUX
(  279) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUN
(  280) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUX
(  281) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDELX
(  282) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDELY
(  283) 
(  284) !---------------------------------------------------------------------
(  285) 
(  286) INTEGER(KIND=JPIM) :: INBESS, INNEGA, ISPECA, ITERK, ITERKX, JLAT, JLON
(  287) INTEGER(KIND=JPIM) :: ISOTRP
(  288) 
(  289) LOGICAL :: LLGWH, LL510, LL520
(  290) LOGICAL :: LLPLANEX
(  291) LOGICAL :: LLPLANEY
(  292) 
(  293) REAL(KIND=JPRB) :: ZCONDEG, ZCONRAD, ZCOSA, ZCOSO, ZDCLA0, ZDCLA1,&
(  294)  & ZDCLA2, ZDLON, ZDM, ZDMMAX, ZDMMIN, ZDRK, &
(  295)  & ZDTLAT, ZFACE, ZIPV, ZJPV, ZLAT, ZLAT2R, &
(  296)  & ZLATLIM, ZLON, ZLON2U, ZPIS2, ZPIS4, ZRKAX, &
(  297)  & ZRKI, ZRKII, ZRKIN, ZRKOLD, ZRKT, ZRPK, ZSECAN, &
(  298)  & ZSECUR, ZSINA, ZSINO, ZUSKP  
(  299) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  300) 
(  301) !---------------------------------------------------------------------
(  302) 
(  303) #include "eggmlt.h"
(  304) #include "eggrvs.h"
(  305) 
(  306) #include "abor1.intfb.h"
(  307) 
(  308) !---------------------------------------------------------------------
(  309) IF (LHOOK) CALL DR_HOOK('EGGX',0,ZHOOK_HANDLE)
(  310) !---------------------------------------------------------------------
(  311) 
(  312) ZPIS2 = PRPI*0.5_JPRB
(  313) ZPIS4 = PRPI*0.25_JPRB
(  314) ZSECUR = 1.E-12_JPRB
(  315) ZSECAN = 1.E-05_JPRB
(  316) 
(  317) !*
(  318) !---------------------------------------------------------------------
(  319) !     1.- PRINTING INPUT PARAMETERS
(  320) ZCONRAD = PRPI/180._JPRB






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 8

(  321) ZCONDEG = 180._JPRB/PRPI
(  322) 
(  323) WRITE (KULOUT,*) ' '
(  324) WRITE (KULOUT,*) ' ---------------------------------- '
(  325) WRITE (KULOUT,*) ' '
(  326) WRITE (KULOUT,*) '      ARPEGE-ALADIN '
(  327) WRITE (KULOUT,*) ' '
(  328) WRITE (KULOUT,*) '    GEOGRAPHY OF GRID-POINTS '
(  329) WRITE (KULOUT,*) ' '
(  330) WRITE (KULOUT,*) ' ---------------------------------- '
(  331) WRITE (KULOUT,*) ' '
(  332) WRITE (KULOUT,*) ' INPUT PARAMETERS '
(  333) WRITE (KULOUT,*) ' '
(  334) WRITE (KULOUT,*) ' PI = ',PRPI
(  335) WRITE (KULOUT,*) ' RADIUS OF PLANET A = ',PRA*1.E-03_JPRB,' KM '
(  336) WRITE (KULOUT,*) ' '
(  337) WRITE (KULOUT,*) ' X-SIZE OF ARRAYS ',KDLSUR-KDLSA+1
(  338) WRITE (KULOUT,*) ' Y-SIZE OF ARRAYS ',KDGEN-KDGSA+1
(  339) WRITE (KULOUT,*) ' '
(  340) WRITE (KULOUT,*) ' X WINDOW KDLUN = ',KDLUN,' KDLUX = ',KDLUX
(  341) WRITE (KULOUT,*) '          SIZE = ',KDLUX-KDLUN+1
(  342) WRITE (KULOUT,*) ' Y WINDOW KDGUN = ',KDGUN,' KDGUX = ',KDGUX
(  343) WRITE (KULOUT,*) '          SIZE = ',KDGUX-KDGUN+1
(  344) WRITE (KULOUT,*) ' '
(  345) WRITE (KULOUT,*) ' ROTATION PARAMETER KROTEQ = ',KROTEQ
(  346) WRITE (KULOUT,*) '          PLONR = ',PLONR
(  347) WRITE (KULOUT,*) '          PLATR = ',PLATR
(  348) WRITE (KULOUT,*) ' '
(  349) WRITE (KULOUT,*) ' ANGLE WITH X/LATITUDE AT PLON0 = ',PBETA
(  350) WRITE (KULOUT,*) ' '
(  351) WRITE (KULOUT,*) ' SW CORNER      PLON1 = ',PLON1
(  352) WRITE (KULOUT,*) '                PLAT1 = ',PLAT1
(  353) WRITE (KULOUT,*) ' '
(  354) WRITE (KULOUT,*) ' NE CORNER      PLON2 = ',PLON2
(  355) WRITE (KULOUT,*) '                PLAT2 = ',PLAT2
(  356) WRITE (KULOUT,*) ' '
(  357) WRITE (KULOUT,*) ' PROJECTION PARAMETER PRPK = ',PRPK
(  358) WRITE (KULOUT,*) ' REF POINT      PLON0 = ',PLON0
(  359) WRITE (KULOUT,*) '                PLAT0 = ',PLAT0
(  360) WRITE (KULOUT,*) ' '
(  361) WRITE (KULOUT,*) ' ISOTROPY PARAMETER KSOTRP = ',KSOTRP
(  362) WRITE (KULOUT,*) ' '
(  363) WRITE (KULOUT,*) ' PROJECTION REF POINT KGIV0 = ',KGIV0
(  364) WRITE (KULOUT,*) ' '
(  365) WRITE (KULOUT,*) ' ---------------------------------- '
(  366) WRITE (KULOUT,*) ' '
(  367) 
(  368) !* have a look whether we calculate plane model version
(  369) LLPLANEX = KDLUN == KDLUX
(  370) LLPLANEY = KDGUN == KDGUX
(  371) 
(  372) IF( LLPLANEX.OR.LLPLANEY )THEN
(  373)   ISOTRP = KSOTRP
(  374)   KSOTRP = 0
(  375)   WRITE (KULOUT,*) '!'
(  376)   WRITE (KULOUT,*) 'YOU RUN PLANE MODEL'
(  377)   WRITE (KULOUT,*) 'KSOTRP LOCALLY RESET TO 0 (ISOTROPIC PARAMETER) '
(  378)   WRITE (KULOUT,*) 'ISOTROPY PARAMETER KSOTRP = ',KSOTRP






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 9

(  379)   WRITE (KULOUT,*) '!'
(  380) ENDIF
(  381) 
(  382) !     SECURITY CORRECTIONS
(  383) IF ( KROTEQ == 0 ) THEN
(  384)   PLONR = 0.0_JPRB
(  385)   PLATR = 0.0_JPRB
(  386) ENDIF
(  387) IF ( PRPK < 0.0_JPRB ) THEN
(  388)   PLON0 = PLONR
(  389)   PLAT0 = PLATR
(  390) ENDIF
(  391) !     CHECK LONGITUDES
(  392) IF ( KROTEQ == 1 ) THEN
(  393)   IF ( PLONR < 0.0_JPRB ) THEN
(  394)     PLONR = PLONR + 2.0_JPRB*PRPI
(  395)     WRITE (KULOUT,*) ' *** EGGX ERROR *** WRONG CONVENTION',&
(  396)      & ' USED FOR LONGITUDES '  
(  397)     WRITE (KULOUT,*) ' *** NEW PLONR = ',PLONR
(  398)   ENDIF
(  399) ENDIF
(  400) IF ( PLON1 < 0.0_JPRB ) THEN
(  401)   PLON1 = PLON1 + 2.0_JPRB*PRPI
(  402)   WRITE (KULOUT,*) ' *** EGGX ERROR *** WRONG CONVENTION',&
(  403)    & ' USED FOR LONGITUDES '  
(  404)   WRITE (KULOUT,*) ' *** NEW PLON1 = ',PLON1
(  405) ENDIF
(  406) IF ( PLON2 < 0.0_JPRB ) THEN
(  407)   PLON2 = PLON2 + 2.0_JPRB*PRPI
(  408)   WRITE (KULOUT,*) ' *** EGGX ERROR *** WRONG CONVENTION',&
(  409)    & ' USED FOR LONGITUDES '  
(  410)   WRITE (KULOUT,*) ' *** NEW PLON2 = ',PLON2
(  411) ENDIF
(  412) IF ( KGIV0 == 0.OR. KGIV0 == 2 ) THEN
(  413)   IF ( PLON0 < 0.0_JPRB ) THEN
(  414)     PLON0 = PLON0 + 2.0_JPRB*PRPI
(  415)     WRITE (KULOUT,*) ' *** EGGX ERROR *** WRONG CONVENTION',&
(  416)      & ' USED FOR LONGITUDES '  
(  417)     WRITE (KULOUT,*) ' *** NEW PLON0 = ',PLON0
(  418)   ENDIF
(  419) ENDIF
(  420) 
(  421) NYMGGR = KROTEQ
(  422) XLATR = PLATR
(  423) XLONR = PLONR
(  424) XBETA = PBETA
(  425) !*
(  426) !--------------------------------------------------------------------
(  427) !     2.- ROTATION TO EQUATOR
(  428) 
(  429) HSUD = 1.0_JPRB
(  430) IF ( KROTEQ == 0 ) THEN
(  431)   ! SOUTH HEMISPHERE DETECTION
(  432)   IF ( PRPK == 10._JPRB .OR. (PRPK > 0.0_JPRB .AND. PRPK <= 1.0_JPRB) ) THEN
(  433)     ! WHEN PROJECTION IS UNKNOWN, IF ONE OF THE REQUESTED LATITUDE IS
(  434)     ! NEGATIVE, A GUESS FOR THE OTHER MUST BE PROVIDED : SO BOTH PLAT1
(  435)     ! AND PLAT2 ARE ASSUMED KNOWN
(  436)     IF ( KSOTRP == 0 ) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 10

(  437)       IF ( PLAT1 < 0.0_JPRB .AND. PLAT2 < 0.0_JPRB ) THEN
(  438)         HSUD = -1.0_JPRB
(  439)         PLAT1 = ABS(PLAT1)
(  440)         PLAT2 = ABS(PLAT2)
(  441)       ENDIF
(  442)     ELSEIF (KSOTRP == 1 ) THEN
(  443)       IF ( PLAT1 < 0.0_JPRB ) THEN
(  444)         IF ( ZPIS2 >= PLAT2.AND. PLAT2 >= -ZPIS2 ) THEN
(  445)           IF ( PLAT2 < 0.0_JPRB ) THEN
(  446)             HSUD = -1.0_JPRB
(  447)             PLAT1 = ABS(PLAT1)
(  448)             PLAT2 = ABS(PLAT2)
(  449)           ELSEIF ( PRPK == 10._JPRB .AND. PLAT2 >= 0.0_JPRB ) THEN
(  450)             PRPK = 0.0_JPRB
(  451)           ELSE
(  452)             WRITE (KULOUT,*) ' *** EGGX WARNING *** ',&
(  453)              & ' YOU SHOULD USE MERCATOR PROJECTION '  
(  454)           ENDIF
(  455)         ELSEIF ( PRPK /= 10._JPRB ) THEN
(  456)           HSUD = -1.0_JPRB
(  457)           PLAT1 = ABS(PLAT1)
(  458)         ELSE
(  459)           WRITE (KULOUT,*) ' *** EGGX ERROR *** ',&
(  460)            & ' REFERENCE POLE (HSUD) CANNOT BE DECIDED '  
(  461)           WRITE (KULOUT,*) ' RERUN WITH A REASONABLE GUESS ',' FOR PLAT2 '
(  462)           CALL ABOR1(' EGGX: abor1 2.1')
(  463)         ENDIF
(  464)       ENDIF
(  465) 
(  466)     ELSEIF ( KSOTRP == 2 ) THEN
(  467)       IF ( PLAT2 < 0.0_JPRB ) THEN
(  468)         IF ( ZPIS2 >= PLAT1.AND. PLAT1 >= -ZPIS2 ) THEN
(  469)           IF ( PLAT1 < 0.0_JPRB ) THEN
(  470)             HSUD = -1.0_JPRB
(  471)             PLAT1 = ABS(PLAT1)
(  472)             PLAT2 = ABS(PLAT2)
(  473)           ELSEIF ( PLAT1 >= 0.0_JPRB ) THEN
(  474)             WRITE (KULOUT,*) ' *** EGGX ERROR *** ',&
(  475)              & ' PLAT1 CANNOT BE GREATER THAN PLAT2 '  
(  476)             WRITE (KULOUT,*) ' RERUN WITH A REASONABLE GUESS ',' FOR PLAT1 '
(  477)             CALL ABOR1(' EGGX: abor1 2.2')
(  478)           ENDIF
(  479)         ELSEIF ( PRPK /= 10._JPRB ) THEN
(  480)           HSUD = -1.0_JPRB
(  481)           PLAT2 = ABS(PLAT2)
(  482)         ELSE
(  483)           WRITE (KULOUT,*) ' *** EGGX ERROR *** ',&
(  484)            & ' REFERENCE POLE (HSUD) CANNOT BE DECIDED '  
(  485)           WRITE (KULOUT,*) ' RERUN WITH A REASONABLE GUESS ',' FOR PLAT1 '
(  486)           CALL ABOR1(' EGGX: abor1 2.3')
(  487)         ENDIF
(  488)       ENDIF
(  489)     ENDIF
(  490) 
(  491)   ENDIF
(  492) 
(  493)   IF ( HSUD < 0.0_JPRB ) THEN
(  494)     PLAT0 = ABS( PLAT0 )






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 11

(  495)   ENDIF
(  496) 
(  497)   ! NO ROTATION
(  498)   XLON1R =MOD(PLON1,2.0_JPRB*PRPI)
(  499)   IF ( KSOTRP /= 2 ) XLAT1R = PLAT1
(  500)   XLON2R = MOD(PLON2,2.0_JPRB*PRPI)
(  501)   IF ( KSOTRP /= 1 ) ZLAT2R = PLAT2
(  502)   IF ( KGIV0 == 0.OR. KGIV0 == 2 ) XLON0R = PLON0
(  503)   IF ( KGIV0 == 0.OR. KGIV0 == 1 ) XLAT0R = PLAT0
(  504) 
(  505) ELSE
(  506)   ! ROTATION
(  507)   IF ( KSOTRP == 0.OR. KSOTRP == 1 ) THEN
(  508)     ! ROTATION OF SW CORNER
(  509)     ! ----------------------
(  510)     ZSINA = COS( PLATR )*SIN( PLAT1 )&
(  511)      & - SIN( PLATR )*COS( PLAT1 )*COS( PLON1-PLONR )  
(  512)     XLAT1R = ASIN( ZSINA )
(  513)     IF ( ABS( XLAT1R ) >= ZPIS2 ) THEN
(  514)       XLON1R = 0.0_JPRB
(  515)     ELSE
(  516)       ZCOSA = COS( XLAT1R )
(  517)       ZCOSO = ( SIN( PLATR )*SIN( PLAT1 ) +&
(  518)        & COS( PLATR )*COS( PLAT1 )*COS( PLON1-PLONR ) )/ZCOSA  
(  519)       ZCOSO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZCOSO))
(  520)       ZSINO = ( COS( PLAT1 )*SIN( PLON1-PLONR ) )/ZCOSA
(  521)       ZSINO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZSINO))
(  522)       XLON1R = ACOS( ZCOSO )
(  523)       IF ( ASIN( ZSINO ) < 0.0_JPRB ) XLON1R = 2.0_JPRB*PRPI - XLON1R
(  524)     ENDIF
(  525)   ENDIF
(  526) 
(  527)   IF ( KSOTRP == 0.OR. KSOTRP == 2 ) THEN
(  528)     ! ROTATION OF NE CORNER
(  529)     ! ----------------------
(  530)     ZSINA = COS( PLATR )*SIN( PLAT2 )&
(  531)      & - SIN( PLATR )*COS( PLAT2 )*COS( PLON2-PLONR )  
(  532)     ZLAT2R = ASIN( ZSINA )
(  533)     IF ( ABS( ZLAT2R ) >= ZPIS2 ) THEN
(  534)       XLON2R = 0.0_JPRB
(  535)     ELSE
(  536)       ZCOSA = COS( ZLAT2R )
(  537)       ZCOSO = ( SIN( PLATR )*SIN( PLAT2 ) +&
(  538)        & COS( PLATR )*COS( PLAT2 )*COS( PLON2-PLONR ) )/ZCOSA  
(  539)       ZCOSO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZCOSO))
(  540)       ZSINO = ( COS( PLAT2 )*SIN( PLON2-PLONR ) )/ZCOSA
(  541)       ZSINO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZSINO))
(  542)       XLON2R = ACOS( ZCOSO )
(  543)       IF ( ASIN( ZSINO ) < 0.0_JPRB ) XLON2R = 2.0_JPRB*PRPI - XLON2R
(  544)     ENDIF
(  545)   ENDIF
(  546) 
(  547)   !     ROTATION OF PROJECTION REFERENCE POINT
(  548)   !     --------------------------------------
(  549)   IF ( KGIV0 == 2 ) THEN
(  550)     WRITE (KULOUT,*) ' *** EGGX ERROR '
(  551)     WRITE (KULOUT,*) ' KGIV0 = 2 IMPOSSIBLE WITH KROTEQ = 1 '
(  552)     CALL ABOR1(' EGGX: abor1 2.4')






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 12

(  553)   ENDIF
(  554)   IF ( KGIV0 == 0.OR. KGIV0 == 1 ) THEN
(  555)     ZSINA = COS( PLATR )*SIN( PLAT0 )&
(  556)      & - SIN( PLATR )*COS( PLAT0 )*COS( PLON0-PLONR )  
(  557)     XLAT0R = ASIN( ZSINA )
(  558)   ENDIF
(  559)   IF ( KGIV0 == 0 ) THEN
(  560)     IF ( ABS( XLAT0R ) >= ZPIS2 ) THEN
(  561)       XLON0R = 0.0_JPRB
(  562)     ELSE
(  563)       ZCOSA = MAX( COS( XLAT0R ) , ZSECUR )
(  564)       ZCOSO = ( SIN( PLATR )*SIN( PLAT0 ) +&
(  565)        & COS( PLATR )*COS( PLAT0 )*COS( PLON0-PLONR ) )/ZCOSA  
(  566)       ZCOSO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZCOSO))
(  567)       ZSINO = ( COS( PLAT0 )*SIN( PLON0-PLONR ) )/ZCOSA
(  568)       ZSINO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZSINO))
(  569)       XLON0R = ACOS( ZCOSO )
(  570)       IF ( ASIN( ZSINO ) < 0.0_JPRB ) XLON0R = 2.0_JPRB*PRPI - XLON0R
(  571)     ENDIF
(  572)   ENDIF
(  573) ENDIF
(  574) 
(  575) IF ( KROTEQ /= 0 ) THEN
(  576)   IF ( PRPK > 0.0_JPRB ) THEN
(  577)     WRITE (KULOUT,*) ' *** EGGX WARNING ',&
(  578)      & ' USE OF ROTATION + NON-MERCATOR PROJECTION WILL LEAD ',&
(  579)      & ' TO UNPREDICTABLE RESULTS, ESP. IN SOUTH HEMISPHERE '  
(  580)     IF ( XLAT1R < 0.0_JPRB .AND. ZLAT2R < 0.0_JPRB ) THEN
(  581)       HSUD = -1.0_JPRB
(  582)       XLAT1R = ABS( XLAT1R )
(  583)       ZLAT2R = ABS( ZLAT2R )
(  584)       XLAT0R = ABS( XLAT0R )
(  585)     ENDIF
(  586)   ENDIF
(  587) ENDIF
(  588) 
(  589) WRITE (KULOUT,*) ' '
(  590) WRITE (KULOUT,*) ' HEMISPHERE INDICATOR HSUD = ',HSUD
(  591) WRITE (KULOUT,*) ' '
(  592) WRITE (KULOUT,*) ' ROTATED COORDINATES '
(  593) WRITE (KULOUT,*) ' SW CORNER      XLON1R = ',XLON1R
(  594) WRITE (KULOUT,*) '                XLAT1R = ',XLAT1R
(  595) WRITE (KULOUT,*) ' '
(  596) WRITE (KULOUT,*) ' NE CORNER      XLON2R = ',XLON2R
(  597) WRITE (KULOUT,*) '                ZLAT2R = ',ZLAT2R
(  598) WRITE (KULOUT,*) ' '
(  599) WRITE (KULOUT,*) ' REF POINT      XLON0R = ',XLON0R
(  600) WRITE (KULOUT,*) '                XLAT0R = ',XLAT0R
(  601) WRITE (KULOUT,*) ' '
(  602) 
(  603) !*
(  604) !--------------------------------------------------------------------
(  605) !     3.- SPHERICAL GEOMETRY
(  606) 
(  607) IF ( PRPK < 0.0_JPRB ) THEN
(  608) 
(  609)   !   THE GRID IS MADE UP OF REGULARLY SPACED POINTS IN LONGITUDE (X)
(  610)   !   AND LATITUDE (Y) CORRDINATES






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 13

(  611) 
(  612)   !   PDELX AND PDELY ARE NON DIMENSIONNAL IN THAT CASE
(  613) 
(  614)   IF ( KSOTRP == 0 ) THEN
(  615)     XLON1U = XLON1R
(  616)     ZLON2U = XLON2R
(  617)     IF ( ZLON2U < XLON1U ) ZLON2U = 2.0_JPRB*PRPI + ZLON2U
(  618)   ENDIF
(  619)   !   DEFINES OTHER CORNER
(  620)   IF ( KSOTRP == 1 ) THEN
(  621)     XLON1U = XLON1R
(  622)     ZLAT2R = - XLAT1R
(  623)     ZLON2U = XLON1U + ( ZLAT2R-XLAT1R )*&
(  624)      & REAL(KDLUX-KDLUN,JPRB)/REAL(KDGUX-KDGUN,JPRB)  
(  625)     XLON2R = ZLON2U
(  626)     IF ( ZLON2U >= 2.0_JPRB*PRPI ) XLON2R = ZLON2U - 2.0_JPRB*PRPI
(  627)   ENDIF
(  628)   IF ( KSOTRP == 2 ) THEN
(  629)     ZLON2U = XLON2R
(  630)     XLAT1R = - ZLAT2R
(  631)     XLON1U = ZLON2U - ( ZLAT2R-XLAT1R )*&
(  632)      & REAL(KDLUX-KDLUN,JPRB)/REAL(KDGUX-KDGUN,JPRB)  
(  633)     XLON1R = XLON1U
(  634)     IF ( XLON1U >= 2.0_JPRB*PRPI ) XLON1R = XLON1U - 2.0_JPRB*PRPI
(  635)   ENDIF
(  636) 
(  637)   IF( .NOT.LLPLANEX.AND..NOT.LLPLANEY )THEN
(  638)     PDELX = ( ZLON2U-XLON1U )/REAL( KDLUX-KDLUN ,JPRB)
(  639)     PDELY = ( ZLAT2R-XLAT1R )/REAL( KDGUX-KDGUN ,JPRB)
(  640)   ELSEIF( LLPLANEX )THEN
(  641)     PDELY = ( ZLAT2R-XLAT1R )/REAL( KDGUX-KDGUN )
(  642)     PDELX = PDELY
(  643)   ELSEIF( LLPLANEY )THEN
(  644)     PDELX = ( ZLON2U-XLON1U )/REAL( KDLUX-KDLUN )
(  645)     PDELY = PDELX
(  646)   ENDIF
(  647) 
(  648)   XIPORE=0.0_JPRB
(  649)   XJPORE=0.0_JPRB
(  650)   XRPKSM=PRPK
(  651)   XGGPK = PRPK
(  652)   NYMGGI = 10
(  653) 
(  654)   DO JLAT = KDGUN, KDGUX
(  655)     ZLAT = REAL(JLAT-KDGUN,JPRB)*PDELY
(  656) 
(  657)     DO JLON = KDLUN, KDLUX
(  658)       ZLON = REAL(JLON-KDLUN,JPRB)*PDELX
(  659)       PGELAM(JLON,JLAT) = ZLON
(  660)       PGELAT(JLON,JLAT) = ZLAT
(  661)     ENDDO
(  662) 
(  663)     CALL EGGRVS (PRPI, PRA, PDELX, PDELY, KDLSUR-KDLSA+1,&
(  664)      & 1, KDLUX-KDLUN+1, KULOUT,&
(  665)      & PGELAM(KDLUN,JLAT), PGELAT(KDLUN,JLAT), PGM(KDLUN,JLAT),&
(  666)      & PGNORX(KDLUN,JLAT), PGNORY(KDLUN,JLAT))  
(  667)   ENDDO
(  668) ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 14

(  669) 
(  670) !*
(  671) !--------------------------------------------------------------------
(  672) !     4.- MAP FACTOR ON SPHERICAL GEOMETRY
(  673) 
(  674) !*
(  675) !--------------------------------------------------------------------
(  676) !     5.- PREPARATION OF PROJECTION PARAMETERS
(  677) 
(  678) IF ( PRPK >= 0.0_JPRB ) THEN
(  679) 
(  680)   !   PROJECTION LONGITUDES ARE ALWAYS KNOWN
(  681) 
(  682)   !   SPECIAL LOGICAL TRUE WHEN DOMAIN ASTRIDE GREENWICH MERIDIAN
(  683)   !    LLGWH = .F. : GREENWICH OUT OF DOMAIN
(  684)   !    LLGWH = .T. : GREENWICH WITHIN DOMAIN
(  685)   LLGWH = ( XLON2R < XLON1R )
(  686)   NYMGGWH = 0
(  687)   IF ( LLGWH ) NYMGGWH = 1
(  688)   !   SHIFT LONGITUDES WHEN GREENWICH MERIDIAN IS WITHIN THE DOMAIN
(  689)   XLON1U = XLON1R
(  690)   ZLON2U = XLON2R
(  691)   IF ( LLGWH ) THEN
(  692)     ZLON2U = XLON2R + 2.0_JPRB*PRPI
(  693)   ENDIF
(  694) 
(  695)   IF ( KGIV0 == 1.OR. KGIV0 == 3 ) THEN
(  696)     IF ( ABS(ABS(ZLON2U-XLON1U)-PRPI) > ZSECAN ) THEN
(  697)       WRITE (KULOUT,*) ' NORMAL LONGITUDE DIFFERENCE '
(  698)       XLON0U = 0.5_JPRB*( XLON1U + ZLON2U )
(  699)       XLON0R = XLON0U
(  700)     ELSE
(  701)       WRITE (KULOUT,*) ' LONGITUDE DIFFERENCE = PI '
(  702)       XLON0U = XLON1U + ZPIS4
(  703)       XLON0R = XLON0U
(  704)     ENDIF
(  705)     IF ( XLON0U >= 2.0_JPRB*PRPI ) XLON0R = XLON0R - 2.0_JPRB*PRPI
(  706)     WRITE (KULOUT,*) ' '
(  707)     WRITE (KULOUT,*) ' PROJECTION REFERENCE LONGITUDE '
(  708)     WRITE (KULOUT,*) ' (ON ROTATED SPHERE) LON0R = ',XLON0R
(  709)     WRITE (KULOUT,*) ' GREENWICH LOGICAL = ',LLGWH
(  710)     WRITE (KULOUT,*) ' '
(  711)   ENDIF
(  712) 
(  713)   XLON0U = XLON0R
(  714)   IF ( LLGWH .AND. XLON0R < XLON1R ) THEN
(  715)     XLON0U = XLON0R + 2.0_JPRB*PRPI
(  716)   ENDIF
(  717) 
(  718)   !   PROJECTION TYPE IS GIVEN BY THE USER
(  719)   !   ------------------------------------
(  720) 
(  721)   IF ( PRPK <= 1.0_JPRB ) THEN
(  722) 
(  723)     ! DETERMINES MISSING LATITUDE IF ANY
(  724)     IF ( KSOTRP >= 1 ) THEN
(  725) 
(  726)       ! ADJUSTMENT OF ONE EXTREME LATITUDE IN ORDER TO HAVE PDELX = PDELY






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 15

(  727)       CALL EGGMLT (PRPI,KDLUX,KDLUN,KDGUX,KDGUN,KULOUT,1,&
(  728)        & PRPK,XLON0U,XLON1U,ZLON2U,KSOTRP,XLAT1R,ZLAT2R,&
(  729)        & HSUD,XBETA)  
(  730) 
(  731)     ENDIF
(  732) 
(  733)     ! DETERMINES REFERENCE LATITUDE
(  734) 
(  735)     IF ( KGIV0 == 2.OR. KGIV0 == 3 ) THEN
(  736)       XLAT0R = 0.5_JPRB*( ZLAT2R + XLAT1R )
(  737)       XLAT0R = MIN(ZPIS2,MAX(-ZPIS2,XLAT0R))
(  738)       WRITE (KULOUT,*) ' '
(  739)       WRITE (KULOUT,*) ' PROJECTION REFERENCE LATITUDE ',&
(  740)        & ' (ON ROTATED SPHERE) '  
(  741)       WRITE (KULOUT,*) ' LAT0R = ',XLAT0R
(  742)       WRITE (KULOUT,*) ' '
(  743)     ENDIF
(  744) 
(  745)   ENDIF
(  746) 
(  747)   !     MAP PROJECTION TYPE AND POSSIBLY ONE CORNER MUST BE DETERMINED
(  748)   !     --------------------------------------------------------------
(  749)   IF ( PRPK == 10._JPRB ) THEN
(  750) 
(  751)     ! EXPLORE VARIATIONS OF MAP FACTOR
(  752)     ! --------------------------------
(  753) 
(  754)     ZLATLIM = PRPI/6._JPRB
(  755)     ! FIRST GUESS : EITHER STEREO OR MERCATOR
(  756)     IF ( KSOTRP == 0 ) THEN
(  757)       ZRPK = 1.0_JPRB
(  758)       IF ( XLAT1R < ZLATLIM ) ZRPK = 0.0_JPRB
(  759)     ELSEIF ( KSOTRP == 1 ) THEN
(  760)       ZRPK = 1.0_JPRB
(  761)       IF ( XLAT1R < ZLATLIM ) ZRPK = 0.0_JPRB
(  762)     ELSEIF ( KSOTRP == 2 ) THEN
(  763)       ZRPK = 1.0_JPRB
(  764)       IF ( ZLAT2R < ZLATLIM ) ZRPK = 0.0_JPRB
(  765)     ENDIF
(  766) 
(  767)     ! FIRST GUESS POSSIBLE OTHER LATITUDE
(  768)     IF ( KSOTRP >= 1 ) THEN
(  769)       CALL EGGMLT (PRPI,KDLUX,KDLUN,KDGUX,KDGUN,KULOUT,1,&
(  770)        & ZRPK,XLON0U,XLON1U,ZLON2U,KSOTRP,XLAT1R,ZLAT2R,&
(  771)        & HSUD,XBETA)  
(  772)     ENDIF
(  773)     ! FIRST GUESS REFERENCE LATITUDE
(  774)     IF ( KGIV0 == 2.OR. KGIV0 == 3 ) THEN
(  775)       XLAT0R = 0.5_JPRB*( ZLAT2R + XLAT1R )
(  776)       XLAT0R = MIN(ZPIS2,MAX(-ZPIS2,XLAT0R))
(  777)     ENDIF
(  778) 
(  779)     ! PREPARING FOR OUTER ITERATION LOOP (RK + LATITUDE)
(  780)     ITERKX = 10
(  781)     ITERK = 0
(  782)     ZRKOLD = ZRPK
(  783) 
(  784)     LL510=.TRUE.






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 16

(  785) 
(  786)     DO WHILE(LL510)
(  787) 
(  788)       ZRKII = 0.01_JPRB
(  789)       ZDRK = 0.01_JPRB
(  790)       ZRKI = 0.0_JPRB
(  791)       ISPECA = 0
(  792) 
(  793)       ! IDENTIFYING SPECIAL CASES THAT MUST GO INTO THE INNER LOOP
(  794)       IF ( XLAT1R*ZLAT2R  <=  0.0_JPRB ) THEN
(  795)         ! SPECIAL CASE : DOMAIN ASTRIDE EQUATOR
(  796)         ZRPK = 0.0_JPRB
(  797)         ZRKOLD = ZRPK
(  798)         ISPECA = 1
(  799)       ELSEIF ( HSUD > 0.0_JPRB .AND.ABS(ZLAT2R) <= ABS(XLAT1R) ) THEN
(  800)         ! SPECIAL CASE : DOMAIN INCLUDING NORTH POLE (THE TEST IS A WEAK ONE)
(  801)         ZRPK = 1.0_JPRB
(  802)         ZRKOLD = ZRPK
(  803)         ISPECA = 1
(  804)       ELSEIF ( HSUD < 0.0_JPRB .AND.ABS(XLAT1R) <= ABS(ZLAT2R) ) THEN
(  805)         ! SPECIAL CASE : DOMAIN INCLUDING SOUTH POLE (THE TEST IS A WEAK ONE)
(  806)         ZRPK = 1.0_JPRB
(  807)         ZRKOLD = ZRPK
(  808)         ISPECA = 1
(  809)       ELSEIF ( ABS(ABS(ZLAT2R)-ZPIS2) < ZSECAN ) THEN
(  810)         ! VARIOUS OTHER SPECIAL CASES THAT MUST NOT COVER THE WHOLE LOOP
(  811)         ZRKI = ZRKII
(  812)       ELSEIF ( ABS(ABS(XLAT1R)-ZPIS2) < ZSECAN ) THEN
(  813)         ! VARIOUS OTHER SPECIAL CASES THAT MUST NOT COVER THE WHOLE LOOP
(  814)         ZRKI = ZRKII
(  815)       ENDIF
(  816) 
(  817)       IF ( ISPECA /= 1 ) THEN
(  818) 
(  819)         ! PREPARE FOR INNER LOOP ON RK
(  820)         ZDMMAX = -1.0_JPRB
(  821)         ZDMMIN = 1.E+05_JPRB
(  822)         ZRKAX = 1.0_JPRB
(  823)         ZRKIN = 1.0_JPRB
(  824)         INNEGA = 0
(  825)         INBESS = 0
(  826)         ZRKT = ZRKI
(  827) 
(  828)         ! INNER LOOP ON RK
(  829) 
(  830)         LL520=.TRUE.
(  831) 
(  832)         DO WHILE(LL520)
(  833)           ! COMPUTES MAP FACTOR VARIATION FOR VARIOUS PROJECTION
(  834)           IF ( ZRKT == 0.0_JPRB ) THEN
(  835)             ZDM = COS(XLAT0R)/COS(ZLAT2R) - COS(XLAT0R)/COS(XLAT1R)
(  836)           ELSEIF ( ZRKT /= 1.0_JPRB ) THEN
(  837)             ZDM = (COS(XLAT0R)**(1.0_JPRB-ZRKT))*&
(  838)              & ((1.0_JPRB+SIN(XLAT0R))**ZRKT)*( (COS(XLAT1R)**(ZRKT-1.0_JPRB))*&
(  839)              & ((1.0_JPRB+SIN(XLAT1R))**(-ZRKT)) - (COS(ZLAT2R)**(ZRKT-1.0_JPRB))*&
(  840)              & ((1.0_JPRB+SIN(ZLAT2R))**(-ZRKT)) )  
(  841)           ELSEIF ( ZRKT == 1.0_JPRB ) THEN
(  842)             ZDM = (1.0_JPRB+SIN(XLAT0R))*( 1.0_JPRB/(1.0_JPRB+SIN(XLAT1R)) -&






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 17

(  843)              & 1.0_JPRB/(1.0_JPRB+SIN(ZLAT2R)) )  
(  844)           ENDIF
(  845)           INBESS = INBESS + 1
(  846)           IF ( ZDM <= 0.0_JPRB ) THEN
(  847)             INNEGA = INNEGA + 1
(  848)           ENDIF
(  849)           IF ( ZDM >= ZDMMAX .AND. ZDM > 0.0_JPRB ) THEN
(  850)             ZDMMAX = ZDM
(  851)             ZRKAX = ZRKT
(  852)           ENDIF
(  853)           IF ( ZDM <= ZDMMIN .AND. ZDM > 0.0_JPRB ) THEN
(  854)             ZDMMIN = ZDM
(  855)             ZRKIN = ZRKT
(  856)           ENDIF
(  857)           ZRKT = ZRKT + ZDRK
(  858)           LL520=(ZRKT <= 1.0_JPRB)
(  859)         ENDDO ! DO WHILE(LL520)
(  860) 
(  861)         WRITE (KULOUT,*) ' '
(  862)         WRITE (KULOUT,*) ' CHOICE OF OPTIMAL RK ITERATION ',ITERK
(  863)         WRITE (KULOUT,*) ' PREVIOUS RK ',ZRKOLD
(  864)         WRITE (KULOUT,*) ' TEST OVER ',INBESS,' VALUES '
(  865)         WRITE (KULOUT,*) ' INCLUDING ',INNEGA,' NEGATIVE VALUES'
(  866)         WRITE (KULOUT,*) ' RK MINI = ',ZRKI,' INCRMENT = ',ZDRK
(  867)         WRITE (KULOUT,*) ' '
(  868)         WRITE (KULOUT,*) ' DELTA(M) MAXI = ',ZDMMAX,' AT RK = ',ZRKAX
(  869)         WRITE (KULOUT,*) ' DELTA(M) MINI = ',ZDMMIN,' AT RK = ',ZRKIN
(  870) 
(  871)         ! UPDATES VALUE OF GUESS ZRPK
(  872)         ZRKOLD = ZRPK
(  873)         ZRPK = ZRKIN
(  874) 
(  875)       ENDIF ! ISPECA /= 1
(  876) 
(  877)       IF ( KSOTRP == 0 ) THEN
(  878)         ! END THE OUTER LOOP IF BOTH LATITUDES WERE KNOWN
(  879)         ZRKOLD = ZRPK
(  880)       ELSEIF ( KSOTRP >= 1 ) THEN
(  881)         ! DETRMINES NEW OTHER LATITUDE
(  882)         CALL EGGMLT (PRPI,KDLUX,KDLUN,KDGUX,KDGUN,KULOUT,1,&
(  883)          & ZRPK,XLON0U,XLON1U,ZLON2U,KSOTRP,XLAT1R,ZLAT2R,&
(  884)          & HSUD,XBETA)  
(  885)       ENDIF
(  886)       ! NEW REFERENCE LATITUDE
(  887)       IF ( KGIV0 == 2.OR. KGIV0 == 3 ) THEN
(  888)         XLAT0R = 0.5_JPRB*( ZLAT2R + XLAT1R )
(  889)         XLAT0R = MIN(ZPIS2,MAX(-ZPIS2,XLAT0R))
(  890)       ENDIF
(  891) 
(  892)       ! COMPLETES INTERATION OF OUTER LOOP (RK AND LATITUDE)
(  893)       ITERK = ITERK + 1
(  894)       IF ( ITERK > ITERKX ) THEN
(  895)         WRITE (KULOUT,*) ' *** EGGX **** TROUBLE '
(  896)         WRITE (KULOUT,*) ' NO CONVERGENCE OF AUTOMATIC CHOICE '
(  897)         CALL ABOR1(' EGGX: abor1 5.1')
(  898)       ENDIF
(  899) 
(  900)       LL510=(ABS(ZRPK-ZRKOLD) > ZDRK)






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 18

(  901) 
(  902)     ENDDO ! DO WHILE(LL510)
(  903) 
(  904)     PRPK = ZRPK
(  905)     WRITE (KULOUT,*) ' '
(  906)     WRITE (KULOUT,*) ' --- EGGX AUTOMATIC CHOICE '
(  907)     WRITE (KULOUT,*) ' '
(  908)     WRITE (KULOUT,*) ' FINAL VALUE OF PRPK = ',PRPK
(  909)     WRITE (KULOUT,*) ' '
(  910)     WRITE (KULOUT,*) ' PROJECTION REFERENCE LATITUDE ',&
(  911)      & ' (ON ROTATED SPHERE) '  
(  912)     WRITE (KULOUT,*) ' FINAL LATITUDE LAT1 R = ',XLAT1R
(  913)     WRITE (KULOUT,*) ' FINAL LATITUDE LAT2 R = ',ZLAT2R
(  914)     WRITE (KULOUT,*) ' LAT0R = ',XLAT0R
(  915)     WRITE (KULOUT,*) ' '
(  916)   ENDIF
(  917) 
(  918) ENDIF
(  919) !     MEMORIZES THE FINAL VALUE OF PRPK
(  920) XGGPK = PRPK
(  921) 
(  922) !*
(  923) !---------------------------------------------------------------------
(  924) !     6.- PROJECTION ON CARTESIAN PLAN
(  925) 
(  926) !     REMARK : THE CODE IS GENERAL, BUT STEREO/LAMBERT SHOULD
(  927) !              NOT BE COMBINED TO ROTATION
(  928) 
(  929) IF ( PRPK > 1.0_JPRB ) THEN
(  930)   WRITE (KULOUT,*) ' *** EGGX ERROR : NON-EXISTING PROJ.'
(  931)   CALL ABOR1(' EGGX: abor1 6.1')
(  932) ENDIF
(  933) 
(  934) IF ( PRPK > 0.0_JPRB ) THEN
(  935)   WRITE (KULOUT,*) ' STEREO OR LAMBERT PROJECTION '
(  936)   IF ( PRPK == 1.0_JPRB ) WRITE (KULOUT,*)&
(  937)    & ' EFFECTIVELY STREOGRAPHIC PROJECTION '  
(  938) 
(  939)   !   COMPUTES BASIC PARAMETERS
(  940)   !   -------------------------
(  941) 
(  942)   !    HALF COLATITUDE
(  943)   ZDCLA1 = ZPIS4 - 0.5_JPRB*XLAT1R
(  944)   ZDCLA2 = ZPIS4 - 0.5_JPRB*ZLAT2R
(  945)   ZDCLA0 = ZPIS4 - 0.5_JPRB*XLAT0R
(  946)   !   PROJECTION CONSTANTS
(  947)   IF ( PRPK < 1.0_JPRB ) THEN
(  948)     XGGM0 = ( COS( XLAT0R )**(1.0_JPRB-PRPK) )*&
(  949)      & ( ( 1.0_JPRB + SIN( XLAT0R ) )**PRPK )  
(  950)     ZUSKP = XGGM0/PRPK
(  951)     XRPKSM = 1.0_JPRB/ZUSKP
(  952)   ELSE
(  953)     XGGM0 = 1.0_JPRB + SIN( XLAT0R )
(  954)     ZUSKP = XGGM0
(  955)     XRPKSM = 1.0_JPRB/ZUSKP
(  956)   ENDIF
(  957) 
(  958)   !   COMPUTES RESOLUTION






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 19

(  959)   !   -------------------
(  960)   IF( .NOT.LLPLANEX.AND..NOT.LLPLANEY )THEN
(  961)     PDELX = PRA*ZUSKP*( (TAN(ZDCLA2)**PRPK)*SIN( PRPK*(&
(  962)      & ZLON2U-XLON0U)-XBETA ) - (TAN(ZDCLA1)**PRPK)*&
(  963)      & SIN( PRPK*(XLON1U-XLON0U)-XBETA ) )/REAL(KDLUX-KDLUN,JPRB)  
(  964)     PDELY = HSUD*PRA*ZUSKP*( (TAN(ZDCLA1)**PRPK)*COS( PRPK*(&
(  965)      & XLON1U-XLON0U)-XBETA ) - (TAN(ZDCLA2)**PRPK)*&
(  966)      & COS( PRPK*(ZLON2U-XLON0U)-XBETA ) )/REAL(KDGUX-KDGUN,JPRB)  
(  967)   ELSEIF( LLPLANEX )THEN
(  968)     PDELY = HSUD*PRA*ZUSKP*( (TAN(ZDCLA1)**PRPK)*COS( PRPK*(&
(  969)      & XLON1U-XLON0U)-XBETA ) - (TAN(ZDCLA2)**PRPK)*&
(  970)      & COS( PRPK*(ZLON2U-XLON0U)-XBETA ) )/REAL(KDGUX-KDGUN)  
(  971)     PDELX=PDELY
(  972)   ELSEIF( LLPLANEY )THEN
(  973)     PDELX = PRA*ZUSKP*( (TAN(ZDCLA2)**PRPK)*SIN( PRPK*(&
(  974)      & ZLON2U-XLON0U)-XBETA ) - (TAN(ZDCLA1)**PRPK)*&
(  975)      & SIN( PRPK*(XLON1U-XLON0U)-XBETA ) )/REAL(KDLUX-KDLUN)  
(  976)     PDELY = PDELX
(  977)   ENDIF
(  978)       
(  979)   WRITE (KULOUT,*) ' '
(  980)   WRITE (KULOUT,*) ' MAP FACTOR BASE XGGM0 = ',XGGM0
(  981)   WRITE (KULOUT,*) ' ZUSKP = ',ZUSKP
(  982)   WRITE (KULOUT,*) ' '
(  983)   WRITE (KULOUT,*) ' X GRID SIZE (KM) = ',PDELX*1.E-03_JPRB
(  984)   WRITE (KULOUT,*) ' '
(  985)   WRITE (KULOUT,*) ' Y GRID SIZE (KM) = ',PDELY*1.E-03_JPRB
(  986)   WRITE (KULOUT,*) ' '
(  987) 
(  988)   !   COMPUTES POLE LOCATION ON GRID
(  989)   !   ------------------------------
(  990) 
(  991)   XIPORE =  - PRA*ZUSKP*( TAN( ZDCLA1 )**PRPK )*&
(  992)    & SIN( PRPK*(XLON1U-XLON0U)-XBETA )/PDELX  
(  993)   XJPORE =  HSUD*PRA*ZUSKP*( TAN( ZDCLA1 )**PRPK )*&
(  994)    & COS( PRPK*(XLON1U-XLON0U)-XBETA )/PDELY  
(  995)   NYMGGI = 10
(  996) 
(  997)   WRITE (KULOUT,*) ' '
(  998)   WRITE (KULOUT,*) ' POLE LOCATION ON GRID IP = ',XIPORE,' JP = ',XJPORE
(  999) 
( 1000)   ZIPV = REAL( KDLUX ,JPRB) - PRA*ZUSKP*( TAN( ZDCLA2 )**PRPK )*&
( 1001)    & SIN( PRPK*(ZLON2U-XLON0U)-XBETA )/PDELX  - REAL(KDLUN,JPRB)  
( 1002)   ZJPV = REAL( KDGUX ,JPRB) + PRA*ZUSKP*( TAN( ZDCLA2 )**PRPK )*&
( 1003)    & COS( PRPK*(ZLON2U-XLON0U)-XBETA )*HSUD/PDELY -&
( 1004)    & REAL(KDGUN,JPRB)  
( 1005) 
( 1006)   WRITE (KULOUT,*) ' VRF POLE LOCATION ON GRID IP = ',ZIPV,' JP = ',ZJPV
( 1007) 
( 1008)   !   GRID POINTS LOCATION
( 1009)   !   --------------------
( 1010) 
( 1011)   DO JLAT = KDGUN, KDGUX
( 1012) 
( 1013)     DO JLON = KDLUN, KDLUX
( 1014)       PGELAM(JLON,JLAT) = REAL(JLON-KDLUN,JPRB)*PDELX
( 1015)       PGELAT(JLON,JLAT) = REAL(JLAT-KDGUN,JPRB)*PDELY
( 1016)     ENDDO






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 20

( 1017) 
( 1018)     CALL EGGRVS (PRPI, PRA, PDELX, PDELY, KDLSUR-KDLSA+1,&
( 1019)      & 1, KDLUX-KDLUN+1, KULOUT,&
( 1020)      & PGELAM(KDLUN,JLAT), PGELAT(KDLUN,JLAT), PGM(KDLUN,JLAT),&
( 1021)      & PGNORX(KDLUN,JLAT), PGNORY(KDLUN,JLAT))  
( 1022)   ENDDO
( 1023) 
( 1024) ENDIF
( 1025) 
( 1026) IF ( PRPK == 0.0_JPRB ) THEN
( 1027)   WRITE (KULOUT,*) ' MERCATOR PROJECTION '
( 1028) 
( 1029)   !   COMPUTES BASIC PARAMETERS
( 1030)   !   -------------------------
( 1031) 
( 1032)   !    HALF COLATITUDE
( 1033)   ZDCLA1 = ZPIS4 - 0.5_JPRB*XLAT1R
( 1034)   ZDCLA2 = ZPIS4 - 0.5_JPRB*ZLAT2R
( 1035)   ZDCLA0 = ZPIS4 - 0.5_JPRB*XLAT0R
( 1036) 
( 1037)   !   COMPUTES RESOLUTION
( 1038)   !   -------------------
( 1039) 
( 1040)   ZFACE = PRA*COS( XLAT0R )
( 1041)   ZDLON =  ZLON2U - XLON1U
( 1042)   ZDTLAT = LOG( TAN(ZDCLA1)/TAN(ZDCLA2) )
( 1043)   IF( .NOT.LLPLANEX.AND..NOT.LLPLANEY )THEN
( 1044)     PDELX = ZFACE*( ZDLON*COS(XBETA) + ZDTLAT*SIN(XBETA) )&
( 1045)      & /REAL( KDLUX-KDLUN ,JPRB)  
( 1046)     PDELY = ZFACE*( -ZDLON*SIN(XBETA) + ZDTLAT*COS(XBETA) )&
( 1047)      & /REAL( KDGUX-KDGUN ,JPRB)  
( 1048)   ELSEIF( LLPLANEX )THEN
( 1049)     PDELY = ZFACE*( -ZDLON*SIN(XBETA) + ZDTLAT*COS(XBETA) )&
( 1050)      & /REAL( KDGUX-KDGUN )  
( 1051)     PDELX = PDELY
( 1052)   ELSEIF( LLPLANEY )THEN
( 1053)     PDELX = ZFACE*( ZDLON*COS(XBETA) + ZDTLAT*SIN(XBETA) )&
( 1054)      & /REAL( KDLUX-KDLUN )  
( 1055)     PDELY = PDELX
( 1056)   ENDIF
( 1057) 
( 1058)   WRITE (KULOUT,*) ' '
( 1059)   WRITE (KULOUT,*) ' MAP FACTOR BASE COS( LAT0 ) = ',COS( XLAT0R )
( 1060)   WRITE (KULOUT,*) ' '
( 1061)   WRITE (KULOUT,*) ' X GRID SIZE (KM) = ',PDELX*1.E-03_JPRB
( 1062)   WRITE (KULOUT,*) ' '
( 1063)   WRITE (KULOUT,*) ' Y GRID SIZE (KM) = ',PDELY*1.E-03_JPRB
( 1064)   WRITE (KULOUT,*) ' '
( 1065) 
( 1066)   !   COMPUTES EQUATOR LOCATION ON GRID
( 1067)   !   ------------------------------
( 1068) 
( 1069)   XIPORE = - PRA*COS( XLAT0R )*( XLON1U-XLON0U )/PDELX
( 1070)   XJPORE = + PRA*COS( XLAT0R )*LOG(TAN( ZDCLA1 ) )/PDELY
( 1071)   XRPKSM=1.0_JPRB
( 1072)   XGGPK = PRPK
( 1073)   NYMGGI = 10
( 1074) 






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 21

( 1075)   WRITE (KULOUT,*) ' '
( 1076)   WRITE (KULOUT,*) ' EQUATOR LOCATION ON GRID IE = ',XIPORE,' JE = ',XJPORE
( 1077) 
( 1078)   !     GRID POINTS LOCATION
( 1079)   !     --------------------
( 1080) 
( 1081)   DO JLAT = KDGUN, KDGUX
( 1082) 
( 1083)     DO JLON = KDLUN, KDLUX
( 1084)       PGELAM(JLON,JLAT) = REAL(JLON-KDLUN,JPRB)*PDELX
( 1085)       PGELAT(JLON,JLAT) = REAL(JLAT-KDGUN,JPRB)*PDELY
( 1086)     ENDDO
( 1087) 
( 1088)     CALL EGGRVS (PRPI, PRA, PDELX, PDELY, KDLSUR-KDLSA+1,&
( 1089)      & 1, KDLUX-KDLUN+1, KULOUT,&
( 1090)      & PGELAM(KDLUN,JLAT), PGELAT(KDLUN,JLAT), PGM(KDLUN,JLAT),&
( 1091)      & PGNORX(KDLUN,JLAT), PGNORY(KDLUN,JLAT))  
( 1092)   ENDDO
( 1093) 
( 1094) ENDIF
( 1095) 
( 1096) !*
( 1097) !---------------------------------------------------------------------
( 1098) !     7.- INVERSE ROTATION BACK TO GEOGRAPHICAL COORDINATES
( 1099) 
( 1100) !    THIS OPERATION IS PERFORMED BY EGGRVS
( 1101) 
( 1102) !    FINAL UPDATE OF ACTUAL CORNERS USED
( 1103) 
( 1104) IF ( KSOTRP == 1 ) THEN
( 1105)   PLAT2 = PGELAT(KDLUX,KDGUX)
( 1106)   PLON2 = PGELAM(KDLUX,KDGUX)
( 1107) ENDIF
( 1108) IF ( KSOTRP == 2 ) THEN
( 1109)   PLAT1 = PGELAT(KDLUN,KDGUN)
( 1110)   PLON1 = PGELAM(KDLUN,KDGUN)
( 1111) ENDIF
( 1112) 
( 1113) !    PLON1 AND PLON2 MUST BE BETWEEN 0 AND 2*RPI
( 1114) 
( 1115) PLON1=MOD(PLON1,2*PRPI)
( 1116) PLON2=MOD(PLON2,2*PRPI)
( 1117) 
( 1118) IF ( HSUD < 0.0_JPRB ) THEN
( 1119)   IF ( KSOTRP /= 2 ) THEN
( 1120)     PLAT1 = HSUD*PLAT1
( 1121)   ENDIF
( 1122)   IF ( KSOTRP /= 1 ) THEN
( 1123)     PLAT2 = HSUD*PLAT2
( 1124)   ENDIF
( 1125)   PLAT0 = HSUD*PLAT0
( 1126) ENDIF
( 1127) 
( 1128) ! KSOTRP reset back to original value
( 1129) IF( LLPLANEX.OR.LLPLANEY )THEN
( 1130)   KSOTRP = ISOTRP
( 1131) ENDIF
( 1132) 






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 22

( 1133) WRITE (KULOUT,*) ' '
( 1134) WRITE (KULOUT,*) ' ---------- '
( 1135) WRITE (KULOUT,*) ' '
( 1136) WRITE (KULOUT,*) '  EGGX IS OVER '
( 1137) WRITE (KULOUT,*) ' '
( 1138) WRITE (KULOUT,*) ' ---------- '
( 1139) WRITE (KULOUT,*) ' '
( 1140) WRITE (KULOUT,*) ' '
( 1141) 
( 1142) !---------------------------------------------------------------------
( 1143) IF (LHOOK) CALL DR_HOOK('EGGX',1,ZHOOK_HANDLE)
( 1144) END SUBROUTINE EGGX




















































NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 23

(    1) # 1 "eggx.F90"
(    1) SUBROUTINE EGGX (PRPI, PRA, KROTEQ, PLONR, PLATR, PBETA,&
(    2)  & PLON1, PLAT1, PLON2, PLAT2, PLON0, PLAT0, PRPK, KULOUT,&
(    3)  & KSOTRP, KGIV0,&
(    4)  & PGELAM, PGELAT, PGM, PGNORX, PGNORY,&
(    5)  & KDLSA, KDLSUR, KDGSA, KDGEN, KDLUN, KDLUX, KDGUN, KDGUX,&
(    6)  & PDELX, PDELY)  
(    7) !****
(    8) !----------------------------------------------------------------------
(    9) # 10 "eggx.F90"
(   10) !     GEOGRAPHY OF GRID-POINTS
(   11) !     ARPEGE-ALADIN
(   12) !     -------------------------
(   13) # 14 "eggx.F90"
(   14) !       -------------------------------------------------------
(   15) !     PURPOSE
(   16) !     -------
(   17) !      PROVIDES THE BASIC GEOGRAPHICAL PARAMETERS OF EACH GRID-POINT
(   18) !      IN THE WINDOW OF INTERNAL+COUPLING ZONE, DEFINING THE
(   19) !      GEOGRAPHICAL DOMAIN OF INTEREST.
(   20) !      SIMULTANEOUSLY, INITIALISES THE INTERNAL GEOGRAPHICAL COMMON
(   21) !      /YEMGGCM/ FOR POSSIBLE RE-USE OF POSITION INVERSION SUBROUTINE
(   22) !      EGGRVS.
(   23) # 24 "eggx.F90"
(   24) !      THE GEOGRAPHICAL PARAMETERS ARE :
(   25) !       - GEOGRAPHIC LONGITUDE
(   26) !       - GEOGRAPHIC LATITUDE
(   27) !       - MAP FACTOR
(   28) !       - COMPONENTS OF VECTOR DIRECTED TOWARDS THE GEOGRAPHIC NORTH
(   29) !       POLE FOR PROJECTION OF VECTORS
(   30) !       - X GRID-SIZE (DISTANCE OR LONGITUDE INCREMENT)
(   31) !       - Y GRID-SIZE (DISTANCE OR LATITUDE INCREMENT)
(   32) !      THE LAST TWO DEPEND ON THE GEOMETRY. THE LATTER CAN BE
(   33) !       - SPHERICAL GEOMETRY, WITH ROTATION OF DOMAIN TO THE EQUATOR
(   34) !       - CARTESIAN GEOMETRY, WITH PROJECTION OF DOMAIN ON A PLANE
(   35) # 36 "eggx.F90"
(   36) !      ROTATION AND PROJECTION CAN BE COMBINED. HOWEVER, PROJECTIONS
(   37) !      OTHER THAN MERCATOR SHOULD BE USED WITHOUT ROTATION.
(   38) # 39 "eggx.F90"
(   39) !      EGGX CAN RUN UNDER FULL USER CONTROL OR IN MORE OR LESS
(   40) !      AUTOMATIC MODES
(   41) # 42 "eggx.F90"
(   42) !      FROM THESE BASIC PARAMETERS, OTHER CAN EASILY BE DEDUCED, SUCH
(   43) !      AS THE CORIOLIS PARAMETER, ETC.
(   44) # 45 "eggx.F90"
(   45) !      (GENERAL WARNING ABOUT AUTOMATIC MODE)
(   46) !      --------------------------------------
(   47) !       NOTE THAT AUTOMATIC MODE IS NOT SURE TO CONVERGE, AND MOREOVER,
(   48) !      IT MAY CONVERGE TOWARD A SOLUTION DIFFERENT FROM WHAT YOU EXPECTED
(   49) !      THIS IS SO IN PARTICULAR FOR A DOMAIN OVER THE POLE OR NEAR THE
(   50) !      EQUATOR. IT IS RECOMMENDED TO CHECK CAREFULLY A CHOICE OF
(   51) !      PARAMETERS BEFORE RUNNING A COMPLETE SUITE
(   52) # 53 "eggx.F90"
(   53) !      (CONVENTIONS FOR LATITUDE, LONGITUDE)
(   54) !      -------------------------------------
(   55) !       THEY ARE IN RADIANS
(   56) !       LATITUDE VARY FROM  -PI/2  (SOUTH POLE) TO  PI/2  (NORTH POLE)
(   57) !       LONGITUDE VARY FROM  0 (GREENWICH OR EQUIVALENT) TO 2*PI






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 24

(   58) !         THE CONVENTION FOR A POLE IS THAT IT HAS LONGITUDE 0
(   59) # 60 "eggx.F90"
(   60) !      (HANDLING OF PROJECTION IN SOUTHERN HEMISPHERE)
(   61) !      ------------------------------------------------
(   62) !       IT IS ASSUMED THAT DOMAINS NOT ROTATED AND ENTERELY CONTAINED
(   63) !       IN THE SOUTHERN HEMISPHERE WILL BE PROJECTED USING STEREO/LAMBERT
(   64) # 65 "eggx.F90"
(   65) !       IN THAT CASE, AND IN THAT CASE ONLY,
(   66) !         HSUD IS SET TO -1. IN THE INTERNAL COMMON
(   67) # 68 "eggx.F90"
(   68) !       THE SIGN OF LATITUDES IS CHANGED FOR ALL INTERNAL CALCULATIONS,
(   69) !       SO THAT ALL THE TRIGONOMETRY IS UNCHANGED, HOWEVER, THE RESPECTIVE
(   70) !       POSITIONS OF POLE AND GRID ARE REVERSED
(   71) # 72 "eggx.F90"
(   72) !       WHEREVER THIS DIFFERENCE MATTERS, THAT IS:
(   73) !       - MAPPING POLAR COORDINATES TO (X,Y)
(   74) !       - VECTOR ROTATION
(   75) !       ALTERNATIVE LINES OR MULTIPLICATIONS BY HSUD ARE INCLUDED
(   76) # 77 "eggx.F90"
(   77) !       THE SIGNS OF OUTGOING OR INCOMING LATITUDES ARE CHANGED AT THE LAST
(   78) !        MINUTE OR PRIOR TO ANY COMPUTATION
(   79) # 80 "eggx.F90"
(   80) !      (CONVENTIONS FOR ARRAY ORGANISATION)
(   81) !      ------------------------------------
(   82) !       THE POINT (KDLUN,KDGUN) HAS GEOGRAPHIC COORDINATES (PLON1,PLAT1)
(   83) !       THE POINT (KDLUX,KDGUX)                            (PLON2,PLAT2)
(   84) !        THE FIRST INDEX (X DIRECTION) VARIES ROUGHLY
(   85) !        WITH INCREASING LONGITUDE
(   86) !        THE SECOND INDEX (Y DIRECTION) VARIES
(   87) !        ROUGHLY WITH INCREASING LATITUDE
(   88) !        THEY ARE ACTUAL LONGITUDE, LATITUDE ONLY IN THE CASE WITHOUT PROJ.
(   89) # 90 "eggx.F90"
(   90) !     ONLY A PART OF THE ARRAYS IS INITIALIZED : THAT PART CORRESPONDING
(   91) !     TO INTERNAL + COUPLING ZONES. IT MIGHT BE NECESSARY TO COMPLETE
(   92) !     THE ARRAYS (SUCH AS GM) IN ORDER TO MAKE THEM DOUBLY-PERIODIC.
(   93) # 94 "eggx.F90"
(   94) !     ONE TYPE OF ROTATION AND THREE TYPES OF PROJECTIONS ARE RECOGNISED
(   95) # 96 "eggx.F90"
(   96) !      (CONVENTIONS FOR WIND AND OTHER VECTORS ROTATION)
(   97) !      --------------------------------------------------
(   98) !       GEOGRAPHIC U = PGNORY * U PROJ - PGNORX * V PROJ
(   99) !       GEOGRAPHIC V = PGNORX * U PROJ + PGNORY * V PROJ
(  100) # 101 "eggx.F90"
(  101) !       WHEN USING THIS TRANSFORM, DO NOT FORGET THE MAP FACTOR EFFECT
(  102) # 103 "eggx.F90"
(  103) !       THE INVERSE TRANSFORM IS EASY TO DEDUCE (IT IS A ROTATION)
(  104) # 105 "eggx.F90"
(  105) !       (OVERVIEW OF ALGORITHM)
(  106) !       -----------------------
(  107) !     PARAMETERS ARE EDITED  AND POSSIBLY CHECKED
(  108) !     THEY ARE OPTIONNALLY ROTATED
(  109) !     SOME AUTOMATIC ADJUSTMENTS OF PROJECTION PARAMETER ARE OPTIONALLY
(  110) !     PERFORMED
(  111) !     PROJECTION IS PERFORMED (OPTIONNALLY) ON THE ROTATED SPHERE
(  112) !     AT THIS STAGE, INCREMENTS OR DISTANCE ON THE MAP ARE DEDUCED
(  113) !     COMPONENTS OF ROTATION UNDER PROJECTION ARE COMPUTED
(  114) !     INVERSE ROTATION BACK TO GEOGRAPHICAL VALUES IS OPTIONNALLY DONE
(  115) !     ON THE RESULTS, COMPONENTS OF ROTATION ARE COMPOSED WITH THOSE






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 25

(  116) !     OF PROJECTION
(  117) # 118 "eggx.F90"
(  118) !     INPUT PARAMETERS
(  119) !     ----------------
(  120) !      PRPI : PI (3.14ETC AS GENERALLY DEFINED ELSEWHERE : YOMCST IN ARPEGE)
(  121) !      PRA  : A, RADIUS OF SPHERICAL PLANET (M)
(  122) !       WARNING :
(  123) !       ---------  DEPENDING ON OPTIONS, INPUT PARAMETERS MAY BECOME OUTPUT
(  124) !                  PARAMETERS. EVEN IF UNITIALISED, THE VARIABLES MUST BE
(  125) !                  DECLARE INDEPENDENTLY.
(  126) # 127 "eggx.F90"
(  127) !      KROTEQ = 0 : NO ROTATION
(  128) !             = 1 : POINT (PLONR,PLATR) IS ROTATED TO EQUATOR, THE NORTH POLE
(  129) !                   IS ON THE NEW GREENWICH MERIDIAN
(  130) # 131 "eggx.F90"
(  131) !      PLONR : GEOGRAPHIC LONGITUDE OF REFERENCE POINT OF ROTATION
(  132) !      PLATR : GEOGRAPHIC LATITUDE OF REFERENCE POINT OF ROTATION
(  133) # 134 "eggx.F90"
(  134) !      PBETA : ANGLE (IN RD) BETWEEN X-AXIS AND ROTATED LATITUDE CIRCLES
(  135) !              AT THE REFERENCE LONGITUDE
(  136) !              (USUALLY, PBETA = 0. : GIVES PURE PROJECTIONS)
(  137) # 138 "eggx.F90"
(  138) !      PLON1, PLAT1 : GEOGRAPHIC LONGITUDE, LATITUDE OF THE SOUTH-WEST
(  139) !                     CORNER OF USEFUL DOMAIN
(  140) !      PLON2, PLAT2 : GEOGRAPHIC LONGITUDE, LATITUDE OF THE NORTH-EAST
(  141) !                     CORNER OF USEFUL DOMAIN
(  142) !       IF ROTATION IS REQUIRED, (PLON1,PLAT1) IS SELF DETERMINED
(  143) !       FROM (PLONR,PLATR) AND (PLON2,PLAT2) WHEN KSOTRP = 2
(  144) !       IF PROJECTION IS REQUIRED, PLAT1 IS SEFL DETERMINED WHEN
(  145) !       KSOTRP = 2. PLON1 MUST BE GIVEN.
(  146) # 147 "eggx.F90"
(  147) !       IF ROTATION IS REQUIRED, (PLON2,PLAT2) IS SELF DETERMINED
(  148) !       FROM (PLONR,PLATR) AND (PLON1,PLAT1) WHEN KSOTRP = 1
(  149) !       IF PROJECTION IS REQUIRED, PLAT2 IS SEFL DETERMINED WHEN
(  150) !       KSOTRP = 1. PLON2 MUST BE GIVEN.
(  151) # 152 "eggx.F90"
(  152) !      PLON0 : GEOGRAPHIC LONGITUDE OF REFERENCE FOR THE PROJECTION
(  153) !              (THE VERTICAL ONE IN STEREO/LAMBERT)
(  154) !        WARNING :
(  155) !        ---------  STRANGE RESULTS MAIN OCCUR IF PLON0 IS OUT OF THE
(  156) !                   DOMAIN
(  157) !        PLON0 IS NOT REQUIRED WHEN KGIV0 =1 OR 3
(  158) !      PLAT0 : GEOGRAPHIC LATITUDE OF REFERENCE FOR THE PROJECTION
(  159) !              (WHERE M = 1)
(  160) !        PLAT0 IS NOT REQUIRED WHEN KGIV0 = 2 OR 3
(  161) !      PRPK  : PROJECTION PARAMETER AND DEFINITION
(  162) !              PRPK = 10. PROJECTION TYPE SELF DETERMINED
(  163) !                         BY MINIMIZING THE VARIATION OF THE MAP FACTOR
(  164) !              PRPK = 1.  POLAR STEREOGRAPHIC PROJECTION
(  165) !              0. < PRPK < 1.  LAMBERT CONFORMAL PROJECTION WITH
(  166) !                              CONE PARAMETER PRPK
(  167) !              PRPK = 0.  MERCATOR CONFORMAL PROJECTION
(  168) !              PRPK < 0.  NO PROJECTION
(  169) !             ON OUTPUT, PRPK CONTAINS THE EFFECTIVE PROJECTION
(  170) !             PARAMETER THAT HAS BEEN USED
(  171) !      KSOTRP : ISOTROPY PARAMETER UNDER PROJECTION
(  172) !               = 0, PLAT1, PLAT2 USED AS GIVEN. GRID SPACING ISOTROPY
(  173) !                    GENERALLY NOT AVAILABLE ( PDELX DIFFERENT FORM PDELY )






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 26

(  174) !               = 1, GRID SPACING ISOTROPIC, PLAT1 USED AS GIVEN,
(  175) !                    PLAT2 CHANGED (PLON2 SELF DETERMINED IF KROTEQ = 1)
(  176) !               = 2, GRID SPACING ISOTROPIC, PLAT2 USED AS GIVEN,
(  177) !                    PLAT1 CHANGED (PLON1 SELF DETERMINED IF KROTEQ = 1)
(  178) # 179 "eggx.F90"
(  179) !      KGIV0 : CHOICE OF REFERENCE POINT FOR PROJECTION
(  180) !               = 0, PLAT0 AND PLON0 USED AS GIVEN
(  181) !               = 1, PLAT0 REQUIRED, PLON0 SELF DETERMINED
(  182) !               = 2, PLON0 REQUIRED, PLAT0 SELF DETERMINED
(  183) !               = 3, PLAT0 AND PLON0 SELF DETERMINED
(  184) # 185 "eggx.F90"
(  185) !      KDLSA:KDLSUR : LOWER AND UPPER FIRST DIMENSIONS OF ARRAYS (X)
(  186) !      KDGSA:KDGEN  : LOWER AND UPPER SECOND DIMENSIONS OF ARRAYS (Y)
(  187) # 188 "eggx.F90"
(  188) !      KDLUN:KDLUX  : LOWER AND UPPER FIRST DIMENSIONS OF
(  189) !                     THE DOMAIN OF INTEREST, WHERE ARRAYS ARE
(  190) !                     INITIALIZED.
(  191) !      KDGUN:KDGUX  : LOWER AND UPPER SECOND DIMENSIONS OF
(  192) !                     THE DOMAIN OF INTEREST, WHERE ARRAYS ARE
(  193) !                     INITIALIZED.
(  194) !                   TOGETHER WITH THE CORNERS OF THE DOMAIN, THESE
(  195) !                   DEFINE THE GRID RESOLUTION
(  196) # 197 "eggx.F90"
(  197) !      KULOUT : UNIT OF OUTPUT FILE
(  198) # 199 "eggx.F90"
(  199) !     IMPLICIT INPUT
(  200) !     --------------
(  201) !       NONE
(  202) !       THIS IS AN ENVIRONMENT INDEPENDENT SUBROUTINE
(  203) # 204 "eggx.F90"
(  204) !     OTHER INPUT  OR EXTERNALS
(  205) !     -------------------------
(  206) !       ALL MANNER OF TRIGONOMETRIC FUNCTIONS AND LOGARITHMS
(  207) !       CALLS EGGMLT TO COMPUTE MISSING LATITUDE WHEN KSOTRP > 0
(  208) !       CALLS EGGRVS TO DEDUCE GEOGRAPHIC PARAMETERS FROM FINAL
(  209) !       PROJECTION AND ROTATION PARAMETERS.
(  210) # 211 "eggx.F90"
(  211) !       AFTER A FIRST CALL TO EGGX, ROUTINE EGGRVS CAN BE RE-CALLED
(  212) !       EXTERNALLY WITH DIFFERENT (PROJECTED OR) ROTATED POSITIONS
(  213) # 214 "eggx.F90"
(  214) !     OUTPUT PARAMETERS
(  215) !     -----------------
(  216) !       PGELAM(KDLSA:KDLSUR,KDGSA:KDGEN) :
(  217) !                          GEOGRAPHIC LONGITUDE
(  218) !       PGELAT(KDLSA:KDLSUR,KDGSA:KDGEN) :
(  219) !                          GEOGRAPHIC LATITUDE
(  220) !       PGM(KDLSA:KDLSUR,KDGSA:KDGSUR) : MAP FACTOR
(  221) !       PGNORX(KDLSA:KDLSUR,KDGSA:KDGEN) :
(  222) !              PROJECTION OF GEOGRAPHICAL NORTH UNIT VECTOR ON X AXIS
(  223) !       PGNORY(KDLSA:KDLSUR,KDGSA:KDGEN) :
(  224) !              PROJECTION OF GEOGRAPHICAL NORTH UNIT VECTOR ON Y AXIS
(  225) # 226 "eggx.F90"
(  226) !       PDELX : GRID SIZE IN M ALONG X IF PROJECTION
(  227) !               LONGITUDE INCREMENT IN RD IF SPHERICAL GEOMETRY
(  228) !               NECESSARY TO COMPUTE PERIOD AND DERIVATIVES
(  229) !       PDELY : GRID SIZE IN M ALONG Y IF PROJECTION
(  230) !               LATITUDE INCREMENT IN RD IF SPEHRICAL GEOMETRY
(  231) # 232 "eggx.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 27

(  232) !     WRITTEN BY
(  233) !     ---------- ALAIN JOLY
(  234) # 235 "eggx.F90"
(  235) !     NEW NORTHERN HEMISPHERE VERSION : 27/2/92
(  236) !     SOUTHERN HEM ISPHERE VERSION : 27/1/93
(  237) # 238 "eggx.F90"
(  238) !---------------------------------------------------------------------
(  239) # 240 "eggx.F90"
(  240) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  241) USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  242) # 243 "eggx.F90"
(  243) USE YEMGGCM  , ONLY : NYMGGI   ,NYMGGR   ,NYMGGWH  ,XLATR    ,&
(  244)  & XLONR    ,XGGPK    ,XRPKSM   ,XLAT0R   ,XLON0R   ,&
(  245)  & XLON0U   ,XIPORE   ,XJPORE   ,XGGM0    ,XLON1R   ,&
(  246)  & XLON1U   ,XLAT1R   ,XLON2R   ,HSUD     ,XBETA  
(  247) # 248 "eggx.F90"
(  248) !---------------------------------------------------------------------
(  249) # 250 "eggx.F90"
(  250) IMPLICIT NONE
(  251) # 252 "eggx.F90"
(  252) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLSA 
(  253) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLSUR 
(  254) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGSA 
(  255) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGEN 
(  256) REAL(KIND=JPRB)   ,INTENT(IN)    :: PRPI
(  257) REAL(KIND=JPRB)   ,INTENT(IN)    :: PRA
(  258) INTEGER(KIND=JPIM),INTENT(IN)    :: KROTEQ 
(  259) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLONR 
(  260) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLATR 
(  261) REAL(KIND=JPRB)   ,INTENT(IN)    :: PBETA 
(  262) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLON1 
(  263) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAT1 
(  264) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLON2 
(  265) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAT2 
(  266) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLON0 
(  267) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAT0 
(  268) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PRPK
(  269) INTEGER(KIND=JPIM),INTENT(IN)    :: KULOUT
(  270) INTEGER(KIND=JPIM),INTENT(INOUT) :: KSOTRP
(  271) INTEGER(KIND=JPIM),INTENT(IN)    :: KGIV0 
(  272) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGELAM(KDLSA:KDLSUR,KDGSA:KDGEN)
(  273) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGELAT(KDLSA:KDLSUR,KDGSA:KDGEN)
(  274) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGM(KDLSA:KDLSUR,KDGSA:KDGEN)
(  275) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGNORX(KDLSA:KDLSUR,KDGSA:KDGEN)
(  276) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGNORY(KDLSA:KDLSUR,KDGSA:KDGEN)
(  277) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLUN
(  278) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLUX
(  279) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUN
(  280) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUX
(  281) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDELX
(  282) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PDELY
(  283) # 284 "eggx.F90"
(  284) !---------------------------------------------------------------------
(  285) # 286 "eggx.F90"
(  286) INTEGER(KIND=JPIM) :: INBESS, INNEGA, ISPECA, ITERK, ITERKX, JLAT, JLON
(  287) INTEGER(KIND=JPIM) :: ISOTRP
(  288) # 289 "eggx.F90"
(  289) LOGICAL :: LLGWH, LL510, LL520






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 28

(  290) LOGICAL :: LLPLANEX
(  291) LOGICAL :: LLPLANEY
(  292) # 293 "eggx.F90"
(  293) REAL(KIND=JPRB) :: ZCONDEG, ZCONRAD, ZCOSA, ZCOSO, ZDCLA0, ZDCLA1,&
(  294)  & ZDCLA2, ZDLON, ZDM, ZDMMAX, ZDMMIN, ZDRK, &
(  295)  & ZDTLAT, ZFACE, ZIPV, ZJPV, ZLAT, ZLAT2R, &
(  296)  & ZLATLIM, ZLON, ZLON2U, ZPIS2, ZPIS4, ZRKAX, &
(  297)  & ZRKI, ZRKII, ZRKIN, ZRKOLD, ZRKT, ZRPK, ZSECAN, &
(  298)  & ZSECUR, ZSINA, ZSINO, ZUSKP  
(  299) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  300) # 301 "eggx.F90"
(  301) !---------------------------------------------------------------------
(  302) # 303 "eggx.F90"
(  303) # 1 ".D[61]/eggmlt.h"
(    1) INTERFACE
(    2) SUBROUTINE EGGMLT (PRPI, KDLUX, KDLUN, KDGUX, KDGUN, KULOUT,&
(    3)  & KPRINT, PRPK, PLON0U, PLON1U, PLON2U, KSOTRP, PLAT1R, PLAT2R,&
(    4)  & PHSUD,PBETA)  
(    5) # 6 ".D[61]/eggmlt.h"
(    6) !--------------------------------------------------------------------------
(    7) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(    8) !--------------------------------------------------------------------------
(    9) IMPLICIT NONE
(   10) REAL(KIND=JPRB)   ,INTENT(IN)    :: PRPI 
(   11) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLUX 
(   12) INTEGER(KIND=JPIM),INTENT(IN)    :: KDLUN 
(   13) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUX 
(   14) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUN 
(   15) INTEGER(KIND=JPIM),INTENT(IN)    :: KULOUT 
(   16) INTEGER(KIND=JPIM),INTENT(IN)    :: KPRINT 
(   17) REAL(KIND=JPRB)   ,INTENT(IN)    :: PRPK 
(   18) REAL(KIND=JPRB)   ,INTENT(IN)    :: PLON0U 
(   19) REAL(KIND=JPRB)   ,INTENT(IN)    :: PLON1U 
(   20) REAL(KIND=JPRB)   ,INTENT(IN)    :: PLON2U 
(   21) INTEGER(KIND=JPIM),INTENT(IN)    :: KSOTRP 
(   22) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAT1R 
(   23) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLAT2R 
(   24) REAL(KIND=JPRB)   ,INTENT(IN)    :: PHSUD 
(   25) REAL(KIND=JPRB)   ,INTENT(IN)    :: PBETA 
(   26) !--------------------------------------------------------------------------
(   27) END SUBROUTINE EGGMLT
(   28) END INTERFACE
(   29) # 304 "eggx.F90"
(  304) # 304 "eggx.F90"
(  304) # 1 ".D[61]/eggrvs.h"
(    1) INTERFACE
(    2) SUBROUTINE EGGRVS (PRPI, PRA, PDELX, PDELY, KPROF,&
(    3)  & KBEG, KEND, KULOUT, PGELAM, PGELAT, PGM, PGNORX, PGNORY)  
(    4) !---------------------------------------------------------------------
(    5) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(    6) !-------------------------------------------------------------------
(    7) IMPLICIT NONE
(    8) INTEGER(KIND=JPIM),INTENT(IN)    :: KPROF 
(    9) REAL(KIND=JPRB)   ,INTENT(IN)    :: PRPI 
(   10) REAL(KIND=JPRB)   ,INTENT(IN)    :: PRA 
(   11) REAL(KIND=JPRB)   ,INTENT(IN)    :: PDELX 
(   12) REAL(KIND=JPRB)   ,INTENT(IN)    :: PDELY 
(   13) INTEGER(KIND=JPIM),INTENT(IN)    :: KBEG 






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 29

(   14) INTEGER(KIND=JPIM),INTENT(IN)    :: KEND 
(   15) INTEGER(KIND=JPIM),INTENT(IN)    :: KULOUT 
(   16) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGELAM(KPROF) 
(   17) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PGELAT(KPROF) 
(   18) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGM(KPROF) 
(   19) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGNORX(KPROF) 
(   20) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PGNORY(KPROF) 
(   21) !-------------------------------------------------------------------
(   22) END SUBROUTINE EGGRVS
(   23) END INTERFACE
(   24) # 305 "eggx.F90"
(  305) # 306 "eggx.F90"
(  306) # 1 ".D[61]/abor1.intfb.h"
(    1) INTERFACE
(    2) # 3 ".D[61]/abor1.intfb.h"
(    3) SUBROUTINE ABOR1(CDTEXT)
(    4) CHARACTER(LEN=*), INTENT(IN) :: CDTEXT
(    5) END SUBROUTINE ABOR1
(    6) # 7 ".D[61]/abor1.intfb.h"
(    7) SUBROUTINE ABOR1FL(CDFILE, KLINENUM, CDTEXT)
(    8) USE PARKIND1  ,ONLY : JPIM
(    9) CHARACTER(LEN=*), INTENT(IN) :: CDFILE,CDTEXT
(   10) INTEGER(KIND=JPIM), INTENT(IN) :: KLINENUM
(   11) END SUBROUTINE ABOR1FL
(   12) # 13 ".D[61]/abor1.intfb.h"
(   13) SUBROUTINE ABOR1_EXCEPTION_HANDLER()
(   14) END SUBROUTINE ABOR1_EXCEPTION_HANDLER
(   15) # 16 ".D[61]/abor1.intfb.h"
(   16) END INTERFACE
(   17) # 307 "eggx.F90"
(  307) # 308 "eggx.F90"
(  308) !---------------------------------------------------------------------
(  309) IF (LHOOK) CALL DR_HOOK('EGGX',0,ZHOOK_HANDLE)
(  310) !---------------------------------------------------------------------
(  311) # 312 "eggx.F90"
(  312) ZPIS2 = PRPI*0.5_JPRB
(  313) ZPIS4 = PRPI*0.25_JPRB
(  314) ZSECUR = 1.E-12_JPRB
(  315) ZSECAN = 1.E-05_JPRB
(  316) # 317 "eggx.F90"
(  317) !*
(  318) !---------------------------------------------------------------------
(  319) !     1.- PRINTING INPUT PARAMETERS
(  320) ZCONRAD = PRPI/180._JPRB
(  321) ZCONDEG = 180._JPRB/PRPI
(  322) # 323 "eggx.F90"
(  323) WRITE (KULOUT,*) ' '
(  324) WRITE (KULOUT,*) ' ---------------------------------- '
(  325) WRITE (KULOUT,*) ' '
(  326) WRITE (KULOUT,*) '      ARPEGE-ALADIN '
(  327) WRITE (KULOUT,*) ' '
(  328) WRITE (KULOUT,*) '    GEOGRAPHY OF GRID-POINTS '
(  329) WRITE (KULOUT,*) ' '
(  330) WRITE (KULOUT,*) ' ---------------------------------- '
(  331) WRITE (KULOUT,*) ' '
(  332) WRITE (KULOUT,*) ' INPUT PARAMETERS '
(  333) WRITE (KULOUT,*) ' '
(  334) WRITE (KULOUT,*) ' PI = ',PRPI






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 30

(  335) WRITE (KULOUT,*) ' RADIUS OF PLANET A = ',PRA*1.E-03_JPRB,' KM '
(  336) WRITE (KULOUT,*) ' '
(  337) WRITE (KULOUT,*) ' X-SIZE OF ARRAYS ',KDLSUR-KDLSA+1
(  338) WRITE (KULOUT,*) ' Y-SIZE OF ARRAYS ',KDGEN-KDGSA+1
(  339) WRITE (KULOUT,*) ' '
(  340) WRITE (KULOUT,*) ' X WINDOW KDLUN = ',KDLUN,' KDLUX = ',KDLUX
(  341) WRITE (KULOUT,*) '          SIZE = ',KDLUX-KDLUN+1
(  342) WRITE (KULOUT,*) ' Y WINDOW KDGUN = ',KDGUN,' KDGUX = ',KDGUX
(  343) WRITE (KULOUT,*) '          SIZE = ',KDGUX-KDGUN+1
(  344) WRITE (KULOUT,*) ' '
(  345) WRITE (KULOUT,*) ' ROTATION PARAMETER KROTEQ = ',KROTEQ
(  346) WRITE (KULOUT,*) '          PLONR = ',PLONR
(  347) WRITE (KULOUT,*) '          PLATR = ',PLATR
(  348) WRITE (KULOUT,*) ' '
(  349) WRITE (KULOUT,*) ' ANGLE WITH X/LATITUDE AT PLON0 = ',PBETA
(  350) WRITE (KULOUT,*) ' '
(  351) WRITE (KULOUT,*) ' SW CORNER      PLON1 = ',PLON1
(  352) WRITE (KULOUT,*) '                PLAT1 = ',PLAT1
(  353) WRITE (KULOUT,*) ' '
(  354) WRITE (KULOUT,*) ' NE CORNER      PLON2 = ',PLON2
(  355) WRITE (KULOUT,*) '                PLAT2 = ',PLAT2
(  356) WRITE (KULOUT,*) ' '
(  357) WRITE (KULOUT,*) ' PROJECTION PARAMETER PRPK = ',PRPK
(  358) WRITE (KULOUT,*) ' REF POINT      PLON0 = ',PLON0
(  359) WRITE (KULOUT,*) '                PLAT0 = ',PLAT0
(  360) WRITE (KULOUT,*) ' '
(  361) WRITE (KULOUT,*) ' ISOTROPY PARAMETER KSOTRP = ',KSOTRP
(  362) WRITE (KULOUT,*) ' '
(  363) WRITE (KULOUT,*) ' PROJECTION REF POINT KGIV0 = ',KGIV0
(  364) WRITE (KULOUT,*) ' '
(  365) WRITE (KULOUT,*) ' ---------------------------------- '
(  366) WRITE (KULOUT,*) ' '
(  367) # 368 "eggx.F90"
(  368) !* have a look whether we calculate plane model version
(  369) LLPLANEX = KDLUN == KDLUX
(  370) LLPLANEY = KDGUN == KDGUX
(  371) # 372 "eggx.F90"
(  372) IF( LLPLANEX.OR.LLPLANEY )THEN
(  373)   ISOTRP = KSOTRP
(  374)   KSOTRP = 0
(  375)   WRITE (KULOUT,*) '!'
(  376)   WRITE (KULOUT,*) 'YOU RUN PLANE MODEL'
(  377)   WRITE (KULOUT,*) 'KSOTRP LOCALLY RESET TO 0 (ISOTROPIC PARAMETER) '
(  378)   WRITE (KULOUT,*) 'ISOTROPY PARAMETER KSOTRP = ',KSOTRP
(  379)   WRITE (KULOUT,*) '!'
(  380) ENDIF
(  381) # 382 "eggx.F90"
(  382) !     SECURITY CORRECTIONS
(  383) IF ( KROTEQ == 0 ) THEN
(  384)   PLONR = 0.0_JPRB
(  385)   PLATR = 0.0_JPRB
(  386) ENDIF
(  387) IF ( PRPK < 0.0_JPRB ) THEN
(  388)   PLON0 = PLONR
(  389)   PLAT0 = PLATR
(  390) ENDIF
(  391) !     CHECK LONGITUDES
(  392) IF ( KROTEQ == 1 ) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 31

(  393)   IF ( PLONR < 0.0_JPRB ) THEN
(  394)     PLONR = PLONR + 2.0_JPRB*PRPI
(  395)     WRITE (KULOUT,*) ' *** EGGX ERROR *** WRONG CONVENTION',&
(  396)      & ' USED FOR LONGITUDES '  
(  397)     WRITE (KULOUT,*) ' *** NEW PLONR = ',PLONR
(  398)   ENDIF
(  399) ENDIF
(  400) IF ( PLON1 < 0.0_JPRB ) THEN
(  401)   PLON1 = PLON1 + 2.0_JPRB*PRPI
(  402)   WRITE (KULOUT,*) ' *** EGGX ERROR *** WRONG CONVENTION',&
(  403)    & ' USED FOR LONGITUDES '  
(  404)   WRITE (KULOUT,*) ' *** NEW PLON1 = ',PLON1
(  405) ENDIF
(  406) IF ( PLON2 < 0.0_JPRB ) THEN
(  407)   PLON2 = PLON2 + 2.0_JPRB*PRPI
(  408)   WRITE (KULOUT,*) ' *** EGGX ERROR *** WRONG CONVENTION',&
(  409)    & ' USED FOR LONGITUDES '  
(  410)   WRITE (KULOUT,*) ' *** NEW PLON2 = ',PLON2
(  411) ENDIF
(  412) IF ( KGIV0 == 0.OR. KGIV0 == 2 ) THEN
(  413)   IF ( PLON0 < 0.0_JPRB ) THEN
(  414)     PLON0 = PLON0 + 2.0_JPRB*PRPI
(  415)     WRITE (KULOUT,*) ' *** EGGX ERROR *** WRONG CONVENTION',&
(  416)      & ' USED FOR LONGITUDES '  
(  417)     WRITE (KULOUT,*) ' *** NEW PLON0 = ',PLON0
(  418)   ENDIF
(  419) ENDIF
(  420) # 421 "eggx.F90"
(  421) NYMGGR = KROTEQ
(  422) XLATR = PLATR
(  423) XLONR = PLONR
(  424) XBETA = PBETA
(  425) !*
(  426) !--------------------------------------------------------------------
(  427) !     2.- ROTATION TO EQUATOR
(  428) # 429 "eggx.F90"
(  429) HSUD = 1.0_JPRB
(  430) IF ( KROTEQ == 0 ) THEN
(  431)   ! SOUTH HEMISPHERE DETECTION
(  432)   IF ( PRPK == 10._JPRB .OR. (PRPK > 0.0_JPRB .AND. PRPK <= 1.0_JPRB) ) THEN
(  433)     ! WHEN PROJECTION IS UNKNOWN, IF ONE OF THE REQUESTED LATITUDE IS
(  434)     ! NEGATIVE, A GUESS FOR THE OTHER MUST BE PROVIDED : SO BOTH PLAT1
(  435)     ! AND PLAT2 ARE ASSUMED KNOWN
(  436)     IF ( KSOTRP == 0 ) THEN
(  437)       IF ( PLAT1 < 0.0_JPRB .AND. PLAT2 < 0.0_JPRB ) THEN
(  438)         HSUD = -1.0_JPRB
(  439)         PLAT1 = ABS(PLAT1)
(  440)         PLAT2 = ABS(PLAT2)
(  441)       ENDIF
(  442)     ELSEIF (KSOTRP == 1 ) THEN
(  443)       IF ( PLAT1 < 0.0_JPRB ) THEN
(  444)         IF ( ZPIS2 >= PLAT2.AND. PLAT2 >= -ZPIS2 ) THEN
(  445)           IF ( PLAT2 < 0.0_JPRB ) THEN
(  446)             HSUD = -1.0_JPRB
(  447)             PLAT1 = ABS(PLAT1)
(  448)             PLAT2 = ABS(PLAT2)
(  449)           ELSEIF ( PRPK == 10._JPRB .AND. PLAT2 >= 0.0_JPRB ) THEN
(  450)             PRPK = 0.0_JPRB






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 32

(  451)           ELSE
(  452)             WRITE (KULOUT,*) ' *** EGGX WARNING *** ',&
(  453)              & ' YOU SHOULD USE MERCATOR PROJECTION '  
(  454)           ENDIF
(  455)         ELSEIF ( PRPK /= 10._JPRB ) THEN
(  456)           HSUD = -1.0_JPRB
(  457)           PLAT1 = ABS(PLAT1)
(  458)         ELSE
(  459)           WRITE (KULOUT,*) ' *** EGGX ERROR *** ',&
(  460)            & ' REFERENCE POLE (HSUD) CANNOT BE DECIDED '  
(  461)           WRITE (KULOUT,*) ' RERUN WITH A REASONABLE GUESS ',' FOR PLAT2 '
(  462)           CALL ABOR1(' EGGX: abor1 2.1')
(  463)         ENDIF
(  464)       ENDIF
(  465) # 466 "eggx.F90"
(  466)     ELSEIF ( KSOTRP == 2 ) THEN
(  467)       IF ( PLAT2 < 0.0_JPRB ) THEN
(  468)         IF ( ZPIS2 >= PLAT1.AND. PLAT1 >= -ZPIS2 ) THEN
(  469)           IF ( PLAT1 < 0.0_JPRB ) THEN
(  470)             HSUD = -1.0_JPRB
(  471)             PLAT1 = ABS(PLAT1)
(  472)             PLAT2 = ABS(PLAT2)
(  473)           ELSEIF ( PLAT1 >= 0.0_JPRB ) THEN
(  474)             WRITE (KULOUT,*) ' *** EGGX ERROR *** ',&
(  475)              & ' PLAT1 CANNOT BE GREATER THAN PLAT2 '  
(  476)             WRITE (KULOUT,*) ' RERUN WITH A REASONABLE GUESS ',' FOR PLAT1 '
(  477)             CALL ABOR1(' EGGX: abor1 2.2')
(  478)           ENDIF
(  479)         ELSEIF ( PRPK /= 10._JPRB ) THEN
(  480)           HSUD = -1.0_JPRB
(  481)           PLAT2 = ABS(PLAT2)
(  482)         ELSE
(  483)           WRITE (KULOUT,*) ' *** EGGX ERROR *** ',&
(  484)            & ' REFERENCE POLE (HSUD) CANNOT BE DECIDED '  
(  485)           WRITE (KULOUT,*) ' RERUN WITH A REASONABLE GUESS ',' FOR PLAT1 '
(  486)           CALL ABOR1(' EGGX: abor1 2.3')
(  487)         ENDIF
(  488)       ENDIF
(  489)     ENDIF
(  490) # 491 "eggx.F90"
(  491)   ENDIF
(  492) # 493 "eggx.F90"
(  493)   IF ( HSUD < 0.0_JPRB ) THEN
(  494)     PLAT0 = ABS( PLAT0 )
(  495)   ENDIF
(  496) # 497 "eggx.F90"
(  497)   ! NO ROTATION
(  498)   XLON1R =MOD(PLON1,2.0_JPRB*PRPI)
(  499)   IF ( KSOTRP /= 2 ) XLAT1R = PLAT1
(  500)   XLON2R = MOD(PLON2,2.0_JPRB*PRPI)
(  501)   IF ( KSOTRP /= 1 ) ZLAT2R = PLAT2
(  502)   IF ( KGIV0 == 0.OR. KGIV0 == 2 ) XLON0R = PLON0
(  503)   IF ( KGIV0 == 0.OR. KGIV0 == 1 ) XLAT0R = PLAT0
(  504) # 505 "eggx.F90"
(  505) ELSE
(  506)   ! ROTATION
(  507)   IF ( KSOTRP == 0.OR. KSOTRP == 1 ) THEN
(  508)     ! ROTATION OF SW CORNER






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 33

(  509)     ! ----------------------
(  510)     ZSINA = COS( PLATR )*SIN( PLAT1 )&
(  511)      & - SIN( PLATR )*COS( PLAT1 )*COS( PLON1-PLONR )  
(  512)     XLAT1R = ASIN( ZSINA )
(  513)     IF ( ABS( XLAT1R ) >= ZPIS2 ) THEN
(  514)       XLON1R = 0.0_JPRB
(  515)     ELSE
(  516)       ZCOSA = COS( XLAT1R )
(  517)       ZCOSO = ( SIN( PLATR )*SIN( PLAT1 ) +&
(  518)        & COS( PLATR )*COS( PLAT1 )*COS( PLON1-PLONR ) )/ZCOSA  
(  519)       ZCOSO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZCOSO))
(  520)       ZSINO = ( COS( PLAT1 )*SIN( PLON1-PLONR ) )/ZCOSA
(  521)       ZSINO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZSINO))
(  522)       XLON1R = ACOS( ZCOSO )
(  523)       IF ( ASIN( ZSINO ) < 0.0_JPRB ) XLON1R = 2.0_JPRB*PRPI - XLON1R
(  524)     ENDIF
(  525)   ENDIF
(  526) # 527 "eggx.F90"
(  527)   IF ( KSOTRP == 0.OR. KSOTRP == 2 ) THEN
(  528)     ! ROTATION OF NE CORNER
(  529)     ! ----------------------
(  530)     ZSINA = COS( PLATR )*SIN( PLAT2 )&
(  531)      & - SIN( PLATR )*COS( PLAT2 )*COS( PLON2-PLONR )  
(  532)     ZLAT2R = ASIN( ZSINA )
(  533)     IF ( ABS( ZLAT2R ) >= ZPIS2 ) THEN
(  534)       XLON2R = 0.0_JPRB
(  535)     ELSE
(  536)       ZCOSA = COS( ZLAT2R )
(  537)       ZCOSO = ( SIN( PLATR )*SIN( PLAT2 ) +&
(  538)        & COS( PLATR )*COS( PLAT2 )*COS( PLON2-PLONR ) )/ZCOSA  
(  539)       ZCOSO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZCOSO))
(  540)       ZSINO = ( COS( PLAT2 )*SIN( PLON2-PLONR ) )/ZCOSA
(  541)       ZSINO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZSINO))
(  542)       XLON2R = ACOS( ZCOSO )
(  543)       IF ( ASIN( ZSINO ) < 0.0_JPRB ) XLON2R = 2.0_JPRB*PRPI - XLON2R
(  544)     ENDIF
(  545)   ENDIF
(  546) # 547 "eggx.F90"
(  547)   !     ROTATION OF PROJECTION REFERENCE POINT
(  548)   !     --------------------------------------
(  549)   IF ( KGIV0 == 2 ) THEN
(  550)     WRITE (KULOUT,*) ' *** EGGX ERROR '
(  551)     WRITE (KULOUT,*) ' KGIV0 = 2 IMPOSSIBLE WITH KROTEQ = 1 '
(  552)     CALL ABOR1(' EGGX: abor1 2.4')
(  553)   ENDIF
(  554)   IF ( KGIV0 == 0.OR. KGIV0 == 1 ) THEN
(  555)     ZSINA = COS( PLATR )*SIN( PLAT0 )&
(  556)      & - SIN( PLATR )*COS( PLAT0 )*COS( PLON0-PLONR )  
(  557)     XLAT0R = ASIN( ZSINA )
(  558)   ENDIF
(  559)   IF ( KGIV0 == 0 ) THEN
(  560)     IF ( ABS( XLAT0R ) >= ZPIS2 ) THEN
(  561)       XLON0R = 0.0_JPRB
(  562)     ELSE
(  563)       ZCOSA = MAX( COS( XLAT0R ) , ZSECUR )
(  564)       ZCOSO = ( SIN( PLATR )*SIN( PLAT0 ) +&
(  565)        & COS( PLATR )*COS( PLAT0 )*COS( PLON0-PLONR ) )/ZCOSA  
(  566)       ZCOSO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZCOSO))






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 34

(  567)       ZSINO = ( COS( PLAT0 )*SIN( PLON0-PLONR ) )/ZCOSA
(  568)       ZSINO = MIN(1.0_JPRB,MAX(-1.0_JPRB,ZSINO))
(  569)       XLON0R = ACOS( ZCOSO )
(  570)       IF ( ASIN( ZSINO ) < 0.0_JPRB ) XLON0R = 2.0_JPRB*PRPI - XLON0R
(  571)     ENDIF
(  572)   ENDIF
(  573) ENDIF
(  574) # 575 "eggx.F90"
(  575) IF ( KROTEQ /= 0 ) THEN
(  576)   IF ( PRPK > 0.0_JPRB ) THEN
(  577)     WRITE (KULOUT,*) ' *** EGGX WARNING ',&
(  578)      & ' USE OF ROTATION + NON-MERCATOR PROJECTION WILL LEAD ',&
(  579)      & ' TO UNPREDICTABLE RESULTS, ESP. IN SOUTH HEMISPHERE '  
(  580)     IF ( XLAT1R < 0.0_JPRB .AND. ZLAT2R < 0.0_JPRB ) THEN
(  581)       HSUD = -1.0_JPRB
(  582)       XLAT1R = ABS( XLAT1R )
(  583)       ZLAT2R = ABS( ZLAT2R )
(  584)       XLAT0R = ABS( XLAT0R )
(  585)     ENDIF
(  586)   ENDIF
(  587) ENDIF
(  588) # 589 "eggx.F90"
(  589) WRITE (KULOUT,*) ' '
(  590) WRITE (KULOUT,*) ' HEMISPHERE INDICATOR HSUD = ',HSUD
(  591) WRITE (KULOUT,*) ' '
(  592) WRITE (KULOUT,*) ' ROTATED COORDINATES '
(  593) WRITE (KULOUT,*) ' SW CORNER      XLON1R = ',XLON1R
(  594) WRITE (KULOUT,*) '                XLAT1R = ',XLAT1R
(  595) WRITE (KULOUT,*) ' '
(  596) WRITE (KULOUT,*) ' NE CORNER      XLON2R = ',XLON2R
(  597) WRITE (KULOUT,*) '                ZLAT2R = ',ZLAT2R
(  598) WRITE (KULOUT,*) ' '
(  599) WRITE (KULOUT,*) ' REF POINT      XLON0R = ',XLON0R
(  600) WRITE (KULOUT,*) '                XLAT0R = ',XLAT0R
(  601) WRITE (KULOUT,*) ' '
(  602) # 603 "eggx.F90"
(  603) !*
(  604) !--------------------------------------------------------------------
(  605) !     3.- SPHERICAL GEOMETRY
(  606) # 607 "eggx.F90"
(  607) IF ( PRPK < 0.0_JPRB ) THEN
(  608) # 609 "eggx.F90"
(  609)   !   THE GRID IS MADE UP OF REGULARLY SPACED POINTS IN LONGITUDE (X)
(  610)   !   AND LATITUDE (Y) CORRDINATES
(  611) # 612 "eggx.F90"
(  612)   !   PDELX AND PDELY ARE NON DIMENSIONNAL IN THAT CASE
(  613) # 614 "eggx.F90"
(  614)   IF ( KSOTRP == 0 ) THEN
(  615)     XLON1U = XLON1R
(  616)     ZLON2U = XLON2R
(  617)     IF ( ZLON2U < XLON1U ) ZLON2U = 2.0_JPRB*PRPI + ZLON2U
(  618)   ENDIF
(  619)   !   DEFINES OTHER CORNER
(  620)   IF ( KSOTRP == 1 ) THEN
(  621)     XLON1U = XLON1R
(  622)     ZLAT2R = - XLAT1R
(  623)     ZLON2U = XLON1U + ( ZLAT2R-XLAT1R )*&
(  624)      & REAL(KDLUX-KDLUN,JPRB)/REAL(KDGUX-KDGUN,JPRB)  






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 35

(  625)     XLON2R = ZLON2U
(  626)     IF ( ZLON2U >= 2.0_JPRB*PRPI ) XLON2R = ZLON2U - 2.0_JPRB*PRPI
(  627)   ENDIF
(  628)   IF ( KSOTRP == 2 ) THEN
(  629)     ZLON2U = XLON2R
(  630)     XLAT1R = - ZLAT2R
(  631)     XLON1U = ZLON2U - ( ZLAT2R-XLAT1R )*&
(  632)      & REAL(KDLUX-KDLUN,JPRB)/REAL(KDGUX-KDGUN,JPRB)  
(  633)     XLON1R = XLON1U
(  634)     IF ( XLON1U >= 2.0_JPRB*PRPI ) XLON1R = XLON1U - 2.0_JPRB*PRPI
(  635)   ENDIF
(  636) # 637 "eggx.F90"
(  637)   IF( .NOT.LLPLANEX.AND..NOT.LLPLANEY )THEN
(  638)     PDELX = ( ZLON2U-XLON1U )/REAL( KDLUX-KDLUN ,JPRB)
(  639)     PDELY = ( ZLAT2R-XLAT1R )/REAL( KDGUX-KDGUN ,JPRB)
(  640)   ELSEIF( LLPLANEX )THEN
(  641)     PDELY = ( ZLAT2R-XLAT1R )/REAL( KDGUX-KDGUN )
(  642)     PDELX = PDELY
(  643)   ELSEIF( LLPLANEY )THEN
(  644)     PDELX = ( ZLON2U-XLON1U )/REAL( KDLUX-KDLUN )
(  645)     PDELY = PDELX
(  646)   ENDIF
(  647) # 648 "eggx.F90"
(  648)   XIPORE=0.0_JPRB
(  649)   XJPORE=0.0_JPRB
(  650)   XRPKSM=PRPK
(  651)   XGGPK = PRPK
(  652)   NYMGGI = 10
(  653) # 654 "eggx.F90"
(  654)   DO JLAT = KDGUN, KDGUX
(  655)     ZLAT = REAL(JLAT-KDGUN,JPRB)*PDELY
(  656) # 657 "eggx.F90"
(  657)     DO JLON = KDLUN, KDLUX
(  658)       ZLON = REAL(JLON-KDLUN,JPRB)*PDELX
(  659)       PGELAM(JLON,JLAT) = ZLON
(  660)       PGELAT(JLON,JLAT) = ZLAT
(  661)     ENDDO
(  662) # 663 "eggx.F90"
(  663)     CALL EGGRVS (PRPI, PRA, PDELX, PDELY, KDLSUR-KDLSA+1,&
(  664)      & 1, KDLUX-KDLUN+1, KULOUT,&
(  665)      & PGELAM(KDLUN,JLAT), PGELAT(KDLUN,JLAT), PGM(KDLUN,JLAT),&
(  666)      & PGNORX(KDLUN,JLAT), PGNORY(KDLUN,JLAT))  
(  667)   ENDDO
(  668) ENDIF
(  669) # 670 "eggx.F90"
(  670) !*
(  671) !--------------------------------------------------------------------
(  672) !     4.- MAP FACTOR ON SPHERICAL GEOMETRY
(  673) # 674 "eggx.F90"
(  674) !*
(  675) !--------------------------------------------------------------------
(  676) !     5.- PREPARATION OF PROJECTION PARAMETERS
(  677) # 678 "eggx.F90"
(  678) IF ( PRPK >= 0.0_JPRB ) THEN
(  679) # 680 "eggx.F90"
(  680)   !   PROJECTION LONGITUDES ARE ALWAYS KNOWN
(  681) # 682 "eggx.F90"
(  682)   !   SPECIAL LOGICAL TRUE WHEN DOMAIN ASTRIDE GREENWICH MERIDIAN






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 36

(  683)   !    LLGWH = .F. : GREENWICH OUT OF DOMAIN
(  684)   !    LLGWH = .T. : GREENWICH WITHIN DOMAIN
(  685)   LLGWH = ( XLON2R < XLON1R )
(  686)   NYMGGWH = 0
(  687)   IF ( LLGWH ) NYMGGWH = 1
(  688)   !   SHIFT LONGITUDES WHEN GREENWICH MERIDIAN IS WITHIN THE DOMAIN
(  689)   XLON1U = XLON1R
(  690)   ZLON2U = XLON2R
(  691)   IF ( LLGWH ) THEN
(  692)     ZLON2U = XLON2R + 2.0_JPRB*PRPI
(  693)   ENDIF
(  694) # 695 "eggx.F90"
(  695)   IF ( KGIV0 == 1.OR. KGIV0 == 3 ) THEN
(  696)     IF ( ABS(ABS(ZLON2U-XLON1U)-PRPI) > ZSECAN ) THEN
(  697)       WRITE (KULOUT,*) ' NORMAL LONGITUDE DIFFERENCE '
(  698)       XLON0U = 0.5_JPRB*( XLON1U + ZLON2U )
(  699)       XLON0R = XLON0U
(  700)     ELSE
(  701)       WRITE (KULOUT,*) ' LONGITUDE DIFFERENCE = PI '
(  702)       XLON0U = XLON1U + ZPIS4
(  703)       XLON0R = XLON0U
(  704)     ENDIF
(  705)     IF ( XLON0U >= 2.0_JPRB*PRPI ) XLON0R = XLON0R - 2.0_JPRB*PRPI
(  706)     WRITE (KULOUT,*) ' '
(  707)     WRITE (KULOUT,*) ' PROJECTION REFERENCE LONGITUDE '
(  708)     WRITE (KULOUT,*) ' (ON ROTATED SPHERE) LON0R = ',XLON0R
(  709)     WRITE (KULOUT,*) ' GREENWICH LOGICAL = ',LLGWH
(  710)     WRITE (KULOUT,*) ' '
(  711)   ENDIF
(  712) # 713 "eggx.F90"
(  713)   XLON0U = XLON0R
(  714)   IF ( LLGWH .AND. XLON0R < XLON1R ) THEN
(  715)     XLON0U = XLON0R + 2.0_JPRB*PRPI
(  716)   ENDIF
(  717) # 718 "eggx.F90"
(  718)   !   PROJECTION TYPE IS GIVEN BY THE USER
(  719)   !   ------------------------------------
(  720) # 721 "eggx.F90"
(  721)   IF ( PRPK <= 1.0_JPRB ) THEN
(  722) # 723 "eggx.F90"
(  723)     ! DETERMINES MISSING LATITUDE IF ANY
(  724)     IF ( KSOTRP >= 1 ) THEN
(  725) # 726 "eggx.F90"
(  726)       ! ADJUSTMENT OF ONE EXTREME LATITUDE IN ORDER TO HAVE PDELX = PDELY
(  727)       CALL EGGMLT (PRPI,KDLUX,KDLUN,KDGUX,KDGUN,KULOUT,1,&
(  728)        & PRPK,XLON0U,XLON1U,ZLON2U,KSOTRP,XLAT1R,ZLAT2R,&
(  729)        & HSUD,XBETA)  
(  730) # 731 "eggx.F90"
(  731)     ENDIF
(  732) # 733 "eggx.F90"
(  733)     ! DETERMINES REFERENCE LATITUDE
(  734) # 735 "eggx.F90"
(  735)     IF ( KGIV0 == 2.OR. KGIV0 == 3 ) THEN
(  736)       XLAT0R = 0.5_JPRB*( ZLAT2R + XLAT1R )
(  737)       XLAT0R = MIN(ZPIS2,MAX(-ZPIS2,XLAT0R))
(  738)       WRITE (KULOUT,*) ' '
(  739)       WRITE (KULOUT,*) ' PROJECTION REFERENCE LATITUDE ',&
(  740)        & ' (ON ROTATED SPHERE) '  






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 37

(  741)       WRITE (KULOUT,*) ' LAT0R = ',XLAT0R
(  742)       WRITE (KULOUT,*) ' '
(  743)     ENDIF
(  744) # 745 "eggx.F90"
(  745)   ENDIF
(  746) # 747 "eggx.F90"
(  747)   !     MAP PROJECTION TYPE AND POSSIBLY ONE CORNER MUST BE DETERMINED
(  748)   !     --------------------------------------------------------------
(  749)   IF ( PRPK == 10._JPRB ) THEN
(  750) # 751 "eggx.F90"
(  751)     ! EXPLORE VARIATIONS OF MAP FACTOR
(  752)     ! --------------------------------
(  753) # 754 "eggx.F90"
(  754)     ZLATLIM = PRPI/6._JPRB
(  755)     ! FIRST GUESS : EITHER STEREO OR MERCATOR
(  756)     IF ( KSOTRP == 0 ) THEN
(  757)       ZRPK = 1.0_JPRB
(  758)       IF ( XLAT1R < ZLATLIM ) ZRPK = 0.0_JPRB
(  759)     ELSEIF ( KSOTRP == 1 ) THEN
(  760)       ZRPK = 1.0_JPRB
(  761)       IF ( XLAT1R < ZLATLIM ) ZRPK = 0.0_JPRB
(  762)     ELSEIF ( KSOTRP == 2 ) THEN
(  763)       ZRPK = 1.0_JPRB
(  764)       IF ( ZLAT2R < ZLATLIM ) ZRPK = 0.0_JPRB
(  765)     ENDIF
(  766) # 767 "eggx.F90"
(  767)     ! FIRST GUESS POSSIBLE OTHER LATITUDE
(  768)     IF ( KSOTRP >= 1 ) THEN
(  769)       CALL EGGMLT (PRPI,KDLUX,KDLUN,KDGUX,KDGUN,KULOUT,1,&
(  770)        & ZRPK,XLON0U,XLON1U,ZLON2U,KSOTRP,XLAT1R,ZLAT2R,&
(  771)        & HSUD,XBETA)  
(  772)     ENDIF
(  773)     ! FIRST GUESS REFERENCE LATITUDE
(  774)     IF ( KGIV0 == 2.OR. KGIV0 == 3 ) THEN
(  775)       XLAT0R = 0.5_JPRB*( ZLAT2R + XLAT1R )
(  776)       XLAT0R = MIN(ZPIS2,MAX(-ZPIS2,XLAT0R))
(  777)     ENDIF
(  778) # 779 "eggx.F90"
(  779)     ! PREPARING FOR OUTER ITERATION LOOP (RK + LATITUDE)
(  780)     ITERKX = 10
(  781)     ITERK = 0
(  782)     ZRKOLD = ZRPK
(  783) # 784 "eggx.F90"
(  784)     LL510=.TRUE.
(  785) # 786 "eggx.F90"
(  786)     DO WHILE(LL510)
(  787) # 788 "eggx.F90"
(  788)       ZRKII = 0.01_JPRB
(  789)       ZDRK = 0.01_JPRB
(  790)       ZRKI = 0.0_JPRB
(  791)       ISPECA = 0
(  792) # 793 "eggx.F90"
(  793)       ! IDENTIFYING SPECIAL CASES THAT MUST GO INTO THE INNER LOOP
(  794)       IF ( XLAT1R*ZLAT2R  <=  0.0_JPRB ) THEN
(  795)         ! SPECIAL CASE : DOMAIN ASTRIDE EQUATOR
(  796)         ZRPK = 0.0_JPRB
(  797)         ZRKOLD = ZRPK
(  798)         ISPECA = 1






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 38

(  799)       ELSEIF ( HSUD > 0.0_JPRB .AND.ABS(ZLAT2R) <= ABS(XLAT1R) ) THEN
(  800)         ! SPECIAL CASE : DOMAIN INCLUDING NORTH POLE (THE TEST IS A WEAK ONE)
(  801)         ZRPK = 1.0_JPRB
(  802)         ZRKOLD = ZRPK
(  803)         ISPECA = 1
(  804)       ELSEIF ( HSUD < 0.0_JPRB .AND.ABS(XLAT1R) <= ABS(ZLAT2R) ) THEN
(  805)         ! SPECIAL CASE : DOMAIN INCLUDING SOUTH POLE (THE TEST IS A WEAK ONE)
(  806)         ZRPK = 1.0_JPRB
(  807)         ZRKOLD = ZRPK
(  808)         ISPECA = 1
(  809)       ELSEIF ( ABS(ABS(ZLAT2R)-ZPIS2) < ZSECAN ) THEN
(  810)         ! VARIOUS OTHER SPECIAL CASES THAT MUST NOT COVER THE WHOLE LOOP
(  811)         ZRKI = ZRKII
(  812)       ELSEIF ( ABS(ABS(XLAT1R)-ZPIS2) < ZSECAN ) THEN
(  813)         ! VARIOUS OTHER SPECIAL CASES THAT MUST NOT COVER THE WHOLE LOOP
(  814)         ZRKI = ZRKII
(  815)       ENDIF
(  816) # 817 "eggx.F90"
(  817)       IF ( ISPECA /= 1 ) THEN
(  818) # 819 "eggx.F90"
(  819)         ! PREPARE FOR INNER LOOP ON RK
(  820)         ZDMMAX = -1.0_JPRB
(  821)         ZDMMIN = 1.E+05_JPRB
(  822)         ZRKAX = 1.0_JPRB
(  823)         ZRKIN = 1.0_JPRB
(  824)         INNEGA = 0
(  825)         INBESS = 0
(  826)         ZRKT = ZRKI
(  827) # 828 "eggx.F90"
(  828)         ! INNER LOOP ON RK
(  829) # 830 "eggx.F90"
(  830)         LL520=.TRUE.
(  831) # 832 "eggx.F90"
(  832)         DO WHILE(LL520)
(  833)           ! COMPUTES MAP FACTOR VARIATION FOR VARIOUS PROJECTION
(  834)           IF ( ZRKT == 0.0_JPRB ) THEN
(  835)             ZDM = COS(XLAT0R)/COS(ZLAT2R) - COS(XLAT0R)/COS(XLAT1R)
(  836)           ELSEIF ( ZRKT /= 1.0_JPRB ) THEN
(  837)             ZDM = (COS(XLAT0R)**(1.0_JPRB-ZRKT))*&
(  838)              & ((1.0_JPRB+SIN(XLAT0R))**ZRKT)*( (COS(XLAT1R)**(ZRKT-1.0_JPRB))*&
(  839)              & ((1.0_JPRB+SIN(XLAT1R))**(-ZRKT)) - (COS(ZLAT2R)**(ZRKT-1.0_JPRB))*&
(  840)              & ((1.0_JPRB+SIN(ZLAT2R))**(-ZRKT)) )  
(  841)           ELSEIF ( ZRKT == 1.0_JPRB ) THEN
(  842)             ZDM = (1.0_JPRB+SIN(XLAT0R))*( 1.0_JPRB/(1.0_JPRB+SIN(XLAT1R)) -&
(  843)              & 1.0_JPRB/(1.0_JPRB+SIN(ZLAT2R)) )  
(  844)           ENDIF
(  845)           INBESS = INBESS + 1
(  846)           IF ( ZDM <= 0.0_JPRB ) THEN
(  847)             INNEGA = INNEGA + 1
(  848)           ENDIF
(  849)           IF ( ZDM >= ZDMMAX .AND. ZDM > 0.0_JPRB ) THEN
(  850)             ZDMMAX = ZDM
(  851)             ZRKAX = ZRKT
(  852)           ENDIF
(  853)           IF ( ZDM <= ZDMMIN .AND. ZDM > 0.0_JPRB ) THEN
(  854)             ZDMMIN = ZDM
(  855)             ZRKIN = ZRKT
(  856)           ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 39

(  857)           ZRKT = ZRKT + ZDRK
(  858)           LL520=(ZRKT <= 1.0_JPRB)
(  859)         ENDDO ! DO WHILE(LL520)
(  860) # 861 "eggx.F90"
(  861)         WRITE (KULOUT,*) ' '
(  862)         WRITE (KULOUT,*) ' CHOICE OF OPTIMAL RK ITERATION ',ITERK
(  863)         WRITE (KULOUT,*) ' PREVIOUS RK ',ZRKOLD
(  864)         WRITE (KULOUT,*) ' TEST OVER ',INBESS,' VALUES '
(  865)         WRITE (KULOUT,*) ' INCLUDING ',INNEGA,' NEGATIVE VALUES'
(  866)         WRITE (KULOUT,*) ' RK MINI = ',ZRKI,' INCRMENT = ',ZDRK
(  867)         WRITE (KULOUT,*) ' '
(  868)         WRITE (KULOUT,*) ' DELTA(M) MAXI = ',ZDMMAX,' AT RK = ',ZRKAX
(  869)         WRITE (KULOUT,*) ' DELTA(M) MINI = ',ZDMMIN,' AT RK = ',ZRKIN
(  870) # 871 "eggx.F90"
(  871)         ! UPDATES VALUE OF GUESS ZRPK
(  872)         ZRKOLD = ZRPK
(  873)         ZRPK = ZRKIN
(  874) # 875 "eggx.F90"
(  875)       ENDIF ! ISPECA /= 1
(  876) # 877 "eggx.F90"
(  877)       IF ( KSOTRP == 0 ) THEN
(  878)         ! END THE OUTER LOOP IF BOTH LATITUDES WERE KNOWN
(  879)         ZRKOLD = ZRPK
(  880)       ELSEIF ( KSOTRP >= 1 ) THEN
(  881)         ! DETRMINES NEW OTHER LATITUDE
(  882)         CALL EGGMLT (PRPI,KDLUX,KDLUN,KDGUX,KDGUN,KULOUT,1,&
(  883)          & ZRPK,XLON0U,XLON1U,ZLON2U,KSOTRP,XLAT1R,ZLAT2R,&
(  884)          & HSUD,XBETA)  
(  885)       ENDIF
(  886)       ! NEW REFERENCE LATITUDE
(  887)       IF ( KGIV0 == 2.OR. KGIV0 == 3 ) THEN
(  888)         XLAT0R = 0.5_JPRB*( ZLAT2R + XLAT1R )
(  889)         XLAT0R = MIN(ZPIS2,MAX(-ZPIS2,XLAT0R))
(  890)       ENDIF
(  891) # 892 "eggx.F90"
(  892)       ! COMPLETES INTERATION OF OUTER LOOP (RK AND LATITUDE)
(  893)       ITERK = ITERK + 1
(  894)       IF ( ITERK > ITERKX ) THEN
(  895)         WRITE (KULOUT,*) ' *** EGGX **** TROUBLE '
(  896)         WRITE (KULOUT,*) ' NO CONVERGENCE OF AUTOMATIC CHOICE '
(  897)         CALL ABOR1(' EGGX: abor1 5.1')
(  898)       ENDIF
(  899) # 900 "eggx.F90"
(  900)       LL510=(ABS(ZRPK-ZRKOLD) > ZDRK)
(  901) # 902 "eggx.F90"
(  902)     ENDDO ! DO WHILE(LL510)
(  903) # 904 "eggx.F90"
(  904)     PRPK = ZRPK
(  905)     WRITE (KULOUT,*) ' '
(  906)     WRITE (KULOUT,*) ' --- EGGX AUTOMATIC CHOICE '
(  907)     WRITE (KULOUT,*) ' '
(  908)     WRITE (KULOUT,*) ' FINAL VALUE OF PRPK = ',PRPK
(  909)     WRITE (KULOUT,*) ' '
(  910)     WRITE (KULOUT,*) ' PROJECTION REFERENCE LATITUDE ',&
(  911)      & ' (ON ROTATED SPHERE) '  
(  912)     WRITE (KULOUT,*) ' FINAL LATITUDE LAT1 R = ',XLAT1R
(  913)     WRITE (KULOUT,*) ' FINAL LATITUDE LAT2 R = ',ZLAT2R
(  914)     WRITE (KULOUT,*) ' LAT0R = ',XLAT0R






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 40

(  915)     WRITE (KULOUT,*) ' '
(  916)   ENDIF
(  917) # 918 "eggx.F90"
(  918) ENDIF
(  919) !     MEMORIZES THE FINAL VALUE OF PRPK
(  920) XGGPK = PRPK
(  921) # 922 "eggx.F90"
(  922) !*
(  923) !---------------------------------------------------------------------
(  924) !     6.- PROJECTION ON CARTESIAN PLAN
(  925) # 926 "eggx.F90"
(  926) !     REMARK : THE CODE IS GENERAL, BUT STEREO/LAMBERT SHOULD
(  927) !              NOT BE COMBINED TO ROTATION
(  928) # 929 "eggx.F90"
(  929) IF ( PRPK > 1.0_JPRB ) THEN
(  930)   WRITE (KULOUT,*) ' *** EGGX ERROR : NON-EXISTING PROJ.'
(  931)   CALL ABOR1(' EGGX: abor1 6.1')
(  932) ENDIF
(  933) # 934 "eggx.F90"
(  934) IF ( PRPK > 0.0_JPRB ) THEN
(  935)   WRITE (KULOUT,*) ' STEREO OR LAMBERT PROJECTION '
(  936)   IF ( PRPK == 1.0_JPRB ) WRITE (KULOUT,*)&
(  937)    & ' EFFECTIVELY STREOGRAPHIC PROJECTION '  
(  938) # 939 "eggx.F90"
(  939)   !   COMPUTES BASIC PARAMETERS
(  940)   !   -------------------------
(  941) # 942 "eggx.F90"
(  942)   !    HALF COLATITUDE
(  943)   ZDCLA1 = ZPIS4 - 0.5_JPRB*XLAT1R
(  944)   ZDCLA2 = ZPIS4 - 0.5_JPRB*ZLAT2R
(  945)   ZDCLA0 = ZPIS4 - 0.5_JPRB*XLAT0R
(  946)   !   PROJECTION CONSTANTS
(  947)   IF ( PRPK < 1.0_JPRB ) THEN
(  948)     XGGM0 = ( COS( XLAT0R )**(1.0_JPRB-PRPK) )*&
(  949)      & ( ( 1.0_JPRB + SIN( XLAT0R ) )**PRPK )  
(  950)     ZUSKP = XGGM0/PRPK
(  951)     XRPKSM = 1.0_JPRB/ZUSKP
(  952)   ELSE
(  953)     XGGM0 = 1.0_JPRB + SIN( XLAT0R )
(  954)     ZUSKP = XGGM0
(  955)     XRPKSM = 1.0_JPRB/ZUSKP
(  956)   ENDIF
(  957) # 958 "eggx.F90"
(  958)   !   COMPUTES RESOLUTION
(  959)   !   -------------------
(  960)   IF( .NOT.LLPLANEX.AND..NOT.LLPLANEY )THEN
(  961)     PDELX = PRA*ZUSKP*( (TAN(ZDCLA2)**PRPK)*SIN( PRPK*(&
(  962)      & ZLON2U-XLON0U)-XBETA ) - (TAN(ZDCLA1)**PRPK)*&
(  963)      & SIN( PRPK*(XLON1U-XLON0U)-XBETA ) )/REAL(KDLUX-KDLUN,JPRB)  
(  964)     PDELY = HSUD*PRA*ZUSKP*( (TAN(ZDCLA1)**PRPK)*COS( PRPK*(&
(  965)      & XLON1U-XLON0U)-XBETA ) - (TAN(ZDCLA2)**PRPK)*&
(  966)      & COS( PRPK*(ZLON2U-XLON0U)-XBETA ) )/REAL(KDGUX-KDGUN,JPRB)  
(  967)   ELSEIF( LLPLANEX )THEN
(  968)     PDELY = HSUD*PRA*ZUSKP*( (TAN(ZDCLA1)**PRPK)*COS( PRPK*(&
(  969)      & XLON1U-XLON0U)-XBETA ) - (TAN(ZDCLA2)**PRPK)*&
(  970)      & COS( PRPK*(ZLON2U-XLON0U)-XBETA ) )/REAL(KDGUX-KDGUN)  
(  971)     PDELX=PDELY
(  972)   ELSEIF( LLPLANEY )THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 41

(  973)     PDELX = PRA*ZUSKP*( (TAN(ZDCLA2)**PRPK)*SIN( PRPK*(&
(  974)      & ZLON2U-XLON0U)-XBETA ) - (TAN(ZDCLA1)**PRPK)*&
(  975)      & SIN( PRPK*(XLON1U-XLON0U)-XBETA ) )/REAL(KDLUX-KDLUN)  
(  976)     PDELY = PDELX
(  977)   ENDIF
(  978)       
(  979)   WRITE (KULOUT,*) ' '
(  980)   WRITE (KULOUT,*) ' MAP FACTOR BASE XGGM0 = ',XGGM0
(  981)   WRITE (KULOUT,*) ' ZUSKP = ',ZUSKP
(  982)   WRITE (KULOUT,*) ' '
(  983)   WRITE (KULOUT,*) ' X GRID SIZE (KM) = ',PDELX*1.E-03_JPRB
(  984)   WRITE (KULOUT,*) ' '
(  985)   WRITE (KULOUT,*) ' Y GRID SIZE (KM) = ',PDELY*1.E-03_JPRB
(  986)   WRITE (KULOUT,*) ' '
(  987) # 988 "eggx.F90"
(  988)   !   COMPUTES POLE LOCATION ON GRID
(  989)   !   ------------------------------
(  990) # 991 "eggx.F90"
(  991)   XIPORE =  - PRA*ZUSKP*( TAN( ZDCLA1 )**PRPK )*&
(  992)    & SIN( PRPK*(XLON1U-XLON0U)-XBETA )/PDELX  
(  993)   XJPORE =  HSUD*PRA*ZUSKP*( TAN( ZDCLA1 )**PRPK )*&
(  994)    & COS( PRPK*(XLON1U-XLON0U)-XBETA )/PDELY  
(  995)   NYMGGI = 10
(  996) # 997 "eggx.F90"
(  997)   WRITE (KULOUT,*) ' '
(  998)   WRITE (KULOUT,*) ' POLE LOCATION ON GRID IP = ',XIPORE,' JP = ',XJPORE
(  999) # 1000 "eggx.F90"
( 1000)   ZIPV = REAL( KDLUX ,JPRB) - PRA*ZUSKP*( TAN( ZDCLA2 )**PRPK )*&
( 1001)    & SIN( PRPK*(ZLON2U-XLON0U)-XBETA )/PDELX  - REAL(KDLUN,JPRB)  
( 1002)   ZJPV = REAL( KDGUX ,JPRB) + PRA*ZUSKP*( TAN( ZDCLA2 )**PRPK )*&
( 1003)    & COS( PRPK*(ZLON2U-XLON0U)-XBETA )*HSUD/PDELY -&
( 1004)    & REAL(KDGUN,JPRB)  
( 1005) # 1006 "eggx.F90"
( 1006)   WRITE (KULOUT,*) ' VRF POLE LOCATION ON GRID IP = ',ZIPV,' JP = ',ZJPV
( 1007) # 1008 "eggx.F90"
( 1008)   !   GRID POINTS LOCATION
( 1009)   !   --------------------
( 1010) # 1011 "eggx.F90"
( 1011)   DO JLAT = KDGUN, KDGUX
( 1012) # 1013 "eggx.F90"
( 1013)     DO JLON = KDLUN, KDLUX
( 1014)       PGELAM(JLON,JLAT) = REAL(JLON-KDLUN,JPRB)*PDELX
( 1015)       PGELAT(JLON,JLAT) = REAL(JLAT-KDGUN,JPRB)*PDELY
( 1016)     ENDDO
( 1017) # 1018 "eggx.F90"
( 1018)     CALL EGGRVS (PRPI, PRA, PDELX, PDELY, KDLSUR-KDLSA+1,&
( 1019)      & 1, KDLUX-KDLUN+1, KULOUT,&
( 1020)      & PGELAM(KDLUN,JLAT), PGELAT(KDLUN,JLAT), PGM(KDLUN,JLAT),&
( 1021)      & PGNORX(KDLUN,JLAT), PGNORY(KDLUN,JLAT))  
( 1022)   ENDDO
( 1023) # 1024 "eggx.F90"
( 1024) ENDIF
( 1025) # 1026 "eggx.F90"
( 1026) IF ( PRPK == 0.0_JPRB ) THEN
( 1027)   WRITE (KULOUT,*) ' MERCATOR PROJECTION '
( 1028) # 1029 "eggx.F90"
( 1029)   !   COMPUTES BASIC PARAMETERS
( 1030)   !   -------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 42

( 1031) # 1032 "eggx.F90"
( 1032)   !    HALF COLATITUDE
( 1033)   ZDCLA1 = ZPIS4 - 0.5_JPRB*XLAT1R
( 1034)   ZDCLA2 = ZPIS4 - 0.5_JPRB*ZLAT2R
( 1035)   ZDCLA0 = ZPIS4 - 0.5_JPRB*XLAT0R
( 1036) # 1037 "eggx.F90"
( 1037)   !   COMPUTES RESOLUTION
( 1038)   !   -------------------
( 1039) # 1040 "eggx.F90"
( 1040)   ZFACE = PRA*COS( XLAT0R )
( 1041)   ZDLON =  ZLON2U - XLON1U
( 1042)   ZDTLAT = LOG( TAN(ZDCLA1)/TAN(ZDCLA2) )
( 1043)   IF( .NOT.LLPLANEX.AND..NOT.LLPLANEY )THEN
( 1044)     PDELX = ZFACE*( ZDLON*COS(XBETA) + ZDTLAT*SIN(XBETA) )&
( 1045)      & /REAL( KDLUX-KDLUN ,JPRB)  
( 1046)     PDELY = ZFACE*( -ZDLON*SIN(XBETA) + ZDTLAT*COS(XBETA) )&
( 1047)      & /REAL( KDGUX-KDGUN ,JPRB)  
( 1048)   ELSEIF( LLPLANEX )THEN
( 1049)     PDELY = ZFACE*( -ZDLON*SIN(XBETA) + ZDTLAT*COS(XBETA) )&
( 1050)      & /REAL( KDGUX-KDGUN )  
( 1051)     PDELX = PDELY
( 1052)   ELSEIF( LLPLANEY )THEN
( 1053)     PDELX = ZFACE*( ZDLON*COS(XBETA) + ZDTLAT*SIN(XBETA) )&
( 1054)      & /REAL( KDLUX-KDLUN )  
( 1055)     PDELY = PDELX
( 1056)   ENDIF
( 1057) # 1058 "eggx.F90"
( 1058)   WRITE (KULOUT,*) ' '
( 1059)   WRITE (KULOUT,*) ' MAP FACTOR BASE COS( LAT0 ) = ',COS( XLAT0R )
( 1060)   WRITE (KULOUT,*) ' '
( 1061)   WRITE (KULOUT,*) ' X GRID SIZE (KM) = ',PDELX*1.E-03_JPRB
( 1062)   WRITE (KULOUT,*) ' '
( 1063)   WRITE (KULOUT,*) ' Y GRID SIZE (KM) = ',PDELY*1.E-03_JPRB
( 1064)   WRITE (KULOUT,*) ' '
( 1065) # 1066 "eggx.F90"
( 1066)   !   COMPUTES EQUATOR LOCATION ON GRID
( 1067)   !   ------------------------------
( 1068) # 1069 "eggx.F90"
( 1069)   XIPORE = - PRA*COS( XLAT0R )*( XLON1U-XLON0U )/PDELX
( 1070)   XJPORE = + PRA*COS( XLAT0R )*LOG(TAN( ZDCLA1 ) )/PDELY
( 1071)   XRPKSM=1.0_JPRB
( 1072)   XGGPK = PRPK
( 1073)   NYMGGI = 10
( 1074) # 1075 "eggx.F90"
( 1075)   WRITE (KULOUT,*) ' '
( 1076)   WRITE (KULOUT,*) ' EQUATOR LOCATION ON GRID IE = ',XIPORE,' JE = ',XJPORE
( 1077) # 1078 "eggx.F90"
( 1078)   !     GRID POINTS LOCATION
( 1079)   !     --------------------
( 1080) # 1081 "eggx.F90"
( 1081)   DO JLAT = KDGUN, KDGUX
( 1082) # 1083 "eggx.F90"
( 1083)     DO JLON = KDLUN, KDLUX
( 1084)       PGELAM(JLON,JLAT) = REAL(JLON-KDLUN,JPRB)*PDELX
( 1085)       PGELAT(JLON,JLAT) = REAL(JLAT-KDGUN,JPRB)*PDELY
( 1086)     ENDDO
( 1087) # 1088 "eggx.F90"
( 1088)     CALL EGGRVS (PRPI, PRA, PDELX, PDELY, KDLSUR-KDLSA+1,&






NVFORTRAN (Version     23.1)          02/24/2023  13:37:50      page 43

( 1089)      & 1, KDLUX-KDLUN+1, KULOUT,&
( 1090)      & PGELAM(KDLUN,JLAT), PGELAT(KDLUN,JLAT), PGM(KDLUN,JLAT),&
( 1091)      & PGNORX(KDLUN,JLAT), PGNORY(KDLUN,JLAT))  
( 1092)   ENDDO
( 1093) # 1094 "eggx.F90"
( 1094) ENDIF
( 1095) # 1096 "eggx.F90"
( 1096) !*
( 1097) !---------------------------------------------------------------------
( 1098) !     7.- INVERSE ROTATION BACK TO GEOGRAPHICAL COORDINATES
( 1099) # 1100 "eggx.F90"
( 1100) !    THIS OPERATION IS PERFORMED BY EGGRVS
( 1101) # 1102 "eggx.F90"
( 1102) !    FINAL UPDATE OF ACTUAL CORNERS USED
( 1103) # 1104 "eggx.F90"
( 1104) IF ( KSOTRP == 1 ) THEN
( 1105)   PLAT2 = PGELAT(KDLUX,KDGUX)
( 1106)   PLON2 = PGELAM(KDLUX,KDGUX)
( 1107) ENDIF
( 1108) IF ( KSOTRP == 2 ) THEN
( 1109)   PLAT1 = PGELAT(KDLUN,KDGUN)
( 1110)   PLON1 = PGELAM(KDLUN,KDGUN)
( 1111) ENDIF
( 1112) # 1113 "eggx.F90"
( 1113) !    PLON1 AND PLON2 MUST BE BETWEEN 0 AND 2*RPI
( 1114) # 1115 "eggx.F90"
( 1115) PLON1=MOD(PLON1,2*PRPI)
( 1116) PLON2=MOD(PLON2,2*PRPI)
( 1117) # 1118 "eggx.F90"
( 1118) IF ( HSUD < 0.0_JPRB ) THEN
( 1119)   IF ( KSOTRP /= 2 ) THEN
( 1120)     PLAT1 = HSUD*PLAT1
( 1121)   ENDIF
( 1122)   IF ( KSOTRP /= 1 ) THEN
( 1123)     PLAT2 = HSUD*PLAT2
( 1124)   ENDIF
( 1125)   PLAT0 = HSUD*PLAT0
( 1126) ENDIF
( 1127) # 1128 "eggx.F90"
( 1128) ! KSOTRP reset back to original value
( 1129) IF( LLPLANEX.OR.LLPLANEY )THEN
( 1130)   KSOTRP = ISOTRP
( 1131) ENDIF
( 1132) # 1133 "eggx.F90"
( 1133) WRITE (KULOUT,*) ' '
( 1134) WRITE (KULOUT,*) ' ---------- '
( 1135) WRITE (KULOUT,*) ' '
( 1136) WRITE (KULOUT,*) '  EGGX IS OVER '
( 1137) WRITE (KULOUT,*) ' '
( 1138) WRITE (KULOUT,*) ' ---------- '
( 1139) WRITE (KULOUT,*) ' '
( 1140) WRITE (KULOUT,*) ' '
( 1141) # 1142 "eggx.F90"
( 1142) !---------------------------------------------------------------------
( 1143) IF (LHOOK) CALL DR_HOOK('EGGX',1,ZHOOK_HANDLE)
( 1144) END SUBROUTINE EGGX
