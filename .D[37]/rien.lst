


NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: rien.F90

(    1) SUBROUTINE RIEN(CDNAMC,KTYPTR,PSLAPO,PLOCEN,&
(    2)  & PCODIL,KTRONC,KDGL,KNXLON,KNLOPA,KNOZPA,PSINLA,&
(    3)  & KHTYP,KFLEV,PREF,PVALH,PVBH,KQUAD,&
(    4)  & KDGSA,KDGEN,PEPS,LDFICP,KULOUT)  
(    5) 
(    6) !**** *RIEN*  - Read Input ENvironment
(    7) 
(    8) !     Purpose.
(    9) !     --------
(   10) !           It extracts geometry information from ARPEGE file. 
(   11) 
(   12) 
(   13) !**   Interface.
(   14) !     ----------
(   15) !        *CALL* *RIEN(CDNAMC,KTYPTR,PSLAPO,PLOCEN,
(   16) !    &           PCODIL,KTRONC,KDGL,KNXLON,KNLOPA,KNOZPA,PSINLA,
(   17) !    &           KHTYP,KFLEV,PREF,PVALH,PVBH,KQUAD,
(   18) !    &           KDGSA,KDGEN,PEPS,LDFICP,KULOUT)
(   19) 
(   20) !        Explicit arguments :
(   21) !        --------------------
(   22) 
(   23) !        Input-Output:
(   24) !        ----------------------------
(   25) 
(   26) !        CDNAMC        ...   Name of the cadre
(   27) 
(   28) !        Determination of reference geometry:
(   29) 
(   30) !        KTYPTR        ...   Type of Schmidt transform






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 3

(   31) !                            1  ===>  Pole is at geog. North Pole
(   32) !                            and stretching is equal to 1
(   33) !                            2  ===>  General case
(   34) !        PSLAPO        ...   Sinus latitude of pole of dilatation
(   35) !        PLOCEN        ...   Longitude of pole of dilatation
(   36) !        PCODIL        ...   Stretching factor
(   37) !        KTRONC        ...   Truncation
(   38) !        KDGL          ...   Number of latitudes without poles
(   39) !        KNXLON        ...   Max. number of longitudes at a parallel
(   40) !        KNLOPA        ...   Number of longitudes at a parallel
(   41) !        KNOZPA        ...   Max. wave number at a parallel
(   42) !        KHTYP         ...   Type of collocation grid
(   43) !                            0 ==>   regular grid
(   44) !                            2 ==>   reduced grid towards the poles
(   45) !        KFLEV         ...   Number of vertical levels
(   46) !        PREF          ...   Reference pressure
(   47) !        PVALH         ...   "A" coefficients of vertical system
(   48) !        PVBH          ...   "B" coefficients of vertical system
(   49) !        KQUAD         ...   Quadrature ( 1 : Gauss ; 2 : Lobatto)
(   50) !        LDFICP        ...   .TRUE.  if file contains the poles
(   51) !   -----------------------------------------------------------------
(   52) !        Input :
(   53) !        -------
(   54) 
(   55) !        KDGSA         ...   First row of arrays KNLOPA and KNOZPA
(   56) !        KDGEN         ...   Last row of arrays KNLOPA and KNOZPA
(   57) !        PEPS          ...   Precision of the tests on real variables
(   58) !        KULOUT        ...   Output file unit
(   59) !   -----------------------------------------------------------------
(   60) 
(   61) !        Output:
(   62) !        ----------------------------
(   63) 
(   64) !        PSINLA        ...   Sinus of latitudes
(   65) 
(   66) !   -----------------------------------------------------------------
(   67) 
(   68) !        Implicit arguments :
(   69) !        --------------------
(   70) !        None.
(   71) 
(   72) !     Method.
(   73) !     -------
(   74) !        See documentation
(   75) 
(   76) !     Externals.
(   77) !     ----------
(   78) 
(   79) !     Reference.
(   80) !     ----------
(   81) !        ARPEGE/ALADIN Documentation.
(   82) !        Document 'Control of coherence between namelist and Arpege File'
(   83) !        by R. El Khatib
(   84) 
(   85) !     Original CHIEN Author
(   86) !     -------
(   87) !        Radmila Bubnova *GMAP/COMPAS - stage MICECO*
(   88) 






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 4

(   89) 
(   90) !     Modifications.
(   91) !     --------------
(   92) !        Original : 91-12-10
(   93) !        O. Marsden : May 2016 Extracted the KINF==1 case from CHIEN, to clean up GEOMETRY intents
(   94) !     ------------------------------------------------------------------
(   95) 
(   96) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   97) USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(   98) 
(   99) !     ------------------------------------------------------------------
(  100) 
(  101) IMPLICIT NONE
(  102) 
(  103) INTEGER(KIND=JPIM),INTENT(INOUT) :: KFLEV 
(  104) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGSA 
(  105) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGEN 
(  106) CHARACTER(LEN=16) ,INTENT(IN)    :: CDNAMC
(  107) INTEGER(KIND=JPIM),INTENT(INOUT) :: KTYPTR 
(  108) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSLAPO 
(  109) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLOCEN 
(  110) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCODIL 
(  111) INTEGER(KIND=JPIM),INTENT(INOUT) :: KTRONC 
(  112) INTEGER(KIND=JPIM),INTENT(INOUT) :: KDGL 
(  113) INTEGER(KIND=JPIM),INTENT(INOUT) :: KNXLON 
(  114) INTEGER(KIND=JPIM),INTENT(INOUT) :: KNLOPA(KDGSA:KDGEN) 
(  115) INTEGER(KIND=JPIM),INTENT(INOUT) :: KNOZPA(KDGSA:KDGEN) 
(  116) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSINLA(KDGSA:KDGEN) 
(  117) INTEGER(KIND=JPIM),INTENT(INOUT) :: KHTYP 
(  118) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PREF 
(  119) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVALH(0:KFLEV) 
(  120) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVBH(0:KFLEV) 
(  121) INTEGER(KIND=JPIM),INTENT(INOUT) :: KQUAD 
(  122) REAL(KIND=JPRB)   ,INTENT(IN)    :: PEPS 
(  123) LOGICAL           ,INTENT(OUT)   :: LDFICP 
(  124) INTEGER(KIND=JPIM),INTENT(IN)    :: KULOUT 
(  125) 
(  126) !     ------------------------------------------------------------------
(  127) 
(  128) INTEGER(KIND=JPIM), ALLOCATABLE :: INLOPA(:),INOZPA(:)
(  129) REAL(KIND=JPRB), ALLOCATABLE :: ZVALH(:),ZVBH(:)
(  130) REAL(KIND=JPRB), ALLOCATABLE :: ZSINLA(:)
(  131) LOGICAL :: LLGARD
(  132) 
(  133) INTEGER(KIND=JPIM) :: IDGL, IDGNH, IERR, IERRA, IHTYP, INIVER, INLATI, &
(  134)  & INXLON, IQUADF, ISTROW, ITRONC, ITYPTR, JFLEV, JL, JLAT, JLEV, IMAXLEV, &
(  135)  & IMAXGL, IMAXLON, IMAXTRUNC 
(  136) 
(  137) REAL(KIND=JPRB) :: ZCLOPO, ZCODIL, ZEPS, ZMUNPOL, ZREF, ZSLAPO, ZSLOPO, ZX1
(  138) REAL(KIND=JPRB) :: ZX2
(  139) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  140) 
(  141) !     ------------------------------------------------------------------
(  142) 
(  143) #include "abor1.intfb.h"
(  144) 
(  145) !     ------------------------------------------------------------------
(  146) 






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 5

(  147) IF (LHOOK) CALL DR_HOOK('RIEN',0,ZHOOK_HANDLE)
(  148) 
(  149) !     ------------------------------------------------------------------
(  150) 
(  151) !*       0.    Get software limits
(  152) !              -------------------
(  153) 
(  154) CALL FALIMU(IMAXLEV,IMAXTRUNC,IMAXGL,IMAXLON)
(  155) ALLOCATE(INLOPA(IMAXGL))
(  156) ALLOCATE(INOZPA(IMAXGL))
(  157) ALLOCATE(ZSINLA(IMAXGL))
(  158) ALLOCATE(ZVALH(0:IMAXLEV))
(  159) ALLOCATE(ZVBH(0:IMAXLEV))
(  160) 
(  161) !*       1.    Read file characteristics
(  162) !              -------------------------
(  163) 
(  164) WRITE(KULOUT,*) ' HAF, HAF : CADRE : ',CDNAMC
(  165) CALL FACIES(CDNAMC,ITYPTR,ZSLAPO,ZCLOPO,ZSLOPO,ZCODIL,ITRONC,&
(  166)  & INLATI,INXLON,INLOPA,INOZPA,ZSINLA,INIVER,ZREF,ZVALH,ZVBH,LLGARD)  
(  167) 
(  168) IF (INLATI > KDGEN-KDGSA+1) THEN
(  169)   CALL ABOR1('RIEN : MAX. NUMBER OF LATITUDE ROWS IN MODEL TOO SMALL !')
(  170) ENDIF
(  171) IF (INIVER > KFLEV) THEN
(  172)   CALL ABOR1('RIEN : MAX. NUMBER OF LEVEL IN MODEL TOO SMALL !')
(  173) ENDIF
(  174) 
(  175) !*       2.    Preliminary tests
(  176) !              -----------------
(  177) 
(  178) !              Test - type of file
(  179) 
(  180) IF(ITYPTR < 0) THEN
(  181)   WRITE(KULOUT,*) 'YOU ARE USING A FILE ALADIN ',&
(  182)    & 'WHILE THE MODEL EXPECTS A FILE ARPEGE'  
(  183)   CALL ABOR1('RIEN: ABOR1 CALLED 2a')
(  184) ENDIF
(  185) 
(  186) !              Test - type of collocation grid
(  187) 
(  188) IF(INLOPA(1) == INLOPA(INT(INLATI/2))) THEN
(  189)   IHTYP = 0
(  190)   WRITE(KULOUT,*) 'FILE HAS REGULAR GRID '
(  191) ELSE
(  192)   IHTYP = 2
(  193)   WRITE(KULOUT,*) 'FILE HAS REDUCED GRID '
(  194) ENDIF
(  195) 
(  196) !              Poles story
(  197) 
(  198) ZMUNPOL = 0.9999999999_JPRB
(  199) IF(ZSINLA(1) >= ZMUNPOL) THEN
(  200)   WRITE(KULOUT,*) ' FILE CONTAINS THE POLES '
(  201)   LDFICP = .TRUE.
(  202)   IDGL = INLATI - 2
(  203)   IDGNH = (IDGL+1)/2
(  204) !       The following test ensures that the fields of the file






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 6

(  205) !       will be read properly :
(  206)   IF(INLOPA(1) /= INLOPA(2)) THEN
(  207)     WRITE(KULOUT,*) ' FILE ROWS #1 AND #2 DO NOT HAVE THE ',&
(  208)      & 'SAME NUMBER OF LONGITUDES'  
(  209)     WRITE(KULOUT,*) ' THIS MAKES THE MODEL UNABLE TO READ THE '&
(  210)      & ,'FILE PROPERLY'  
(  211)     CALL ABOR1('RIEN: ABOR1 CALLED 2b')
(  212)   ENDIF
(  213) ELSE
(  214)   WRITE(KULOUT,*) ' FILE DOES NOT CONTAINS THE POLES '
(  215)   LDFICP = .FALSE.
(  216)   IDGL = INLATI
(  217)   IDGNH = (IDGL+1)/2
(  218) ENDIF
(  219) 
(  220) !              Test - Gaussian or Lobatto truncation
(  221) 
(  222) IF(LDFICP) THEN
(  223)   ZX1 = 1.0_JPRB - ZSINLA(2)
(  224)   ZX2 = ZSINLA(2) - ZSINLA(3)
(  225)   IF (ZX1 > ZX2) THEN
(  226)     IQUADF = 2
(  227)     WRITE(KULOUT,*) 'FILE HAS LOBATTO QUADRATURE'
(  228)     IF(MOD(INLATI,2) == 0) THEN
(  229)       WRITE(KULOUT,*) ' WARNING ! INLATI IS EVEN !'
(  230)     ENDIF
(  231)   ELSE
(  232)     IQUADF = 1
(  233)     WRITE(KULOUT,*) 'FILE HAS GAUSSIAN QUADRATURE'
(  234)     IF(MOD(INLATI,2) == 1) THEN
(  235)       WRITE(KULOUT,*) ' WARNING ! INLATI IS ODD !'
(  236)     ENDIF
(  237)   ENDIF
(  238) ELSE
(  239)   IQUADF = 1
(  240)   WRITE(KULOUT,*) 'FILE HAS GAUSSIAN QUADRATURE'
(  241)   IF(MOD(INLATI,2) == 1) THEN
(  242)     WRITE(KULOUT,*) ' WARNING ! INLATI IS ODD !'
(  243)   ENDIF
(  244) ENDIF
(  245) 
(  246) 
(  247) 
(  248) !*       4.    Read information from file (extracted from CHIEN) 
(  249) 
(  250) !*      4.1  Pole of dilatation, stretching, truncation, coef. A, B
(  251) 
(  252)   KHTYP  = IHTYP
(  253)   KQUAD  = IQUADF
(  254)   KTYPTR = ITYPTR
(  255)   PCODIL = ZCODIL
(  256)   PSLAPO = ZSLAPO
(  257)   PLOCEN = SIGN(1.0_JPRB,ZSLOPO)*ACOS(ZCLOPO)
(  258)   KTRONC = ITRONC
(  259)   KFLEV  = INIVER
(  260)   PREF   = ZREF
(  261)   DO JLEV = 0,KFLEV
(  262)     PVALH(JLEV) = ZVALH(JLEV)






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 7

(  263)     PVBH(JLEV)  = ZVBH(JLEV)
(  264)   ENDDO
(  265) 
(  266) !*      4.2  Latitudes and longitudes.
(  267) 
(  268)   KNXLON = INXLON
(  269)   IF(LDFICP) THEN
(  270)     KDGL = IDGL
(  271)     DO JL= 0, IDGNH
(  272)       PSINLA(JL) = ZSINLA(JL+1)
(  273)       KNLOPA(JL) = INLOPA(JL+1)
(  274)       KNOZPA(JL) = INOZPA(JL+1)
(  275)     ENDDO
(  276)     DO JL=0, IDGNH
(  277)       PSINLA(KDGL+1 - JL) =  - ZSINLA(JL+1)
(  278)       KNLOPA(KDGL+1 - JL) = INLOPA(JL+1)
(  279)       KNOZPA(KDGL+1 - JL) = INOZPA(JL+1)
(  280)     ENDDO
(  281)   ELSE
(  282)     KDGL = IDGL
(  283)     DO JL= 1, IDGNH
(  284)       PSINLA(JL) = ZSINLA(JL)
(  285)       KNLOPA(JL) = INLOPA(JL)
(  286)       KNOZPA(JL) = INOZPA(JL)
(  287)     ENDDO
(  288)     DO JL=1, IDGNH
(  289)       PSINLA(KDGL - JL + 1) =  - ZSINLA(JL)
(  290)       KNLOPA(KDGL - JL + 1) = INLOPA(JL)
(  291)       KNOZPA(KDGL - JL + 1) = INOZPA(JL)
(  292)     ENDDO
(  293)     IF (KDGSA < 1) THEN
(  294)       PSINLA(0) = 1.0_JPRB
(  295)       KNLOPA(0) = INLOPA(1)
(  296)       KNOZPA(0) = INOZPA(1)
(  297)     ENDIF
(  298)     IF (KDGEN > KDGL) THEN
(  299)       PSINLA(KDGL+1) =  - 1.0_JPRB
(  300)       KNLOPA(KDGL+1) = INLOPA(1)
(  301)       KNOZPA(KDGL+1) = INOZPA(1)
(  302)     ENDIF
(  303)   ENDIF
(  304) 
(  305) 
(  306) 
(  307) DEALLOCATE(INLOPA)
(  308) DEALLOCATE(INOZPA)
(  309) DEALLOCATE(ZSINLA)
(  310) DEALLOCATE(ZVALH)
(  311) DEALLOCATE(ZVBH)
(  312) 
(  313) !     ------------------------------------------------------------------
(  314) 
(  315) IF (LHOOK) CALL DR_HOOK('RIEN',1,ZHOOK_HANDLE)
(  316) END SUBROUTINE RIEN
(  317) 









NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 8

(    1) # 1 "rien.F90"
(    1) SUBROUTINE RIEN(CDNAMC,KTYPTR,PSLAPO,PLOCEN,&
(    2)  & PCODIL,KTRONC,KDGL,KNXLON,KNLOPA,KNOZPA,PSINLA,&
(    3)  & KHTYP,KFLEV,PREF,PVALH,PVBH,KQUAD,&
(    4)  & KDGSA,KDGEN,PEPS,LDFICP,KULOUT)  
(    5) # 6 "rien.F90"
(    6) !**** *RIEN*  - Read Input ENvironment
(    7) # 8 "rien.F90"
(    8) !     Purpose.
(    9) !     --------
(   10) !           It extracts geometry information from ARPEGE file. 
(   11) # 13 "rien.F90"
(   13) !**   Interface.
(   14) !     ----------
(   15) !        *CALL* *RIEN(CDNAMC,KTYPTR,PSLAPO,PLOCEN,
(   16) !    &           PCODIL,KTRONC,KDGL,KNXLON,KNLOPA,KNOZPA,PSINLA,
(   17) !    &           KHTYP,KFLEV,PREF,PVALH,PVBH,KQUAD,
(   18) !    &           KDGSA,KDGEN,PEPS,LDFICP,KULOUT)
(   19) # 20 "rien.F90"
(   20) !        Explicit arguments :
(   21) !        --------------------
(   22) # 23 "rien.F90"
(   23) !        Input-Output:
(   24) !        ----------------------------
(   25) # 26 "rien.F90"
(   26) !        CDNAMC        ...   Name of the cadre
(   27) # 28 "rien.F90"
(   28) !        Determination of reference geometry:
(   29) # 30 "rien.F90"
(   30) !        KTYPTR        ...   Type of Schmidt transform
(   31) !                            1  ===>  Pole is at geog. North Pole
(   32) !                            and stretching is equal to 1
(   33) !                            2  ===>  General case
(   34) !        PSLAPO        ...   Sinus latitude of pole of dilatation
(   35) !        PLOCEN        ...   Longitude of pole of dilatation
(   36) !        PCODIL        ...   Stretching factor
(   37) !        KTRONC        ...   Truncation
(   38) !        KDGL          ...   Number of latitudes without poles
(   39) !        KNXLON        ...   Max. number of longitudes at a parallel
(   40) !        KNLOPA        ...   Number of longitudes at a parallel
(   41) !        KNOZPA        ...   Max. wave number at a parallel
(   42) !        KHTYP         ...   Type of collocation grid
(   43) !                            0 ==>   regular grid
(   44) !                            2 ==>   reduced grid towards the poles
(   45) !        KFLEV         ...   Number of vertical levels
(   46) !        PREF          ...   Reference pressure
(   47) !        PVALH         ...   "A" coefficients of vertical system
(   48) !        PVBH          ...   "B" coefficients of vertical system
(   49) !        KQUAD         ...   Quadrature ( 1 : Gauss ; 2 : Lobatto)
(   50) !        LDFICP        ...   .TRUE.  if file contains the poles
(   51) !   -----------------------------------------------------------------
(   52) !        Input :
(   53) !        -------
(   54) # 55 "rien.F90"
(   55) !        KDGSA         ...   First row of arrays KNLOPA and KNOZPA
(   56) !        KDGEN         ...   Last row of arrays KNLOPA and KNOZPA
(   57) !        PEPS          ...   Precision of the tests on real variables
(   58) !        KULOUT        ...   Output file unit






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 9

(   59) !   -----------------------------------------------------------------
(   60) # 61 "rien.F90"
(   61) !        Output:
(   62) !        ----------------------------
(   63) # 64 "rien.F90"
(   64) !        PSINLA        ...   Sinus of latitudes
(   65) # 66 "rien.F90"
(   66) !   -----------------------------------------------------------------
(   67) # 68 "rien.F90"
(   68) !        Implicit arguments :
(   69) !        --------------------
(   70) !        None.
(   71) # 72 "rien.F90"
(   72) !     Method.
(   73) !     -------
(   74) !        See documentation
(   75) # 76 "rien.F90"
(   76) !     Externals.
(   77) !     ----------
(   78) # 79 "rien.F90"
(   79) !     Reference.
(   80) !     ----------
(   81) !        ARPEGE/ALADIN Documentation.
(   82) !        Document 'Control of coherence between namelist and Arpege File'
(   83) !        by R. El Khatib
(   84) # 85 "rien.F90"
(   85) !     Original CHIEN Author
(   86) !     -------
(   87) !        Radmila Bubnova *GMAP/COMPAS - stage MICECO*
(   88) # 90 "rien.F90"
(   90) !     Modifications.
(   91) !     --------------
(   92) !        Original : 91-12-10
(   93) !        O. Marsden : May 2016 Extracted the KINF==1 case from CHIEN, to clean up GEOMETRY intents
(   94) !     ------------------------------------------------------------------
(   95) # 96 "rien.F90"
(   96) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   97) USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(   98) # 99 "rien.F90"
(   99) !     ------------------------------------------------------------------
(  100) # 101 "rien.F90"
(  101) IMPLICIT NONE
(  102) # 103 "rien.F90"
(  103) INTEGER(KIND=JPIM),INTENT(INOUT) :: KFLEV 
(  104) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGSA 
(  105) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGEN 
(  106) CHARACTER(LEN=16) ,INTENT(IN)    :: CDNAMC
(  107) INTEGER(KIND=JPIM),INTENT(INOUT) :: KTYPTR 
(  108) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PSLAPO 
(  109) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PLOCEN 
(  110) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PCODIL 
(  111) INTEGER(KIND=JPIM),INTENT(INOUT) :: KTRONC 
(  112) INTEGER(KIND=JPIM),INTENT(INOUT) :: KDGL 
(  113) INTEGER(KIND=JPIM),INTENT(INOUT) :: KNXLON 
(  114) INTEGER(KIND=JPIM),INTENT(INOUT) :: KNLOPA(KDGSA:KDGEN) 
(  115) INTEGER(KIND=JPIM),INTENT(INOUT) :: KNOZPA(KDGSA:KDGEN) 
(  116) REAL(KIND=JPRB)   ,INTENT(OUT)   :: PSINLA(KDGSA:KDGEN) 
(  117) INTEGER(KIND=JPIM),INTENT(INOUT) :: KHTYP 






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 10

(  118) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PREF 
(  119) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVALH(0:KFLEV) 
(  120) REAL(KIND=JPRB)   ,INTENT(INOUT) :: PVBH(0:KFLEV) 
(  121) INTEGER(KIND=JPIM),INTENT(INOUT) :: KQUAD 
(  122) REAL(KIND=JPRB)   ,INTENT(IN)    :: PEPS 
(  123) LOGICAL           ,INTENT(OUT)   :: LDFICP 
(  124) INTEGER(KIND=JPIM),INTENT(IN)    :: KULOUT 
(  125) # 126 "rien.F90"
(  126) !     ------------------------------------------------------------------
(  127) # 128 "rien.F90"
(  128) INTEGER(KIND=JPIM), ALLOCATABLE :: INLOPA(:),INOZPA(:)
(  129) REAL(KIND=JPRB), ALLOCATABLE :: ZVALH(:),ZVBH(:)
(  130) REAL(KIND=JPRB), ALLOCATABLE :: ZSINLA(:)
(  131) LOGICAL :: LLGARD
(  132) # 133 "rien.F90"
(  133) INTEGER(KIND=JPIM) :: IDGL, IDGNH, IERR, IERRA, IHTYP, INIVER, INLATI, &
(  134)  & INXLON, IQUADF, ISTROW, ITRONC, ITYPTR, JFLEV, JL, JLAT, JLEV, IMAXLEV, &
(  135)  & IMAXGL, IMAXLON, IMAXTRUNC 
(  136) # 137 "rien.F90"
(  137) REAL(KIND=JPRB) :: ZCLOPO, ZCODIL, ZEPS, ZMUNPOL, ZREF, ZSLAPO, ZSLOPO, ZX1
(  138) REAL(KIND=JPRB) :: ZX2
(  139) REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  140) # 141 "rien.F90"
(  141) !     ------------------------------------------------------------------
(  142) # 143 "rien.F90"
(  143) # 1 ".D[61]/abor1.intfb.h"
(    1) INTERFACE
(    2) # 3 ".D[61]/abor1.intfb.h"
(    3) SUBROUTINE ABOR1(CDTEXT)
(    4) CHARACTER(LEN=*), INTENT(IN) :: CDTEXT
(    5) END SUBROUTINE ABOR1
(    6) # 7 ".D[61]/abor1.intfb.h"
(    7) SUBROUTINE ABOR1FL(CDFILE, KLINENUM, CDTEXT)
(    8) USE PARKIND1  ,ONLY : JPIM
(    9) CHARACTER(LEN=*), INTENT(IN) :: CDFILE,CDTEXT
(   10) INTEGER(KIND=JPIM), INTENT(IN) :: KLINENUM
(   11) END SUBROUTINE ABOR1FL
(   12) # 13 ".D[61]/abor1.intfb.h"
(   13) SUBROUTINE ABOR1_EXCEPTION_HANDLER()
(   14) END SUBROUTINE ABOR1_EXCEPTION_HANDLER
(   15) # 16 ".D[61]/abor1.intfb.h"
(   16) END INTERFACE
(   17) # 144 "rien.F90"
(  144) # 145 "rien.F90"
(  145) !     ------------------------------------------------------------------
(  146) # 147 "rien.F90"
(  147) IF (LHOOK) CALL DR_HOOK('RIEN',0,ZHOOK_HANDLE)
(  148) # 149 "rien.F90"
(  149) !     ------------------------------------------------------------------
(  150) # 151 "rien.F90"
(  151) !*       0.    Get software limits
(  152) !              -------------------
(  153) # 154 "rien.F90"
(  154) CALL FALIMU(IMAXLEV,IMAXTRUNC,IMAXGL,IMAXLON)
(  155) ALLOCATE(INLOPA(IMAXGL))
(  156) ALLOCATE(INOZPA(IMAXGL))
(  157) ALLOCATE(ZSINLA(IMAXGL))
(  158) ALLOCATE(ZVALH(0:IMAXLEV))






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 11

(  159) ALLOCATE(ZVBH(0:IMAXLEV))
(  160) # 161 "rien.F90"
(  161) !*       1.    Read file characteristics
(  162) !              -------------------------
(  163) # 164 "rien.F90"
(  164) WRITE(KULOUT,*) ' HAF, HAF : CADRE : ',CDNAMC
(  165) CALL FACIES(CDNAMC,ITYPTR,ZSLAPO,ZCLOPO,ZSLOPO,ZCODIL,ITRONC,&
(  166)  & INLATI,INXLON,INLOPA,INOZPA,ZSINLA,INIVER,ZREF,ZVALH,ZVBH,LLGARD)  
(  167) # 168 "rien.F90"
(  168) IF (INLATI > KDGEN-KDGSA+1) THEN
(  169)   CALL ABOR1('RIEN : MAX. NUMBER OF LATITUDE ROWS IN MODEL TOO SMALL !')
(  170) ENDIF
(  171) IF (INIVER > KFLEV) THEN
(  172)   CALL ABOR1('RIEN : MAX. NUMBER OF LEVEL IN MODEL TOO SMALL !')
(  173) ENDIF
(  174) # 175 "rien.F90"
(  175) !*       2.    Preliminary tests
(  176) !              -----------------
(  177) # 178 "rien.F90"
(  178) !              Test - type of file
(  179) # 180 "rien.F90"
(  180) IF(ITYPTR < 0) THEN
(  181)   WRITE(KULOUT,*) 'YOU ARE USING A FILE ALADIN ',&
(  182)    & 'WHILE THE MODEL EXPECTS A FILE ARPEGE'  
(  183)   CALL ABOR1('RIEN: ABOR1 CALLED 2a')
(  184) ENDIF
(  185) # 186 "rien.F90"
(  186) !              Test - type of collocation grid
(  187) # 188 "rien.F90"
(  188) IF(INLOPA(1) == INLOPA(INT(INLATI/2))) THEN
(  189)   IHTYP = 0
(  190)   WRITE(KULOUT,*) 'FILE HAS REGULAR GRID '
(  191) ELSE
(  192)   IHTYP = 2
(  193)   WRITE(KULOUT,*) 'FILE HAS REDUCED GRID '
(  194) ENDIF
(  195) # 196 "rien.F90"
(  196) !              Poles story
(  197) # 198 "rien.F90"
(  198) ZMUNPOL = 0.9999999999_JPRB
(  199) IF(ZSINLA(1) >= ZMUNPOL) THEN
(  200)   WRITE(KULOUT,*) ' FILE CONTAINS THE POLES '
(  201)   LDFICP = .TRUE.
(  202)   IDGL = INLATI - 2
(  203)   IDGNH = (IDGL+1)/2
(  204) !       The following test ensures that the fields of the file
(  205) !       will be read properly :
(  206)   IF(INLOPA(1) /= INLOPA(2)) THEN
(  207)     WRITE(KULOUT,*) ' FILE ROWS #1 AND #2 DO NOT HAVE THE ',&
(  208)      & 'SAME NUMBER OF LONGITUDES'  
(  209)     WRITE(KULOUT,*) ' THIS MAKES THE MODEL UNABLE TO READ THE '&
(  210)      & ,'FILE PROPERLY'  
(  211)     CALL ABOR1('RIEN: ABOR1 CALLED 2b')
(  212)   ENDIF
(  213) ELSE
(  214)   WRITE(KULOUT,*) ' FILE DOES NOT CONTAINS THE POLES '
(  215)   LDFICP = .FALSE.
(  216)   IDGL = INLATI






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 12

(  217)   IDGNH = (IDGL+1)/2
(  218) ENDIF
(  219) # 220 "rien.F90"
(  220) !              Test - Gaussian or Lobatto truncation
(  221) # 222 "rien.F90"
(  222) IF(LDFICP) THEN
(  223)   ZX1 = 1.0_JPRB - ZSINLA(2)
(  224)   ZX2 = ZSINLA(2) - ZSINLA(3)
(  225)   IF (ZX1 > ZX2) THEN
(  226)     IQUADF = 2
(  227)     WRITE(KULOUT,*) 'FILE HAS LOBATTO QUADRATURE'
(  228)     IF(MOD(INLATI,2) == 0) THEN
(  229)       WRITE(KULOUT,*) ' WARNING ! INLATI IS EVEN !'
(  230)     ENDIF
(  231)   ELSE
(  232)     IQUADF = 1
(  233)     WRITE(KULOUT,*) 'FILE HAS GAUSSIAN QUADRATURE'
(  234)     IF(MOD(INLATI,2) == 1) THEN
(  235)       WRITE(KULOUT,*) ' WARNING ! INLATI IS ODD !'
(  236)     ENDIF
(  237)   ENDIF
(  238) ELSE
(  239)   IQUADF = 1
(  240)   WRITE(KULOUT,*) 'FILE HAS GAUSSIAN QUADRATURE'
(  241)   IF(MOD(INLATI,2) == 1) THEN
(  242)     WRITE(KULOUT,*) ' WARNING ! INLATI IS ODD !'
(  243)   ENDIF
(  244) ENDIF
(  245) # 248 "rien.F90"
(  248) !*       4.    Read information from file (extracted from CHIEN) 
(  249) # 250 "rien.F90"
(  250) !*      4.1  Pole of dilatation, stretching, truncation, coef. A, B
(  251) # 252 "rien.F90"
(  252)   KHTYP  = IHTYP
(  253)   KQUAD  = IQUADF
(  254)   KTYPTR = ITYPTR
(  255)   PCODIL = ZCODIL
(  256)   PSLAPO = ZSLAPO
(  257)   PLOCEN = SIGN(1.0_JPRB,ZSLOPO)*ACOS(ZCLOPO)
(  258)   KTRONC = ITRONC
(  259)   KFLEV  = INIVER
(  260)   PREF   = ZREF
(  261)   DO JLEV = 0,KFLEV
(  262)     PVALH(JLEV) = ZVALH(JLEV)
(  263)     PVBH(JLEV)  = ZVBH(JLEV)
(  264)   ENDDO
(  265) # 266 "rien.F90"
(  266) !*      4.2  Latitudes and longitudes.
(  267) # 268 "rien.F90"
(  268)   KNXLON = INXLON
(  269)   IF(LDFICP) THEN
(  270)     KDGL = IDGL
(  271)     DO JL= 0, IDGNH
(  272)       PSINLA(JL) = ZSINLA(JL+1)
(  273)       KNLOPA(JL) = INLOPA(JL+1)
(  274)       KNOZPA(JL) = INOZPA(JL+1)
(  275)     ENDDO
(  276)     DO JL=0, IDGNH






NVFORTRAN (Version     23.1)          02/24/2023  13:38:36      page 13

(  277)       PSINLA(KDGL+1 - JL) =  - ZSINLA(JL+1)
(  278)       KNLOPA(KDGL+1 - JL) = INLOPA(JL+1)
(  279)       KNOZPA(KDGL+1 - JL) = INOZPA(JL+1)
(  280)     ENDDO
(  281)   ELSE
(  282)     KDGL = IDGL
(  283)     DO JL= 1, IDGNH
(  284)       PSINLA(JL) = ZSINLA(JL)
(  285)       KNLOPA(JL) = INLOPA(JL)
(  286)       KNOZPA(JL) = INOZPA(JL)
(  287)     ENDDO
(  288)     DO JL=1, IDGNH
(  289)       PSINLA(KDGL - JL + 1) =  - ZSINLA(JL)
(  290)       KNLOPA(KDGL - JL + 1) = INLOPA(JL)
(  291)       KNOZPA(KDGL - JL + 1) = INOZPA(JL)
(  292)     ENDDO
(  293)     IF (KDGSA < 1) THEN
(  294)       PSINLA(0) = 1.0_JPRB
(  295)       KNLOPA(0) = INLOPA(1)
(  296)       KNOZPA(0) = INOZPA(1)
(  297)     ENDIF
(  298)     IF (KDGEN > KDGL) THEN
(  299)       PSINLA(KDGL+1) =  - 1.0_JPRB
(  300)       KNLOPA(KDGL+1) = INLOPA(1)
(  301)       KNOZPA(KDGL+1) = INOZPA(1)
(  302)     ENDIF
(  303)   ENDIF
(  304) # 307 "rien.F90"
(  307) DEALLOCATE(INLOPA)
(  308) DEALLOCATE(INOZPA)
(  309) DEALLOCATE(ZSINLA)
(  310) DEALLOCATE(ZVALH)
(  311) DEALLOCATE(ZVBH)
(  312) # 313 "rien.F90"
(  313) !     ------------------------------------------------------------------
(  314) # 315 "rien.F90"
(  315) IF (LHOOK) CALL DR_HOOK('RIEN',1,ZHOOK_HANDLE)
(  316) END SUBROUTINE RIEN
