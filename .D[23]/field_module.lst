


NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: field_module.F90

(    1) ! Rank and shape definitions for simple templating
(    2) !
(    3) ! Note that the ranks encode coneptual dimensions here, eg. FIELD_2D encodes
(    4) ! a surface field and FIELD_3D represents a field with a vertical component.
(    5) 
(    6) 
(    7) 
(    8) MODULE FIELD_MODULE
(    9)   ! The FIELD types provided by this module provide data abstractions that
(   10)   ! decouple data storage in memory from the data views used in thread-parallel
(   11)   ! sections of the code. They are intended to thinly wrap ATLAS_FIELD
(   12)   ! objects and provide additional features that may later be
(   13)   ! incorporated into Atlas. They can also provide backward-compatibility
(   14)   ! for non-Atlas execution modes.
(   15) 
(   16) USE PARKIND1, ONLY: JPIM, JPRB
(   17) USE OML_MOD, ONLY: OML_MAX_THREADS, OML_MY_THREAD
(   18) USE IEEE_ARITHMETIC, ONLY: IEEE_SIGNALING_NAN
(   19) 
(   20) IMPLICIT NONE
(   21) 
(   22) TYPE FIELD_2D
(   23)   ! A FIELD encapsulates a single multi-dimensional array and can
(   24)   ! provide block-indexed "views" of the data for automating the
(   25)   ! allocation and parallel iterration of NPROMA blocks.
(   26) 
(   27)   ! The data view to be used in thread-parallel sections
(   28)   !
(   29)   ! The underlying view pointer is of rank-1, since we always
(   30)   ! the horizontal component as a single dimension.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 3

(   31)   REAL(KIND=JPRB), POINTER :: VIEW(:) => NULL()
(   32) 
(   33)   ! TODO: Atlas-based field data storage field
(   34)   ! TODO: Do we still need to use pointers here?
(   35)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(   36) 
(   37)   ! Storage pointer for non-Atlas backward-compatibility mode
(   38)   !
(   39)   ! The underlying storage pointer has the rank as the dimension,
(   40)   ! where the innermost dimension represents the horizontal and
(   41)   ! the outermost one is the block index.
(   42)   REAL(KIND=JPRB), POINTER :: PTR(:,:) => NULL()
(   43)   REAL(KIND=JPRB), ALLOCATABLE :: DATA(:,:)
(   44) 
(   45)   ! For wrapping discontiguous fields in co-allocated storage
(   46)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(   47)   ! and integer index, to allow block pointer extraction that
(   48)   ! conforms with CUDA device pointers in PGI.
(   49)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:) => NULL()
(   50)   INTEGER(KIND=JPIM) :: FIDX
(   51) 
(   52)   ! A separate data pointer that can be used to create
(   53)   ! a contiguous chunk of host memory to cleanly map to
(   54)   ! device, should the %DATA pointer be discontiguous.
(   55)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:) => NULL()
(   56) 
(   57)   ! Number of blocks used in the data layout
(   58)   INTEGER :: NBLOCKS
(   59) 
(   60)   ! Flag indicating whether this field stores real data
(   61)   LOGICAL :: ACTIVE = .FALSE.
(   62)   ! Flag indicating the use a single block-buffer per thread
(   63)   LOGICAL :: THREAD_BUFFER = .FALSE.
(   64)   ! Flag indicating whether we own the allocated base array
(   65)   LOGICAL :: OWNED = .TRUE.
(   66) 
(   67)   INTEGER(KIND=JPIM) :: LBOUNDS (2) = [1, 1]
(   68)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(   69) 
(   70) CONTAINS
(   71) 
(   72)   PROCEDURE :: CLONE => FIELD_2D_CLONE
(   73)   PROCEDURE :: UPDATE_VIEW => FIELD_2D_UPDATE_VIEW
(   74)   PROCEDURE :: EXTRACT_VIEW => FIELD_2D_EXTRACT_VIEW
(   75)   PROCEDURE :: GET_VIEW => FIELD_2D_GET_VIEW
(   76)   PROCEDURE :: FINAL => FIELD_2D_FINAL
(   77) 
(   78)   ! GPU-specific device data transfer API
(   79)   PROCEDURE :: CREATE_DEVICE => FIELD_2D_CREATE_DEVICE
(   80)   PROCEDURE :: UPDATE_DEVICE => FIELD_2D_UPDATE_DEVICE
(   81)   PROCEDURE :: UPDATE_HOST => FIELD_2D_UPDATE_HOST
(   82)   PROCEDURE :: DELETE_DEVICE => FIELD_2D_DELETE_DEVICE
(   83) END TYPE FIELD_2D
(   84) 
(   85) TYPE FIELD_3D
(   86)   ! A FIELD encapsulates a single multi-dimensional array and can
(   87)   ! provide block-indexed "views" of the data for automating the
(   88)   ! allocation and parallel iterration of NPROMA blocks.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 4

(   89) 
(   90)   ! The data view to be used in thread-parallel sections
(   91)   !
(   92)   ! The underlying view pointer is of rank-1, since we always
(   93)   ! the horizontal component as a single dimension.
(   94)   REAL(KIND=JPRB), POINTER :: VIEW(:,:) => NULL()
(   95) 
(   96)   ! TODO: Atlas-based field data storage field
(   97)   ! TODO: Do we still need to use pointers here?
(   98)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(   99) 
(  100)   ! Storage pointer for non-Atlas backward-compatibility mode
(  101)   !
(  102)   ! The underlying storage pointer has the rank as the dimension,
(  103)   ! where the innermost dimension represents the horizontal and
(  104)   ! the outermost one is the block index.
(  105)   REAL(KIND=JPRB), POINTER :: PTR(:,:,:) => NULL()
(  106)   REAL(KIND=JPRB), ALLOCATABLE :: DATA(:,:,:)
(  107) 
(  108)   ! For wrapping discontiguous fields in co-allocated storage
(  109)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  110)   ! and integer index, to allow block pointer extraction that
(  111)   ! conforms with CUDA device pointers in PGI.
(  112)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:) => NULL()
(  113)   INTEGER(KIND=JPIM) :: FIDX
(  114) 
(  115)   ! A separate data pointer that can be used to create
(  116)   ! a contiguous chunk of host memory to cleanly map to
(  117)   ! device, should the %DATA pointer be discontiguous.
(  118)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:) => NULL()
(  119) 
(  120)   ! Number of blocks used in the data layout
(  121)   INTEGER :: NBLOCKS
(  122) 
(  123)   ! Flag indicating whether this field stores real data
(  124)   LOGICAL :: ACTIVE = .FALSE.
(  125)   ! Flag indicating the use a single block-buffer per thread
(  126)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  127)   ! Flag indicating whether we own the allocated base array
(  128)   LOGICAL :: OWNED = .TRUE.
(  129) 
(  130)   INTEGER(KIND=JPIM) :: LBOUNDS (3) = [1, 1, 1]
(  131)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  132) 
(  133) CONTAINS
(  134) 
(  135)   PROCEDURE :: CLONE => FIELD_3D_CLONE
(  136)   PROCEDURE :: UPDATE_VIEW => FIELD_3D_UPDATE_VIEW
(  137)   PROCEDURE :: EXTRACT_VIEW => FIELD_3D_EXTRACT_VIEW
(  138)   PROCEDURE :: GET_VIEW => FIELD_3D_GET_VIEW
(  139)   PROCEDURE :: FINAL => FIELD_3D_FINAL
(  140) 
(  141)   ! GPU-specific device data transfer API
(  142)   PROCEDURE :: CREATE_DEVICE => FIELD_3D_CREATE_DEVICE
(  143)   PROCEDURE :: UPDATE_DEVICE => FIELD_3D_UPDATE_DEVICE
(  144)   PROCEDURE :: UPDATE_HOST => FIELD_3D_UPDATE_HOST
(  145)   PROCEDURE :: DELETE_DEVICE => FIELD_3D_DELETE_DEVICE
(  146) END TYPE FIELD_3D






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 5

(  147) 
(  148) TYPE FIELD_4D
(  149)   ! A FIELD encapsulates a single multi-dimensional array and can
(  150)   ! provide block-indexed "views" of the data for automating the
(  151)   ! allocation and parallel iterration of NPROMA blocks.
(  152) 
(  153)   ! The data view to be used in thread-parallel sections
(  154)   !
(  155)   ! The underlying view pointer is of rank-1, since we always
(  156)   ! the horizontal component as a single dimension.
(  157)   REAL(KIND=JPRB), POINTER :: VIEW(:,:,:) => NULL()
(  158) 
(  159)   ! TODO: Atlas-based field data storage field
(  160)   ! TODO: Do we still need to use pointers here?
(  161)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  162) 
(  163)   ! Storage pointer for non-Atlas backward-compatibility mode
(  164)   !
(  165)   ! The underlying storage pointer has the rank as the dimension,
(  166)   ! where the innermost dimension represents the horizontal and
(  167)   ! the outermost one is the block index.
(  168)   REAL(KIND=JPRB), POINTER :: PTR(:,:,:,:) => NULL()
(  169)   REAL(KIND=JPRB), ALLOCATABLE :: DATA(:,:,:,:)
(  170) 
(  171)   ! For wrapping discontiguous fields in co-allocated storage
(  172)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  173)   ! and integer index, to allow block pointer extraction that
(  174)   ! conforms with CUDA device pointers in PGI.
(  175)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:) => NULL()
(  176)   INTEGER(KIND=JPIM) :: FIDX
(  177) 
(  178)   ! A separate data pointer that can be used to create
(  179)   ! a contiguous chunk of host memory to cleanly map to
(  180)   ! device, should the %DATA pointer be discontiguous.
(  181)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:) => NULL()
(  182) 
(  183)   ! Number of blocks used in the data layout
(  184)   INTEGER :: NBLOCKS
(  185) 
(  186)   ! Flag indicating whether this field stores real data
(  187)   LOGICAL :: ACTIVE = .FALSE.
(  188)   ! Flag indicating the use a single block-buffer per thread
(  189)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  190)   ! Flag indicating whether we own the allocated base array
(  191)   LOGICAL :: OWNED = .TRUE.
(  192) 
(  193)   INTEGER(KIND=JPIM) :: LBOUNDS (4) = [1, 1, 1, 1]
(  194)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  195) 
(  196) CONTAINS
(  197) 
(  198)   PROCEDURE :: CLONE => FIELD_4D_CLONE
(  199)   PROCEDURE :: UPDATE_VIEW => FIELD_4D_UPDATE_VIEW
(  200)   PROCEDURE :: EXTRACT_VIEW => FIELD_4D_EXTRACT_VIEW
(  201)   PROCEDURE :: GET_VIEW => FIELD_4D_GET_VIEW
(  202)   PROCEDURE :: FINAL => FIELD_4D_FINAL
(  203) 
(  204)   ! GPU-specific device data transfer API






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 6

(  205)   PROCEDURE :: CREATE_DEVICE => FIELD_4D_CREATE_DEVICE
(  206)   PROCEDURE :: UPDATE_DEVICE => FIELD_4D_UPDATE_DEVICE
(  207)   PROCEDURE :: UPDATE_HOST => FIELD_4D_UPDATE_HOST
(  208)   PROCEDURE :: DELETE_DEVICE => FIELD_4D_DELETE_DEVICE
(  209) END TYPE FIELD_4D
(  210) 
(  211) TYPE FIELD_5D
(  212)   ! A FIELD encapsulates a single multi-dimensional array and can
(  213)   ! provide block-indexed "views" of the data for automating the
(  214)   ! allocation and parallel iterration of NPROMA blocks.
(  215) 
(  216)   ! The data view to be used in thread-parallel sections
(  217)   !
(  218)   ! The underlying view pointer is of rank-1, since we always
(  219)   ! the horizontal component as a single dimension.
(  220)   REAL(KIND=JPRB), POINTER :: VIEW(:,:,:,:) => NULL()
(  221) 
(  222)   ! TODO: Atlas-based field data storage field
(  223)   ! TODO: Do we still need to use pointers here?
(  224)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  225) 
(  226)   ! Storage pointer for non-Atlas backward-compatibility mode
(  227)   !
(  228)   ! The underlying storage pointer has the rank as the dimension,
(  229)   ! where the innermost dimension represents the horizontal and
(  230)   ! the outermost one is the block index.
(  231)   REAL(KIND=JPRB), POINTER :: PTR(:,:,:,:,:) => NULL()
(  232)   REAL(KIND=JPRB), ALLOCATABLE :: DATA(:,:,:,:,:)
(  233) 
(  234)   ! For wrapping discontiguous fields in co-allocated storage
(  235)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  236)   ! and integer index, to allow block pointer extraction that
(  237)   ! conforms with CUDA device pointers in PGI.
(  238)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:,:) => NULL()
(  239)   INTEGER(KIND=JPIM) :: FIDX
(  240) 
(  241)   ! A separate data pointer that can be used to create
(  242)   ! a contiguous chunk of host memory to cleanly map to
(  243)   ! device, should the %DATA pointer be discontiguous.
(  244)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:) => NULL()
(  245) 
(  246)   ! Number of blocks used in the data layout
(  247)   INTEGER :: NBLOCKS
(  248) 
(  249)   ! Flag indicating whether this field stores real data
(  250)   LOGICAL :: ACTIVE = .FALSE.
(  251)   ! Flag indicating the use a single block-buffer per thread
(  252)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  253)   ! Flag indicating whether we own the allocated base array
(  254)   LOGICAL :: OWNED = .TRUE.
(  255) 
(  256)   INTEGER(KIND=JPIM) :: LBOUNDS (5) = [1, 1, 1, 1, 1]
(  257)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  258) 
(  259) CONTAINS
(  260) 
(  261)   PROCEDURE :: CLONE => FIELD_5D_CLONE
(  262)   PROCEDURE :: UPDATE_VIEW => FIELD_5D_UPDATE_VIEW






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 7

(  263)   PROCEDURE :: EXTRACT_VIEW => FIELD_5D_EXTRACT_VIEW
(  264)   PROCEDURE :: GET_VIEW => FIELD_5D_GET_VIEW
(  265)   PROCEDURE :: FINAL => FIELD_5D_FINAL
(  266) 
(  267)   ! GPU-specific device data transfer API
(  268)   PROCEDURE :: CREATE_DEVICE => FIELD_5D_CREATE_DEVICE
(  269)   PROCEDURE :: UPDATE_DEVICE => FIELD_5D_UPDATE_DEVICE
(  270)   PROCEDURE :: UPDATE_HOST => FIELD_5D_UPDATE_HOST
(  271)   PROCEDURE :: DELETE_DEVICE => FIELD_5D_DELETE_DEVICE
(  272) END TYPE FIELD_5D
(  273) 
(  274) TYPE FIELD_INT2D
(  275)   ! A FIELD encapsulates a single multi-dimensional array and can
(  276)   ! provide block-indexed "views" of the data for automating the
(  277)   ! allocation and parallel iterration of NPROMA blocks.
(  278) 
(  279)   ! The data view to be used in thread-parallel sections
(  280)   !
(  281)   ! The underlying view pointer is of rank-1, since we always
(  282)   ! the horizontal component as a single dimension.
(  283)   INTEGER(KIND=JPIM), POINTER :: VIEW(:) => NULL()
(  284) 
(  285)   ! TODO: Atlas-based field data storage field
(  286)   ! TODO: Do we still need to use pointers here?
(  287)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  288) 
(  289)   ! Storage pointer for non-Atlas backward-compatibility mode
(  290)   !
(  291)   ! The underlying storage pointer has the rank as the dimension,
(  292)   ! where the innermost dimension represents the horizontal and
(  293)   ! the outermost one is the block index.
(  294)   INTEGER(KIND=JPIM), POINTER :: PTR(:,:) => NULL()
(  295)   INTEGER(KIND=JPIM), ALLOCATABLE :: DATA(:,:)
(  296) 
(  297)   ! For wrapping discontiguous fields in co-allocated storage
(  298)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  299)   ! and integer index, to allow block pointer extraction that
(  300)   ! conforms with CUDA device pointers in PGI.
(  301)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:) => NULL()
(  302)   INTEGER(KIND=JPIM) :: FIDX
(  303) 
(  304)   ! A separate data pointer that can be used to create
(  305)   ! a contiguous chunk of host memory to cleanly map to
(  306)   ! device, should the %DATA pointer be discontiguous.
(  307)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:) => NULL()
(  308) 
(  309)   ! Number of blocks used in the data layout
(  310)   INTEGER :: NBLOCKS
(  311) 
(  312)   ! Flag indicating whether this field stores real data
(  313)   LOGICAL :: ACTIVE = .FALSE.
(  314)   ! Flag indicating the use a single block-buffer per thread
(  315)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  316)   ! Flag indicating whether we own the allocated base array
(  317)   LOGICAL :: OWNED = .TRUE.
(  318) 
(  319)   INTEGER(KIND=JPIM) :: LBOUNDS (2) = [1, 1]
(  320)   INTEGER(KIND=JPIM) :: ISTATUS = 0






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 8

(  321) 
(  322) CONTAINS
(  323) 
(  324)   PROCEDURE :: CLONE => FIELD_INT2D_CLONE
(  325)   PROCEDURE :: UPDATE_VIEW => FIELD_INT2D_UPDATE_VIEW
(  326)   PROCEDURE :: EXTRACT_VIEW => FIELD_INT2D_EXTRACT_VIEW
(  327)   PROCEDURE :: GET_VIEW => FIELD_INT2D_GET_VIEW
(  328)   PROCEDURE :: FINAL => FIELD_INT2D_FINAL
(  329) 
(  330)   ! GPU-specific device data transfer API
(  331)   PROCEDURE :: CREATE_DEVICE => FIELD_INT2D_CREATE_DEVICE
(  332)   PROCEDURE :: UPDATE_DEVICE => FIELD_INT2D_UPDATE_DEVICE
(  333)   PROCEDURE :: UPDATE_HOST => FIELD_INT2D_UPDATE_HOST
(  334)   PROCEDURE :: DELETE_DEVICE => FIELD_INT2D_DELETE_DEVICE
(  335) END TYPE FIELD_INT2D
(  336) 
(  337) TYPE FIELD_INT3D
(  338)   ! A FIELD encapsulates a single multi-dimensional array and can
(  339)   ! provide block-indexed "views" of the data for automating the
(  340)   ! allocation and parallel iterration of NPROMA blocks.
(  341) 
(  342)   ! The data view to be used in thread-parallel sections
(  343)   !
(  344)   ! The underlying view pointer is of rank-1, since we always
(  345)   ! the horizontal component as a single dimension.
(  346)   INTEGER(KIND=JPIM), POINTER :: VIEW(:,:) => NULL()
(  347) 
(  348)   ! TODO: Atlas-based field data storage field
(  349)   ! TODO: Do we still need to use pointers here?
(  350)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  351) 
(  352)   ! Storage pointer for non-Atlas backward-compatibility mode
(  353)   !
(  354)   ! The underlying storage pointer has the rank as the dimension,
(  355)   ! where the innermost dimension represents the horizontal and
(  356)   ! the outermost one is the block index.
(  357)   INTEGER(KIND=JPIM), POINTER :: PTR(:,:,:) => NULL()
(  358)   INTEGER(KIND=JPIM), ALLOCATABLE :: DATA(:,:,:)
(  359) 
(  360)   ! For wrapping discontiguous fields in co-allocated storage
(  361)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  362)   ! and integer index, to allow block pointer extraction that
(  363)   ! conforms with CUDA device pointers in PGI.
(  364)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:) => NULL()
(  365)   INTEGER(KIND=JPIM) :: FIDX
(  366) 
(  367)   ! A separate data pointer that can be used to create
(  368)   ! a contiguous chunk of host memory to cleanly map to
(  369)   ! device, should the %DATA pointer be discontiguous.
(  370)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:) => NULL()
(  371) 
(  372)   ! Number of blocks used in the data layout
(  373)   INTEGER :: NBLOCKS
(  374) 
(  375)   ! Flag indicating whether this field stores real data
(  376)   LOGICAL :: ACTIVE = .FALSE.
(  377)   ! Flag indicating the use a single block-buffer per thread
(  378)   LOGICAL :: THREAD_BUFFER = .FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 9

(  379)   ! Flag indicating whether we own the allocated base array
(  380)   LOGICAL :: OWNED = .TRUE.
(  381) 
(  382)   INTEGER(KIND=JPIM) :: LBOUNDS (3) = [1, 1, 1]
(  383)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  384) 
(  385) CONTAINS
(  386) 
(  387)   PROCEDURE :: CLONE => FIELD_INT3D_CLONE
(  388)   PROCEDURE :: UPDATE_VIEW => FIELD_INT3D_UPDATE_VIEW
(  389)   PROCEDURE :: EXTRACT_VIEW => FIELD_INT3D_EXTRACT_VIEW
(  390)   PROCEDURE :: GET_VIEW => FIELD_INT3D_GET_VIEW
(  391)   PROCEDURE :: FINAL => FIELD_INT3D_FINAL
(  392) 
(  393)   ! GPU-specific device data transfer API
(  394)   PROCEDURE :: CREATE_DEVICE => FIELD_INT3D_CREATE_DEVICE
(  395)   PROCEDURE :: UPDATE_DEVICE => FIELD_INT3D_UPDATE_DEVICE
(  396)   PROCEDURE :: UPDATE_HOST => FIELD_INT3D_UPDATE_HOST
(  397)   PROCEDURE :: DELETE_DEVICE => FIELD_INT3D_DELETE_DEVICE
(  398) END TYPE FIELD_INT3D
(  399) 
(  400) TYPE FIELD_INT4D
(  401)   ! A FIELD encapsulates a single multi-dimensional array and can
(  402)   ! provide block-indexed "views" of the data for automating the
(  403)   ! allocation and parallel iterration of NPROMA blocks.
(  404) 
(  405)   ! The data view to be used in thread-parallel sections
(  406)   !
(  407)   ! The underlying view pointer is of rank-1, since we always
(  408)   ! the horizontal component as a single dimension.
(  409)   INTEGER(KIND=JPIM), POINTER :: VIEW(:,:,:) => NULL()
(  410) 
(  411)   ! TODO: Atlas-based field data storage field
(  412)   ! TODO: Do we still need to use pointers here?
(  413)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  414) 
(  415)   ! Storage pointer for non-Atlas backward-compatibility mode
(  416)   !
(  417)   ! The underlying storage pointer has the rank as the dimension,
(  418)   ! where the innermost dimension represents the horizontal and
(  419)   ! the outermost one is the block index.
(  420)   INTEGER(KIND=JPIM), POINTER :: PTR(:,:,:,:) => NULL()
(  421)   INTEGER(KIND=JPIM), ALLOCATABLE :: DATA(:,:,:,:)
(  422) 
(  423)   ! For wrapping discontiguous fields in co-allocated storage
(  424)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  425)   ! and integer index, to allow block pointer extraction that
(  426)   ! conforms with CUDA device pointers in PGI.
(  427)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:) => NULL()
(  428)   INTEGER(KIND=JPIM) :: FIDX
(  429) 
(  430)   ! A separate data pointer that can be used to create
(  431)   ! a contiguous chunk of host memory to cleanly map to
(  432)   ! device, should the %DATA pointer be discontiguous.
(  433)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:) => NULL()
(  434) 
(  435)   ! Number of blocks used in the data layout
(  436)   INTEGER :: NBLOCKS






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 10

(  437) 
(  438)   ! Flag indicating whether this field stores real data
(  439)   LOGICAL :: ACTIVE = .FALSE.
(  440)   ! Flag indicating the use a single block-buffer per thread
(  441)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  442)   ! Flag indicating whether we own the allocated base array
(  443)   LOGICAL :: OWNED = .TRUE.
(  444) 
(  445)   INTEGER(KIND=JPIM) :: LBOUNDS (4) = [1, 1, 1, 1]
(  446)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  447) 
(  448) CONTAINS
(  449) 
(  450)   PROCEDURE :: CLONE => FIELD_INT4D_CLONE
(  451)   PROCEDURE :: UPDATE_VIEW => FIELD_INT4D_UPDATE_VIEW
(  452)   PROCEDURE :: EXTRACT_VIEW => FIELD_INT4D_EXTRACT_VIEW
(  453)   PROCEDURE :: GET_VIEW => FIELD_INT4D_GET_VIEW
(  454)   PROCEDURE :: FINAL => FIELD_INT4D_FINAL
(  455) 
(  456)   ! GPU-specific device data transfer API
(  457)   PROCEDURE :: CREATE_DEVICE => FIELD_INT4D_CREATE_DEVICE
(  458)   PROCEDURE :: UPDATE_DEVICE => FIELD_INT4D_UPDATE_DEVICE
(  459)   PROCEDURE :: UPDATE_HOST => FIELD_INT4D_UPDATE_HOST
(  460)   PROCEDURE :: DELETE_DEVICE => FIELD_INT4D_DELETE_DEVICE
(  461) END TYPE FIELD_INT4D
(  462) 
(  463) TYPE FIELD_INT5D
(  464)   ! A FIELD encapsulates a single multi-dimensional array and can
(  465)   ! provide block-indexed "views" of the data for automating the
(  466)   ! allocation and parallel iterration of NPROMA blocks.
(  467) 
(  468)   ! The data view to be used in thread-parallel sections
(  469)   !
(  470)   ! The underlying view pointer is of rank-1, since we always
(  471)   ! the horizontal component as a single dimension.
(  472)   INTEGER(KIND=JPIM), POINTER :: VIEW(:,:,:,:) => NULL()
(  473) 
(  474)   ! TODO: Atlas-based field data storage field
(  475)   ! TODO: Do we still need to use pointers here?
(  476)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  477) 
(  478)   ! Storage pointer for non-Atlas backward-compatibility mode
(  479)   !
(  480)   ! The underlying storage pointer has the rank as the dimension,
(  481)   ! where the innermost dimension represents the horizontal and
(  482)   ! the outermost one is the block index.
(  483)   INTEGER(KIND=JPIM), POINTER :: PTR(:,:,:,:,:) => NULL()
(  484)   INTEGER(KIND=JPIM), ALLOCATABLE :: DATA(:,:,:,:,:)
(  485) 
(  486)   ! For wrapping discontiguous fields in co-allocated storage
(  487)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  488)   ! and integer index, to allow block pointer extraction that
(  489)   ! conforms with CUDA device pointers in PGI.
(  490)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:,:) => NULL()
(  491)   INTEGER(KIND=JPIM) :: FIDX
(  492) 
(  493)   ! A separate data pointer that can be used to create
(  494)   ! a contiguous chunk of host memory to cleanly map to






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 11

(  495)   ! device, should the %DATA pointer be discontiguous.
(  496)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:) => NULL()
(  497) 
(  498)   ! Number of blocks used in the data layout
(  499)   INTEGER :: NBLOCKS
(  500) 
(  501)   ! Flag indicating whether this field stores real data
(  502)   LOGICAL :: ACTIVE = .FALSE.
(  503)   ! Flag indicating the use a single block-buffer per thread
(  504)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  505)   ! Flag indicating whether we own the allocated base array
(  506)   LOGICAL :: OWNED = .TRUE.
(  507) 
(  508)   INTEGER(KIND=JPIM) :: LBOUNDS (5) = [1, 1, 1, 1, 1]
(  509)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  510) 
(  511) CONTAINS
(  512) 
(  513)   PROCEDURE :: CLONE => FIELD_INT5D_CLONE
(  514)   PROCEDURE :: UPDATE_VIEW => FIELD_INT5D_UPDATE_VIEW
(  515)   PROCEDURE :: EXTRACT_VIEW => FIELD_INT5D_EXTRACT_VIEW
(  516)   PROCEDURE :: GET_VIEW => FIELD_INT5D_GET_VIEW
(  517)   PROCEDURE :: FINAL => FIELD_INT5D_FINAL
(  518) 
(  519)   ! GPU-specific device data transfer API
(  520)   PROCEDURE :: CREATE_DEVICE => FIELD_INT5D_CREATE_DEVICE
(  521)   PROCEDURE :: UPDATE_DEVICE => FIELD_INT5D_UPDATE_DEVICE
(  522)   PROCEDURE :: UPDATE_HOST => FIELD_INT5D_UPDATE_HOST
(  523)   PROCEDURE :: DELETE_DEVICE => FIELD_INT5D_DELETE_DEVICE
(  524) END TYPE FIELD_INT5D
(  525) 
(  526) TYPE FIELD_LOG2D
(  527)   ! A FIELD encapsulates a single multi-dimensional array and can
(  528)   ! provide block-indexed "views" of the data for automating the
(  529)   ! allocation and parallel iterration of NPROMA blocks.
(  530) 
(  531)   ! The data view to be used in thread-parallel sections
(  532)   !
(  533)   ! The underlying view pointer is of rank-1, since we always
(  534)   ! the horizontal component as a single dimension.
(  535)   LOGICAL, POINTER :: VIEW(:) => NULL()
(  536) 
(  537)   ! TODO: Atlas-based field data storage field
(  538)   ! TODO: Do we still need to use pointers here?
(  539)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  540) 
(  541)   ! Storage pointer for non-Atlas backward-compatibility mode
(  542)   !
(  543)   ! The underlying storage pointer has the rank as the dimension,
(  544)   ! where the innermost dimension represents the horizontal and
(  545)   ! the outermost one is the block index.
(  546)   LOGICAL, POINTER :: PTR(:,:) => NULL()
(  547)   LOGICAL, ALLOCATABLE :: DATA(:,:)
(  548) 
(  549)   ! For wrapping discontiguous fields in co-allocated storage
(  550)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  551)   ! and integer index, to allow block pointer extraction that
(  552)   ! conforms with CUDA device pointers in PGI.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 12

(  553)   LOGICAL, POINTER, CONTIGUOUS :: BASE_PTR(:,:,:) => NULL()
(  554)   INTEGER(KIND=JPIM) :: FIDX
(  555) 
(  556)   ! A separate data pointer that can be used to create
(  557)   ! a contiguous chunk of host memory to cleanly map to
(  558)   ! device, should the %DATA pointer be discontiguous.
(  559)   LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:) => NULL()
(  560) 
(  561)   ! Number of blocks used in the data layout
(  562)   INTEGER :: NBLOCKS
(  563) 
(  564)   ! Flag indicating whether this field stores real data
(  565)   LOGICAL :: ACTIVE = .FALSE.
(  566)   ! Flag indicating the use a single block-buffer per thread
(  567)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  568)   ! Flag indicating whether we own the allocated base array
(  569)   LOGICAL :: OWNED = .TRUE.
(  570) 
(  571)   INTEGER(KIND=JPIM) :: LBOUNDS (2) = [1, 1]
(  572)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  573) 
(  574) CONTAINS
(  575) 
(  576)   PROCEDURE :: CLONE => FIELD_LOG2D_CLONE
(  577)   PROCEDURE :: UPDATE_VIEW => FIELD_LOG2D_UPDATE_VIEW
(  578)   PROCEDURE :: EXTRACT_VIEW => FIELD_LOG2D_EXTRACT_VIEW
(  579)   PROCEDURE :: GET_VIEW => FIELD_LOG2D_GET_VIEW
(  580)   PROCEDURE :: FINAL => FIELD_LOG2D_FINAL
(  581) 
(  582)   ! GPU-specific device data transfer API
(  583)   PROCEDURE :: CREATE_DEVICE => FIELD_LOG2D_CREATE_DEVICE
(  584)   PROCEDURE :: UPDATE_DEVICE => FIELD_LOG2D_UPDATE_DEVICE
(  585)   PROCEDURE :: UPDATE_HOST => FIELD_LOG2D_UPDATE_HOST
(  586)   PROCEDURE :: DELETE_DEVICE => FIELD_LOG2D_DELETE_DEVICE
(  587) END TYPE FIELD_LOG2D
(  588) 
(  589) TYPE FIELD_LOG3D
(  590)   ! A FIELD encapsulates a single multi-dimensional array and can
(  591)   ! provide block-indexed "views" of the data for automating the
(  592)   ! allocation and parallel iterration of NPROMA blocks.
(  593) 
(  594)   ! The data view to be used in thread-parallel sections
(  595)   !
(  596)   ! The underlying view pointer is of rank-1, since we always
(  597)   ! the horizontal component as a single dimension.
(  598)   LOGICAL, POINTER :: VIEW(:,:) => NULL()
(  599) 
(  600)   ! TODO: Atlas-based field data storage field
(  601)   ! TODO: Do we still need to use pointers here?
(  602)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  603) 
(  604)   ! Storage pointer for non-Atlas backward-compatibility mode
(  605)   !
(  606)   ! The underlying storage pointer has the rank as the dimension,
(  607)   ! where the innermost dimension represents the horizontal and
(  608)   ! the outermost one is the block index.
(  609)   LOGICAL, POINTER :: PTR(:,:,:) => NULL()
(  610)   LOGICAL, ALLOCATABLE :: DATA(:,:,:)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 13

(  611) 
(  612)   ! For wrapping discontiguous fields in co-allocated storage
(  613)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  614)   ! and integer index, to allow block pointer extraction that
(  615)   ! conforms with CUDA device pointers in PGI.
(  616)   LOGICAL, POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:) => NULL()
(  617)   INTEGER(KIND=JPIM) :: FIDX
(  618) 
(  619)   ! A separate data pointer that can be used to create
(  620)   ! a contiguous chunk of host memory to cleanly map to
(  621)   ! device, should the %DATA pointer be discontiguous.
(  622)   LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:) => NULL()
(  623) 
(  624)   ! Number of blocks used in the data layout
(  625)   INTEGER :: NBLOCKS
(  626) 
(  627)   ! Flag indicating whether this field stores real data
(  628)   LOGICAL :: ACTIVE = .FALSE.
(  629)   ! Flag indicating the use a single block-buffer per thread
(  630)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  631)   ! Flag indicating whether we own the allocated base array
(  632)   LOGICAL :: OWNED = .TRUE.
(  633) 
(  634)   INTEGER(KIND=JPIM) :: LBOUNDS (3) = [1, 1, 1]
(  635)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  636) 
(  637) CONTAINS
(  638) 
(  639)   PROCEDURE :: CLONE => FIELD_LOG3D_CLONE
(  640)   PROCEDURE :: UPDATE_VIEW => FIELD_LOG3D_UPDATE_VIEW
(  641)   PROCEDURE :: EXTRACT_VIEW => FIELD_LOG3D_EXTRACT_VIEW
(  642)   PROCEDURE :: GET_VIEW => FIELD_LOG3D_GET_VIEW
(  643)   PROCEDURE :: FINAL => FIELD_LOG3D_FINAL
(  644) 
(  645)   ! GPU-specific device data transfer API
(  646)   PROCEDURE :: CREATE_DEVICE => FIELD_LOG3D_CREATE_DEVICE
(  647)   PROCEDURE :: UPDATE_DEVICE => FIELD_LOG3D_UPDATE_DEVICE
(  648)   PROCEDURE :: UPDATE_HOST => FIELD_LOG3D_UPDATE_HOST
(  649)   PROCEDURE :: DELETE_DEVICE => FIELD_LOG3D_DELETE_DEVICE
(  650) END TYPE FIELD_LOG3D
(  651) 
(  652) TYPE FIELD_LOG4D
(  653)   ! A FIELD encapsulates a single multi-dimensional array and can
(  654)   ! provide block-indexed "views" of the data for automating the
(  655)   ! allocation and parallel iterration of NPROMA blocks.
(  656) 
(  657)   ! The data view to be used in thread-parallel sections
(  658)   !
(  659)   ! The underlying view pointer is of rank-1, since we always
(  660)   ! the horizontal component as a single dimension.
(  661)   LOGICAL, POINTER :: VIEW(:,:,:) => NULL()
(  662) 
(  663)   ! TODO: Atlas-based field data storage field
(  664)   ! TODO: Do we still need to use pointers here?
(  665)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  666) 
(  667)   ! Storage pointer for non-Atlas backward-compatibility mode
(  668)   !






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 14

(  669)   ! The underlying storage pointer has the rank as the dimension,
(  670)   ! where the innermost dimension represents the horizontal and
(  671)   ! the outermost one is the block index.
(  672)   LOGICAL, POINTER :: PTR(:,:,:,:) => NULL()
(  673)   LOGICAL, ALLOCATABLE :: DATA(:,:,:,:)
(  674) 
(  675)   ! For wrapping discontiguous fields in co-allocated storage
(  676)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  677)   ! and integer index, to allow block pointer extraction that
(  678)   ! conforms with CUDA device pointers in PGI.
(  679)   LOGICAL, POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:) => NULL()
(  680)   INTEGER(KIND=JPIM) :: FIDX
(  681) 
(  682)   ! A separate data pointer that can be used to create
(  683)   ! a contiguous chunk of host memory to cleanly map to
(  684)   ! device, should the %DATA pointer be discontiguous.
(  685)   LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:) => NULL()
(  686) 
(  687)   ! Number of blocks used in the data layout
(  688)   INTEGER :: NBLOCKS
(  689) 
(  690)   ! Flag indicating whether this field stores real data
(  691)   LOGICAL :: ACTIVE = .FALSE.
(  692)   ! Flag indicating the use a single block-buffer per thread
(  693)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  694)   ! Flag indicating whether we own the allocated base array
(  695)   LOGICAL :: OWNED = .TRUE.
(  696) 
(  697)   INTEGER(KIND=JPIM) :: LBOUNDS (4) = [1, 1, 1, 1]
(  698)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  699) 
(  700) CONTAINS
(  701) 
(  702)   PROCEDURE :: CLONE => FIELD_LOG4D_CLONE
(  703)   PROCEDURE :: UPDATE_VIEW => FIELD_LOG4D_UPDATE_VIEW
(  704)   PROCEDURE :: EXTRACT_VIEW => FIELD_LOG4D_EXTRACT_VIEW
(  705)   PROCEDURE :: GET_VIEW => FIELD_LOG4D_GET_VIEW
(  706)   PROCEDURE :: FINAL => FIELD_LOG4D_FINAL
(  707) 
(  708)   ! GPU-specific device data transfer API
(  709)   PROCEDURE :: CREATE_DEVICE => FIELD_LOG4D_CREATE_DEVICE
(  710)   PROCEDURE :: UPDATE_DEVICE => FIELD_LOG4D_UPDATE_DEVICE
(  711)   PROCEDURE :: UPDATE_HOST => FIELD_LOG4D_UPDATE_HOST
(  712)   PROCEDURE :: DELETE_DEVICE => FIELD_LOG4D_DELETE_DEVICE
(  713) END TYPE FIELD_LOG4D
(  714) 
(  715) TYPE FIELD_LOG5D
(  716)   ! A FIELD encapsulates a single multi-dimensional array and can
(  717)   ! provide block-indexed "views" of the data for automating the
(  718)   ! allocation and parallel iterration of NPROMA blocks.
(  719) 
(  720)   ! The data view to be used in thread-parallel sections
(  721)   !
(  722)   ! The underlying view pointer is of rank-1, since we always
(  723)   ! the horizontal component as a single dimension.
(  724)   LOGICAL, POINTER :: VIEW(:,:,:,:) => NULL()
(  725) 
(  726)   ! TODO: Atlas-based field data storage field






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 15

(  727)   ! TODO: Do we still need to use pointers here?
(  728)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  729) 
(  730)   ! Storage pointer for non-Atlas backward-compatibility mode
(  731)   !
(  732)   ! The underlying storage pointer has the rank as the dimension,
(  733)   ! where the innermost dimension represents the horizontal and
(  734)   ! the outermost one is the block index.
(  735)   LOGICAL, POINTER :: PTR(:,:,:,:,:) => NULL()
(  736)   LOGICAL, ALLOCATABLE :: DATA(:,:,:,:,:)
(  737) 
(  738)   ! For wrapping discontiguous fields in co-allocated storage
(  739)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  740)   ! and integer index, to allow block pointer extraction that
(  741)   ! conforms with CUDA device pointers in PGI.
(  742)   LOGICAL, POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:,:) => NULL()
(  743)   INTEGER(KIND=JPIM) :: FIDX
(  744) 
(  745)   ! A separate data pointer that can be used to create
(  746)   ! a contiguous chunk of host memory to cleanly map to
(  747)   ! device, should the %DATA pointer be discontiguous.
(  748)   LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:) => NULL()
(  749) 
(  750)   ! Number of blocks used in the data layout
(  751)   INTEGER :: NBLOCKS
(  752) 
(  753)   ! Flag indicating whether this field stores real data
(  754)   LOGICAL :: ACTIVE = .FALSE.
(  755)   ! Flag indicating the use a single block-buffer per thread
(  756)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  757)   ! Flag indicating whether we own the allocated base array
(  758)   LOGICAL :: OWNED = .TRUE.
(  759) 
(  760)   INTEGER(KIND=JPIM) :: LBOUNDS (5) = [1, 1, 1, 1, 1]
(  761)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  762) 
(  763) CONTAINS
(  764) 
(  765)   PROCEDURE :: CLONE => FIELD_LOG5D_CLONE
(  766)   PROCEDURE :: UPDATE_VIEW => FIELD_LOG5D_UPDATE_VIEW
(  767)   PROCEDURE :: EXTRACT_VIEW => FIELD_LOG5D_EXTRACT_VIEW
(  768)   PROCEDURE :: GET_VIEW => FIELD_LOG5D_GET_VIEW
(  769)   PROCEDURE :: FINAL => FIELD_LOG5D_FINAL
(  770) 
(  771)   ! GPU-specific device data transfer API
(  772)   PROCEDURE :: CREATE_DEVICE => FIELD_LOG5D_CREATE_DEVICE
(  773)   PROCEDURE :: UPDATE_DEVICE => FIELD_LOG5D_UPDATE_DEVICE
(  774)   PROCEDURE :: UPDATE_HOST => FIELD_LOG5D_UPDATE_HOST
(  775)   PROCEDURE :: DELETE_DEVICE => FIELD_LOG5D_DELETE_DEVICE
(  776) END TYPE FIELD_LOG5D
(  777) 
(  778) 
(  779) INTEGER (KIND=JPIM), PARAMETER :: NDEVFRESH = B'00000001', NHSTFRESH = B'00000010'
(  780) 
(  781) TYPE FIELD_2D_PTR
(  782)   ! Struct to hold references to field objects
(  783)   TYPE(FIELD_2D), POINTER :: PTR => NULL()
(  784) END TYPE FIELD_2D_PTR






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 16

(  785) 
(  786) TYPE FIELD_2D_VIEW
(  787)   ! Struct to hold array views, so we can make arrays of them
(  788)   REAL(KIND=JPRB), POINTER :: P(:) => NULL()
(  789) END TYPE FIELD_2D_VIEW
(  790) 
(  791) TYPE FIELD_3D_PTR
(  792)   ! Struct to hold references to field objects
(  793)   TYPE(FIELD_3D), POINTER :: PTR => NULL()
(  794) END TYPE FIELD_3D_PTR
(  795) 
(  796) TYPE FIELD_3D_VIEW
(  797)   ! Struct to hold array views, so we can make arrays of them
(  798)   REAL(KIND=JPRB), POINTER :: P(:,:) => NULL()
(  799) END TYPE FIELD_3D_VIEW
(  800) 
(  801) TYPE FIELD_4D_PTR
(  802)   ! Struct to hold references to field objects
(  803)   TYPE(FIELD_4D), POINTER :: PTR => NULL()
(  804) END TYPE FIELD_4D_PTR
(  805) 
(  806) TYPE FIELD_4D_VIEW
(  807)   ! Struct to hold array views, so we can make arrays of them
(  808)   REAL(KIND=JPRB), POINTER :: P(:,:,:) => NULL()
(  809) END TYPE FIELD_4D_VIEW
(  810) 
(  811) TYPE FIELD_5D_PTR
(  812)   ! Struct to hold references to field objects
(  813)   TYPE(FIELD_5D), POINTER :: PTR => NULL()
(  814) END TYPE FIELD_5D_PTR
(  815) 
(  816) TYPE FIELD_5D_VIEW
(  817)   ! Struct to hold array views, so we can make arrays of them
(  818)   REAL(KIND=JPRB), POINTER :: P(:,:,:,:) => NULL()
(  819) END TYPE FIELD_5D_VIEW
(  820) 
(  821) 
(  822) INTERFACE FIELD_2D
(  823)   MODULE PROCEDURE :: FIELD_2D_WRAP
(  824)   MODULE PROCEDURE :: FIELD_2D_WRAP_PACKED
(  825)   ! MODULE PROCEDURE :: FIELD_2D_EMPTY
(  826)   MODULE PROCEDURE :: FIELD_2D_ALLOCATE
(  827) END INTERFACE
(  828) 
(  829) INTERFACE FIELD_3D
(  830)   MODULE PROCEDURE :: FIELD_3D_WRAP
(  831)   MODULE PROCEDURE :: FIELD_3D_WRAP_PACKED
(  832)   ! MODULE PROCEDURE :: FIELD_3D_EMPTY
(  833)   MODULE PROCEDURE :: FIELD_3D_ALLOCATE
(  834) END INTERFACE
(  835) 
(  836) INTERFACE FIELD_4D
(  837)   MODULE PROCEDURE :: FIELD_4D_WRAP
(  838)   MODULE PROCEDURE :: FIELD_4D_WRAP_PACKED
(  839)   ! MODULE PROCEDURE :: FIELD_4D_EMPTY
(  840)   MODULE PROCEDURE :: FIELD_4D_ALLOCATE
(  841) END INTERFACE
(  842) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 17

(  843) INTERFACE FIELD_5D
(  844)   MODULE PROCEDURE :: FIELD_5D_WRAP
(  845)   MODULE PROCEDURE :: FIELD_5D_WRAP_PACKED
(  846)   ! MODULE PROCEDURE :: FIELD_5D_EMPTY
(  847)   MODULE PROCEDURE :: FIELD_5D_ALLOCATE
(  848) END INTERFACE
(  849) 
(  850) INTERFACE FIELD_INT2D
(  851)   MODULE PROCEDURE :: FIELD_INT2D_WRAP
(  852)   MODULE PROCEDURE :: FIELD_INT2D_WRAP_PACKED
(  853)   ! MODULE PROCEDURE :: FIELD_INT2D_EMPTY
(  854)   MODULE PROCEDURE :: FIELD_INT2D_ALLOCATE
(  855) END INTERFACE
(  856) 
(  857) INTERFACE FIELD_INT3D
(  858)   MODULE PROCEDURE :: FIELD_INT3D_WRAP
(  859)   MODULE PROCEDURE :: FIELD_INT3D_WRAP_PACKED
(  860)   ! MODULE PROCEDURE :: FIELD_INT3D_EMPTY
(  861)   MODULE PROCEDURE :: FIELD_INT3D_ALLOCATE
(  862) END INTERFACE
(  863) 
(  864) INTERFACE FIELD_INT4D
(  865)   MODULE PROCEDURE :: FIELD_INT4D_WRAP
(  866)   MODULE PROCEDURE :: FIELD_INT4D_WRAP_PACKED
(  867)   ! MODULE PROCEDURE :: FIELD_INT4D_EMPTY
(  868)   MODULE PROCEDURE :: FIELD_INT4D_ALLOCATE
(  869) END INTERFACE
(  870) 
(  871) INTERFACE FIELD_INT5D
(  872)   MODULE PROCEDURE :: FIELD_INT5D_WRAP
(  873)   MODULE PROCEDURE :: FIELD_INT5D_WRAP_PACKED
(  874)   ! MODULE PROCEDURE :: FIELD_INT5D_EMPTY
(  875)   MODULE PROCEDURE :: FIELD_INT5D_ALLOCATE
(  876) END INTERFACE
(  877) 
(  878) INTERFACE FIELD_LOG2D
(  879)   MODULE PROCEDURE :: FIELD_LOG2D_WRAP
(  880)   MODULE PROCEDURE :: FIELD_LOG2D_WRAP_PACKED
(  881)   ! MODULE PROCEDURE :: FIELD_LOG2D_EMPTY
(  882)   MODULE PROCEDURE :: FIELD_LOG2D_ALLOCATE
(  883) END INTERFACE
(  884) 
(  885) INTERFACE FIELD_LOG3D
(  886)   MODULE PROCEDURE :: FIELD_LOG3D_WRAP
(  887)   MODULE PROCEDURE :: FIELD_LOG3D_WRAP_PACKED
(  888)   ! MODULE PROCEDURE :: FIELD_LOG3D_EMPTY
(  889)   MODULE PROCEDURE :: FIELD_LOG3D_ALLOCATE
(  890) END INTERFACE
(  891) 
(  892) INTERFACE FIELD_LOG4D
(  893)   MODULE PROCEDURE :: FIELD_LOG4D_WRAP
(  894)   MODULE PROCEDURE :: FIELD_LOG4D_WRAP_PACKED
(  895)   ! MODULE PROCEDURE :: FIELD_LOG4D_EMPTY
(  896)   MODULE PROCEDURE :: FIELD_LOG4D_ALLOCATE
(  897) END INTERFACE
(  898) 
(  899) INTERFACE FIELD_LOG5D
(  900)   MODULE PROCEDURE :: FIELD_LOG5D_WRAP






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 18

(  901)   MODULE PROCEDURE :: FIELD_LOG5D_WRAP_PACKED
(  902)   ! MODULE PROCEDURE :: FIELD_LOG5D_EMPTY
(  903)   MODULE PROCEDURE :: FIELD_LOG5D_ALLOCATE
(  904) END INTERFACE
(  905) 
(  906) 
(  907) INTERFACE ALLOCATE_FIELD
(  908)   MODULE PROCEDURE :: ALLOCATE_FIELD_2D
(  909)   MODULE PROCEDURE :: ALLOCATE_FIELD_3D
(  910)   MODULE PROCEDURE :: ALLOCATE_FIELD_4D
(  911)   MODULE PROCEDURE :: ALLOCATE_FIELD_5D
(  912)   MODULE PROCEDURE :: ALLOCATE_FIELD_INT2D
(  913)   MODULE PROCEDURE :: ALLOCATE_FIELD_INT3D
(  914)   MODULE PROCEDURE :: ALLOCATE_FIELD_INT4D
(  915)   MODULE PROCEDURE :: ALLOCATE_FIELD_INT5D
(  916)   MODULE PROCEDURE :: ALLOCATE_FIELD_LOG2D
(  917)   MODULE PROCEDURE :: ALLOCATE_FIELD_LOG3D
(  918)   MODULE PROCEDURE :: ALLOCATE_FIELD_LOG4D
(  919)   MODULE PROCEDURE :: ALLOCATE_FIELD_LOG5D
(  920) END INTERFACE
(  921) 
(  922) 
(  923) INTERFACE FILL_BUFFER
(  924)   MODULE PROCEDURE :: FILL_BUFFER_2D, FILL_BUFFER_3D
(  925)   MODULE PROCEDURE :: FILL_BUFFER_4D, FILL_BUFFER_5D
(  926)   MODULE PROCEDURE :: FILL_BUFFER_INT2D, FILL_BUFFER_INT3D
(  927)   MODULE PROCEDURE :: FILL_BUFFER_INT4D, FILL_BUFFER_INT5D
(  928)   MODULE PROCEDURE :: FILL_BUFFER_LOG2D, FILL_BUFFER_LOG3D
(  929)   MODULE PROCEDURE :: FILL_BUFFER_LOG4D, FILL_BUFFER_LOG5D
(  930) END INTERFACE FILL_BUFFER
(  931) 
(  932) 
(  933) INTERFACE FIELD_CREATE_DEVICE
(  934)   MODULE PROCEDURE :: FIELD_2D_CREATE_DEVICE
(  935)   MODULE PROCEDURE :: FIELD_3D_CREATE_DEVICE
(  936)   MODULE PROCEDURE :: FIELD_4D_CREATE_DEVICE
(  937)   MODULE PROCEDURE :: FIELD_5D_CREATE_DEVICE
(  938)   MODULE PROCEDURE :: FIELD_INT2D_CREATE_DEVICE
(  939)   MODULE PROCEDURE :: FIELD_INT3D_CREATE_DEVICE
(  940)   MODULE PROCEDURE :: FIELD_INT4D_CREATE_DEVICE
(  941)   MODULE PROCEDURE :: FIELD_INT5D_CREATE_DEVICE
(  942)   MODULE PROCEDURE :: FIELD_LOG2D_CREATE_DEVICE
(  943)   MODULE PROCEDURE :: FIELD_LOG3D_CREATE_DEVICE
(  944)   MODULE PROCEDURE :: FIELD_LOG4D_CREATE_DEVICE
(  945)   MODULE PROCEDURE :: FIELD_LOG5D_CREATE_DEVICE
(  946) END INTERFACE FIELD_CREATE_DEVICE
(  947) 
(  948) INTERFACE FIELD_UPDATE_DEVICE
(  949)   MODULE PROCEDURE :: FIELD_2D_UPDATE_DEVICE
(  950)   MODULE PROCEDURE :: FIELD_3D_UPDATE_DEVICE
(  951)   MODULE PROCEDURE :: FIELD_4D_UPDATE_DEVICE
(  952)   MODULE PROCEDURE :: FIELD_5D_UPDATE_DEVICE
(  953)   MODULE PROCEDURE :: FIELD_INT2D_UPDATE_DEVICE
(  954)   MODULE PROCEDURE :: FIELD_INT3D_UPDATE_DEVICE
(  955)   MODULE PROCEDURE :: FIELD_INT4D_UPDATE_DEVICE
(  956)   MODULE PROCEDURE :: FIELD_INT5D_UPDATE_DEVICE
(  957)   MODULE PROCEDURE :: FIELD_LOG2D_UPDATE_DEVICE
(  958)   MODULE PROCEDURE :: FIELD_LOG3D_UPDATE_DEVICE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 19

(  959)   MODULE PROCEDURE :: FIELD_LOG4D_UPDATE_DEVICE
(  960)   MODULE PROCEDURE :: FIELD_LOG5D_UPDATE_DEVICE
(  961) END INTERFACE FIELD_UPDATE_DEVICE
(  962) 
(  963) INTERFACE FIELD_UPDATE_HOST
(  964)   MODULE PROCEDURE :: FIELD_2D_UPDATE_HOST
(  965)   MODULE PROCEDURE :: FIELD_3D_UPDATE_HOST
(  966)   MODULE PROCEDURE :: FIELD_4D_UPDATE_HOST
(  967)   MODULE PROCEDURE :: FIELD_5D_UPDATE_HOST
(  968)   MODULE PROCEDURE :: FIELD_INT2D_UPDATE_HOST
(  969)   MODULE PROCEDURE :: FIELD_INT3D_UPDATE_HOST
(  970)   MODULE PROCEDURE :: FIELD_INT4D_UPDATE_HOST
(  971)   MODULE PROCEDURE :: FIELD_INT5D_UPDATE_HOST
(  972)   MODULE PROCEDURE :: FIELD_LOG2D_UPDATE_HOST
(  973)   MODULE PROCEDURE :: FIELD_LOG3D_UPDATE_HOST
(  974)   MODULE PROCEDURE :: FIELD_LOG4D_UPDATE_HOST
(  975)   MODULE PROCEDURE :: FIELD_LOG5D_UPDATE_HOST
(  976) END INTERFACE FIELD_UPDATE_HOST
(  977) 
(  978) INTERFACE FIELD_DELETE_DEVICE
(  979)   MODULE PROCEDURE :: FIELD_2D_DELETE_DEVICE
(  980)   MODULE PROCEDURE :: FIELD_3D_DELETE_DEVICE
(  981)   MODULE PROCEDURE :: FIELD_4D_DELETE_DEVICE
(  982)   MODULE PROCEDURE :: FIELD_5D_DELETE_DEVICE
(  983)   MODULE PROCEDURE :: FIELD_INT2D_DELETE_DEVICE
(  984)   MODULE PROCEDURE :: FIELD_INT3D_DELETE_DEVICE
(  985)   MODULE PROCEDURE :: FIELD_INT4D_DELETE_DEVICE
(  986)   MODULE PROCEDURE :: FIELD_INT5D_DELETE_DEVICE
(  987)   MODULE PROCEDURE :: FIELD_LOG2D_DELETE_DEVICE
(  988)   MODULE PROCEDURE :: FIELD_LOG3D_DELETE_DEVICE
(  989)   MODULE PROCEDURE :: FIELD_LOG4D_DELETE_DEVICE
(  990)   MODULE PROCEDURE :: FIELD_LOG5D_DELETE_DEVICE
(  991) END INTERFACE FIELD_DELETE_DEVICE
(  992) 
(  993) INTERFACE GET_DEVICE_DATA
(  994)   MODULE PROCEDURE :: FIELD_2D_GET_DEVICE_DATA
(  995)   MODULE PROCEDURE :: FIELD_3D_GET_DEVICE_DATA
(  996)   MODULE PROCEDURE :: FIELD_4D_GET_DEVICE_DATA
(  997)   MODULE PROCEDURE :: FIELD_5D_GET_DEVICE_DATA
(  998)   MODULE PROCEDURE :: FIELD_INT2D_GET_DEVICE_DATA
(  999)   MODULE PROCEDURE :: FIELD_INT3D_GET_DEVICE_DATA
( 1000)   MODULE PROCEDURE :: FIELD_INT4D_GET_DEVICE_DATA
( 1001)   MODULE PROCEDURE :: FIELD_INT5D_GET_DEVICE_DATA
( 1002)   MODULE PROCEDURE :: FIELD_LOG2D_GET_DEVICE_DATA
( 1003)   MODULE PROCEDURE :: FIELD_LOG3D_GET_DEVICE_DATA
( 1004)   MODULE PROCEDURE :: FIELD_LOG4D_GET_DEVICE_DATA
( 1005)   MODULE PROCEDURE :: FIELD_LOG5D_GET_DEVICE_DATA
( 1006) END INTERFACE GET_DEVICE_DATA
( 1007) 
( 1008) 
( 1009) CONTAINS
( 1010) 
( 1011)   SUBROUTINE FILL_BUFFER_2D(BUFFER, INDEX)
( 1012)     ! Utility routine to fill data buffers (views)
( 1013)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:)
( 1014)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1015)     INTEGER(KIND=JPIM) :: IDX
( 1016) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 20

( 1017)     IDX = INDEX+1
( 1018)     BUFFER(IDX:) = BUFFER(INDEX)
( 1019)   END SUBROUTINE FILL_BUFFER_2D
( 1020) 
( 1021)   SUBROUTINE FILL_BUFFER_3D(BUFFER, INDEX)
( 1022)     ! Utility routine to fill data buffers (views)
( 1023)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:,:)
( 1024)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1025)     INTEGER(KIND=JPIM) :: I, IDX
( 1026) 
( 1027)     IDX = INDEX+1
( 1028)     DO I=1, SIZE(BUFFER, 2)
( 1029)       BUFFER(IDX:,I) = BUFFER(INDEX,I)
( 1030)     END DO
( 1031)   END SUBROUTINE FILL_BUFFER_3D
( 1032) 
( 1033)   SUBROUTINE FILL_BUFFER_4D(BUFFER, INDEX)
( 1034)     ! Utility routine to fill data buffers (views)
( 1035)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:,:,:)
( 1036)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1037)     INTEGER(KIND=JPIM) :: I, J, IDX
( 1038) 
( 1039)     IDX = INDEX+1
( 1040)     DO I=1, SIZE(BUFFER, 2)
( 1041)       DO J=1, SIZE(BUFFER, 3)
( 1042)         BUFFER(IDX:,I,J) = BUFFER(INDEX,I,J)
( 1043)       END DO
( 1044)     END DO
( 1045)   END SUBROUTINE FILL_BUFFER_4D
( 1046) 
( 1047)   SUBROUTINE FILL_BUFFER_5D(BUFFER, INDEX)
( 1048)     ! Utility routine to fill data buffers (views)
( 1049)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:,:,:,:)
( 1050)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1051)     INTEGER(KIND=JPIM) :: I, J, K, IDX
( 1052) 
( 1053)     IDX = INDEX+1
( 1054)     DO I=1, SIZE(BUFFER, 2)
( 1055)       DO J=1, SIZE(BUFFER, 3)
( 1056)         DO K=1, SIZE(BUFFER, 4)
( 1057)           BUFFER(IDX:,I,J,K) = BUFFER(INDEX,I,J,K)
( 1058)         END DO
( 1059)       END DO
( 1060)     END DO
( 1061)   END SUBROUTINE FILL_BUFFER_5D
( 1062) 
( 1063)   SUBROUTINE FILL_BUFFER_INT2D(BUFFER, INDEX)
( 1064)     ! Utility routine to fill data buffers (views)
( 1065)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: BUFFER(:)
( 1066)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1067)     INTEGER(KIND=JPIM) :: IDX
( 1068) 
( 1069)     IDX = INDEX+1
( 1070)     BUFFER(IDX:) = BUFFER(INDEX)
( 1071)   END SUBROUTINE FILL_BUFFER_INT2D
( 1072) 
( 1073)   SUBROUTINE FILL_BUFFER_INT3D(BUFFER, INDEX)
( 1074)     ! Utility routine to fill data buffers (views)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 21

( 1075)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: BUFFER(:,:)
( 1076)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1077)     INTEGER(KIND=JPIM) :: I, IDX
( 1078) 
( 1079)     IDX = INDEX+1
( 1080)     DO I=1, SIZE(BUFFER, 2)
( 1081)       BUFFER(IDX:,I) = BUFFER(INDEX,I)
( 1082)     END DO
( 1083)   END SUBROUTINE FILL_BUFFER_INT3D
( 1084) 
( 1085)   SUBROUTINE FILL_BUFFER_INT4D(BUFFER, INDEX)
( 1086)     ! Utility routine to fill data buffers (views)
( 1087)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: BUFFER(:,:,:)
( 1088)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1089)     INTEGER(KIND=JPIM) :: I, J, IDX
( 1090) 
( 1091)     IDX = INDEX+1
( 1092)     DO I=1, SIZE(BUFFER, 2)
( 1093)       DO J=1, SIZE(BUFFER, 3)
( 1094)         BUFFER(IDX:,I,J) = BUFFER(INDEX,I,J)
( 1095)       END DO
( 1096)     END DO
( 1097)   END SUBROUTINE FILL_BUFFER_INT4D
( 1098) 
( 1099)   SUBROUTINE FILL_BUFFER_INT5D(BUFFER, INDEX)
( 1100)     ! Utility routine to fill data buffers (views)
( 1101)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: BUFFER(:,:,:,:)
( 1102)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1103)     INTEGER(KIND=JPIM) :: I, J, K, IDX
( 1104) 
( 1105)     IDX = INDEX+1
( 1106)     DO I=1, SIZE(BUFFER, 2)
( 1107)       DO J=1, SIZE(BUFFER, 3)
( 1108)         DO K=1, SIZE(BUFFER, 4)
( 1109)           BUFFER(IDX:,I,J,K) = BUFFER(INDEX,I,J,K)
( 1110)         END DO
( 1111)       END DO
( 1112)     END DO
( 1113)   END SUBROUTINE FILL_BUFFER_INT5D
( 1114) 
( 1115)   SUBROUTINE FILL_BUFFER_LOG2D(BUFFER, INDEX)
( 1116)     ! Utility routine to fill data buffers (views)
( 1117)     LOGICAL, POINTER, INTENT(INOUT) :: BUFFER(:)
( 1118)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1119)     INTEGER(KIND=JPIM) :: IDX
( 1120) 
( 1121)     IDX = INDEX+1
( 1122)     BUFFER(IDX:) = BUFFER(INDEX)
( 1123)   END SUBROUTINE FILL_BUFFER_LOG2D
( 1124) 
( 1125)   SUBROUTINE FILL_BUFFER_LOG3D(BUFFER, INDEX)
( 1126)     ! Utility routine to fill data buffers (views)
( 1127)     LOGICAL, POINTER, INTENT(INOUT) :: BUFFER(:,:)
( 1128)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1129)     INTEGER(KIND=JPIM) :: I, IDX
( 1130) 
( 1131)     IDX = INDEX+1
( 1132)     DO I=1, SIZE(BUFFER, 2)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 22

( 1133)       BUFFER(IDX:,I) = BUFFER(INDEX,I)
( 1134)     END DO
( 1135)   END SUBROUTINE FILL_BUFFER_LOG3D
( 1136) 
( 1137)   SUBROUTINE FILL_BUFFER_LOG4D(BUFFER, INDEX)
( 1138)     ! Utility routine to fill data buffers (views)
( 1139)     LOGICAL, POINTER, INTENT(INOUT) :: BUFFER(:,:,:)
( 1140)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1141)     INTEGER(KIND=JPIM) :: I, J, IDX
( 1142) 
( 1143)     IDX = INDEX+1
( 1144)     DO I=1, SIZE(BUFFER, 2)
( 1145)       DO J=1, SIZE(BUFFER, 3)
( 1146)         BUFFER(IDX:,I,J) = BUFFER(INDEX,I,J)
( 1147)       END DO
( 1148)     END DO
( 1149)   END SUBROUTINE FILL_BUFFER_LOG4D
( 1150) 
( 1151)   SUBROUTINE FILL_BUFFER_LOG5D(BUFFER, INDEX)
( 1152)     ! Utility routine to fill data buffers (views)
( 1153)     LOGICAL, POINTER, INTENT(INOUT) :: BUFFER(:,:,:,:)
( 1154)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1155)     INTEGER(KIND=JPIM) :: I, J, K, IDX
( 1156) 
( 1157)     IDX = INDEX+1
( 1158)     DO I=1, SIZE(BUFFER, 2)
( 1159)       DO J=1, SIZE(BUFFER, 3)
( 1160)         DO K=1, SIZE(BUFFER, 4)
( 1161)           BUFFER(IDX:,I,J,K) = BUFFER(INDEX,I,J,K)
( 1162)         END DO
( 1163)       END DO
( 1164)     END DO
( 1165)   END SUBROUTINE FILL_BUFFER_LOG5D
( 1166) 
( 1167) 
( 1168)   FUNCTION FIELD_2D_EMPTY(SHAPE) RESULT(SELF)
( 1169)     ! Create FIELD object by wrapping existing data
( 1170)     !
( 1171)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1172)     ! will be allocated under %VIEW and used by all threads in a
( 1173)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1174)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1175)     TYPE(FIELD_2D) :: SELF
( 1176)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(1)
( 1177) 
( 1178)     SELF%PTR => NULL()
( 1179)     IF (PRESENT(SHAPE)) THEN
( 1180)       ALLOCATE(SELF%VIEW(SHAPE(1)))
( 1181)     END IF
( 1182)     SELF%ACTIVE = .FALSE.
( 1183)     SELF%THREAD_BUFFER = .FALSE.
( 1184)     SELF%OWNED = .FALSE.
( 1185)     SELF%NBLOCKS = 0
( 1186)     SELF%BASE_PTR => NULL()
( 1187)     SELF%FIDX = -1
( 1188)   END FUNCTION FIELD_2D_EMPTY
( 1189) 
( 1190)   FUNCTION FIELD_3D_EMPTY(SHAPE) RESULT(SELF)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 23

( 1191)     ! Create FIELD object by wrapping existing data
( 1192)     !
( 1193)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1194)     ! will be allocated under %VIEW and used by all threads in a
( 1195)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1196)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1197)     TYPE(FIELD_3D) :: SELF
( 1198)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(2)
( 1199) 
( 1200)     SELF%PTR => NULL()
( 1201)     IF (PRESENT(SHAPE)) THEN
( 1202)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2)))
( 1203)     END IF
( 1204)     SELF%ACTIVE = .FALSE.
( 1205)     SELF%THREAD_BUFFER = .FALSE.
( 1206)     SELF%OWNED = .FALSE.
( 1207)     SELF%NBLOCKS = 0
( 1208)     SELF%BASE_PTR => NULL()
( 1209)     SELF%FIDX = -1
( 1210)   END FUNCTION FIELD_3D_EMPTY
( 1211) 
( 1212)   FUNCTION FIELD_4D_EMPTY(SHAPE) RESULT(SELF)
( 1213)     ! Create FIELD object by wrapping existing data
( 1214)     !
( 1215)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1216)     ! will be allocated under %VIEW and used by all threads in a
( 1217)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1218)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1219)     TYPE(FIELD_4D) :: SELF
( 1220)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(3)
( 1221) 
( 1222)     SELF%PTR => NULL()
( 1223)     IF (PRESENT(SHAPE)) THEN
( 1224)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3)))
( 1225)     END IF
( 1226)     SELF%ACTIVE = .FALSE.
( 1227)     SELF%THREAD_BUFFER = .FALSE.
( 1228)     SELF%OWNED = .FALSE.
( 1229)     SELF%NBLOCKS = 0
( 1230)     SELF%BASE_PTR => NULL()
( 1231)     SELF%FIDX = -1
( 1232)   END FUNCTION FIELD_4D_EMPTY
( 1233) 
( 1234)   FUNCTION FIELD_5D_EMPTY(SHAPE) RESULT(SELF)
( 1235)     ! Create FIELD object by wrapping existing data
( 1236)     !
( 1237)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1238)     ! will be allocated under %VIEW and used by all threads in a
( 1239)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1240)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1241)     TYPE(FIELD_5D) :: SELF
( 1242)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(4)
( 1243) 
( 1244)     SELF%PTR => NULL()
( 1245)     IF (PRESENT(SHAPE)) THEN
( 1246)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4)))
( 1247)     END IF
( 1248)     SELF%ACTIVE = .FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 24

( 1249)     SELF%THREAD_BUFFER = .FALSE.
( 1250)     SELF%OWNED = .FALSE.
( 1251)     SELF%NBLOCKS = 0
( 1252)     SELF%BASE_PTR => NULL()
( 1253)     SELF%FIDX = -1
( 1254)   END FUNCTION FIELD_5D_EMPTY
( 1255) 
( 1256)   FUNCTION FIELD_INT2D_EMPTY(SHAPE) RESULT(SELF)
( 1257)     ! Create FIELD object by wrapping existing data
( 1258)     !
( 1259)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1260)     ! will be allocated under %VIEW and used by all threads in a
( 1261)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1262)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1263)     TYPE(FIELD_INT2D) :: SELF
( 1264)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(1)
( 1265) 
( 1266)     SELF%PTR => NULL()
( 1267)     IF (PRESENT(SHAPE)) THEN
( 1268)       ALLOCATE(SELF%VIEW(SHAPE(1)))
( 1269)     END IF
( 1270)     SELF%ACTIVE = .FALSE.
( 1271)     SELF%THREAD_BUFFER = .FALSE.
( 1272)     SELF%OWNED = .FALSE.
( 1273)     SELF%NBLOCKS = 0
( 1274)     SELF%BASE_PTR => NULL()
( 1275)     SELF%FIDX = -1
( 1276)   END FUNCTION FIELD_INT2D_EMPTY
( 1277) 
( 1278)   FUNCTION FIELD_INT3D_EMPTY(SHAPE) RESULT(SELF)
( 1279)     ! Create FIELD object by wrapping existing data
( 1280)     !
( 1281)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1282)     ! will be allocated under %VIEW and used by all threads in a
( 1283)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1284)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1285)     TYPE(FIELD_INT3D) :: SELF
( 1286)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(2)
( 1287) 
( 1288)     SELF%PTR => NULL()
( 1289)     IF (PRESENT(SHAPE)) THEN
( 1290)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2)))
( 1291)     END IF
( 1292)     SELF%ACTIVE = .FALSE.
( 1293)     SELF%THREAD_BUFFER = .FALSE.
( 1294)     SELF%OWNED = .FALSE.
( 1295)     SELF%NBLOCKS = 0
( 1296)     SELF%BASE_PTR => NULL()
( 1297)     SELF%FIDX = -1
( 1298)   END FUNCTION FIELD_INT3D_EMPTY
( 1299) 
( 1300)   FUNCTION FIELD_INT4D_EMPTY(SHAPE) RESULT(SELF)
( 1301)     ! Create FIELD object by wrapping existing data
( 1302)     !
( 1303)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1304)     ! will be allocated under %VIEW and used by all threads in a
( 1305)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1306)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 25

( 1307)     TYPE(FIELD_INT4D) :: SELF
( 1308)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(3)
( 1309) 
( 1310)     SELF%PTR => NULL()
( 1311)     IF (PRESENT(SHAPE)) THEN
( 1312)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3)))
( 1313)     END IF
( 1314)     SELF%ACTIVE = .FALSE.
( 1315)     SELF%THREAD_BUFFER = .FALSE.
( 1316)     SELF%OWNED = .FALSE.
( 1317)     SELF%NBLOCKS = 0
( 1318)     SELF%BASE_PTR => NULL()
( 1319)     SELF%FIDX = -1
( 1320)   END FUNCTION FIELD_INT4D_EMPTY
( 1321) 
( 1322)   FUNCTION FIELD_INT5D_EMPTY(SHAPE) RESULT(SELF)
( 1323)     ! Create FIELD object by wrapping existing data
( 1324)     !
( 1325)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1326)     ! will be allocated under %VIEW and used by all threads in a
( 1327)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1328)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1329)     TYPE(FIELD_INT5D) :: SELF
( 1330)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(4)
( 1331) 
( 1332)     SELF%PTR => NULL()
( 1333)     IF (PRESENT(SHAPE)) THEN
( 1334)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4)))
( 1335)     END IF
( 1336)     SELF%ACTIVE = .FALSE.
( 1337)     SELF%THREAD_BUFFER = .FALSE.
( 1338)     SELF%OWNED = .FALSE.
( 1339)     SELF%NBLOCKS = 0
( 1340)     SELF%BASE_PTR => NULL()
( 1341)     SELF%FIDX = -1
( 1342)   END FUNCTION FIELD_INT5D_EMPTY
( 1343) 
( 1344)   FUNCTION FIELD_LOG2D_EMPTY(SHAPE) RESULT(SELF)
( 1345)     ! Create FIELD object by wrapping existing data
( 1346)     !
( 1347)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1348)     ! will be allocated under %VIEW and used by all threads in a
( 1349)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1350)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1351)     TYPE(FIELD_LOG2D) :: SELF
( 1352)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(1)
( 1353) 
( 1354)     SELF%PTR => NULL()
( 1355)     IF (PRESENT(SHAPE)) THEN
( 1356)       ALLOCATE(SELF%VIEW(SHAPE(1)))
( 1357)     END IF
( 1358)     SELF%ACTIVE = .FALSE.
( 1359)     SELF%THREAD_BUFFER = .FALSE.
( 1360)     SELF%OWNED = .FALSE.
( 1361)     SELF%NBLOCKS = 0
( 1362)     SELF%BASE_PTR => NULL()
( 1363)     SELF%FIDX = -1
( 1364)   END FUNCTION FIELD_LOG2D_EMPTY






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 26

( 1365) 
( 1366)   FUNCTION FIELD_LOG3D_EMPTY(SHAPE) RESULT(SELF)
( 1367)     ! Create FIELD object by wrapping existing data
( 1368)     !
( 1369)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1370)     ! will be allocated under %VIEW and used by all threads in a
( 1371)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1372)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1373)     TYPE(FIELD_LOG3D) :: SELF
( 1374)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(2)
( 1375) 
( 1376)     SELF%PTR => NULL()
( 1377)     IF (PRESENT(SHAPE)) THEN
( 1378)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2)))
( 1379)     END IF
( 1380)     SELF%ACTIVE = .FALSE.
( 1381)     SELF%THREAD_BUFFER = .FALSE.
( 1382)     SELF%OWNED = .FALSE.
( 1383)     SELF%NBLOCKS = 0
( 1384)     SELF%BASE_PTR => NULL()
( 1385)     SELF%FIDX = -1
( 1386)   END FUNCTION FIELD_LOG3D_EMPTY
( 1387) 
( 1388)   FUNCTION FIELD_LOG4D_EMPTY(SHAPE) RESULT(SELF)
( 1389)     ! Create FIELD object by wrapping existing data
( 1390)     !
( 1391)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1392)     ! will be allocated under %VIEW and used by all threads in a
( 1393)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1394)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1395)     TYPE(FIELD_LOG4D) :: SELF
( 1396)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(3)
( 1397) 
( 1398)     SELF%PTR => NULL()
( 1399)     IF (PRESENT(SHAPE)) THEN
( 1400)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3)))
( 1401)     END IF
( 1402)     SELF%ACTIVE = .FALSE.
( 1403)     SELF%THREAD_BUFFER = .FALSE.
( 1404)     SELF%OWNED = .FALSE.
( 1405)     SELF%NBLOCKS = 0
( 1406)     SELF%BASE_PTR => NULL()
( 1407)     SELF%FIDX = -1
( 1408)   END FUNCTION FIELD_LOG4D_EMPTY
( 1409) 
( 1410)   FUNCTION FIELD_LOG5D_EMPTY(SHAPE) RESULT(SELF)
( 1411)     ! Create FIELD object by wrapping existing data
( 1412)     !
( 1413)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1414)     ! will be allocated under %VIEW and used by all threads in a
( 1415)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1416)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1417)     TYPE(FIELD_LOG5D) :: SELF
( 1418)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(4)
( 1419) 
( 1420)     SELF%PTR => NULL()
( 1421)     IF (PRESENT(SHAPE)) THEN
( 1422)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4)))






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 27

( 1423)     END IF
( 1424)     SELF%ACTIVE = .FALSE.
( 1425)     SELF%THREAD_BUFFER = .FALSE.
( 1426)     SELF%OWNED = .FALSE.
( 1427)     SELF%NBLOCKS = 0
( 1428)     SELF%BASE_PTR => NULL()
( 1429)     SELF%FIDX = -1
( 1430)   END FUNCTION FIELD_LOG5D_EMPTY
( 1431) 
( 1432) 
( 1433)   FUNCTION FIELD_2D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1434)     ! Create FIELD object by wrapping existing data
( 1435)     TYPE(FIELD_2D), TARGET :: SELF
( 1436)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:)
( 1437)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1438)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1439)     LOGICAL :: LLPERSISTENT
( 1440) 
( 1441)     LLPERSISTENT = .TRUE.
( 1442)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1443)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1444) 
( 1445)     SELF%PTR => DATA
( 1446)     SELF%ACTIVE = .TRUE.
( 1447)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1448)     SELF%OWNED = .FALSE.
( 1449)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1450)     SELF%BASE_PTR => NULL()
( 1451)     SELF%FIDX = -1
( 1452) 
( 1453)     SELF%ISTATUS = NHSTFRESH
( 1454) 
( 1455)     IF (.NOT. LLPERSISTENT) THEN
( 1456)       IF (OML_MAX_THREADS() /= SIZE (DATA, 2)) THEN
( 1457)         CALL ABOR1 ('FIELD_2D_WRAP: DIMENSION MISMATCH')
( 1458)       ENDIF
( 1459)     ENDIF
( 1460) 
( 1461)   END FUNCTION FIELD_2D_WRAP
( 1462) 
( 1463)   FUNCTION FIELD_3D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1464)     ! Create FIELD object by wrapping existing data
( 1465)     TYPE(FIELD_3D), TARGET :: SELF
( 1466)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
( 1467)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1468)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1469)     LOGICAL :: LLPERSISTENT
( 1470) 
( 1471)     LLPERSISTENT = .TRUE.
( 1472)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1473)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1474) 
( 1475)     SELF%PTR => DATA
( 1476)     SELF%ACTIVE = .TRUE.
( 1477)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1478)     SELF%OWNED = .FALSE.
( 1479)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1480)     SELF%BASE_PTR => NULL()






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 28

( 1481)     SELF%FIDX = -1
( 1482) 
( 1483)     SELF%ISTATUS = NHSTFRESH
( 1484) 
( 1485)     IF (.NOT. LLPERSISTENT) THEN
( 1486)       IF (OML_MAX_THREADS() /= SIZE (DATA, 3)) THEN
( 1487)         CALL ABOR1 ('FIELD_3D_WRAP: DIMENSION MISMATCH')
( 1488)       ENDIF
( 1489)     ENDIF
( 1490) 
( 1491)   END FUNCTION FIELD_3D_WRAP
( 1492) 
( 1493)   FUNCTION FIELD_4D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1494)     ! Create FIELD object by wrapping existing data
( 1495)     TYPE(FIELD_4D), TARGET :: SELF
( 1496)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1497)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1498)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1499)     LOGICAL :: LLPERSISTENT
( 1500) 
( 1501)     LLPERSISTENT = .TRUE.
( 1502)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1503)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1504) 
( 1505)     SELF%PTR => DATA
( 1506)     SELF%ACTIVE = .TRUE.
( 1507)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1508)     SELF%OWNED = .FALSE.
( 1509)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1510)     SELF%BASE_PTR => NULL()
( 1511)     SELF%FIDX = -1
( 1512) 
( 1513)     SELF%ISTATUS = NHSTFRESH
( 1514) 
( 1515)     IF (.NOT. LLPERSISTENT) THEN
( 1516)       IF (OML_MAX_THREADS() /= SIZE (DATA, 4)) THEN
( 1517)         CALL ABOR1 ('FIELD_4D_WRAP: DIMENSION MISMATCH')
( 1518)       ENDIF
( 1519)     ENDIF
( 1520) 
( 1521)   END FUNCTION FIELD_4D_WRAP
( 1522) 
( 1523)   FUNCTION FIELD_5D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1524)     ! Create FIELD object by wrapping existing data
( 1525)     TYPE(FIELD_5D), TARGET :: SELF
( 1526)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1527)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1528)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1529)     LOGICAL :: LLPERSISTENT
( 1530) 
( 1531)     LLPERSISTENT = .TRUE.
( 1532)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1533)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1534) 
( 1535)     SELF%PTR => DATA
( 1536)     SELF%ACTIVE = .TRUE.
( 1537)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1538)     SELF%OWNED = .FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 29

( 1539)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1540)     SELF%BASE_PTR => NULL()
( 1541)     SELF%FIDX = -1
( 1542) 
( 1543)     SELF%ISTATUS = NHSTFRESH
( 1544) 
( 1545)     IF (.NOT. LLPERSISTENT) THEN
( 1546)       IF (OML_MAX_THREADS() /= SIZE (DATA, 5)) THEN
( 1547)         CALL ABOR1 ('FIELD_5D_WRAP: DIMENSION MISMATCH')
( 1548)       ENDIF
( 1549)     ENDIF
( 1550) 
( 1551)   END FUNCTION FIELD_5D_WRAP
( 1552) 
( 1553)   FUNCTION FIELD_INT2D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1554)     ! Create FIELD object by wrapping existing data
( 1555)     TYPE(FIELD_INT2D), TARGET :: SELF
( 1556)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:)
( 1557)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1558)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1559)     LOGICAL :: LLPERSISTENT
( 1560) 
( 1561)     LLPERSISTENT = .TRUE.
( 1562)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1563)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1564) 
( 1565)     SELF%PTR => DATA
( 1566)     SELF%ACTIVE = .TRUE.
( 1567)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1568)     SELF%OWNED = .FALSE.
( 1569)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1570)     SELF%BASE_PTR => NULL()
( 1571)     SELF%FIDX = -1
( 1572) 
( 1573)     SELF%ISTATUS = NHSTFRESH
( 1574) 
( 1575)     IF (.NOT. LLPERSISTENT) THEN
( 1576)       IF (OML_MAX_THREADS() /= SIZE (DATA, 2)) THEN
( 1577)         CALL ABOR1 ('FIELD_INT2D_WRAP: DIMENSION MISMATCH')
( 1578)       ENDIF
( 1579)     ENDIF
( 1580) 
( 1581)   END FUNCTION FIELD_INT2D_WRAP
( 1582) 
( 1583)   FUNCTION FIELD_INT3D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1584)     ! Create FIELD object by wrapping existing data
( 1585)     TYPE(FIELD_INT3D), TARGET :: SELF
( 1586)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:)
( 1587)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1588)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1589)     LOGICAL :: LLPERSISTENT
( 1590) 
( 1591)     LLPERSISTENT = .TRUE.
( 1592)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1593)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1594) 
( 1595)     SELF%PTR => DATA
( 1596)     SELF%ACTIVE = .TRUE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 30

( 1597)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1598)     SELF%OWNED = .FALSE.
( 1599)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1600)     SELF%BASE_PTR => NULL()
( 1601)     SELF%FIDX = -1
( 1602) 
( 1603)     SELF%ISTATUS = NHSTFRESH
( 1604) 
( 1605)     IF (.NOT. LLPERSISTENT) THEN
( 1606)       IF (OML_MAX_THREADS() /= SIZE (DATA, 3)) THEN
( 1607)         CALL ABOR1 ('FIELD_INT3D_WRAP: DIMENSION MISMATCH')
( 1608)       ENDIF
( 1609)     ENDIF
( 1610) 
( 1611)   END FUNCTION FIELD_INT3D_WRAP
( 1612) 
( 1613)   FUNCTION FIELD_INT4D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1614)     ! Create FIELD object by wrapping existing data
( 1615)     TYPE(FIELD_INT4D), TARGET :: SELF
( 1616)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1617)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1618)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1619)     LOGICAL :: LLPERSISTENT
( 1620) 
( 1621)     LLPERSISTENT = .TRUE.
( 1622)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1623)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1624) 
( 1625)     SELF%PTR => DATA
( 1626)     SELF%ACTIVE = .TRUE.
( 1627)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1628)     SELF%OWNED = .FALSE.
( 1629)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1630)     SELF%BASE_PTR => NULL()
( 1631)     SELF%FIDX = -1
( 1632) 
( 1633)     SELF%ISTATUS = NHSTFRESH
( 1634) 
( 1635)     IF (.NOT. LLPERSISTENT) THEN
( 1636)       IF (OML_MAX_THREADS() /= SIZE (DATA, 4)) THEN
( 1637)         CALL ABOR1 ('FIELD_INT4D_WRAP: DIMENSION MISMATCH')
( 1638)       ENDIF
( 1639)     ENDIF
( 1640) 
( 1641)   END FUNCTION FIELD_INT4D_WRAP
( 1642) 
( 1643)   FUNCTION FIELD_INT5D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1644)     ! Create FIELD object by wrapping existing data
( 1645)     TYPE(FIELD_INT5D), TARGET :: SELF
( 1646)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1647)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1648)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1649)     LOGICAL :: LLPERSISTENT
( 1650) 
( 1651)     LLPERSISTENT = .TRUE.
( 1652)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1653)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1654) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 31

( 1655)     SELF%PTR => DATA
( 1656)     SELF%ACTIVE = .TRUE.
( 1657)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1658)     SELF%OWNED = .FALSE.
( 1659)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1660)     SELF%BASE_PTR => NULL()
( 1661)     SELF%FIDX = -1
( 1662) 
( 1663)     SELF%ISTATUS = NHSTFRESH
( 1664) 
( 1665)     IF (.NOT. LLPERSISTENT) THEN
( 1666)       IF (OML_MAX_THREADS() /= SIZE (DATA, 5)) THEN
( 1667)         CALL ABOR1 ('FIELD_INT5D_WRAP: DIMENSION MISMATCH')
( 1668)       ENDIF
( 1669)     ENDIF
( 1670) 
( 1671)   END FUNCTION FIELD_INT5D_WRAP
( 1672) 
( 1673)   FUNCTION FIELD_LOG2D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1674)     ! Create FIELD object by wrapping existing data
( 1675)     TYPE(FIELD_LOG2D), TARGET :: SELF
( 1676)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:)
( 1677)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1678)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1679)     LOGICAL :: LLPERSISTENT
( 1680) 
( 1681)     LLPERSISTENT = .TRUE.
( 1682)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1683)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1684) 
( 1685)     SELF%PTR => DATA
( 1686)     SELF%ACTIVE = .TRUE.
( 1687)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1688)     SELF%OWNED = .FALSE.
( 1689)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1690)     SELF%BASE_PTR => NULL()
( 1691)     SELF%FIDX = -1
( 1692) 
( 1693)     SELF%ISTATUS = NHSTFRESH
( 1694) 
( 1695)     IF (.NOT. LLPERSISTENT) THEN
( 1696)       IF (OML_MAX_THREADS() /= SIZE (DATA, 2)) THEN
( 1697)         CALL ABOR1 ('FIELD_LOG2D_WRAP: DIMENSION MISMATCH')
( 1698)       ENDIF
( 1699)     ENDIF
( 1700) 
( 1701)   END FUNCTION FIELD_LOG2D_WRAP
( 1702) 
( 1703)   FUNCTION FIELD_LOG3D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1704)     ! Create FIELD object by wrapping existing data
( 1705)     TYPE(FIELD_LOG3D), TARGET :: SELF
( 1706)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:)
( 1707)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1708)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1709)     LOGICAL :: LLPERSISTENT
( 1710) 
( 1711)     LLPERSISTENT = .TRUE.
( 1712)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 32

( 1713)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1714) 
( 1715)     SELF%PTR => DATA
( 1716)     SELF%ACTIVE = .TRUE.
( 1717)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1718)     SELF%OWNED = .FALSE.
( 1719)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1720)     SELF%BASE_PTR => NULL()
( 1721)     SELF%FIDX = -1
( 1722) 
( 1723)     SELF%ISTATUS = NHSTFRESH
( 1724) 
( 1725)     IF (.NOT. LLPERSISTENT) THEN
( 1726)       IF (OML_MAX_THREADS() /= SIZE (DATA, 3)) THEN
( 1727)         CALL ABOR1 ('FIELD_LOG3D_WRAP: DIMENSION MISMATCH')
( 1728)       ENDIF
( 1729)     ENDIF
( 1730) 
( 1731)   END FUNCTION FIELD_LOG3D_WRAP
( 1732) 
( 1733)   FUNCTION FIELD_LOG4D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1734)     ! Create FIELD object by wrapping existing data
( 1735)     TYPE(FIELD_LOG4D), TARGET :: SELF
( 1736)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1737)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1738)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1739)     LOGICAL :: LLPERSISTENT
( 1740) 
( 1741)     LLPERSISTENT = .TRUE.
( 1742)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1743)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1744) 
( 1745)     SELF%PTR => DATA
( 1746)     SELF%ACTIVE = .TRUE.
( 1747)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1748)     SELF%OWNED = .FALSE.
( 1749)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1750)     SELF%BASE_PTR => NULL()
( 1751)     SELF%FIDX = -1
( 1752) 
( 1753)     SELF%ISTATUS = NHSTFRESH
( 1754) 
( 1755)     IF (.NOT. LLPERSISTENT) THEN
( 1756)       IF (OML_MAX_THREADS() /= SIZE (DATA, 4)) THEN
( 1757)         CALL ABOR1 ('FIELD_LOG4D_WRAP: DIMENSION MISMATCH')
( 1758)       ENDIF
( 1759)     ENDIF
( 1760) 
( 1761)   END FUNCTION FIELD_LOG4D_WRAP
( 1762) 
( 1763)   FUNCTION FIELD_LOG5D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1764)     ! Create FIELD object by wrapping existing data
( 1765)     TYPE(FIELD_LOG5D), TARGET :: SELF
( 1766)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1767)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1768)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1769)     LOGICAL :: LLPERSISTENT
( 1770) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 33

( 1771)     LLPERSISTENT = .TRUE.
( 1772)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1773)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1774) 
( 1775)     SELF%PTR => DATA
( 1776)     SELF%ACTIVE = .TRUE.
( 1777)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1778)     SELF%OWNED = .FALSE.
( 1779)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1780)     SELF%BASE_PTR => NULL()
( 1781)     SELF%FIDX = -1
( 1782) 
( 1783)     SELF%ISTATUS = NHSTFRESH
( 1784) 
( 1785)     IF (.NOT. LLPERSISTENT) THEN
( 1786)       IF (OML_MAX_THREADS() /= SIZE (DATA, 5)) THEN
( 1787)         CALL ABOR1 ('FIELD_LOG5D_WRAP: DIMENSION MISMATCH')
( 1788)       ENDIF
( 1789)     ENDIF
( 1790) 
( 1791)   END FUNCTION FIELD_LOG5D_WRAP
( 1792) 
( 1793) 
( 1794)   FUNCTION FIELD_2D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1795)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1796)     ! contiguous pointer to existing data and an index.
( 1797)     TYPE(FIELD_2D), TARGET :: SELF
( 1798)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
( 1799)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1800)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1801) 
( 1802)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1803) 
( 1804)     SELF%PTR => DATA(:,IDX,:)
( 1805)     SELF%ACTIVE = .TRUE.
( 1806)     SELF%THREAD_BUFFER = .FALSE.
( 1807)     SELF%OWNED = .FALSE.
( 1808)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1809)     SELF%BASE_PTR => DATA
( 1810)     SELF%FIDX = IDX
( 1811) 
( 1812)     SELF%ISTATUS = NHSTFRESH
( 1813) 
( 1814)   END FUNCTION FIELD_2D_WRAP_PACKED
( 1815) 
( 1816)   FUNCTION FIELD_3D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1817)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1818)     ! contiguous pointer to existing data and an index.
( 1819)     TYPE(FIELD_3D), TARGET :: SELF
( 1820)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1821)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1822)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1823) 
( 1824)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1825) 
( 1826)     SELF%PTR => DATA(:,:,IDX,:)
( 1827)     SELF%ACTIVE = .TRUE.
( 1828)     SELF%THREAD_BUFFER = .FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 34

( 1829)     SELF%OWNED = .FALSE.
( 1830)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1831)     SELF%BASE_PTR => DATA
( 1832)     SELF%FIDX = IDX
( 1833) 
( 1834)     SELF%ISTATUS = NHSTFRESH
( 1835) 
( 1836)   END FUNCTION FIELD_3D_WRAP_PACKED
( 1837) 
( 1838)   FUNCTION FIELD_4D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1839)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1840)     ! contiguous pointer to existing data and an index.
( 1841)     TYPE(FIELD_4D), TARGET :: SELF
( 1842)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1843)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1844)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1845) 
( 1846)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1847) 
( 1848)     SELF%PTR => DATA(:,:,:,IDX,:)
( 1849)     SELF%ACTIVE = .TRUE.
( 1850)     SELF%THREAD_BUFFER = .FALSE.
( 1851)     SELF%OWNED = .FALSE.
( 1852)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1853)     SELF%BASE_PTR => DATA
( 1854)     SELF%FIDX = IDX
( 1855) 
( 1856)     SELF%ISTATUS = NHSTFRESH
( 1857) 
( 1858)   END FUNCTION FIELD_4D_WRAP_PACKED
( 1859) 
( 1860)   FUNCTION FIELD_5D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1861)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1862)     ! contiguous pointer to existing data and an index.
( 1863)     TYPE(FIELD_5D), TARGET :: SELF
( 1864)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:,:)
( 1865)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1866)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1867) 
( 1868)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1869) 
( 1870)     SELF%PTR => DATA(:,:,:,:,IDX,:)
( 1871)     SELF%ACTIVE = .TRUE.
( 1872)     SELF%THREAD_BUFFER = .FALSE.
( 1873)     SELF%OWNED = .FALSE.
( 1874)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1875)     SELF%BASE_PTR => DATA
( 1876)     SELF%FIDX = IDX
( 1877) 
( 1878)     SELF%ISTATUS = NHSTFRESH
( 1879) 
( 1880)   END FUNCTION FIELD_5D_WRAP_PACKED
( 1881) 
( 1882)   FUNCTION FIELD_INT2D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1883)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1884)     ! contiguous pointer to existing data and an index.
( 1885)     TYPE(FIELD_INT2D), TARGET :: SELF
( 1886)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 35

( 1887)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1888)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1889) 
( 1890)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1891) 
( 1892)     SELF%PTR => DATA(:,IDX,:)
( 1893)     SELF%ACTIVE = .TRUE.
( 1894)     SELF%THREAD_BUFFER = .FALSE.
( 1895)     SELF%OWNED = .FALSE.
( 1896)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1897)     SELF%BASE_PTR => DATA
( 1898)     SELF%FIDX = IDX
( 1899) 
( 1900)     SELF%ISTATUS = NHSTFRESH
( 1901) 
( 1902)   END FUNCTION FIELD_INT2D_WRAP_PACKED
( 1903) 
( 1904)   FUNCTION FIELD_INT3D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1905)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1906)     ! contiguous pointer to existing data and an index.
( 1907)     TYPE(FIELD_INT3D), TARGET :: SELF
( 1908)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1909)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1910)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1911) 
( 1912)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1913) 
( 1914)     SELF%PTR => DATA(:,:,IDX,:)
( 1915)     SELF%ACTIVE = .TRUE.
( 1916)     SELF%THREAD_BUFFER = .FALSE.
( 1917)     SELF%OWNED = .FALSE.
( 1918)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1919)     SELF%BASE_PTR => DATA
( 1920)     SELF%FIDX = IDX
( 1921) 
( 1922)     SELF%ISTATUS = NHSTFRESH
( 1923) 
( 1924)   END FUNCTION FIELD_INT3D_WRAP_PACKED
( 1925) 
( 1926)   FUNCTION FIELD_INT4D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1927)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1928)     ! contiguous pointer to existing data and an index.
( 1929)     TYPE(FIELD_INT4D), TARGET :: SELF
( 1930)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1931)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1932)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1933) 
( 1934)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1935) 
( 1936)     SELF%PTR => DATA(:,:,:,IDX,:)
( 1937)     SELF%ACTIVE = .TRUE.
( 1938)     SELF%THREAD_BUFFER = .FALSE.
( 1939)     SELF%OWNED = .FALSE.
( 1940)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1941)     SELF%BASE_PTR => DATA
( 1942)     SELF%FIDX = IDX
( 1943) 
( 1944)     SELF%ISTATUS = NHSTFRESH






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 36

( 1945) 
( 1946)   END FUNCTION FIELD_INT4D_WRAP_PACKED
( 1947) 
( 1948)   FUNCTION FIELD_INT5D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1949)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1950)     ! contiguous pointer to existing data and an index.
( 1951)     TYPE(FIELD_INT5D), TARGET :: SELF
( 1952)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:,:,:)
( 1953)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1954)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1955) 
( 1956)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1957) 
( 1958)     SELF%PTR => DATA(:,:,:,:,IDX,:)
( 1959)     SELF%ACTIVE = .TRUE.
( 1960)     SELF%THREAD_BUFFER = .FALSE.
( 1961)     SELF%OWNED = .FALSE.
( 1962)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1963)     SELF%BASE_PTR => DATA
( 1964)     SELF%FIDX = IDX
( 1965) 
( 1966)     SELF%ISTATUS = NHSTFRESH
( 1967) 
( 1968)   END FUNCTION FIELD_INT5D_WRAP_PACKED
( 1969) 
( 1970)   FUNCTION FIELD_LOG2D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1971)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1972)     ! contiguous pointer to existing data and an index.
( 1973)     TYPE(FIELD_LOG2D), TARGET :: SELF
( 1974)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:)
( 1975)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1976)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1977) 
( 1978)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1979) 
( 1980)     SELF%PTR => DATA(:,IDX,:)
( 1981)     SELF%ACTIVE = .TRUE.
( 1982)     SELF%THREAD_BUFFER = .FALSE.
( 1983)     SELF%OWNED = .FALSE.
( 1984)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1985)     SELF%BASE_PTR => DATA
( 1986)     SELF%FIDX = IDX
( 1987) 
( 1988)     SELF%ISTATUS = NHSTFRESH
( 1989) 
( 1990)   END FUNCTION FIELD_LOG2D_WRAP_PACKED
( 1991) 
( 1992)   FUNCTION FIELD_LOG3D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1993)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1994)     ! contiguous pointer to existing data and an index.
( 1995)     TYPE(FIELD_LOG3D), TARGET :: SELF
( 1996)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1997)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1998)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1999) 
( 2000)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2001) 
( 2002)     SELF%PTR => DATA(:,:,IDX,:)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 37

( 2003)     SELF%ACTIVE = .TRUE.
( 2004)     SELF%THREAD_BUFFER = .FALSE.
( 2005)     SELF%OWNED = .FALSE.
( 2006)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 2007)     SELF%BASE_PTR => DATA
( 2008)     SELF%FIDX = IDX
( 2009) 
( 2010)     SELF%ISTATUS = NHSTFRESH
( 2011) 
( 2012)   END FUNCTION FIELD_LOG3D_WRAP_PACKED
( 2013) 
( 2014)   FUNCTION FIELD_LOG4D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 2015)     ! Create FIELD object packed in a multi-field buffer by storing a
( 2016)     ! contiguous pointer to existing data and an index.
( 2017)     TYPE(FIELD_LOG4D), TARGET :: SELF
( 2018)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 2019)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 2020)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2021) 
( 2022)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2023) 
( 2024)     SELF%PTR => DATA(:,:,:,IDX,:)
( 2025)     SELF%ACTIVE = .TRUE.
( 2026)     SELF%THREAD_BUFFER = .FALSE.
( 2027)     SELF%OWNED = .FALSE.
( 2028)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 2029)     SELF%BASE_PTR => DATA
( 2030)     SELF%FIDX = IDX
( 2031) 
( 2032)     SELF%ISTATUS = NHSTFRESH
( 2033) 
( 2034)   END FUNCTION FIELD_LOG4D_WRAP_PACKED
( 2035) 
( 2036)   FUNCTION FIELD_LOG5D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 2037)     ! Create FIELD object packed in a multi-field buffer by storing a
( 2038)     ! contiguous pointer to existing data and an index.
( 2039)     TYPE(FIELD_LOG5D), TARGET :: SELF
( 2040)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:,:,:)
( 2041)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 2042)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2043) 
( 2044)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2045) 
( 2046)     SELF%PTR => DATA(:,:,:,:,IDX,:)
( 2047)     SELF%ACTIVE = .TRUE.
( 2048)     SELF%THREAD_BUFFER = .FALSE.
( 2049)     SELF%OWNED = .FALSE.
( 2050)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 2051)     SELF%BASE_PTR => DATA
( 2052)     SELF%FIDX = IDX
( 2053) 
( 2054)     SELF%ISTATUS = NHSTFRESH
( 2055) 
( 2056)   END FUNCTION FIELD_LOG5D_WRAP_PACKED
( 2057) 
( 2058) 
( 2059)   SUBROUTINE ALLOCATE_FIELD_2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2060)     ! Create FIELD object by explicitly allocating new data






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 38

( 2061)     !
( 2062)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2063)     TYPE(FIELD_2D), TARGET :: SELF
( 2064)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2065)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2066)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2067)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2068)     INTEGER(KIND=JPIM) :: NBLK
( 2069) 
( 2070)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2071) 
( 2072)     ! By default we allocate thread-local temporaries
( 2073)     SELF%THREAD_BUFFER = .TRUE.
( 2074)     NBLK = OML_MAX_THREADS()
( 2075) 
( 2076)     IF (PRESENT(PERSISTENT)) THEN
( 2077)       IF (PERSISTENT) THEN
( 2078)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2079)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2080)          & ABOR1('FIELD_2D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2081)         SELF%THREAD_BUFFER = .FALSE.
( 2082)         NBLK = NBLOCKS
( 2083)       END IF
( 2084)     END IF
( 2085) 
( 2086)     ! Allocate storage array and store metadata
( 2087)     ALLOCATE(SELF%DATA(SHAPE(1),NBLK))
( 2088)     SELF%PTR => SELF%DATA
( 2089)     SELF%ACTIVE = .TRUE.
( 2090)     SELF%OWNED = .TRUE.
( 2091)     SELF%NBLOCKS = SIZE(SELF%DATA, 2)
( 2092)     SELF%BASE_PTR => NULL()
( 2093)     SELF%FIDX = -1
( 2094) 
( 2095)     SELF%ISTATUS = NHSTFRESH
( 2096) 
( 2097)   END SUBROUTINE ALLOCATE_FIELD_2D
( 2098) 
( 2099)   FUNCTION FIELD_2D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2100)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2101)     TYPE(FIELD_2D), TARGET :: SELF
( 2102)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2103)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2104)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2105)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2106)     INTEGER(KIND=JPIM) :: NBLK
( 2107)    
( 2108)     CALL ALLOCATE_FIELD_2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2109) 
( 2110)   END FUNCTION FIELD_2D_ALLOCATE
( 2111) 
( 2112)   SUBROUTINE ALLOCATE_FIELD_3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2113)     ! Create FIELD object by explicitly allocating new data
( 2114)     !
( 2115)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2116)     TYPE(FIELD_3D), TARGET :: SELF
( 2117)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2118)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 39

( 2119)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2120)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2121)     INTEGER(KIND=JPIM) :: NBLK
( 2122) 
( 2123)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2124) 
( 2125)     ! By default we allocate thread-local temporaries
( 2126)     SELF%THREAD_BUFFER = .TRUE.
( 2127)     NBLK = OML_MAX_THREADS()
( 2128) 
( 2129)     IF (PRESENT(PERSISTENT)) THEN
( 2130)       IF (PERSISTENT) THEN
( 2131)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2132)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2133)          & ABOR1('FIELD_3D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2134)         SELF%THREAD_BUFFER = .FALSE.
( 2135)         NBLK = NBLOCKS
( 2136)       END IF
( 2137)     END IF
( 2138) 
( 2139)     ! Allocate storage array and store metadata
( 2140)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),NBLK))
( 2141)     SELF%PTR => SELF%DATA
( 2142)     SELF%ACTIVE = .TRUE.
( 2143)     SELF%OWNED = .TRUE.
( 2144)     SELF%NBLOCKS = SIZE(SELF%DATA, 3)
( 2145)     SELF%BASE_PTR => NULL()
( 2146)     SELF%FIDX = -1
( 2147) 
( 2148)     SELF%ISTATUS = NHSTFRESH
( 2149) 
( 2150)   END SUBROUTINE ALLOCATE_FIELD_3D
( 2151) 
( 2152)   FUNCTION FIELD_3D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2153)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2154)     TYPE(FIELD_3D), TARGET :: SELF
( 2155)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2156)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2157)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2158)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2159)     INTEGER(KIND=JPIM) :: NBLK
( 2160)    
( 2161)     CALL ALLOCATE_FIELD_3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2162) 
( 2163)   END FUNCTION FIELD_3D_ALLOCATE
( 2164) 
( 2165)   SUBROUTINE ALLOCATE_FIELD_4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2166)     ! Create FIELD object by explicitly allocating new data
( 2167)     !
( 2168)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2169)     TYPE(FIELD_4D), TARGET :: SELF
( 2170)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2171)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2172)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2173)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2174)     INTEGER(KIND=JPIM) :: NBLK
( 2175) 
( 2176)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 40

( 2177) 
( 2178)     ! By default we allocate thread-local temporaries
( 2179)     SELF%THREAD_BUFFER = .TRUE.
( 2180)     NBLK = OML_MAX_THREADS()
( 2181) 
( 2182)     IF (PRESENT(PERSISTENT)) THEN
( 2183)       IF (PERSISTENT) THEN
( 2184)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2185)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2186)          & ABOR1('FIELD_4D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2187)         SELF%THREAD_BUFFER = .FALSE.
( 2188)         NBLK = NBLOCKS
( 2189)       END IF
( 2190)     END IF
( 2191) 
( 2192)     ! Allocate storage array and store metadata
( 2193)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),NBLK))
( 2194)     SELF%PTR => SELF%DATA
( 2195)     SELF%ACTIVE = .TRUE.
( 2196)     SELF%OWNED = .TRUE.
( 2197)     SELF%NBLOCKS = SIZE(SELF%DATA, 4)
( 2198)     SELF%BASE_PTR => NULL()
( 2199)     SELF%FIDX = -1
( 2200) 
( 2201)     SELF%ISTATUS = NHSTFRESH
( 2202) 
( 2203)   END SUBROUTINE ALLOCATE_FIELD_4D
( 2204) 
( 2205)   FUNCTION FIELD_4D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2206)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2207)     TYPE(FIELD_4D), TARGET :: SELF
( 2208)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2209)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2210)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2211)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2212)     INTEGER(KIND=JPIM) :: NBLK
( 2213)    
( 2214)     CALL ALLOCATE_FIELD_4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2215) 
( 2216)   END FUNCTION FIELD_4D_ALLOCATE
( 2217) 
( 2218)   SUBROUTINE ALLOCATE_FIELD_5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2219)     ! Create FIELD object by explicitly allocating new data
( 2220)     !
( 2221)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2222)     TYPE(FIELD_5D), TARGET :: SELF
( 2223)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2224)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2225)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2226)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2227)     INTEGER(KIND=JPIM) :: NBLK
( 2228) 
( 2229)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2230) 
( 2231)     ! By default we allocate thread-local temporaries
( 2232)     SELF%THREAD_BUFFER = .TRUE.
( 2233)     NBLK = OML_MAX_THREADS()
( 2234) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 41

( 2235)     IF (PRESENT(PERSISTENT)) THEN
( 2236)       IF (PERSISTENT) THEN
( 2237)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2238)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2239)          & ABOR1('FIELD_5D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2240)         SELF%THREAD_BUFFER = .FALSE.
( 2241)         NBLK = NBLOCKS
( 2242)       END IF
( 2243)     END IF
( 2244) 
( 2245)     ! Allocate storage array and store metadata
( 2246)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4),NBLK))
( 2247)     SELF%PTR => SELF%DATA
( 2248)     SELF%ACTIVE = .TRUE.
( 2249)     SELF%OWNED = .TRUE.
( 2250)     SELF%NBLOCKS = SIZE(SELF%DATA, 5)
( 2251)     SELF%BASE_PTR => NULL()
( 2252)     SELF%FIDX = -1
( 2253) 
( 2254)     SELF%ISTATUS = NHSTFRESH
( 2255) 
( 2256)   END SUBROUTINE ALLOCATE_FIELD_5D
( 2257) 
( 2258)   FUNCTION FIELD_5D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2259)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2260)     TYPE(FIELD_5D), TARGET :: SELF
( 2261)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2262)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2263)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2264)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2265)     INTEGER(KIND=JPIM) :: NBLK
( 2266)    
( 2267)     CALL ALLOCATE_FIELD_5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2268) 
( 2269)   END FUNCTION FIELD_5D_ALLOCATE
( 2270) 
( 2271)   SUBROUTINE ALLOCATE_FIELD_INT2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2272)     ! Create FIELD object by explicitly allocating new data
( 2273)     !
( 2274)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2275)     TYPE(FIELD_INT2D), TARGET :: SELF
( 2276)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2277)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2278)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2279)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2280)     INTEGER(KIND=JPIM) :: NBLK
( 2281) 
( 2282)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2283) 
( 2284)     ! By default we allocate thread-local temporaries
( 2285)     SELF%THREAD_BUFFER = .TRUE.
( 2286)     NBLK = OML_MAX_THREADS()
( 2287) 
( 2288)     IF (PRESENT(PERSISTENT)) THEN
( 2289)       IF (PERSISTENT) THEN
( 2290)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2291)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2292)          & ABOR1('FIELD_INT2D_ALLOCATE : NBLOCKS not given for persistent allocation!')






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 42

( 2293)         SELF%THREAD_BUFFER = .FALSE.
( 2294)         NBLK = NBLOCKS
( 2295)       END IF
( 2296)     END IF
( 2297) 
( 2298)     ! Allocate storage array and store metadata
( 2299)     ALLOCATE(SELF%DATA(SHAPE(1),NBLK))
( 2300)     SELF%PTR => SELF%DATA
( 2301)     SELF%ACTIVE = .TRUE.
( 2302)     SELF%OWNED = .TRUE.
( 2303)     SELF%NBLOCKS = SIZE(SELF%DATA, 2)
( 2304)     SELF%BASE_PTR => NULL()
( 2305)     SELF%FIDX = -1
( 2306) 
( 2307)     SELF%ISTATUS = NHSTFRESH
( 2308) 
( 2309)   END SUBROUTINE ALLOCATE_FIELD_INT2D
( 2310) 
( 2311)   FUNCTION FIELD_INT2D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2312)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2313)     TYPE(FIELD_INT2D), TARGET :: SELF
( 2314)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2315)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2316)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2317)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2318)     INTEGER(KIND=JPIM) :: NBLK
( 2319)    
( 2320)     CALL ALLOCATE_FIELD_INT2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2321) 
( 2322)   END FUNCTION FIELD_INT2D_ALLOCATE
( 2323) 
( 2324)   SUBROUTINE ALLOCATE_FIELD_INT3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2325)     ! Create FIELD object by explicitly allocating new data
( 2326)     !
( 2327)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2328)     TYPE(FIELD_INT3D), TARGET :: SELF
( 2329)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2330)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2331)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2332)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2333)     INTEGER(KIND=JPIM) :: NBLK
( 2334) 
( 2335)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2336) 
( 2337)     ! By default we allocate thread-local temporaries
( 2338)     SELF%THREAD_BUFFER = .TRUE.
( 2339)     NBLK = OML_MAX_THREADS()
( 2340) 
( 2341)     IF (PRESENT(PERSISTENT)) THEN
( 2342)       IF (PERSISTENT) THEN
( 2343)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2344)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2345)          & ABOR1('FIELD_INT3D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2346)         SELF%THREAD_BUFFER = .FALSE.
( 2347)         NBLK = NBLOCKS
( 2348)       END IF
( 2349)     END IF
( 2350) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 43

( 2351)     ! Allocate storage array and store metadata
( 2352)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),NBLK))
( 2353)     SELF%PTR => SELF%DATA
( 2354)     SELF%ACTIVE = .TRUE.
( 2355)     SELF%OWNED = .TRUE.
( 2356)     SELF%NBLOCKS = SIZE(SELF%DATA, 3)
( 2357)     SELF%BASE_PTR => NULL()
( 2358)     SELF%FIDX = -1
( 2359) 
( 2360)     SELF%ISTATUS = NHSTFRESH
( 2361) 
( 2362)   END SUBROUTINE ALLOCATE_FIELD_INT3D
( 2363) 
( 2364)   FUNCTION FIELD_INT3D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2365)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2366)     TYPE(FIELD_INT3D), TARGET :: SELF
( 2367)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2368)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2369)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2370)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2371)     INTEGER(KIND=JPIM) :: NBLK
( 2372)    
( 2373)     CALL ALLOCATE_FIELD_INT3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2374) 
( 2375)   END FUNCTION FIELD_INT3D_ALLOCATE
( 2376) 
( 2377)   SUBROUTINE ALLOCATE_FIELD_INT4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2378)     ! Create FIELD object by explicitly allocating new data
( 2379)     !
( 2380)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2381)     TYPE(FIELD_INT4D), TARGET :: SELF
( 2382)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2383)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2384)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2385)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2386)     INTEGER(KIND=JPIM) :: NBLK
( 2387) 
( 2388)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2389) 
( 2390)     ! By default we allocate thread-local temporaries
( 2391)     SELF%THREAD_BUFFER = .TRUE.
( 2392)     NBLK = OML_MAX_THREADS()
( 2393) 
( 2394)     IF (PRESENT(PERSISTENT)) THEN
( 2395)       IF (PERSISTENT) THEN
( 2396)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2397)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2398)          & ABOR1('FIELD_INT4D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2399)         SELF%THREAD_BUFFER = .FALSE.
( 2400)         NBLK = NBLOCKS
( 2401)       END IF
( 2402)     END IF
( 2403) 
( 2404)     ! Allocate storage array and store metadata
( 2405)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),NBLK))
( 2406)     SELF%PTR => SELF%DATA
( 2407)     SELF%ACTIVE = .TRUE.
( 2408)     SELF%OWNED = .TRUE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 44

( 2409)     SELF%NBLOCKS = SIZE(SELF%DATA, 4)
( 2410)     SELF%BASE_PTR => NULL()
( 2411)     SELF%FIDX = -1
( 2412) 
( 2413)     SELF%ISTATUS = NHSTFRESH
( 2414) 
( 2415)   END SUBROUTINE ALLOCATE_FIELD_INT4D
( 2416) 
( 2417)   FUNCTION FIELD_INT4D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2418)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2419)     TYPE(FIELD_INT4D), TARGET :: SELF
( 2420)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2421)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2422)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2423)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2424)     INTEGER(KIND=JPIM) :: NBLK
( 2425)    
( 2426)     CALL ALLOCATE_FIELD_INT4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2427) 
( 2428)   END FUNCTION FIELD_INT4D_ALLOCATE
( 2429) 
( 2430)   SUBROUTINE ALLOCATE_FIELD_INT5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2431)     ! Create FIELD object by explicitly allocating new data
( 2432)     !
( 2433)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2434)     TYPE(FIELD_INT5D), TARGET :: SELF
( 2435)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2436)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2437)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2438)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2439)     INTEGER(KIND=JPIM) :: NBLK
( 2440) 
( 2441)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2442) 
( 2443)     ! By default we allocate thread-local temporaries
( 2444)     SELF%THREAD_BUFFER = .TRUE.
( 2445)     NBLK = OML_MAX_THREADS()
( 2446) 
( 2447)     IF (PRESENT(PERSISTENT)) THEN
( 2448)       IF (PERSISTENT) THEN
( 2449)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2450)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2451)          & ABOR1('FIELD_INT5D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2452)         SELF%THREAD_BUFFER = .FALSE.
( 2453)         NBLK = NBLOCKS
( 2454)       END IF
( 2455)     END IF
( 2456) 
( 2457)     ! Allocate storage array and store metadata
( 2458)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4),NBLK))
( 2459)     SELF%PTR => SELF%DATA
( 2460)     SELF%ACTIVE = .TRUE.
( 2461)     SELF%OWNED = .TRUE.
( 2462)     SELF%NBLOCKS = SIZE(SELF%DATA, 5)
( 2463)     SELF%BASE_PTR => NULL()
( 2464)     SELF%FIDX = -1
( 2465) 
( 2466)     SELF%ISTATUS = NHSTFRESH






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 45

( 2467) 
( 2468)   END SUBROUTINE ALLOCATE_FIELD_INT5D
( 2469) 
( 2470)   FUNCTION FIELD_INT5D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2471)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2472)     TYPE(FIELD_INT5D), TARGET :: SELF
( 2473)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2474)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2475)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2476)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2477)     INTEGER(KIND=JPIM) :: NBLK
( 2478)    
( 2479)     CALL ALLOCATE_FIELD_INT5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2480) 
( 2481)   END FUNCTION FIELD_INT5D_ALLOCATE
( 2482) 
( 2483)   SUBROUTINE ALLOCATE_FIELD_LOG2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2484)     ! Create FIELD object by explicitly allocating new data
( 2485)     !
( 2486)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2487)     TYPE(FIELD_LOG2D), TARGET :: SELF
( 2488)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2489)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2490)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2491)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2492)     INTEGER(KIND=JPIM) :: NBLK
( 2493) 
( 2494)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2495) 
( 2496)     ! By default we allocate thread-local temporaries
( 2497)     SELF%THREAD_BUFFER = .TRUE.
( 2498)     NBLK = OML_MAX_THREADS()
( 2499) 
( 2500)     IF (PRESENT(PERSISTENT)) THEN
( 2501)       IF (PERSISTENT) THEN
( 2502)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2503)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2504)          & ABOR1('FIELD_LOG2D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2505)         SELF%THREAD_BUFFER = .FALSE.
( 2506)         NBLK = NBLOCKS
( 2507)       END IF
( 2508)     END IF
( 2509) 
( 2510)     ! Allocate storage array and store metadata
( 2511)     ALLOCATE(SELF%DATA(SHAPE(1),NBLK))
( 2512)     SELF%PTR => SELF%DATA
( 2513)     SELF%ACTIVE = .TRUE.
( 2514)     SELF%OWNED = .TRUE.
( 2515)     SELF%NBLOCKS = SIZE(SELF%DATA, 2)
( 2516)     SELF%BASE_PTR => NULL()
( 2517)     SELF%FIDX = -1
( 2518) 
( 2519)     SELF%ISTATUS = NHSTFRESH
( 2520) 
( 2521)   END SUBROUTINE ALLOCATE_FIELD_LOG2D
( 2522) 
( 2523)   FUNCTION FIELD_LOG2D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2524)     ! WARNING : Using this function kills performance when the %DATA member is allocated






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 46

( 2525)     TYPE(FIELD_LOG2D), TARGET :: SELF
( 2526)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2527)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2528)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2529)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2530)     INTEGER(KIND=JPIM) :: NBLK
( 2531)    
( 2532)     CALL ALLOCATE_FIELD_LOG2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2533) 
( 2534)   END FUNCTION FIELD_LOG2D_ALLOCATE
( 2535) 
( 2536)   SUBROUTINE ALLOCATE_FIELD_LOG3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2537)     ! Create FIELD object by explicitly allocating new data
( 2538)     !
( 2539)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2540)     TYPE(FIELD_LOG3D), TARGET :: SELF
( 2541)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2542)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2543)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2544)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2545)     INTEGER(KIND=JPIM) :: NBLK
( 2546) 
( 2547)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2548) 
( 2549)     ! By default we allocate thread-local temporaries
( 2550)     SELF%THREAD_BUFFER = .TRUE.
( 2551)     NBLK = OML_MAX_THREADS()
( 2552) 
( 2553)     IF (PRESENT(PERSISTENT)) THEN
( 2554)       IF (PERSISTENT) THEN
( 2555)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2556)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2557)          & ABOR1('FIELD_LOG3D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2558)         SELF%THREAD_BUFFER = .FALSE.
( 2559)         NBLK = NBLOCKS
( 2560)       END IF
( 2561)     END IF
( 2562) 
( 2563)     ! Allocate storage array and store metadata
( 2564)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),NBLK))
( 2565)     SELF%PTR => SELF%DATA
( 2566)     SELF%ACTIVE = .TRUE.
( 2567)     SELF%OWNED = .TRUE.
( 2568)     SELF%NBLOCKS = SIZE(SELF%DATA, 3)
( 2569)     SELF%BASE_PTR => NULL()
( 2570)     SELF%FIDX = -1
( 2571) 
( 2572)     SELF%ISTATUS = NHSTFRESH
( 2573) 
( 2574)   END SUBROUTINE ALLOCATE_FIELD_LOG3D
( 2575) 
( 2576)   FUNCTION FIELD_LOG3D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2577)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2578)     TYPE(FIELD_LOG3D), TARGET :: SELF
( 2579)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2580)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2581)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2582)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 47

( 2583)     INTEGER(KIND=JPIM) :: NBLK
( 2584)    
( 2585)     CALL ALLOCATE_FIELD_LOG3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2586) 
( 2587)   END FUNCTION FIELD_LOG3D_ALLOCATE
( 2588) 
( 2589)   SUBROUTINE ALLOCATE_FIELD_LOG4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2590)     ! Create FIELD object by explicitly allocating new data
( 2591)     !
( 2592)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2593)     TYPE(FIELD_LOG4D), TARGET :: SELF
( 2594)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2595)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2596)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2597)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2598)     INTEGER(KIND=JPIM) :: NBLK
( 2599) 
( 2600)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2601) 
( 2602)     ! By default we allocate thread-local temporaries
( 2603)     SELF%THREAD_BUFFER = .TRUE.
( 2604)     NBLK = OML_MAX_THREADS()
( 2605) 
( 2606)     IF (PRESENT(PERSISTENT)) THEN
( 2607)       IF (PERSISTENT) THEN
( 2608)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2609)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2610)          & ABOR1('FIELD_LOG4D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2611)         SELF%THREAD_BUFFER = .FALSE.
( 2612)         NBLK = NBLOCKS
( 2613)       END IF
( 2614)     END IF
( 2615) 
( 2616)     ! Allocate storage array and store metadata
( 2617)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),NBLK))
( 2618)     SELF%PTR => SELF%DATA
( 2619)     SELF%ACTIVE = .TRUE.
( 2620)     SELF%OWNED = .TRUE.
( 2621)     SELF%NBLOCKS = SIZE(SELF%DATA, 4)
( 2622)     SELF%BASE_PTR => NULL()
( 2623)     SELF%FIDX = -1
( 2624) 
( 2625)     SELF%ISTATUS = NHSTFRESH
( 2626) 
( 2627)   END SUBROUTINE ALLOCATE_FIELD_LOG4D
( 2628) 
( 2629)   FUNCTION FIELD_LOG4D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2630)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2631)     TYPE(FIELD_LOG4D), TARGET :: SELF
( 2632)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2633)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2634)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2635)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2636)     INTEGER(KIND=JPIM) :: NBLK
( 2637)    
( 2638)     CALL ALLOCATE_FIELD_LOG4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2639) 
( 2640)   END FUNCTION FIELD_LOG4D_ALLOCATE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 48

( 2641) 
( 2642)   SUBROUTINE ALLOCATE_FIELD_LOG5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2643)     ! Create FIELD object by explicitly allocating new data
( 2644)     !
( 2645)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2646)     TYPE(FIELD_LOG5D), TARGET :: SELF
( 2647)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2648)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2649)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2650)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2651)     INTEGER(KIND=JPIM) :: NBLK
( 2652) 
( 2653)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2654) 
( 2655)     ! By default we allocate thread-local temporaries
( 2656)     SELF%THREAD_BUFFER = .TRUE.
( 2657)     NBLK = OML_MAX_THREADS()
( 2658) 
( 2659)     IF (PRESENT(PERSISTENT)) THEN
( 2660)       IF (PERSISTENT) THEN
( 2661)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2662)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2663)          & ABOR1('FIELD_LOG5D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2664)         SELF%THREAD_BUFFER = .FALSE.
( 2665)         NBLK = NBLOCKS
( 2666)       END IF
( 2667)     END IF
( 2668) 
( 2669)     ! Allocate storage array and store metadata
( 2670)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4),NBLK))
( 2671)     SELF%PTR => SELF%DATA
( 2672)     SELF%ACTIVE = .TRUE.
( 2673)     SELF%OWNED = .TRUE.
( 2674)     SELF%NBLOCKS = SIZE(SELF%DATA, 5)
( 2675)     SELF%BASE_PTR => NULL()
( 2676)     SELF%FIDX = -1
( 2677) 
( 2678)     SELF%ISTATUS = NHSTFRESH
( 2679) 
( 2680)   END SUBROUTINE ALLOCATE_FIELD_LOG5D
( 2681) 
( 2682)   FUNCTION FIELD_LOG5D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2683)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2684)     TYPE(FIELD_LOG5D), TARGET :: SELF
( 2685)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2686)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2687)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2688)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2689)     INTEGER(KIND=JPIM) :: NBLK
( 2690)    
( 2691)     CALL ALLOCATE_FIELD_LOG5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2692) 
( 2693)   END FUNCTION FIELD_LOG5D_ALLOCATE
( 2694) 
( 2695) 
( 2696)   FUNCTION FIELD_2D_CLONE(SELF) RESULT(NEWOBJ)
( 2697)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2698)     ! intact, but replicating view pointers.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 49

( 2699)     CLASS(FIELD_2D) :: SELF
( 2700)     TYPE(FIELD_2D), POINTER :: NEWOBJ
( 2701) 
( 2702)     ALLOCATE(NEWOBJ)
( 2703)     ! For owned storage data, re-allocate but do not copy data over
( 2704)     IF (SELF%OWNED) THEN
( 2705)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2706)       NEWOBJ%PTR => NEWOBJ%DATA
( 2707)     ELSE
( 2708)       NEWOBJ%PTR => SELF%PTR
( 2709)     END IF
( 2710)     NEWOBJ%VIEW => NULL()
( 2711)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2712)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2713)     NEWOBJ%OWNED = .FALSE.
( 2714)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2715)   END FUNCTION FIELD_2D_CLONE
( 2716) 
( 2717)   FUNCTION FIELD_3D_CLONE(SELF) RESULT(NEWOBJ)
( 2718)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2719)     ! intact, but replicating view pointers.
( 2720)     CLASS(FIELD_3D) :: SELF
( 2721)     TYPE(FIELD_3D), POINTER :: NEWOBJ
( 2722) 
( 2723)     ALLOCATE(NEWOBJ)
( 2724)     ! For owned storage data, re-allocate but do not copy data over
( 2725)     IF (SELF%OWNED) THEN
( 2726)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2727)       NEWOBJ%PTR => NEWOBJ%DATA
( 2728)     ELSE
( 2729)       NEWOBJ%PTR => SELF%PTR
( 2730)     END IF
( 2731)     NEWOBJ%VIEW => NULL()
( 2732)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2733)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2734)     NEWOBJ%OWNED = .FALSE.
( 2735)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2736)   END FUNCTION FIELD_3D_CLONE
( 2737) 
( 2738)   FUNCTION FIELD_4D_CLONE(SELF) RESULT(NEWOBJ)
( 2739)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2740)     ! intact, but replicating view pointers.
( 2741)     CLASS(FIELD_4D) :: SELF
( 2742)     TYPE(FIELD_4D), POINTER :: NEWOBJ
( 2743) 
( 2744)     ALLOCATE(NEWOBJ)
( 2745)     ! For owned storage data, re-allocate but do not copy data over
( 2746)     IF (SELF%OWNED) THEN
( 2747)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2748)       NEWOBJ%PTR => NEWOBJ%DATA
( 2749)     ELSE
( 2750)       NEWOBJ%PTR => SELF%PTR
( 2751)     END IF
( 2752)     NEWOBJ%VIEW => NULL()
( 2753)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2754)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2755)     NEWOBJ%OWNED = .FALSE.
( 2756)     NEWOBJ%LBOUNDS = SELF%LBOUNDS






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 50

( 2757)   END FUNCTION FIELD_4D_CLONE
( 2758) 
( 2759)   FUNCTION FIELD_5D_CLONE(SELF) RESULT(NEWOBJ)
( 2760)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2761)     ! intact, but replicating view pointers.
( 2762)     CLASS(FIELD_5D) :: SELF
( 2763)     TYPE(FIELD_5D), POINTER :: NEWOBJ
( 2764) 
( 2765)     ALLOCATE(NEWOBJ)
( 2766)     ! For owned storage data, re-allocate but do not copy data over
( 2767)     IF (SELF%OWNED) THEN
( 2768)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2769)       NEWOBJ%PTR => NEWOBJ%DATA
( 2770)     ELSE
( 2771)       NEWOBJ%PTR => SELF%PTR
( 2772)     END IF
( 2773)     NEWOBJ%VIEW => NULL()
( 2774)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2775)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2776)     NEWOBJ%OWNED = .FALSE.
( 2777)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2778)   END FUNCTION FIELD_5D_CLONE
( 2779) 
( 2780)   FUNCTION FIELD_INT2D_CLONE(SELF) RESULT(NEWOBJ)
( 2781)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2782)     ! intact, but replicating view pointers.
( 2783)     CLASS(FIELD_INT2D) :: SELF
( 2784)     TYPE(FIELD_INT2D), POINTER :: NEWOBJ
( 2785) 
( 2786)     ALLOCATE(NEWOBJ)
( 2787)     ! For owned storage data, re-allocate but do not copy data over
( 2788)     IF (SELF%OWNED) THEN
( 2789)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2790)       NEWOBJ%PTR => NEWOBJ%DATA
( 2791)     ELSE
( 2792)       NEWOBJ%PTR => SELF%PTR
( 2793)     END IF
( 2794)     NEWOBJ%VIEW => NULL()
( 2795)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2796)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2797)     NEWOBJ%OWNED = .FALSE.
( 2798)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2799)   END FUNCTION FIELD_INT2D_CLONE
( 2800) 
( 2801)   FUNCTION FIELD_INT3D_CLONE(SELF) RESULT(NEWOBJ)
( 2802)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2803)     ! intact, but replicating view pointers.
( 2804)     CLASS(FIELD_INT3D) :: SELF
( 2805)     TYPE(FIELD_INT3D), POINTER :: NEWOBJ
( 2806) 
( 2807)     ALLOCATE(NEWOBJ)
( 2808)     ! For owned storage data, re-allocate but do not copy data over
( 2809)     IF (SELF%OWNED) THEN
( 2810)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2811)       NEWOBJ%PTR => NEWOBJ%DATA
( 2812)     ELSE
( 2813)       NEWOBJ%PTR => SELF%PTR
( 2814)     END IF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 51

( 2815)     NEWOBJ%VIEW => NULL()
( 2816)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2817)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2818)     NEWOBJ%OWNED = .FALSE.
( 2819)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2820)   END FUNCTION FIELD_INT3D_CLONE
( 2821) 
( 2822)   FUNCTION FIELD_INT4D_CLONE(SELF) RESULT(NEWOBJ)
( 2823)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2824)     ! intact, but replicating view pointers.
( 2825)     CLASS(FIELD_INT4D) :: SELF
( 2826)     TYPE(FIELD_INT4D), POINTER :: NEWOBJ
( 2827) 
( 2828)     ALLOCATE(NEWOBJ)
( 2829)     ! For owned storage data, re-allocate but do not copy data over
( 2830)     IF (SELF%OWNED) THEN
( 2831)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2832)       NEWOBJ%PTR => NEWOBJ%DATA
( 2833)     ELSE
( 2834)       NEWOBJ%PTR => SELF%PTR
( 2835)     END IF
( 2836)     NEWOBJ%VIEW => NULL()
( 2837)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2838)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2839)     NEWOBJ%OWNED = .FALSE.
( 2840)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2841)   END FUNCTION FIELD_INT4D_CLONE
( 2842) 
( 2843)   FUNCTION FIELD_INT5D_CLONE(SELF) RESULT(NEWOBJ)
( 2844)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2845)     ! intact, but replicating view pointers.
( 2846)     CLASS(FIELD_INT5D) :: SELF
( 2847)     TYPE(FIELD_INT5D), POINTER :: NEWOBJ
( 2848) 
( 2849)     ALLOCATE(NEWOBJ)
( 2850)     ! For owned storage data, re-allocate but do not copy data over
( 2851)     IF (SELF%OWNED) THEN
( 2852)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2853)       NEWOBJ%PTR => NEWOBJ%DATA
( 2854)     ELSE
( 2855)       NEWOBJ%PTR => SELF%PTR
( 2856)     END IF
( 2857)     NEWOBJ%VIEW => NULL()
( 2858)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2859)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2860)     NEWOBJ%OWNED = .FALSE.
( 2861)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2862)   END FUNCTION FIELD_INT5D_CLONE
( 2863) 
( 2864)   FUNCTION FIELD_LOG2D_CLONE(SELF) RESULT(NEWOBJ)
( 2865)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2866)     ! intact, but replicating view pointers.
( 2867)     CLASS(FIELD_LOG2D) :: SELF
( 2868)     TYPE(FIELD_LOG2D), POINTER :: NEWOBJ
( 2869) 
( 2870)     ALLOCATE(NEWOBJ)
( 2871)     ! For owned storage data, re-allocate but do not copy data over
( 2872)     IF (SELF%OWNED) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 52

( 2873)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2874)       NEWOBJ%PTR => NEWOBJ%DATA
( 2875)     ELSE
( 2876)       NEWOBJ%PTR => SELF%PTR
( 2877)     END IF
( 2878)     NEWOBJ%VIEW => NULL()
( 2879)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2880)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2881)     NEWOBJ%OWNED = .FALSE.
( 2882)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2883)   END FUNCTION FIELD_LOG2D_CLONE
( 2884) 
( 2885)   FUNCTION FIELD_LOG3D_CLONE(SELF) RESULT(NEWOBJ)
( 2886)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2887)     ! intact, but replicating view pointers.
( 2888)     CLASS(FIELD_LOG3D) :: SELF
( 2889)     TYPE(FIELD_LOG3D), POINTER :: NEWOBJ
( 2890) 
( 2891)     ALLOCATE(NEWOBJ)
( 2892)     ! For owned storage data, re-allocate but do not copy data over
( 2893)     IF (SELF%OWNED) THEN
( 2894)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2895)       NEWOBJ%PTR => NEWOBJ%DATA
( 2896)     ELSE
( 2897)       NEWOBJ%PTR => SELF%PTR
( 2898)     END IF
( 2899)     NEWOBJ%VIEW => NULL()
( 2900)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2901)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2902)     NEWOBJ%OWNED = .FALSE.
( 2903)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2904)   END FUNCTION FIELD_LOG3D_CLONE
( 2905) 
( 2906)   FUNCTION FIELD_LOG4D_CLONE(SELF) RESULT(NEWOBJ)
( 2907)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2908)     ! intact, but replicating view pointers.
( 2909)     CLASS(FIELD_LOG4D) :: SELF
( 2910)     TYPE(FIELD_LOG4D), POINTER :: NEWOBJ
( 2911) 
( 2912)     ALLOCATE(NEWOBJ)
( 2913)     ! For owned storage data, re-allocate but do not copy data over
( 2914)     IF (SELF%OWNED) THEN
( 2915)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2916)       NEWOBJ%PTR => NEWOBJ%DATA
( 2917)     ELSE
( 2918)       NEWOBJ%PTR => SELF%PTR
( 2919)     END IF
( 2920)     NEWOBJ%VIEW => NULL()
( 2921)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2922)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2923)     NEWOBJ%OWNED = .FALSE.
( 2924)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2925)   END FUNCTION FIELD_LOG4D_CLONE
( 2926) 
( 2927)   FUNCTION FIELD_LOG5D_CLONE(SELF) RESULT(NEWOBJ)
( 2928)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2929)     ! intact, but replicating view pointers.
( 2930)     CLASS(FIELD_LOG5D) :: SELF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 53

( 2931)     TYPE(FIELD_LOG5D), POINTER :: NEWOBJ
( 2932) 
( 2933)     ALLOCATE(NEWOBJ)
( 2934)     ! For owned storage data, re-allocate but do not copy data over
( 2935)     IF (SELF%OWNED) THEN
( 2936)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2937)       NEWOBJ%PTR => NEWOBJ%DATA
( 2938)     ELSE
( 2939)       NEWOBJ%PTR => SELF%PTR
( 2940)     END IF
( 2941)     NEWOBJ%VIEW => NULL()
( 2942)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2943)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2944)     NEWOBJ%OWNED = .FALSE.
( 2945)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2946)   END FUNCTION FIELD_LOG5D_CLONE
( 2947) 
( 2948) 
( 2949)   SUBROUTINE FIELD_2D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 2950)     ! Sets the view pointer FIELD%MP to the block of the given index
( 2951)     CLASS(FIELD_2D), TARGET :: SELF
( 2952)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 2953)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 2954)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 2955)     INTEGER(KIND=JPIM) :: IDX
( 2956) 
( 2957)     IDX = BLOCK_INDEX
( 2958)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 2959)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 2960)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 2961)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 2962)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 2963)     END IF
( 2964) 
( 2965)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 2966)       ! Fill the the buffer by replicating the last entry
( 2967)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 2968)     END IF
( 2969) 
( 2970)     IF (PRESENT(ZERO)) THEN
( 2971)       IF (ZERO) SELF%VIEW(:) = 0.0_JPRB
( 2972)     END IF
( 2973)   END SUBROUTINE FIELD_2D_UPDATE_VIEW
( 2974) 
( 2975)   SUBROUTINE FIELD_3D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 2976)     ! Sets the view pointer FIELD%MP to the block of the given index
( 2977)     CLASS(FIELD_3D), TARGET :: SELF
( 2978)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 2979)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 2980)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 2981)     INTEGER(KIND=JPIM) :: IDX
( 2982) 
( 2983)     IDX = BLOCK_INDEX
( 2984)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 2985)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 2986)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 2987)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 2988)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 54

( 2989)     END IF
( 2990) 
( 2991)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 2992)       ! Fill the the buffer by replicating the last entry
( 2993)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 2994)     END IF
( 2995) 
( 2996)     IF (PRESENT(ZERO)) THEN
( 2997)       IF (ZERO) SELF%VIEW(:,:) = 0.0_JPRB
( 2998)     END IF
( 2999)   END SUBROUTINE FIELD_3D_UPDATE_VIEW
( 3000) 
( 3001)   SUBROUTINE FIELD_4D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3002)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3003)     CLASS(FIELD_4D), TARGET :: SELF
( 3004)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3005)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3006)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3007)     INTEGER(KIND=JPIM) :: IDX
( 3008) 
( 3009)     IDX = BLOCK_INDEX
( 3010)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3011)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3012)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3013)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3014)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3015)     END IF
( 3016) 
( 3017)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3018)       ! Fill the the buffer by replicating the last entry
( 3019)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3020)     END IF
( 3021) 
( 3022)     IF (PRESENT(ZERO)) THEN
( 3023)       IF (ZERO) SELF%VIEW(:,:,:) = 0.0_JPRB
( 3024)     END IF
( 3025)   END SUBROUTINE FIELD_4D_UPDATE_VIEW
( 3026) 
( 3027)   SUBROUTINE FIELD_5D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3028)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3029)     CLASS(FIELD_5D), TARGET :: SELF
( 3030)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3031)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3032)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3033)     INTEGER(KIND=JPIM) :: IDX
( 3034) 
( 3035)     IDX = BLOCK_INDEX
( 3036)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3037)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3038)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3039)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3040)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3041)     END IF
( 3042) 
( 3043)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3044)       ! Fill the the buffer by replicating the last entry
( 3045)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3046)     END IF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 55

( 3047) 
( 3048)     IF (PRESENT(ZERO)) THEN
( 3049)       IF (ZERO) SELF%VIEW(:,:,:,:) = 0.0_JPRB
( 3050)     END IF
( 3051)   END SUBROUTINE FIELD_5D_UPDATE_VIEW
( 3052) 
( 3053)   SUBROUTINE FIELD_INT2D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3054)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3055)     CLASS(FIELD_INT2D), TARGET :: SELF
( 3056)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3057)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3058)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3059)     INTEGER(KIND=JPIM) :: IDX
( 3060) 
( 3061)     IDX = BLOCK_INDEX
( 3062)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3063)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3064)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3065)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3066)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3067)     END IF
( 3068) 
( 3069)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3070)       ! Fill the the buffer by replicating the last entry
( 3071)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3072)     END IF
( 3073) 
( 3074)     IF (PRESENT(ZERO)) THEN
( 3075)       IF (ZERO) SELF%VIEW(:) = 0.0_JPIM
( 3076)     END IF
( 3077)   END SUBROUTINE FIELD_INT2D_UPDATE_VIEW
( 3078) 
( 3079)   SUBROUTINE FIELD_INT3D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3080)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3081)     CLASS(FIELD_INT3D), TARGET :: SELF
( 3082)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3083)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3084)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3085)     INTEGER(KIND=JPIM) :: IDX
( 3086) 
( 3087)     IDX = BLOCK_INDEX
( 3088)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3089)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3090)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3091)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3092)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3093)     END IF
( 3094) 
( 3095)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3096)       ! Fill the the buffer by replicating the last entry
( 3097)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3098)     END IF
( 3099) 
( 3100)     IF (PRESENT(ZERO)) THEN
( 3101)       IF (ZERO) SELF%VIEW(:,:) = 0.0_JPIM
( 3102)     END IF
( 3103)   END SUBROUTINE FIELD_INT3D_UPDATE_VIEW
( 3104) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 56

( 3105)   SUBROUTINE FIELD_INT4D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3106)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3107)     CLASS(FIELD_INT4D), TARGET :: SELF
( 3108)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3109)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3110)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3111)     INTEGER(KIND=JPIM) :: IDX
( 3112) 
( 3113)     IDX = BLOCK_INDEX
( 3114)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3115)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3116)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3117)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3118)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3119)     END IF
( 3120) 
( 3121)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3122)       ! Fill the the buffer by replicating the last entry
( 3123)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3124)     END IF
( 3125) 
( 3126)     IF (PRESENT(ZERO)) THEN
( 3127)       IF (ZERO) SELF%VIEW(:,:,:) = 0.0_JPIM
( 3128)     END IF
( 3129)   END SUBROUTINE FIELD_INT4D_UPDATE_VIEW
( 3130) 
( 3131)   SUBROUTINE FIELD_INT5D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3132)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3133)     CLASS(FIELD_INT5D), TARGET :: SELF
( 3134)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3135)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3136)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3137)     INTEGER(KIND=JPIM) :: IDX
( 3138) 
( 3139)     IDX = BLOCK_INDEX
( 3140)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3141)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3142)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3143)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3144)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3145)     END IF
( 3146) 
( 3147)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3148)       ! Fill the the buffer by replicating the last entry
( 3149)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3150)     END IF
( 3151) 
( 3152)     IF (PRESENT(ZERO)) THEN
( 3153)       IF (ZERO) SELF%VIEW(:,:,:,:) = 0.0_JPIM
( 3154)     END IF
( 3155)   END SUBROUTINE FIELD_INT5D_UPDATE_VIEW
( 3156) 
( 3157)   SUBROUTINE FIELD_LOG2D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3158)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3159)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 3160)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3161)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3162)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 57

( 3163)     INTEGER(KIND=JPIM) :: IDX
( 3164) 
( 3165)     IDX = BLOCK_INDEX
( 3166)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3167)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3168)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3169)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3170)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3171)     END IF
( 3172) 
( 3173)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3174)       ! Fill the the buffer by replicating the last entry
( 3175)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3176)     END IF
( 3177) 
( 3178)     IF (PRESENT(ZERO)) THEN
( 3179)       IF (ZERO) SELF%VIEW(:) = .FALSE.
( 3180)     END IF
( 3181)   END SUBROUTINE FIELD_LOG2D_UPDATE_VIEW
( 3182) 
( 3183)   SUBROUTINE FIELD_LOG3D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3184)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3185)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 3186)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3187)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3188)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3189)     INTEGER(KIND=JPIM) :: IDX
( 3190) 
( 3191)     IDX = BLOCK_INDEX
( 3192)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3193)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3194)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3195)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3196)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3197)     END IF
( 3198) 
( 3199)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3200)       ! Fill the the buffer by replicating the last entry
( 3201)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3202)     END IF
( 3203) 
( 3204)     IF (PRESENT(ZERO)) THEN
( 3205)       IF (ZERO) SELF%VIEW(:,:) = .FALSE.
( 3206)     END IF
( 3207)   END SUBROUTINE FIELD_LOG3D_UPDATE_VIEW
( 3208) 
( 3209)   SUBROUTINE FIELD_LOG4D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3210)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3211)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 3212)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3213)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3214)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3215)     INTEGER(KIND=JPIM) :: IDX
( 3216) 
( 3217)     IDX = BLOCK_INDEX
( 3218)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3219)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3220)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 58

( 3221)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3222)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3223)     END IF
( 3224) 
( 3225)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3226)       ! Fill the the buffer by replicating the last entry
( 3227)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3228)     END IF
( 3229) 
( 3230)     IF (PRESENT(ZERO)) THEN
( 3231)       IF (ZERO) SELF%VIEW(:,:,:) = .FALSE.
( 3232)     END IF
( 3233)   END SUBROUTINE FIELD_LOG4D_UPDATE_VIEW
( 3234) 
( 3235)   SUBROUTINE FIELD_LOG5D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3236)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3237)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 3238)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3239)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3240)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3241)     INTEGER(KIND=JPIM) :: IDX
( 3242) 
( 3243)     IDX = BLOCK_INDEX
( 3244)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3245)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3246)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3247)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3248)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3249)     END IF
( 3250) 
( 3251)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3252)       ! Fill the the buffer by replicating the last entry
( 3253)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3254)     END IF
( 3255) 
( 3256)     IF (PRESENT(ZERO)) THEN
( 3257)       IF (ZERO) SELF%VIEW(:,:,:,:) = .FALSE.
( 3258)     END IF
( 3259)   END SUBROUTINE FIELD_LOG5D_UPDATE_VIEW
( 3260) 
( 3261) 
( 3262)   SUBROUTINE FIELD_2D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3263)     ! Updates internal view and exports it to an external pointer
( 3264)     CLASS(FIELD_2D), TARGET :: SELF
( 3265)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: VIEW_PTR(:)
( 3266)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3267)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3268)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3269)     INTEGER(KIND=JPIM) :: IDX
( 3270) 
( 3271)     IDX = BLOCK_INDEX
( 3272)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3273)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3274)       VIEW_PTR (SELF%LBOUNDS(1):)  => SELF%DATA(:,IDX)
( 3275)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3276)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3277)     ELSE
( 3278)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 59

( 3279)     END IF
( 3280) 
( 3281)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3282)       ! Fill the the buffer by replicating the last entry
( 3283)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3284)     END IF
( 3285) 
( 3286)     IF (PRESENT(ZERO)) THEN
( 3287)       IF (ZERO) VIEW_PTR(:) = 0.0_JPRB
( 3288)     END IF
( 3289)   END SUBROUTINE FIELD_2D_EXTRACT_VIEW
( 3290) 
( 3291)   SUBROUTINE FIELD_3D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3292)     ! Updates internal view and exports it to an external pointer
( 3293)     CLASS(FIELD_3D), TARGET :: SELF
( 3294)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:)
( 3295)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3296)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3297)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3298)     INTEGER(KIND=JPIM) :: IDX
( 3299) 
( 3300)     IDX = BLOCK_INDEX
( 3301)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3302)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3303)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):)  => SELF%DATA(:,:,IDX)
( 3304)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3305)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3306)     ELSE
( 3307)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3308)     END IF
( 3309) 
( 3310)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3311)       ! Fill the the buffer by replicating the last entry
( 3312)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3313)     END IF
( 3314) 
( 3315)     IF (PRESENT(ZERO)) THEN
( 3316)       IF (ZERO) VIEW_PTR(:,:) = 0.0_JPRB
( 3317)     END IF
( 3318)   END SUBROUTINE FIELD_3D_EXTRACT_VIEW
( 3319) 
( 3320)   SUBROUTINE FIELD_4D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3321)     ! Updates internal view and exports it to an external pointer
( 3322)     CLASS(FIELD_4D), TARGET :: SELF
( 3323)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:)
( 3324)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3325)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3326)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3327)     INTEGER(KIND=JPIM) :: IDX
( 3328) 
( 3329)     IDX = BLOCK_INDEX
( 3330)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3331)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3332)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):)  => SELF%DATA(:,:,:,IDX)
( 3333)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3334)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3335)     ELSE
( 3336)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 60

( 3337)     END IF
( 3338) 
( 3339)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3340)       ! Fill the the buffer by replicating the last entry
( 3341)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3342)     END IF
( 3343) 
( 3344)     IF (PRESENT(ZERO)) THEN
( 3345)       IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPRB
( 3346)     END IF
( 3347)   END SUBROUTINE FIELD_4D_EXTRACT_VIEW
( 3348) 
( 3349)   SUBROUTINE FIELD_5D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3350)     ! Updates internal view and exports it to an external pointer
( 3351)     CLASS(FIELD_5D), TARGET :: SELF
( 3352)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:,:)
( 3353)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3354)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3355)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3356)     INTEGER(KIND=JPIM) :: IDX
( 3357) 
( 3358)     IDX = BLOCK_INDEX
( 3359)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3360)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3361)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):)  => SELF%DATA(:,:,:,:,IDX)
( 3362)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3363)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3364)     ELSE
( 3365)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field b
( 3366)     END IF
( 3367) 
( 3368)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3369)       ! Fill the the buffer by replicating the last entry
( 3370)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3371)     END IF
( 3372) 
( 3373)     IF (PRESENT(ZERO)) THEN
( 3374)       IF (ZERO) VIEW_PTR(:,:,:,:) = 0.0_JPRB
( 3375)     END IF
( 3376)   END SUBROUTINE FIELD_5D_EXTRACT_VIEW
( 3377) 
( 3378)   SUBROUTINE FIELD_INT2D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3379)     ! Updates internal view and exports it to an external pointer
( 3380)     CLASS(FIELD_INT2D), TARGET :: SELF
( 3381)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: VIEW_PTR(:)
( 3382)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3383)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3384)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3385)     INTEGER(KIND=JPIM) :: IDX
( 3386) 
( 3387)     IDX = BLOCK_INDEX
( 3388)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3389)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3390)       VIEW_PTR (SELF%LBOUNDS(1):)  => SELF%DATA(:,IDX)
( 3391)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3392)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3393)     ELSE
( 3394)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 61

( 3395)     END IF
( 3396) 
( 3397)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3398)       ! Fill the the buffer by replicating the last entry
( 3399)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3400)     END IF
( 3401) 
( 3402)     IF (PRESENT(ZERO)) THEN
( 3403)       IF (ZERO) VIEW_PTR(:) = 0.0_JPIM
( 3404)     END IF
( 3405)   END SUBROUTINE FIELD_INT2D_EXTRACT_VIEW
( 3406) 
( 3407)   SUBROUTINE FIELD_INT3D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3408)     ! Updates internal view and exports it to an external pointer
( 3409)     CLASS(FIELD_INT3D), TARGET :: SELF
( 3410)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:)
( 3411)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3412)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3413)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3414)     INTEGER(KIND=JPIM) :: IDX
( 3415) 
( 3416)     IDX = BLOCK_INDEX
( 3417)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3418)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3419)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):)  => SELF%DATA(:,:,IDX)
( 3420)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3421)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3422)     ELSE
( 3423)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3424)     END IF
( 3425) 
( 3426)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3427)       ! Fill the the buffer by replicating the last entry
( 3428)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3429)     END IF
( 3430) 
( 3431)     IF (PRESENT(ZERO)) THEN
( 3432)       IF (ZERO) VIEW_PTR(:,:) = 0.0_JPIM
( 3433)     END IF
( 3434)   END SUBROUTINE FIELD_INT3D_EXTRACT_VIEW
( 3435) 
( 3436)   SUBROUTINE FIELD_INT4D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3437)     ! Updates internal view and exports it to an external pointer
( 3438)     CLASS(FIELD_INT4D), TARGET :: SELF
( 3439)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:)
( 3440)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3441)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3442)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3443)     INTEGER(KIND=JPIM) :: IDX
( 3444) 
( 3445)     IDX = BLOCK_INDEX
( 3446)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3447)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3448)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):)  => SELF%DATA(:,:,:,IDX)
( 3449)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3450)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3451)     ELSE
( 3452)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 62

( 3453)     END IF
( 3454) 
( 3455)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3456)       ! Fill the the buffer by replicating the last entry
( 3457)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3458)     END IF
( 3459) 
( 3460)     IF (PRESENT(ZERO)) THEN
( 3461)       IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPIM
( 3462)     END IF
( 3463)   END SUBROUTINE FIELD_INT4D_EXTRACT_VIEW
( 3464) 
( 3465)   SUBROUTINE FIELD_INT5D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3466)     ! Updates internal view and exports it to an external pointer
( 3467)     CLASS(FIELD_INT5D), TARGET :: SELF
( 3468)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:,:)
( 3469)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3470)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3471)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3472)     INTEGER(KIND=JPIM) :: IDX
( 3473) 
( 3474)     IDX = BLOCK_INDEX
( 3475)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3476)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3477)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):)  => SELF%DATA(:,:,:,:,IDX)
( 3478)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3479)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3480)     ELSE
( 3481)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field b
( 3482)     END IF
( 3483) 
( 3484)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3485)       ! Fill the the buffer by replicating the last entry
( 3486)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3487)     END IF
( 3488) 
( 3489)     IF (PRESENT(ZERO)) THEN
( 3490)       IF (ZERO) VIEW_PTR(:,:,:,:) = 0.0_JPIM
( 3491)     END IF
( 3492)   END SUBROUTINE FIELD_INT5D_EXTRACT_VIEW
( 3493) 
( 3494)   SUBROUTINE FIELD_LOG2D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3495)     ! Updates internal view and exports it to an external pointer
( 3496)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 3497)     LOGICAL, POINTER, INTENT(INOUT) :: VIEW_PTR(:)
( 3498)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3499)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3500)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3501)     INTEGER(KIND=JPIM) :: IDX
( 3502) 
( 3503)     IDX = BLOCK_INDEX
( 3504)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3505)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3506)       VIEW_PTR (SELF%LBOUNDS(1):)  => SELF%DATA(:,IDX)
( 3507)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3508)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3509)     ELSE
( 3510)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 63

( 3511)     END IF
( 3512) 
( 3513)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3514)       ! Fill the the buffer by replicating the last entry
( 3515)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3516)     END IF
( 3517) 
( 3518)     IF (PRESENT(ZERO)) THEN
( 3519)       IF (ZERO) VIEW_PTR(:) = .FALSE.
( 3520)     END IF
( 3521)   END SUBROUTINE FIELD_LOG2D_EXTRACT_VIEW
( 3522) 
( 3523)   SUBROUTINE FIELD_LOG3D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3524)     ! Updates internal view and exports it to an external pointer
( 3525)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 3526)     LOGICAL, POINTER, INTENT(INOUT) :: VIEW_PTR(:,:)
( 3527)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3528)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3529)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3530)     INTEGER(KIND=JPIM) :: IDX
( 3531) 
( 3532)     IDX = BLOCK_INDEX
( 3533)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3534)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3535)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):)  => SELF%DATA(:,:,IDX)
( 3536)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3537)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3538)     ELSE
( 3539)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3540)     END IF
( 3541) 
( 3542)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3543)       ! Fill the the buffer by replicating the last entry
( 3544)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3545)     END IF
( 3546) 
( 3547)     IF (PRESENT(ZERO)) THEN
( 3548)       IF (ZERO) VIEW_PTR(:,:) = .FALSE.
( 3549)     END IF
( 3550)   END SUBROUTINE FIELD_LOG3D_EXTRACT_VIEW
( 3551) 
( 3552)   SUBROUTINE FIELD_LOG4D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3553)     ! Updates internal view and exports it to an external pointer
( 3554)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 3555)     LOGICAL, POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:)
( 3556)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3557)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3558)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3559)     INTEGER(KIND=JPIM) :: IDX
( 3560) 
( 3561)     IDX = BLOCK_INDEX
( 3562)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3563)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3564)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):)  => SELF%DATA(:,:,:,IDX)
( 3565)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3566)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3567)     ELSE
( 3568)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 64

( 3569)     END IF
( 3570) 
( 3571)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3572)       ! Fill the the buffer by replicating the last entry
( 3573)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3574)     END IF
( 3575) 
( 3576)     IF (PRESENT(ZERO)) THEN
( 3577)       IF (ZERO) VIEW_PTR(:,:,:) = .FALSE.
( 3578)     END IF
( 3579)   END SUBROUTINE FIELD_LOG4D_EXTRACT_VIEW
( 3580) 
( 3581)   SUBROUTINE FIELD_LOG5D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3582)     ! Updates internal view and exports it to an external pointer
( 3583)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 3584)     LOGICAL, POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:,:)
( 3585)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3586)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3587)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3588)     INTEGER(KIND=JPIM) :: IDX
( 3589) 
( 3590)     IDX = BLOCK_INDEX
( 3591)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3592)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3593)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):)  => SELF%DATA(:,:,:,:,IDX)
( 3594)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3595)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3596)     ELSE
( 3597)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field b
( 3598)     END IF
( 3599) 
( 3600)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3601)       ! Fill the the buffer by replicating the last entry
( 3602)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3603)     END IF
( 3604) 
( 3605)     IF (PRESENT(ZERO)) THEN
( 3606)       IF (ZERO) VIEW_PTR(:,:,:,:) = .FALSE.
( 3607)     END IF
( 3608)   END SUBROUTINE FIELD_LOG5D_EXTRACT_VIEW
( 3609) 
( 3610) 
( 3611)   FUNCTION FIELD_2D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3612)     ! Updates internal view and exports it to an external pointer
( 3613)     CLASS(FIELD_2D), TARGET :: SELF
( 3614)     REAL(KIND=JPRB), POINTER :: VIEW_PTR(:)
( 3615)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3616)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3617)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3618)     INTEGER(KIND=JPIM) :: IDX
( 3619) 
( 3620)     IDX = BLOCK_INDEX
( 3621)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3622)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3623)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3624)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3625)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3626)     ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 65

( 3627)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3628)     END IF
( 3629) 
( 3630)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3631)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3632)         ! Fill the the buffer by replicating the last entry
( 3633)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3634)       END IF
( 3635)     END IF
( 3636) 
( 3637)     IF (PRESENT(ZERO)) THEN
( 3638)       IF (ZERO) VIEW_PTR(:) = 0.0_JPRB
( 3639)     END IF
( 3640)   END FUNCTION FIELD_2D_GET_VIEW
( 3641) 
( 3642)   FUNCTION FIELD_3D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3643)     ! Updates internal view and exports it to an external pointer
( 3644)     CLASS(FIELD_3D), TARGET :: SELF
( 3645)     REAL(KIND=JPRB), POINTER :: VIEW_PTR(:,:)
( 3646)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3647)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3648)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3649)     INTEGER(KIND=JPIM) :: IDX
( 3650) 
( 3651)     IDX = BLOCK_INDEX
( 3652)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3653)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3654)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3655)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3656)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3657)     ELSE
( 3658)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3659)     END IF
( 3660) 
( 3661)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3662)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3663)         ! Fill the the buffer by replicating the last entry
( 3664)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3665)       END IF
( 3666)     END IF
( 3667) 
( 3668)     IF (PRESENT(ZERO)) THEN
( 3669)       IF (ZERO) VIEW_PTR(:,:) = 0.0_JPRB
( 3670)     END IF
( 3671)   END FUNCTION FIELD_3D_GET_VIEW
( 3672) 
( 3673)   FUNCTION FIELD_4D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3674)     ! Updates internal view and exports it to an external pointer
( 3675)     CLASS(FIELD_4D), TARGET :: SELF
( 3676)     REAL(KIND=JPRB), POINTER :: VIEW_PTR(:,:,:)
( 3677)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3678)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3679)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3680)     INTEGER(KIND=JPIM) :: IDX
( 3681) 
( 3682)     IDX = BLOCK_INDEX
( 3683)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3684)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 66

( 3685)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3686)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3687)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3688)     ELSE
( 3689)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3690)     END IF
( 3691) 
( 3692)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3693)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3694)         ! Fill the the buffer by replicating the last entry
( 3695)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3696)       END IF
( 3697)     END IF
( 3698) 
( 3699)     IF (PRESENT(ZERO)) THEN
( 3700)       IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPRB
( 3701)     END IF
( 3702)   END FUNCTION FIELD_4D_GET_VIEW
( 3703) 
( 3704)   FUNCTION FIELD_5D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3705)     ! Updates internal view and exports it to an external pointer
( 3706)     CLASS(FIELD_5D), TARGET :: SELF
( 3707)     REAL(KIND=JPRB), POINTER :: VIEW_PTR(:,:,:,:)
( 3708)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3709)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3710)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3711)     INTEGER(KIND=JPIM) :: IDX
( 3712) 
( 3713)     IDX = BLOCK_INDEX
( 3714)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3715)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3716)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3717)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3718)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3719)     ELSE
( 3720)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field b
( 3721)     END IF
( 3722) 
( 3723)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3724)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3725)         ! Fill the the buffer by replicating the last entry
( 3726)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3727)       END IF
( 3728)     END IF
( 3729) 
( 3730)     IF (PRESENT(ZERO)) THEN
( 3731)       IF (ZERO) VIEW_PTR(:,:,:,:) = 0.0_JPRB
( 3732)     END IF
( 3733)   END FUNCTION FIELD_5D_GET_VIEW
( 3734) 
( 3735)   FUNCTION FIELD_INT2D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3736)     ! Updates internal view and exports it to an external pointer
( 3737)     CLASS(FIELD_INT2D), TARGET :: SELF
( 3738)     INTEGER(KIND=JPIM), POINTER :: VIEW_PTR(:)
( 3739)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3740)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3741)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3742)     INTEGER(KIND=JPIM) :: IDX






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 67

( 3743) 
( 3744)     IDX = BLOCK_INDEX
( 3745)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3746)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3747)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3748)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3749)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3750)     ELSE
( 3751)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3752)     END IF
( 3753) 
( 3754)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3755)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3756)         ! Fill the the buffer by replicating the last entry
( 3757)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3758)       END IF
( 3759)     END IF
( 3760) 
( 3761)     IF (PRESENT(ZERO)) THEN
( 3762)       IF (ZERO) VIEW_PTR(:) = 0.0_JPIM
( 3763)     END IF
( 3764)   END FUNCTION FIELD_INT2D_GET_VIEW
( 3765) 
( 3766)   FUNCTION FIELD_INT3D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3767)     ! Updates internal view and exports it to an external pointer
( 3768)     CLASS(FIELD_INT3D), TARGET :: SELF
( 3769)     INTEGER(KIND=JPIM), POINTER :: VIEW_PTR(:,:)
( 3770)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3771)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3772)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3773)     INTEGER(KIND=JPIM) :: IDX
( 3774) 
( 3775)     IDX = BLOCK_INDEX
( 3776)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3777)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3778)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3779)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3780)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3781)     ELSE
( 3782)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3783)     END IF
( 3784) 
( 3785)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3786)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3787)         ! Fill the the buffer by replicating the last entry
( 3788)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3789)       END IF
( 3790)     END IF
( 3791) 
( 3792)     IF (PRESENT(ZERO)) THEN
( 3793)       IF (ZERO) VIEW_PTR(:,:) = 0.0_JPIM
( 3794)     END IF
( 3795)   END FUNCTION FIELD_INT3D_GET_VIEW
( 3796) 
( 3797)   FUNCTION FIELD_INT4D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3798)     ! Updates internal view and exports it to an external pointer
( 3799)     CLASS(FIELD_INT4D), TARGET :: SELF
( 3800)     INTEGER(KIND=JPIM), POINTER :: VIEW_PTR(:,:,:)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 68

( 3801)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3802)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3803)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3804)     INTEGER(KIND=JPIM) :: IDX
( 3805) 
( 3806)     IDX = BLOCK_INDEX
( 3807)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3808)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3809)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3810)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3811)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3812)     ELSE
( 3813)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3814)     END IF
( 3815) 
( 3816)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3817)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3818)         ! Fill the the buffer by replicating the last entry
( 3819)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3820)       END IF
( 3821)     END IF
( 3822) 
( 3823)     IF (PRESENT(ZERO)) THEN
( 3824)       IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPIM
( 3825)     END IF
( 3826)   END FUNCTION FIELD_INT4D_GET_VIEW
( 3827) 
( 3828)   FUNCTION FIELD_INT5D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3829)     ! Updates internal view and exports it to an external pointer
( 3830)     CLASS(FIELD_INT5D), TARGET :: SELF
( 3831)     INTEGER(KIND=JPIM), POINTER :: VIEW_PTR(:,:,:,:)
( 3832)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3833)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3834)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3835)     INTEGER(KIND=JPIM) :: IDX
( 3836) 
( 3837)     IDX = BLOCK_INDEX
( 3838)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3839)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3840)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3841)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3842)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3843)     ELSE
( 3844)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field b
( 3845)     END IF
( 3846) 
( 3847)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3848)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3849)         ! Fill the the buffer by replicating the last entry
( 3850)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3851)       END IF
( 3852)     END IF
( 3853) 
( 3854)     IF (PRESENT(ZERO)) THEN
( 3855)       IF (ZERO) VIEW_PTR(:,:,:,:) = 0.0_JPIM
( 3856)     END IF
( 3857)   END FUNCTION FIELD_INT5D_GET_VIEW
( 3858) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 69

( 3859)   FUNCTION FIELD_LOG2D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3860)     ! Updates internal view and exports it to an external pointer
( 3861)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 3862)     LOGICAL, POINTER :: VIEW_PTR(:)
( 3863)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3864)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3865)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3866)     INTEGER(KIND=JPIM) :: IDX
( 3867) 
( 3868)     IDX = BLOCK_INDEX
( 3869)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3870)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3871)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3872)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3873)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3874)     ELSE
( 3875)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3876)     END IF
( 3877) 
( 3878)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3879)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3880)         ! Fill the the buffer by replicating the last entry
( 3881)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3882)       END IF
( 3883)     END IF
( 3884) 
( 3885)     IF (PRESENT(ZERO)) THEN
( 3886)       IF (ZERO) VIEW_PTR(:) = .FALSE.
( 3887)     END IF
( 3888)   END FUNCTION FIELD_LOG2D_GET_VIEW
( 3889) 
( 3890)   FUNCTION FIELD_LOG3D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3891)     ! Updates internal view and exports it to an external pointer
( 3892)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 3893)     LOGICAL, POINTER :: VIEW_PTR(:,:)
( 3894)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3895)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3896)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3897)     INTEGER(KIND=JPIM) :: IDX
( 3898) 
( 3899)     IDX = BLOCK_INDEX
( 3900)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3901)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3902)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3903)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3904)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3905)     ELSE
( 3906)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3907)     END IF
( 3908) 
( 3909)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3910)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3911)         ! Fill the the buffer by replicating the last entry
( 3912)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3913)       END IF
( 3914)     END IF
( 3915) 
( 3916)     IF (PRESENT(ZERO)) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 70

( 3917)       IF (ZERO) VIEW_PTR(:,:) = .FALSE.
( 3918)     END IF
( 3919)   END FUNCTION FIELD_LOG3D_GET_VIEW
( 3920) 
( 3921)   FUNCTION FIELD_LOG4D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3922)     ! Updates internal view and exports it to an external pointer
( 3923)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 3924)     LOGICAL, POINTER :: VIEW_PTR(:,:,:)
( 3925)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3926)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3927)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3928)     INTEGER(KIND=JPIM) :: IDX
( 3929) 
( 3930)     IDX = BLOCK_INDEX
( 3931)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3932)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3933)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3934)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3935)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3936)     ELSE
( 3937)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3938)     END IF
( 3939) 
( 3940)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3941)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3942)         ! Fill the the buffer by replicating the last entry
( 3943)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3944)       END IF
( 3945)     END IF
( 3946) 
( 3947)     IF (PRESENT(ZERO)) THEN
( 3948)       IF (ZERO) VIEW_PTR(:,:,:) = .FALSE.
( 3949)     END IF
( 3950)   END FUNCTION FIELD_LOG4D_GET_VIEW
( 3951) 
( 3952)   FUNCTION FIELD_LOG5D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3953)     ! Updates internal view and exports it to an external pointer
( 3954)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 3955)     LOGICAL, POINTER :: VIEW_PTR(:,:,:,:)
( 3956)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3957)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3958)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3959)     INTEGER(KIND=JPIM) :: IDX
( 3960) 
( 3961)     IDX = BLOCK_INDEX
( 3962)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3963)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3964)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3965)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3966)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3967)     ELSE
( 3968)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field b
( 3969)     END IF
( 3970) 
( 3971)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3972)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3973)         ! Fill the the buffer by replicating the last entry
( 3974)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 71

( 3975)       END IF
( 3976)     END IF
( 3977) 
( 3978)     IF (PRESENT(ZERO)) THEN
( 3979)       IF (ZERO) VIEW_PTR(:,:,:,:) = .FALSE.
( 3980)     END IF
( 3981)   END FUNCTION FIELD_LOG5D_GET_VIEW
( 3982) 
( 3983) 
( 3984)   SUBROUTINE FIELD_2D_CREATE_DEVICE(SELF)
( 3985)     ! Initialize a copy of this field on GPU device
( 3986)     CLASS(FIELD_2D), TARGET :: SELF
( 3987) 
( 3988)     SELF%DEVPTR => SELF%DATA
( 3989) !$acc enter data create(SELF%DATA)
( 3990)   END SUBROUTINE FIELD_2D_CREATE_DEVICE
( 3991) 
( 3992)   SUBROUTINE FIELD_3D_CREATE_DEVICE(SELF)
( 3993)     ! Initialize a copy of this field on GPU device
( 3994)     CLASS(FIELD_3D), TARGET :: SELF
( 3995) 
( 3996)     SELF%DEVPTR => SELF%DATA
( 3997) !$acc enter data create(SELF%DATA)
( 3998)   END SUBROUTINE FIELD_3D_CREATE_DEVICE
( 3999) 
( 4000)   SUBROUTINE FIELD_4D_CREATE_DEVICE(SELF)
( 4001)     ! Initialize a copy of this field on GPU device
( 4002)     CLASS(FIELD_4D), TARGET :: SELF
( 4003) 
( 4004)     SELF%DEVPTR => SELF%DATA
( 4005) !$acc enter data create(SELF%DATA)
( 4006)   END SUBROUTINE FIELD_4D_CREATE_DEVICE
( 4007) 
( 4008)   SUBROUTINE FIELD_5D_CREATE_DEVICE(SELF)
( 4009)     ! Initialize a copy of this field on GPU device
( 4010)     CLASS(FIELD_5D), TARGET :: SELF
( 4011) 
( 4012)     SELF%DEVPTR => SELF%DATA
( 4013) !$acc enter data create(SELF%DATA)
( 4014)   END SUBROUTINE FIELD_5D_CREATE_DEVICE
( 4015) 
( 4016)   SUBROUTINE FIELD_INT2D_CREATE_DEVICE(SELF)
( 4017)     ! Initialize a copy of this field on GPU device
( 4018)     CLASS(FIELD_INT2D), TARGET :: SELF
( 4019) 
( 4020)     SELF%DEVPTR => SELF%DATA
( 4021) !$acc enter data create(SELF%DATA)
( 4022)   END SUBROUTINE FIELD_INT2D_CREATE_DEVICE
( 4023) 
( 4024)   SUBROUTINE FIELD_INT3D_CREATE_DEVICE(SELF)
( 4025)     ! Initialize a copy of this field on GPU device
( 4026)     CLASS(FIELD_INT3D), TARGET :: SELF
( 4027) 
( 4028)     SELF%DEVPTR => SELF%DATA
( 4029) !$acc enter data create(SELF%DATA)
( 4030)   END SUBROUTINE FIELD_INT3D_CREATE_DEVICE
( 4031) 
( 4032)   SUBROUTINE FIELD_INT4D_CREATE_DEVICE(SELF)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 72

( 4033)     ! Initialize a copy of this field on GPU device
( 4034)     CLASS(FIELD_INT4D), TARGET :: SELF
( 4035) 
( 4036)     SELF%DEVPTR => SELF%DATA
( 4037) !$acc enter data create(SELF%DATA)
( 4038)   END SUBROUTINE FIELD_INT4D_CREATE_DEVICE
( 4039) 
( 4040)   SUBROUTINE FIELD_INT5D_CREATE_DEVICE(SELF)
( 4041)     ! Initialize a copy of this field on GPU device
( 4042)     CLASS(FIELD_INT5D), TARGET :: SELF
( 4043) 
( 4044)     SELF%DEVPTR => SELF%DATA
( 4045) !$acc enter data create(SELF%DATA)
( 4046)   END SUBROUTINE FIELD_INT5D_CREATE_DEVICE
( 4047) 
( 4048)   SUBROUTINE FIELD_LOG2D_CREATE_DEVICE(SELF)
( 4049)     ! Initialize a copy of this field on GPU device
( 4050)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 4051) 
( 4052)     SELF%DEVPTR => SELF%DATA
( 4053) !$acc enter data create(SELF%DATA)
( 4054)   END SUBROUTINE FIELD_LOG2D_CREATE_DEVICE
( 4055) 
( 4056)   SUBROUTINE FIELD_LOG3D_CREATE_DEVICE(SELF)
( 4057)     ! Initialize a copy of this field on GPU device
( 4058)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 4059) 
( 4060)     SELF%DEVPTR => SELF%DATA
( 4061) !$acc enter data create(SELF%DATA)
( 4062)   END SUBROUTINE FIELD_LOG3D_CREATE_DEVICE
( 4063) 
( 4064)   SUBROUTINE FIELD_LOG4D_CREATE_DEVICE(SELF)
( 4065)     ! Initialize a copy of this field on GPU device
( 4066)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 4067) 
( 4068)     SELF%DEVPTR => SELF%DATA
( 4069) !$acc enter data create(SELF%DATA)
( 4070)   END SUBROUTINE FIELD_LOG4D_CREATE_DEVICE
( 4071) 
( 4072)   SUBROUTINE FIELD_LOG5D_CREATE_DEVICE(SELF)
( 4073)     ! Initialize a copy of this field on GPU device
( 4074)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 4075) 
( 4076)     SELF%DEVPTR => SELF%DATA
( 4077) !$acc enter data create(SELF%DATA)
( 4078)   END SUBROUTINE FIELD_LOG5D_CREATE_DEVICE
( 4079) 
( 4080) 
( 4081)   FUNCTION FIELD_2D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4082)     ! Initialize a copy of this field on GPU device
( 4083)     CLASS(FIELD_2D), TARGET :: SELF
( 4084)     REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:)
( 4085) 
( 4086)     IF (SELF%OWNED) THEN
( 4087)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA
( 4088)     ELSE
( 4089)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DEVPTR
( 4090)     END IF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 73

( 4091)   END FUNCTION FIELD_2D_GET_DEVICE_DATA
( 4092) 
( 4093)   FUNCTION FIELD_3D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4094)     ! Initialize a copy of this field on GPU device
( 4095)     CLASS(FIELD_3D), TARGET :: SELF
( 4096)     REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:)
( 4097) 
( 4098)     IF (SELF%OWNED) THEN
( 4099)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA
( 4100)     ELSE
( 4101)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DEVPTR
( 4102)     END IF
( 4103)   END FUNCTION FIELD_3D_GET_DEVICE_DATA
( 4104) 
( 4105)   FUNCTION FIELD_4D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4106)     ! Initialize a copy of this field on GPU device
( 4107)     CLASS(FIELD_4D), TARGET :: SELF
( 4108)     REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:)
( 4109) 
( 4110)     IF (SELF%OWNED) THEN
( 4111)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA
( 4112)     ELSE
( 4113)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DEVPTR
( 4114)     END IF
( 4115)   END FUNCTION FIELD_4D_GET_DEVICE_DATA
( 4116) 
( 4117)   FUNCTION FIELD_5D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4118)     ! Initialize a copy of this field on GPU device
( 4119)     CLASS(FIELD_5D), TARGET :: SELF
( 4120)     REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:)
( 4121) 
( 4122)     IF (SELF%OWNED) THEN
( 4123)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DATA
( 4124)     ELSE
( 4125)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DEVPTR
( 4126)     END IF
( 4127)   END FUNCTION FIELD_5D_GET_DEVICE_DATA
( 4128) 
( 4129)   FUNCTION FIELD_INT2D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4130)     ! Initialize a copy of this field on GPU device
( 4131)     CLASS(FIELD_INT2D), TARGET :: SELF
( 4132)     INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:)
( 4133) 
( 4134)     IF (SELF%OWNED) THEN
( 4135)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA
( 4136)     ELSE
( 4137)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DEVPTR
( 4138)     END IF
( 4139)   END FUNCTION FIELD_INT2D_GET_DEVICE_DATA
( 4140) 
( 4141)   FUNCTION FIELD_INT3D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4142)     ! Initialize a copy of this field on GPU device
( 4143)     CLASS(FIELD_INT3D), TARGET :: SELF
( 4144)     INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:)
( 4145) 
( 4146)     IF (SELF%OWNED) THEN
( 4147)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA
( 4148)     ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 74

( 4149)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DEVPTR
( 4150)     END IF
( 4151)   END FUNCTION FIELD_INT3D_GET_DEVICE_DATA
( 4152) 
( 4153)   FUNCTION FIELD_INT4D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4154)     ! Initialize a copy of this field on GPU device
( 4155)     CLASS(FIELD_INT4D), TARGET :: SELF
( 4156)     INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:)
( 4157) 
( 4158)     IF (SELF%OWNED) THEN
( 4159)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA
( 4160)     ELSE
( 4161)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DEVPTR
( 4162)     END IF
( 4163)   END FUNCTION FIELD_INT4D_GET_DEVICE_DATA
( 4164) 
( 4165)   FUNCTION FIELD_INT5D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4166)     ! Initialize a copy of this field on GPU device
( 4167)     CLASS(FIELD_INT5D), TARGET :: SELF
( 4168)     INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:)
( 4169) 
( 4170)     IF (SELF%OWNED) THEN
( 4171)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DATA
( 4172)     ELSE
( 4173)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DEVPTR
( 4174)     END IF
( 4175)   END FUNCTION FIELD_INT5D_GET_DEVICE_DATA
( 4176) 
( 4177)   FUNCTION FIELD_LOG2D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4178)     ! Initialize a copy of this field on GPU device
( 4179)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 4180)     LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:)
( 4181) 
( 4182)     IF (SELF%OWNED) THEN
( 4183)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA
( 4184)     ELSE
( 4185)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DEVPTR
( 4186)     END IF
( 4187)   END FUNCTION FIELD_LOG2D_GET_DEVICE_DATA
( 4188) 
( 4189)   FUNCTION FIELD_LOG3D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4190)     ! Initialize a copy of this field on GPU device
( 4191)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 4192)     LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:)
( 4193) 
( 4194)     IF (SELF%OWNED) THEN
( 4195)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA
( 4196)     ELSE
( 4197)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DEVPTR
( 4198)     END IF
( 4199)   END FUNCTION FIELD_LOG3D_GET_DEVICE_DATA
( 4200) 
( 4201)   FUNCTION FIELD_LOG4D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4202)     ! Initialize a copy of this field on GPU device
( 4203)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 4204)     LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:)
( 4205) 
( 4206)     IF (SELF%OWNED) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 75

( 4207)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA
( 4208)     ELSE
( 4209)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DEVPTR
( 4210)     END IF
( 4211)   END FUNCTION FIELD_LOG4D_GET_DEVICE_DATA
( 4212) 
( 4213)   FUNCTION FIELD_LOG5D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4214)     ! Initialize a copy of this field on GPU device
( 4215)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 4216)     LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:)
( 4217) 
( 4218)     IF (SELF%OWNED) THEN
( 4219)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DATA
( 4220)     ELSE
( 4221)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DEVPTR
( 4222)     END IF
( 4223)   END FUNCTION FIELD_LOG5D_GET_DEVICE_DATA
( 4224) 
( 4225) 
( 4226)   SUBROUTINE FIELD_2D_UPDATE_DEVICE(SELF)
( 4227)     ! Create a copy of this field on device and copy data over
( 4228)     CLASS(FIELD_2D), TARGET :: SELF
( 4229) 
( 4230)     IF (SELF%OWNED) THEN
( 4231) !$acc enter data copyin(SELF%DATA)
( 4232)       SELF%DEVPTR => SELF%DATA
( 4233)     ELSE
( 4234)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4235) !$acc enter data copyin(SELF%DEVPTR)
( 4236)     END IF
( 4237)   END SUBROUTINE FIELD_2D_UPDATE_DEVICE
( 4238) 
( 4239)   SUBROUTINE FIELD_3D_UPDATE_DEVICE(SELF)
( 4240)     ! Create a copy of this field on device and copy data over
( 4241)     CLASS(FIELD_3D), TARGET :: SELF
( 4242) 
( 4243)     IF (SELF%OWNED) THEN
( 4244) !$acc enter data copyin(SELF%DATA)
( 4245)       SELF%DEVPTR => SELF%DATA
( 4246)     ELSE
( 4247)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4248) !$acc enter data copyin(SELF%DEVPTR)
( 4249)     END IF
( 4250)   END SUBROUTINE FIELD_3D_UPDATE_DEVICE
( 4251) 
( 4252)   SUBROUTINE FIELD_4D_UPDATE_DEVICE(SELF)
( 4253)     ! Create a copy of this field on device and copy data over
( 4254)     CLASS(FIELD_4D), TARGET :: SELF
( 4255) 
( 4256)     IF (SELF%OWNED) THEN
( 4257) !$acc enter data copyin(SELF%DATA)
( 4258)       SELF%DEVPTR => SELF%DATA
( 4259)     ELSE
( 4260)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4261) !$acc enter data copyin(SELF%DEVPTR)
( 4262)     END IF
( 4263)   END SUBROUTINE FIELD_4D_UPDATE_DEVICE
( 4264) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 76

( 4265)   SUBROUTINE FIELD_5D_UPDATE_DEVICE(SELF)
( 4266)     ! Create a copy of this field on device and copy data over
( 4267)     CLASS(FIELD_5D), TARGET :: SELF
( 4268) 
( 4269)     IF (SELF%OWNED) THEN
( 4270) !$acc enter data copyin(SELF%DATA)
( 4271)       SELF%DEVPTR => SELF%DATA
( 4272)     ELSE
( 4273)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4274) !$acc enter data copyin(SELF%DEVPTR)
( 4275)     END IF
( 4276)   END SUBROUTINE FIELD_5D_UPDATE_DEVICE
( 4277) 
( 4278)   SUBROUTINE FIELD_INT2D_UPDATE_DEVICE(SELF)
( 4279)     ! Create a copy of this field on device and copy data over
( 4280)     CLASS(FIELD_INT2D), TARGET :: SELF
( 4281) 
( 4282)     IF (SELF%OWNED) THEN
( 4283) !$acc enter data copyin(SELF%DATA)
( 4284)       SELF%DEVPTR => SELF%DATA
( 4285)     ELSE
( 4286)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4287) !$acc enter data copyin(SELF%DEVPTR)
( 4288)     END IF
( 4289)   END SUBROUTINE FIELD_INT2D_UPDATE_DEVICE
( 4290) 
( 4291)   SUBROUTINE FIELD_INT3D_UPDATE_DEVICE(SELF)
( 4292)     ! Create a copy of this field on device and copy data over
( 4293)     CLASS(FIELD_INT3D), TARGET :: SELF
( 4294) 
( 4295)     IF (SELF%OWNED) THEN
( 4296) !$acc enter data copyin(SELF%DATA)
( 4297)       SELF%DEVPTR => SELF%DATA
( 4298)     ELSE
( 4299)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4300) !$acc enter data copyin(SELF%DEVPTR)
( 4301)     END IF
( 4302)   END SUBROUTINE FIELD_INT3D_UPDATE_DEVICE
( 4303) 
( 4304)   SUBROUTINE FIELD_INT4D_UPDATE_DEVICE(SELF)
( 4305)     ! Create a copy of this field on device and copy data over
( 4306)     CLASS(FIELD_INT4D), TARGET :: SELF
( 4307) 
( 4308)     IF (SELF%OWNED) THEN
( 4309) !$acc enter data copyin(SELF%DATA)
( 4310)       SELF%DEVPTR => SELF%DATA
( 4311)     ELSE
( 4312)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4313) !$acc enter data copyin(SELF%DEVPTR)
( 4314)     END IF
( 4315)   END SUBROUTINE FIELD_INT4D_UPDATE_DEVICE
( 4316) 
( 4317)   SUBROUTINE FIELD_INT5D_UPDATE_DEVICE(SELF)
( 4318)     ! Create a copy of this field on device and copy data over
( 4319)     CLASS(FIELD_INT5D), TARGET :: SELF
( 4320) 
( 4321)     IF (SELF%OWNED) THEN
( 4322) !$acc enter data copyin(SELF%DATA)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 77

( 4323)       SELF%DEVPTR => SELF%DATA
( 4324)     ELSE
( 4325)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4326) !$acc enter data copyin(SELF%DEVPTR)
( 4327)     END IF
( 4328)   END SUBROUTINE FIELD_INT5D_UPDATE_DEVICE
( 4329) 
( 4330)   SUBROUTINE FIELD_LOG2D_UPDATE_DEVICE(SELF)
( 4331)     ! Create a copy of this field on device and copy data over
( 4332)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 4333) 
( 4334)     IF (SELF%OWNED) THEN
( 4335) !$acc enter data copyin(SELF%DATA)
( 4336)       SELF%DEVPTR => SELF%DATA
( 4337)     ELSE
( 4338)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4339) !$acc enter data copyin(SELF%DEVPTR)
( 4340)     END IF
( 4341)   END SUBROUTINE FIELD_LOG2D_UPDATE_DEVICE
( 4342) 
( 4343)   SUBROUTINE FIELD_LOG3D_UPDATE_DEVICE(SELF)
( 4344)     ! Create a copy of this field on device and copy data over
( 4345)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 4346) 
( 4347)     IF (SELF%OWNED) THEN
( 4348) !$acc enter data copyin(SELF%DATA)
( 4349)       SELF%DEVPTR => SELF%DATA
( 4350)     ELSE
( 4351)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4352) !$acc enter data copyin(SELF%DEVPTR)
( 4353)     END IF
( 4354)   END SUBROUTINE FIELD_LOG3D_UPDATE_DEVICE
( 4355) 
( 4356)   SUBROUTINE FIELD_LOG4D_UPDATE_DEVICE(SELF)
( 4357)     ! Create a copy of this field on device and copy data over
( 4358)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 4359) 
( 4360)     IF (SELF%OWNED) THEN
( 4361) !$acc enter data copyin(SELF%DATA)
( 4362)       SELF%DEVPTR => SELF%DATA
( 4363)     ELSE
( 4364)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4365) !$acc enter data copyin(SELF%DEVPTR)
( 4366)     END IF
( 4367)   END SUBROUTINE FIELD_LOG4D_UPDATE_DEVICE
( 4368) 
( 4369)   SUBROUTINE FIELD_LOG5D_UPDATE_DEVICE(SELF)
( 4370)     ! Create a copy of this field on device and copy data over
( 4371)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 4372) 
( 4373)     IF (SELF%OWNED) THEN
( 4374) !$acc enter data copyin(SELF%DATA)
( 4375)       SELF%DEVPTR => SELF%DATA
( 4376)     ELSE
( 4377)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4378) !$acc enter data copyin(SELF%DEVPTR)
( 4379)     END IF
( 4380)   END SUBROUTINE FIELD_LOG5D_UPDATE_DEVICE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 78

( 4381) 
( 4382) 
( 4383)   SUBROUTINE FIELD_2D_UPDATE_HOST(SELF)
( 4384)     ! Synchronize device data back to host
( 4385)     CLASS(FIELD_2D) :: SELF
( 4386) 
( 4387)     IF (SELF%OWNED) THEN
( 4388)       !$acc exit data copyout(SELF%DATA)
( 4389)     ELSE
( 4390)       !$acc exit data copyout(SELF%DEVPTR)
( 4391)       SELF%PTR(:,:) = SELF%DEVPTR(:,:)
( 4392)     END IF
( 4393)   END SUBROUTINE FIELD_2D_UPDATE_HOST
( 4394) 
( 4395)   SUBROUTINE FIELD_3D_UPDATE_HOST(SELF)
( 4396)     ! Synchronize device data back to host
( 4397)     CLASS(FIELD_3D) :: SELF
( 4398) 
( 4399)     IF (SELF%OWNED) THEN
( 4400)       !$acc exit data copyout(SELF%DATA)
( 4401)     ELSE
( 4402)       !$acc exit data copyout(SELF%DEVPTR)
( 4403)       SELF%PTR(:,:,:) = SELF%DEVPTR(:,:,:)
( 4404)     END IF
( 4405)   END SUBROUTINE FIELD_3D_UPDATE_HOST
( 4406) 
( 4407)   SUBROUTINE FIELD_4D_UPDATE_HOST(SELF)
( 4408)     ! Synchronize device data back to host
( 4409)     CLASS(FIELD_4D) :: SELF
( 4410) 
( 4411)     IF (SELF%OWNED) THEN
( 4412)       !$acc exit data copyout(SELF%DATA)
( 4413)     ELSE
( 4414)       !$acc exit data copyout(SELF%DEVPTR)
( 4415)       SELF%PTR(:,:,:,:) = SELF%DEVPTR(:,:,:,:)
( 4416)     END IF
( 4417)   END SUBROUTINE FIELD_4D_UPDATE_HOST
( 4418) 
( 4419)   SUBROUTINE FIELD_5D_UPDATE_HOST(SELF)
( 4420)     ! Synchronize device data back to host
( 4421)     CLASS(FIELD_5D) :: SELF
( 4422) 
( 4423)     IF (SELF%OWNED) THEN
( 4424)       !$acc exit data copyout(SELF%DATA)
( 4425)     ELSE
( 4426)       !$acc exit data copyout(SELF%DEVPTR)
( 4427)       SELF%PTR(:,:,:,:,:) = SELF%DEVPTR(:,:,:,:,:)
( 4428)     END IF
( 4429)   END SUBROUTINE FIELD_5D_UPDATE_HOST
( 4430) 
( 4431)   SUBROUTINE FIELD_INT2D_UPDATE_HOST(SELF)
( 4432)     ! Synchronize device data back to host
( 4433)     CLASS(FIELD_INT2D) :: SELF
( 4434) 
( 4435)     IF (SELF%OWNED) THEN
( 4436)       !$acc exit data copyout(SELF%DATA)
( 4437)     ELSE
( 4438)       !$acc exit data copyout(SELF%DEVPTR)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 79

( 4439)       SELF%PTR(:,:) = SELF%DEVPTR(:,:)
( 4440)     END IF
( 4441)   END SUBROUTINE FIELD_INT2D_UPDATE_HOST
( 4442) 
( 4443)   SUBROUTINE FIELD_INT3D_UPDATE_HOST(SELF)
( 4444)     ! Synchronize device data back to host
( 4445)     CLASS(FIELD_INT3D) :: SELF
( 4446) 
( 4447)     IF (SELF%OWNED) THEN
( 4448)       !$acc exit data copyout(SELF%DATA)
( 4449)     ELSE
( 4450)       !$acc exit data copyout(SELF%DEVPTR)
( 4451)       SELF%PTR(:,:,:) = SELF%DEVPTR(:,:,:)
( 4452)     END IF
( 4453)   END SUBROUTINE FIELD_INT3D_UPDATE_HOST
( 4454) 
( 4455)   SUBROUTINE FIELD_INT4D_UPDATE_HOST(SELF)
( 4456)     ! Synchronize device data back to host
( 4457)     CLASS(FIELD_INT4D) :: SELF
( 4458) 
( 4459)     IF (SELF%OWNED) THEN
( 4460)       !$acc exit data copyout(SELF%DATA)
( 4461)     ELSE
( 4462)       !$acc exit data copyout(SELF%DEVPTR)
( 4463)       SELF%PTR(:,:,:,:) = SELF%DEVPTR(:,:,:,:)
( 4464)     END IF
( 4465)   END SUBROUTINE FIELD_INT4D_UPDATE_HOST
( 4466) 
( 4467)   SUBROUTINE FIELD_INT5D_UPDATE_HOST(SELF)
( 4468)     ! Synchronize device data back to host
( 4469)     CLASS(FIELD_INT5D) :: SELF
( 4470) 
( 4471)     IF (SELF%OWNED) THEN
( 4472)       !$acc exit data copyout(SELF%DATA)
( 4473)     ELSE
( 4474)       !$acc exit data copyout(SELF%DEVPTR)
( 4475)       SELF%PTR(:,:,:,:,:) = SELF%DEVPTR(:,:,:,:,:)
( 4476)     END IF
( 4477)   END SUBROUTINE FIELD_INT5D_UPDATE_HOST
( 4478) 
( 4479)   SUBROUTINE FIELD_LOG2D_UPDATE_HOST(SELF)
( 4480)     ! Synchronize device data back to host
( 4481)     CLASS(FIELD_LOG2D) :: SELF
( 4482) 
( 4483)     IF (SELF%OWNED) THEN
( 4484)       !$acc exit data copyout(SELF%DATA)
( 4485)     ELSE
( 4486)       !$acc exit data copyout(SELF%DEVPTR)
( 4487)       SELF%PTR(:,:) = SELF%DEVPTR(:,:)
( 4488)     END IF
( 4489)   END SUBROUTINE FIELD_LOG2D_UPDATE_HOST
( 4490) 
( 4491)   SUBROUTINE FIELD_LOG3D_UPDATE_HOST(SELF)
( 4492)     ! Synchronize device data back to host
( 4493)     CLASS(FIELD_LOG3D) :: SELF
( 4494) 
( 4495)     IF (SELF%OWNED) THEN
( 4496)       !$acc exit data copyout(SELF%DATA)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 80

( 4497)     ELSE
( 4498)       !$acc exit data copyout(SELF%DEVPTR)
( 4499)       SELF%PTR(:,:,:) = SELF%DEVPTR(:,:,:)
( 4500)     END IF
( 4501)   END SUBROUTINE FIELD_LOG3D_UPDATE_HOST
( 4502) 
( 4503)   SUBROUTINE FIELD_LOG4D_UPDATE_HOST(SELF)
( 4504)     ! Synchronize device data back to host
( 4505)     CLASS(FIELD_LOG4D) :: SELF
( 4506) 
( 4507)     IF (SELF%OWNED) THEN
( 4508)       !$acc exit data copyout(SELF%DATA)
( 4509)     ELSE
( 4510)       !$acc exit data copyout(SELF%DEVPTR)
( 4511)       SELF%PTR(:,:,:,:) = SELF%DEVPTR(:,:,:,:)
( 4512)     END IF
( 4513)   END SUBROUTINE FIELD_LOG4D_UPDATE_HOST
( 4514) 
( 4515)   SUBROUTINE FIELD_LOG5D_UPDATE_HOST(SELF)
( 4516)     ! Synchronize device data back to host
( 4517)     CLASS(FIELD_LOG5D) :: SELF
( 4518) 
( 4519)     IF (SELF%OWNED) THEN
( 4520)       !$acc exit data copyout(SELF%DATA)
( 4521)     ELSE
( 4522)       !$acc exit data copyout(SELF%DEVPTR)
( 4523)       SELF%PTR(:,:,:,:,:) = SELF%DEVPTR(:,:,:,:,:)
( 4524)     END IF
( 4525)   END SUBROUTINE FIELD_LOG5D_UPDATE_HOST
( 4526) 
( 4527) 
( 4528)   SUBROUTINE FIELD_2D_DELETE_DEVICE(SELF)
( 4529)     ! Initialize a copy of this field on GPU device
( 4530)     CLASS(FIELD_2D), TARGET :: SELF
( 4531) 
( 4532) !$acc exit data delete(SELF%DEVPTR)
( 4533)     IF (SELF%OWNED) THEN
( 4534)       NULLIFY(SELF%DEVPTR)
( 4535)     ELSE
( 4536)       DEALLOCATE(SELF%DEVPTR)
( 4537)     END IF
( 4538)   END SUBROUTINE FIELD_2D_DELETE_DEVICE
( 4539) 
( 4540)   SUBROUTINE FIELD_3D_DELETE_DEVICE(SELF)
( 4541)     ! Initialize a copy of this field on GPU device
( 4542)     CLASS(FIELD_3D), TARGET :: SELF
( 4543) 
( 4544) !$acc exit data delete(SELF%DEVPTR)
( 4545)     IF (SELF%OWNED) THEN
( 4546)       NULLIFY(SELF%DEVPTR)
( 4547)     ELSE
( 4548)       DEALLOCATE(SELF%DEVPTR)
( 4549)     END IF
( 4550)   END SUBROUTINE FIELD_3D_DELETE_DEVICE
( 4551) 
( 4552)   SUBROUTINE FIELD_4D_DELETE_DEVICE(SELF)
( 4553)     ! Initialize a copy of this field on GPU device
( 4554)     CLASS(FIELD_4D), TARGET :: SELF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 81

( 4555) 
( 4556) !$acc exit data delete(SELF%DEVPTR)
( 4557)     IF (SELF%OWNED) THEN
( 4558)       NULLIFY(SELF%DEVPTR)
( 4559)     ELSE
( 4560)       DEALLOCATE(SELF%DEVPTR)
( 4561)     END IF
( 4562)   END SUBROUTINE FIELD_4D_DELETE_DEVICE
( 4563) 
( 4564)   SUBROUTINE FIELD_5D_DELETE_DEVICE(SELF)
( 4565)     ! Initialize a copy of this field on GPU device
( 4566)     CLASS(FIELD_5D), TARGET :: SELF
( 4567) 
( 4568) !$acc exit data delete(SELF%DEVPTR)
( 4569)     IF (SELF%OWNED) THEN
( 4570)       NULLIFY(SELF%DEVPTR)
( 4571)     ELSE
( 4572)       DEALLOCATE(SELF%DEVPTR)
( 4573)     END IF
( 4574)   END SUBROUTINE FIELD_5D_DELETE_DEVICE
( 4575) 
( 4576)   SUBROUTINE FIELD_INT2D_DELETE_DEVICE(SELF)
( 4577)     ! Initialize a copy of this field on GPU device
( 4578)     CLASS(FIELD_INT2D), TARGET :: SELF
( 4579) 
( 4580) !$acc exit data delete(SELF%DEVPTR)
( 4581)     IF (SELF%OWNED) THEN
( 4582)       NULLIFY(SELF%DEVPTR)
( 4583)     ELSE
( 4584)       DEALLOCATE(SELF%DEVPTR)
( 4585)     END IF
( 4586)   END SUBROUTINE FIELD_INT2D_DELETE_DEVICE
( 4587) 
( 4588)   SUBROUTINE FIELD_INT3D_DELETE_DEVICE(SELF)
( 4589)     ! Initialize a copy of this field on GPU device
( 4590)     CLASS(FIELD_INT3D), TARGET :: SELF
( 4591) 
( 4592) !$acc exit data delete(SELF%DEVPTR)
( 4593)     IF (SELF%OWNED) THEN
( 4594)       NULLIFY(SELF%DEVPTR)
( 4595)     ELSE
( 4596)       DEALLOCATE(SELF%DEVPTR)
( 4597)     END IF
( 4598)   END SUBROUTINE FIELD_INT3D_DELETE_DEVICE
( 4599) 
( 4600)   SUBROUTINE FIELD_INT4D_DELETE_DEVICE(SELF)
( 4601)     ! Initialize a copy of this field on GPU device
( 4602)     CLASS(FIELD_INT4D), TARGET :: SELF
( 4603) 
( 4604) !$acc exit data delete(SELF%DEVPTR)
( 4605)     IF (SELF%OWNED) THEN
( 4606)       NULLIFY(SELF%DEVPTR)
( 4607)     ELSE
( 4608)       DEALLOCATE(SELF%DEVPTR)
( 4609)     END IF
( 4610)   END SUBROUTINE FIELD_INT4D_DELETE_DEVICE
( 4611) 
( 4612)   SUBROUTINE FIELD_INT5D_DELETE_DEVICE(SELF)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 82

( 4613)     ! Initialize a copy of this field on GPU device
( 4614)     CLASS(FIELD_INT5D), TARGET :: SELF
( 4615) 
( 4616) !$acc exit data delete(SELF%DEVPTR)
( 4617)     IF (SELF%OWNED) THEN
( 4618)       NULLIFY(SELF%DEVPTR)
( 4619)     ELSE
( 4620)       DEALLOCATE(SELF%DEVPTR)
( 4621)     END IF
( 4622)   END SUBROUTINE FIELD_INT5D_DELETE_DEVICE
( 4623) 
( 4624)   SUBROUTINE FIELD_LOG2D_DELETE_DEVICE(SELF)
( 4625)     ! Initialize a copy of this field on GPU device
( 4626)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 4627) 
( 4628) !$acc exit data delete(SELF%DEVPTR)
( 4629)     IF (SELF%OWNED) THEN
( 4630)       NULLIFY(SELF%DEVPTR)
( 4631)     ELSE
( 4632)       DEALLOCATE(SELF%DEVPTR)
( 4633)     END IF
( 4634)   END SUBROUTINE FIELD_LOG2D_DELETE_DEVICE
( 4635) 
( 4636)   SUBROUTINE FIELD_LOG3D_DELETE_DEVICE(SELF)
( 4637)     ! Initialize a copy of this field on GPU device
( 4638)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 4639) 
( 4640) !$acc exit data delete(SELF%DEVPTR)
( 4641)     IF (SELF%OWNED) THEN
( 4642)       NULLIFY(SELF%DEVPTR)
( 4643)     ELSE
( 4644)       DEALLOCATE(SELF%DEVPTR)
( 4645)     END IF
( 4646)   END SUBROUTINE FIELD_LOG3D_DELETE_DEVICE
( 4647) 
( 4648)   SUBROUTINE FIELD_LOG4D_DELETE_DEVICE(SELF)
( 4649)     ! Initialize a copy of this field on GPU device
( 4650)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 4651) 
( 4652) !$acc exit data delete(SELF%DEVPTR)
( 4653)     IF (SELF%OWNED) THEN
( 4654)       NULLIFY(SELF%DEVPTR)
( 4655)     ELSE
( 4656)       DEALLOCATE(SELF%DEVPTR)
( 4657)     END IF
( 4658)   END SUBROUTINE FIELD_LOG4D_DELETE_DEVICE
( 4659) 
( 4660)   SUBROUTINE FIELD_LOG5D_DELETE_DEVICE(SELF)
( 4661)     ! Initialize a copy of this field on GPU device
( 4662)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 4663) 
( 4664) !$acc exit data delete(SELF%DEVPTR)
( 4665)     IF (SELF%OWNED) THEN
( 4666)       NULLIFY(SELF%DEVPTR)
( 4667)     ELSE
( 4668)       DEALLOCATE(SELF%DEVPTR)
( 4669)     END IF
( 4670)   END SUBROUTINE FIELD_LOG5D_DELETE_DEVICE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 83

( 4671) 
( 4672) 
( 4673)   SUBROUTINE FIELD_2D_FINAL(SELF)
( 4674)     ! Finalizes field and dealloactes owned data
( 4675)     CLASS(FIELD_2D) :: SELF
( 4676)     IF (SELF%OWNED) THEN
( 4677)       DEALLOCATE(SELF%DATA)
( 4678)     END IF
( 4679)     NULLIFY(SELF%PTR)
( 4680)     NULLIFY(SELF%VIEW)
( 4681)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4682)       !$acc exit data delete (SELF%DEVPTR)
( 4683)       DEALLOCATE (SELF%DEVPTR)
( 4684)       NULLIFY (SELF%DEVPTR)
( 4685)     ENDIF
( 4686)   END SUBROUTINE FIELD_2D_FINAL
( 4687) 
( 4688)   SUBROUTINE FIELD_3D_FINAL(SELF)
( 4689)     ! Finalizes field and dealloactes owned data
( 4690)     CLASS(FIELD_3D) :: SELF
( 4691)     IF (SELF%OWNED) THEN
( 4692)       DEALLOCATE(SELF%DATA)
( 4693)     END IF
( 4694)     NULLIFY(SELF%PTR)
( 4695)     NULLIFY(SELF%VIEW)
( 4696)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4697)       !$acc exit data delete (SELF%DEVPTR)
( 4698)       DEALLOCATE (SELF%DEVPTR)
( 4699)       NULLIFY (SELF%DEVPTR)
( 4700)     ENDIF
( 4701)   END SUBROUTINE FIELD_3D_FINAL
( 4702) 
( 4703)   SUBROUTINE FIELD_4D_FINAL(SELF)
( 4704)     ! Finalizes field and dealloactes owned data
( 4705)     CLASS(FIELD_4D) :: SELF
( 4706)     IF (SELF%OWNED) THEN
( 4707)       DEALLOCATE(SELF%DATA)
( 4708)     END IF
( 4709)     NULLIFY(SELF%PTR)
( 4710)     NULLIFY(SELF%VIEW)
( 4711)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4712)       !$acc exit data delete (SELF%DEVPTR)
( 4713)       DEALLOCATE (SELF%DEVPTR)
( 4714)       NULLIFY (SELF%DEVPTR)
( 4715)     ENDIF
( 4716)   END SUBROUTINE FIELD_4D_FINAL
( 4717) 
( 4718)   SUBROUTINE FIELD_5D_FINAL(SELF)
( 4719)     ! Finalizes field and dealloactes owned data
( 4720)     CLASS(FIELD_5D) :: SELF
( 4721)     IF (SELF%OWNED) THEN
( 4722)       DEALLOCATE(SELF%DATA)
( 4723)     END IF
( 4724)     NULLIFY(SELF%PTR)
( 4725)     NULLIFY(SELF%VIEW)
( 4726)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4727)       !$acc exit data delete (SELF%DEVPTR)
( 4728)       DEALLOCATE (SELF%DEVPTR)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 84

( 4729)       NULLIFY (SELF%DEVPTR)
( 4730)     ENDIF
( 4731)   END SUBROUTINE FIELD_5D_FINAL
( 4732) 
( 4733)   SUBROUTINE FIELD_INT2D_FINAL(SELF)
( 4734)     ! Finalizes field and dealloactes owned data
( 4735)     CLASS(FIELD_INT2D) :: SELF
( 4736)     IF (SELF%OWNED) THEN
( 4737)       DEALLOCATE(SELF%DATA)
( 4738)     END IF
( 4739)     NULLIFY(SELF%PTR)
( 4740)     NULLIFY(SELF%VIEW)
( 4741)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4742)       !$acc exit data delete (SELF%DEVPTR)
( 4743)       DEALLOCATE (SELF%DEVPTR)
( 4744)       NULLIFY (SELF%DEVPTR)
( 4745)     ENDIF
( 4746)   END SUBROUTINE FIELD_INT2D_FINAL
( 4747) 
( 4748)   SUBROUTINE FIELD_INT3D_FINAL(SELF)
( 4749)     ! Finalizes field and dealloactes owned data
( 4750)     CLASS(FIELD_INT3D) :: SELF
( 4751)     IF (SELF%OWNED) THEN
( 4752)       DEALLOCATE(SELF%DATA)
( 4753)     END IF
( 4754)     NULLIFY(SELF%PTR)
( 4755)     NULLIFY(SELF%VIEW)
( 4756)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4757)       !$acc exit data delete (SELF%DEVPTR)
( 4758)       DEALLOCATE (SELF%DEVPTR)
( 4759)       NULLIFY (SELF%DEVPTR)
( 4760)     ENDIF
( 4761)   END SUBROUTINE FIELD_INT3D_FINAL
( 4762) 
( 4763)   SUBROUTINE FIELD_INT4D_FINAL(SELF)
( 4764)     ! Finalizes field and dealloactes owned data
( 4765)     CLASS(FIELD_INT4D) :: SELF
( 4766)     IF (SELF%OWNED) THEN
( 4767)       DEALLOCATE(SELF%DATA)
( 4768)     END IF
( 4769)     NULLIFY(SELF%PTR)
( 4770)     NULLIFY(SELF%VIEW)
( 4771)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4772)       !$acc exit data delete (SELF%DEVPTR)
( 4773)       DEALLOCATE (SELF%DEVPTR)
( 4774)       NULLIFY (SELF%DEVPTR)
( 4775)     ENDIF
( 4776)   END SUBROUTINE FIELD_INT4D_FINAL
( 4777) 
( 4778)   SUBROUTINE FIELD_INT5D_FINAL(SELF)
( 4779)     ! Finalizes field and dealloactes owned data
( 4780)     CLASS(FIELD_INT5D) :: SELF
( 4781)     IF (SELF%OWNED) THEN
( 4782)       DEALLOCATE(SELF%DATA)
( 4783)     END IF
( 4784)     NULLIFY(SELF%PTR)
( 4785)     NULLIFY(SELF%VIEW)
( 4786)     IF (ASSOCIATED (SELF%DEVPTR)) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 85

( 4787)       !$acc exit data delete (SELF%DEVPTR)
( 4788)       DEALLOCATE (SELF%DEVPTR)
( 4789)       NULLIFY (SELF%DEVPTR)
( 4790)     ENDIF
( 4791)   END SUBROUTINE FIELD_INT5D_FINAL
( 4792) 
( 4793)   SUBROUTINE FIELD_LOG2D_FINAL(SELF)
( 4794)     ! Finalizes field and dealloactes owned data
( 4795)     CLASS(FIELD_LOG2D) :: SELF
( 4796)     IF (SELF%OWNED) THEN
( 4797)       DEALLOCATE(SELF%DATA)
( 4798)     END IF
( 4799)     NULLIFY(SELF%PTR)
( 4800)     NULLIFY(SELF%VIEW)
( 4801)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4802)       !$acc exit data delete (SELF%DEVPTR)
( 4803)       DEALLOCATE (SELF%DEVPTR)
( 4804)       NULLIFY (SELF%DEVPTR)
( 4805)     ENDIF
( 4806)   END SUBROUTINE FIELD_LOG2D_FINAL
( 4807) 
( 4808)   SUBROUTINE FIELD_LOG3D_FINAL(SELF)
( 4809)     ! Finalizes field and dealloactes owned data
( 4810)     CLASS(FIELD_LOG3D) :: SELF
( 4811)     IF (SELF%OWNED) THEN
( 4812)       DEALLOCATE(SELF%DATA)
( 4813)     END IF
( 4814)     NULLIFY(SELF%PTR)
( 4815)     NULLIFY(SELF%VIEW)
( 4816)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4817)       !$acc exit data delete (SELF%DEVPTR)
( 4818)       DEALLOCATE (SELF%DEVPTR)
( 4819)       NULLIFY (SELF%DEVPTR)
( 4820)     ENDIF
( 4821)   END SUBROUTINE FIELD_LOG3D_FINAL
( 4822) 
( 4823)   SUBROUTINE FIELD_LOG4D_FINAL(SELF)
( 4824)     ! Finalizes field and dealloactes owned data
( 4825)     CLASS(FIELD_LOG4D) :: SELF
( 4826)     IF (SELF%OWNED) THEN
( 4827)       DEALLOCATE(SELF%DATA)
( 4828)     END IF
( 4829)     NULLIFY(SELF%PTR)
( 4830)     NULLIFY(SELF%VIEW)
( 4831)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4832)       !$acc exit data delete (SELF%DEVPTR)
( 4833)       DEALLOCATE (SELF%DEVPTR)
( 4834)       NULLIFY (SELF%DEVPTR)
( 4835)     ENDIF
( 4836)   END SUBROUTINE FIELD_LOG4D_FINAL
( 4837) 
( 4838)   SUBROUTINE FIELD_LOG5D_FINAL(SELF)
( 4839)     ! Finalizes field and dealloactes owned data
( 4840)     CLASS(FIELD_LOG5D) :: SELF
( 4841)     IF (SELF%OWNED) THEN
( 4842)       DEALLOCATE(SELF%DATA)
( 4843)     END IF
( 4844)     NULLIFY(SELF%PTR)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 86

( 4845)     NULLIFY(SELF%VIEW)
( 4846)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4847)       !$acc exit data delete (SELF%DEVPTR)
( 4848)       DEALLOCATE (SELF%DEVPTR)
( 4849)       NULLIFY (SELF%DEVPTR)
( 4850)     ENDIF
( 4851)   END SUBROUTINE FIELD_LOG5D_FINAL
( 4852) 
( 4853) 
( 4854) END MODULE FIELD_MODULE
( 4855) 
( 4856) 
( 4857) 



















































NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 87

(    1) # 1 "field_module.F90"
(    1) ! Rank and shape definitions for simple templating
(    2) !
(    3) ! Note that the ranks encode coneptual dimensions here, eg. FIELD_2D encodes
(    4) ! a surface field and FIELD_3D represents a field with a vertical component.
(    5) # 8 "field_module.F90"
(    8) MODULE FIELD_MODULE
(    9)   ! The FIELD types provided by this module provide data abstractions that
(   10)   ! decouple data storage in memory from the data views used in thread-parallel
(   11)   ! sections of the code. They are intended to thinly wrap ATLAS_FIELD
(   12)   ! objects and provide additional features that may later be
(   13)   ! incorporated into Atlas. They can also provide backward-compatibility
(   14)   ! for non-Atlas execution modes.
(   15) # 16 "field_module.F90"
(   16) USE PARKIND1, ONLY: JPIM, JPRB
(   17) USE OML_MOD, ONLY: OML_MAX_THREADS, OML_MY_THREAD
(   18) USE IEEE_ARITHMETIC, ONLY: IEEE_SIGNALING_NAN
(   19) # 20 "field_module.F90"
(   20) IMPLICIT NONE
(   21) # 22 "field_module.F90"
(   22) TYPE FIELD_2D
(   23)   ! A FIELD encapsulates a single multi-dimensional array and can
(   24)   ! provide block-indexed "views" of the data for automating the
(   25)   ! allocation and parallel iterration of NPROMA blocks.
(   26) # 27 "field_module.F90"
(   27)   ! The data view to be used in thread-parallel sections
(   28)   !
(   29)   ! The underlying view pointer is of rank-1, since we always
(   30)   ! the horizontal component as a single dimension.
(   31)   REAL(KIND=JPRB), POINTER :: VIEW(:) => NULL()
(   32) # 33 "field_module.F90"
(   33)   ! TODO: Atlas-based field data storage field
(   34)   ! TODO: Do we still need to use pointers here?
(   35)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(   36) # 37 "field_module.F90"
(   37)   ! Storage pointer for non-Atlas backward-compatibility mode
(   38)   !
(   39)   ! The underlying storage pointer has the rank as the dimension,
(   40)   ! where the innermost dimension represents the horizontal and
(   41)   ! the outermost one is the block index.
(   42)   REAL(KIND=JPRB), POINTER :: PTR(:,:) => NULL()
(   43)   REAL(KIND=JPRB), ALLOCATABLE :: DATA(:,:)
(   44) # 45 "field_module.F90"
(   45)   ! For wrapping discontiguous fields in co-allocated storage
(   46)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(   47)   ! and integer index, to allow block pointer extraction that
(   48)   ! conforms with CUDA device pointers in PGI.
(   49)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:) => NULL()
(   50)   INTEGER(KIND=JPIM) :: FIDX
(   51) # 52 "field_module.F90"
(   52)   ! A separate data pointer that can be used to create
(   53)   ! a contiguous chunk of host memory to cleanly map to
(   54)   ! device, should the %DATA pointer be discontiguous.
(   55)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:) => NULL()
(   56) # 57 "field_module.F90"
(   57)   ! Number of blocks used in the data layout
(   58)   INTEGER :: NBLOCKS
(   59) # 60 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 88

(   60)   ! Flag indicating whether this field stores real data
(   61)   LOGICAL :: ACTIVE = .FALSE.
(   62)   ! Flag indicating the use a single block-buffer per thread
(   63)   LOGICAL :: THREAD_BUFFER = .FALSE.
(   64)   ! Flag indicating whether we own the allocated base array
(   65)   LOGICAL :: OWNED = .TRUE.
(   66) # 67 "field_module.F90"
(   67)   INTEGER(KIND=JPIM) :: LBOUNDS (2) = [1, 1]
(   68)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(   69) # 70 "field_module.F90"
(   70) CONTAINS
(   71) # 72 "field_module.F90"
(   72)   PROCEDURE :: CLONE => FIELD_2D_CLONE
(   73)   PROCEDURE :: UPDATE_VIEW => FIELD_2D_UPDATE_VIEW
(   74)   PROCEDURE :: EXTRACT_VIEW => FIELD_2D_EXTRACT_VIEW
(   75)   PROCEDURE :: GET_VIEW => FIELD_2D_GET_VIEW
(   76)   PROCEDURE :: FINAL => FIELD_2D_FINAL
(   77) # 78 "field_module.F90"
(   78)   ! GPU-specific device data transfer API
(   79)   PROCEDURE :: CREATE_DEVICE => FIELD_2D_CREATE_DEVICE
(   80)   PROCEDURE :: UPDATE_DEVICE => FIELD_2D_UPDATE_DEVICE
(   81)   PROCEDURE :: UPDATE_HOST => FIELD_2D_UPDATE_HOST
(   82)   PROCEDURE :: DELETE_DEVICE => FIELD_2D_DELETE_DEVICE
(   83) END TYPE FIELD_2D
(   84) # 85 "field_module.F90"
(   85) TYPE FIELD_3D
(   86)   ! A FIELD encapsulates a single multi-dimensional array and can
(   87)   ! provide block-indexed "views" of the data for automating the
(   88)   ! allocation and parallel iterration of NPROMA blocks.
(   89) # 90 "field_module.F90"
(   90)   ! The data view to be used in thread-parallel sections
(   91)   !
(   92)   ! The underlying view pointer is of rank-1, since we always
(   93)   ! the horizontal component as a single dimension.
(   94)   REAL(KIND=JPRB), POINTER :: VIEW(:,:) => NULL()
(   95) # 96 "field_module.F90"
(   96)   ! TODO: Atlas-based field data storage field
(   97)   ! TODO: Do we still need to use pointers here?
(   98)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(   99) # 100 "field_module.F90"
(  100)   ! Storage pointer for non-Atlas backward-compatibility mode
(  101)   !
(  102)   ! The underlying storage pointer has the rank as the dimension,
(  103)   ! where the innermost dimension represents the horizontal and
(  104)   ! the outermost one is the block index.
(  105)   REAL(KIND=JPRB), POINTER :: PTR(:,:,:) => NULL()
(  106)   REAL(KIND=JPRB), ALLOCATABLE :: DATA(:,:,:)
(  107) # 108 "field_module.F90"
(  108)   ! For wrapping discontiguous fields in co-allocated storage
(  109)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  110)   ! and integer index, to allow block pointer extraction that
(  111)   ! conforms with CUDA device pointers in PGI.
(  112)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:) => NULL()
(  113)   INTEGER(KIND=JPIM) :: FIDX
(  114) # 115 "field_module.F90"
(  115)   ! A separate data pointer that can be used to create
(  116)   ! a contiguous chunk of host memory to cleanly map to
(  117)   ! device, should the %DATA pointer be discontiguous.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 89

(  118)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:) => NULL()
(  119) # 120 "field_module.F90"
(  120)   ! Number of blocks used in the data layout
(  121)   INTEGER :: NBLOCKS
(  122) # 123 "field_module.F90"
(  123)   ! Flag indicating whether this field stores real data
(  124)   LOGICAL :: ACTIVE = .FALSE.
(  125)   ! Flag indicating the use a single block-buffer per thread
(  126)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  127)   ! Flag indicating whether we own the allocated base array
(  128)   LOGICAL :: OWNED = .TRUE.
(  129) # 130 "field_module.F90"
(  130)   INTEGER(KIND=JPIM) :: LBOUNDS (3) = [1, 1, 1]
(  131)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  132) # 133 "field_module.F90"
(  133) CONTAINS
(  134) # 135 "field_module.F90"
(  135)   PROCEDURE :: CLONE => FIELD_3D_CLONE
(  136)   PROCEDURE :: UPDATE_VIEW => FIELD_3D_UPDATE_VIEW
(  137)   PROCEDURE :: EXTRACT_VIEW => FIELD_3D_EXTRACT_VIEW
(  138)   PROCEDURE :: GET_VIEW => FIELD_3D_GET_VIEW
(  139)   PROCEDURE :: FINAL => FIELD_3D_FINAL
(  140) # 141 "field_module.F90"
(  141)   ! GPU-specific device data transfer API
(  142)   PROCEDURE :: CREATE_DEVICE => FIELD_3D_CREATE_DEVICE
(  143)   PROCEDURE :: UPDATE_DEVICE => FIELD_3D_UPDATE_DEVICE
(  144)   PROCEDURE :: UPDATE_HOST => FIELD_3D_UPDATE_HOST
(  145)   PROCEDURE :: DELETE_DEVICE => FIELD_3D_DELETE_DEVICE
(  146) END TYPE FIELD_3D
(  147) # 148 "field_module.F90"
(  148) TYPE FIELD_4D
(  149)   ! A FIELD encapsulates a single multi-dimensional array and can
(  150)   ! provide block-indexed "views" of the data for automating the
(  151)   ! allocation and parallel iterration of NPROMA blocks.
(  152) # 153 "field_module.F90"
(  153)   ! The data view to be used in thread-parallel sections
(  154)   !
(  155)   ! The underlying view pointer is of rank-1, since we always
(  156)   ! the horizontal component as a single dimension.
(  157)   REAL(KIND=JPRB), POINTER :: VIEW(:,:,:) => NULL()
(  158) # 159 "field_module.F90"
(  159)   ! TODO: Atlas-based field data storage field
(  160)   ! TODO: Do we still need to use pointers here?
(  161)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  162) # 163 "field_module.F90"
(  163)   ! Storage pointer for non-Atlas backward-compatibility mode
(  164)   !
(  165)   ! The underlying storage pointer has the rank as the dimension,
(  166)   ! where the innermost dimension represents the horizontal and
(  167)   ! the outermost one is the block index.
(  168)   REAL(KIND=JPRB), POINTER :: PTR(:,:,:,:) => NULL()
(  169)   REAL(KIND=JPRB), ALLOCATABLE :: DATA(:,:,:,:)
(  170) # 171 "field_module.F90"
(  171)   ! For wrapping discontiguous fields in co-allocated storage
(  172)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  173)   ! and integer index, to allow block pointer extraction that
(  174)   ! conforms with CUDA device pointers in PGI.
(  175)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:) => NULL()






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 90

(  176)   INTEGER(KIND=JPIM) :: FIDX
(  177) # 178 "field_module.F90"
(  178)   ! A separate data pointer that can be used to create
(  179)   ! a contiguous chunk of host memory to cleanly map to
(  180)   ! device, should the %DATA pointer be discontiguous.
(  181)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:) => NULL()
(  182) # 183 "field_module.F90"
(  183)   ! Number of blocks used in the data layout
(  184)   INTEGER :: NBLOCKS
(  185) # 186 "field_module.F90"
(  186)   ! Flag indicating whether this field stores real data
(  187)   LOGICAL :: ACTIVE = .FALSE.
(  188)   ! Flag indicating the use a single block-buffer per thread
(  189)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  190)   ! Flag indicating whether we own the allocated base array
(  191)   LOGICAL :: OWNED = .TRUE.
(  192) # 193 "field_module.F90"
(  193)   INTEGER(KIND=JPIM) :: LBOUNDS (4) = [1, 1, 1, 1]
(  194)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  195) # 196 "field_module.F90"
(  196) CONTAINS
(  197) # 198 "field_module.F90"
(  198)   PROCEDURE :: CLONE => FIELD_4D_CLONE
(  199)   PROCEDURE :: UPDATE_VIEW => FIELD_4D_UPDATE_VIEW
(  200)   PROCEDURE :: EXTRACT_VIEW => FIELD_4D_EXTRACT_VIEW
(  201)   PROCEDURE :: GET_VIEW => FIELD_4D_GET_VIEW
(  202)   PROCEDURE :: FINAL => FIELD_4D_FINAL
(  203) # 204 "field_module.F90"
(  204)   ! GPU-specific device data transfer API
(  205)   PROCEDURE :: CREATE_DEVICE => FIELD_4D_CREATE_DEVICE
(  206)   PROCEDURE :: UPDATE_DEVICE => FIELD_4D_UPDATE_DEVICE
(  207)   PROCEDURE :: UPDATE_HOST => FIELD_4D_UPDATE_HOST
(  208)   PROCEDURE :: DELETE_DEVICE => FIELD_4D_DELETE_DEVICE
(  209) END TYPE FIELD_4D
(  210) # 211 "field_module.F90"
(  211) TYPE FIELD_5D
(  212)   ! A FIELD encapsulates a single multi-dimensional array and can
(  213)   ! provide block-indexed "views" of the data for automating the
(  214)   ! allocation and parallel iterration of NPROMA blocks.
(  215) # 216 "field_module.F90"
(  216)   ! The data view to be used in thread-parallel sections
(  217)   !
(  218)   ! The underlying view pointer is of rank-1, since we always
(  219)   ! the horizontal component as a single dimension.
(  220)   REAL(KIND=JPRB), POINTER :: VIEW(:,:,:,:) => NULL()
(  221) # 222 "field_module.F90"
(  222)   ! TODO: Atlas-based field data storage field
(  223)   ! TODO: Do we still need to use pointers here?
(  224)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  225) # 226 "field_module.F90"
(  226)   ! Storage pointer for non-Atlas backward-compatibility mode
(  227)   !
(  228)   ! The underlying storage pointer has the rank as the dimension,
(  229)   ! where the innermost dimension represents the horizontal and
(  230)   ! the outermost one is the block index.
(  231)   REAL(KIND=JPRB), POINTER :: PTR(:,:,:,:,:) => NULL()
(  232)   REAL(KIND=JPRB), ALLOCATABLE :: DATA(:,:,:,:,:)
(  233) # 234 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 91

(  234)   ! For wrapping discontiguous fields in co-allocated storage
(  235)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  236)   ! and integer index, to allow block pointer extraction that
(  237)   ! conforms with CUDA device pointers in PGI.
(  238)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:,:) => NULL()
(  239)   INTEGER(KIND=JPIM) :: FIDX
(  240) # 241 "field_module.F90"
(  241)   ! A separate data pointer that can be used to create
(  242)   ! a contiguous chunk of host memory to cleanly map to
(  243)   ! device, should the %DATA pointer be discontiguous.
(  244)   REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:) => NULL()
(  245) # 246 "field_module.F90"
(  246)   ! Number of blocks used in the data layout
(  247)   INTEGER :: NBLOCKS
(  248) # 249 "field_module.F90"
(  249)   ! Flag indicating whether this field stores real data
(  250)   LOGICAL :: ACTIVE = .FALSE.
(  251)   ! Flag indicating the use a single block-buffer per thread
(  252)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  253)   ! Flag indicating whether we own the allocated base array
(  254)   LOGICAL :: OWNED = .TRUE.
(  255) # 256 "field_module.F90"
(  256)   INTEGER(KIND=JPIM) :: LBOUNDS (5) = [1, 1, 1, 1, 1]
(  257)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  258) # 259 "field_module.F90"
(  259) CONTAINS
(  260) # 261 "field_module.F90"
(  261)   PROCEDURE :: CLONE => FIELD_5D_CLONE
(  262)   PROCEDURE :: UPDATE_VIEW => FIELD_5D_UPDATE_VIEW
(  263)   PROCEDURE :: EXTRACT_VIEW => FIELD_5D_EXTRACT_VIEW
(  264)   PROCEDURE :: GET_VIEW => FIELD_5D_GET_VIEW
(  265)   PROCEDURE :: FINAL => FIELD_5D_FINAL
(  266) # 267 "field_module.F90"
(  267)   ! GPU-specific device data transfer API
(  268)   PROCEDURE :: CREATE_DEVICE => FIELD_5D_CREATE_DEVICE
(  269)   PROCEDURE :: UPDATE_DEVICE => FIELD_5D_UPDATE_DEVICE
(  270)   PROCEDURE :: UPDATE_HOST => FIELD_5D_UPDATE_HOST
(  271)   PROCEDURE :: DELETE_DEVICE => FIELD_5D_DELETE_DEVICE
(  272) END TYPE FIELD_5D
(  273) # 274 "field_module.F90"
(  274) TYPE FIELD_INT2D
(  275)   ! A FIELD encapsulates a single multi-dimensional array and can
(  276)   ! provide block-indexed "views" of the data for automating the
(  277)   ! allocation and parallel iterration of NPROMA blocks.
(  278) # 279 "field_module.F90"
(  279)   ! The data view to be used in thread-parallel sections
(  280)   !
(  281)   ! The underlying view pointer is of rank-1, since we always
(  282)   ! the horizontal component as a single dimension.
(  283)   INTEGER(KIND=JPIM), POINTER :: VIEW(:) => NULL()
(  284) # 285 "field_module.F90"
(  285)   ! TODO: Atlas-based field data storage field
(  286)   ! TODO: Do we still need to use pointers here?
(  287)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  288) # 289 "field_module.F90"
(  289)   ! Storage pointer for non-Atlas backward-compatibility mode
(  290)   !
(  291)   ! The underlying storage pointer has the rank as the dimension,






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 92

(  292)   ! where the innermost dimension represents the horizontal and
(  293)   ! the outermost one is the block index.
(  294)   INTEGER(KIND=JPIM), POINTER :: PTR(:,:) => NULL()
(  295)   INTEGER(KIND=JPIM), ALLOCATABLE :: DATA(:,:)
(  296) # 297 "field_module.F90"
(  297)   ! For wrapping discontiguous fields in co-allocated storage
(  298)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  299)   ! and integer index, to allow block pointer extraction that
(  300)   ! conforms with CUDA device pointers in PGI.
(  301)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:) => NULL()
(  302)   INTEGER(KIND=JPIM) :: FIDX
(  303) # 304 "field_module.F90"
(  304)   ! A separate data pointer that can be used to create
(  305)   ! a contiguous chunk of host memory to cleanly map to
(  306)   ! device, should the %DATA pointer be discontiguous.
(  307)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:) => NULL()
(  308) # 309 "field_module.F90"
(  309)   ! Number of blocks used in the data layout
(  310)   INTEGER :: NBLOCKS
(  311) # 312 "field_module.F90"
(  312)   ! Flag indicating whether this field stores real data
(  313)   LOGICAL :: ACTIVE = .FALSE.
(  314)   ! Flag indicating the use a single block-buffer per thread
(  315)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  316)   ! Flag indicating whether we own the allocated base array
(  317)   LOGICAL :: OWNED = .TRUE.
(  318) # 319 "field_module.F90"
(  319)   INTEGER(KIND=JPIM) :: LBOUNDS (2) = [1, 1]
(  320)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  321) # 322 "field_module.F90"
(  322) CONTAINS
(  323) # 324 "field_module.F90"
(  324)   PROCEDURE :: CLONE => FIELD_INT2D_CLONE
(  325)   PROCEDURE :: UPDATE_VIEW => FIELD_INT2D_UPDATE_VIEW
(  326)   PROCEDURE :: EXTRACT_VIEW => FIELD_INT2D_EXTRACT_VIEW
(  327)   PROCEDURE :: GET_VIEW => FIELD_INT2D_GET_VIEW
(  328)   PROCEDURE :: FINAL => FIELD_INT2D_FINAL
(  329) # 330 "field_module.F90"
(  330)   ! GPU-specific device data transfer API
(  331)   PROCEDURE :: CREATE_DEVICE => FIELD_INT2D_CREATE_DEVICE
(  332)   PROCEDURE :: UPDATE_DEVICE => FIELD_INT2D_UPDATE_DEVICE
(  333)   PROCEDURE :: UPDATE_HOST => FIELD_INT2D_UPDATE_HOST
(  334)   PROCEDURE :: DELETE_DEVICE => FIELD_INT2D_DELETE_DEVICE
(  335) END TYPE FIELD_INT2D
(  336) # 337 "field_module.F90"
(  337) TYPE FIELD_INT3D
(  338)   ! A FIELD encapsulates a single multi-dimensional array and can
(  339)   ! provide block-indexed "views" of the data for automating the
(  340)   ! allocation and parallel iterration of NPROMA blocks.
(  341) # 342 "field_module.F90"
(  342)   ! The data view to be used in thread-parallel sections
(  343)   !
(  344)   ! The underlying view pointer is of rank-1, since we always
(  345)   ! the horizontal component as a single dimension.
(  346)   INTEGER(KIND=JPIM), POINTER :: VIEW(:,:) => NULL()
(  347) # 348 "field_module.F90"
(  348)   ! TODO: Atlas-based field data storage field
(  349)   ! TODO: Do we still need to use pointers here?






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 93

(  350)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  351) # 352 "field_module.F90"
(  352)   ! Storage pointer for non-Atlas backward-compatibility mode
(  353)   !
(  354)   ! The underlying storage pointer has the rank as the dimension,
(  355)   ! where the innermost dimension represents the horizontal and
(  356)   ! the outermost one is the block index.
(  357)   INTEGER(KIND=JPIM), POINTER :: PTR(:,:,:) => NULL()
(  358)   INTEGER(KIND=JPIM), ALLOCATABLE :: DATA(:,:,:)
(  359) # 360 "field_module.F90"
(  360)   ! For wrapping discontiguous fields in co-allocated storage
(  361)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  362)   ! and integer index, to allow block pointer extraction that
(  363)   ! conforms with CUDA device pointers in PGI.
(  364)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:) => NULL()
(  365)   INTEGER(KIND=JPIM) :: FIDX
(  366) # 367 "field_module.F90"
(  367)   ! A separate data pointer that can be used to create
(  368)   ! a contiguous chunk of host memory to cleanly map to
(  369)   ! device, should the %DATA pointer be discontiguous.
(  370)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:) => NULL()
(  371) # 372 "field_module.F90"
(  372)   ! Number of blocks used in the data layout
(  373)   INTEGER :: NBLOCKS
(  374) # 375 "field_module.F90"
(  375)   ! Flag indicating whether this field stores real data
(  376)   LOGICAL :: ACTIVE = .FALSE.
(  377)   ! Flag indicating the use a single block-buffer per thread
(  378)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  379)   ! Flag indicating whether we own the allocated base array
(  380)   LOGICAL :: OWNED = .TRUE.
(  381) # 382 "field_module.F90"
(  382)   INTEGER(KIND=JPIM) :: LBOUNDS (3) = [1, 1, 1]
(  383)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  384) # 385 "field_module.F90"
(  385) CONTAINS
(  386) # 387 "field_module.F90"
(  387)   PROCEDURE :: CLONE => FIELD_INT3D_CLONE
(  388)   PROCEDURE :: UPDATE_VIEW => FIELD_INT3D_UPDATE_VIEW
(  389)   PROCEDURE :: EXTRACT_VIEW => FIELD_INT3D_EXTRACT_VIEW
(  390)   PROCEDURE :: GET_VIEW => FIELD_INT3D_GET_VIEW
(  391)   PROCEDURE :: FINAL => FIELD_INT3D_FINAL
(  392) # 393 "field_module.F90"
(  393)   ! GPU-specific device data transfer API
(  394)   PROCEDURE :: CREATE_DEVICE => FIELD_INT3D_CREATE_DEVICE
(  395)   PROCEDURE :: UPDATE_DEVICE => FIELD_INT3D_UPDATE_DEVICE
(  396)   PROCEDURE :: UPDATE_HOST => FIELD_INT3D_UPDATE_HOST
(  397)   PROCEDURE :: DELETE_DEVICE => FIELD_INT3D_DELETE_DEVICE
(  398) END TYPE FIELD_INT3D
(  399) # 400 "field_module.F90"
(  400) TYPE FIELD_INT4D
(  401)   ! A FIELD encapsulates a single multi-dimensional array and can
(  402)   ! provide block-indexed "views" of the data for automating the
(  403)   ! allocation and parallel iterration of NPROMA blocks.
(  404) # 405 "field_module.F90"
(  405)   ! The data view to be used in thread-parallel sections
(  406)   !
(  407)   ! The underlying view pointer is of rank-1, since we always






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 94

(  408)   ! the horizontal component as a single dimension.
(  409)   INTEGER(KIND=JPIM), POINTER :: VIEW(:,:,:) => NULL()
(  410) # 411 "field_module.F90"
(  411)   ! TODO: Atlas-based field data storage field
(  412)   ! TODO: Do we still need to use pointers here?
(  413)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  414) # 415 "field_module.F90"
(  415)   ! Storage pointer for non-Atlas backward-compatibility mode
(  416)   !
(  417)   ! The underlying storage pointer has the rank as the dimension,
(  418)   ! where the innermost dimension represents the horizontal and
(  419)   ! the outermost one is the block index.
(  420)   INTEGER(KIND=JPIM), POINTER :: PTR(:,:,:,:) => NULL()
(  421)   INTEGER(KIND=JPIM), ALLOCATABLE :: DATA(:,:,:,:)
(  422) # 423 "field_module.F90"
(  423)   ! For wrapping discontiguous fields in co-allocated storage
(  424)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  425)   ! and integer index, to allow block pointer extraction that
(  426)   ! conforms with CUDA device pointers in PGI.
(  427)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:) => NULL()
(  428)   INTEGER(KIND=JPIM) :: FIDX
(  429) # 430 "field_module.F90"
(  430)   ! A separate data pointer that can be used to create
(  431)   ! a contiguous chunk of host memory to cleanly map to
(  432)   ! device, should the %DATA pointer be discontiguous.
(  433)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:) => NULL()
(  434) # 435 "field_module.F90"
(  435)   ! Number of blocks used in the data layout
(  436)   INTEGER :: NBLOCKS
(  437) # 438 "field_module.F90"
(  438)   ! Flag indicating whether this field stores real data
(  439)   LOGICAL :: ACTIVE = .FALSE.
(  440)   ! Flag indicating the use a single block-buffer per thread
(  441)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  442)   ! Flag indicating whether we own the allocated base array
(  443)   LOGICAL :: OWNED = .TRUE.
(  444) # 445 "field_module.F90"
(  445)   INTEGER(KIND=JPIM) :: LBOUNDS (4) = [1, 1, 1, 1]
(  446)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  447) # 448 "field_module.F90"
(  448) CONTAINS
(  449) # 450 "field_module.F90"
(  450)   PROCEDURE :: CLONE => FIELD_INT4D_CLONE
(  451)   PROCEDURE :: UPDATE_VIEW => FIELD_INT4D_UPDATE_VIEW
(  452)   PROCEDURE :: EXTRACT_VIEW => FIELD_INT4D_EXTRACT_VIEW
(  453)   PROCEDURE :: GET_VIEW => FIELD_INT4D_GET_VIEW
(  454)   PROCEDURE :: FINAL => FIELD_INT4D_FINAL
(  455) # 456 "field_module.F90"
(  456)   ! GPU-specific device data transfer API
(  457)   PROCEDURE :: CREATE_DEVICE => FIELD_INT4D_CREATE_DEVICE
(  458)   PROCEDURE :: UPDATE_DEVICE => FIELD_INT4D_UPDATE_DEVICE
(  459)   PROCEDURE :: UPDATE_HOST => FIELD_INT4D_UPDATE_HOST
(  460)   PROCEDURE :: DELETE_DEVICE => FIELD_INT4D_DELETE_DEVICE
(  461) END TYPE FIELD_INT4D
(  462) # 463 "field_module.F90"
(  463) TYPE FIELD_INT5D
(  464)   ! A FIELD encapsulates a single multi-dimensional array and can
(  465)   ! provide block-indexed "views" of the data for automating the






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 95

(  466)   ! allocation and parallel iterration of NPROMA blocks.
(  467) # 468 "field_module.F90"
(  468)   ! The data view to be used in thread-parallel sections
(  469)   !
(  470)   ! The underlying view pointer is of rank-1, since we always
(  471)   ! the horizontal component as a single dimension.
(  472)   INTEGER(KIND=JPIM), POINTER :: VIEW(:,:,:,:) => NULL()
(  473) # 474 "field_module.F90"
(  474)   ! TODO: Atlas-based field data storage field
(  475)   ! TODO: Do we still need to use pointers here?
(  476)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  477) # 478 "field_module.F90"
(  478)   ! Storage pointer for non-Atlas backward-compatibility mode
(  479)   !
(  480)   ! The underlying storage pointer has the rank as the dimension,
(  481)   ! where the innermost dimension represents the horizontal and
(  482)   ! the outermost one is the block index.
(  483)   INTEGER(KIND=JPIM), POINTER :: PTR(:,:,:,:,:) => NULL()
(  484)   INTEGER(KIND=JPIM), ALLOCATABLE :: DATA(:,:,:,:,:)
(  485) # 486 "field_module.F90"
(  486)   ! For wrapping discontiguous fields in co-allocated storage
(  487)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  488)   ! and integer index, to allow block pointer extraction that
(  489)   ! conforms with CUDA device pointers in PGI.
(  490)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:,:) => NULL()
(  491)   INTEGER(KIND=JPIM) :: FIDX
(  492) # 493 "field_module.F90"
(  493)   ! A separate data pointer that can be used to create
(  494)   ! a contiguous chunk of host memory to cleanly map to
(  495)   ! device, should the %DATA pointer be discontiguous.
(  496)   INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:) => NULL()
(  497) # 498 "field_module.F90"
(  498)   ! Number of blocks used in the data layout
(  499)   INTEGER :: NBLOCKS
(  500) # 501 "field_module.F90"
(  501)   ! Flag indicating whether this field stores real data
(  502)   LOGICAL :: ACTIVE = .FALSE.
(  503)   ! Flag indicating the use a single block-buffer per thread
(  504)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  505)   ! Flag indicating whether we own the allocated base array
(  506)   LOGICAL :: OWNED = .TRUE.
(  507) # 508 "field_module.F90"
(  508)   INTEGER(KIND=JPIM) :: LBOUNDS (5) = [1, 1, 1, 1, 1]
(  509)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  510) # 511 "field_module.F90"
(  511) CONTAINS
(  512) # 513 "field_module.F90"
(  513)   PROCEDURE :: CLONE => FIELD_INT5D_CLONE
(  514)   PROCEDURE :: UPDATE_VIEW => FIELD_INT5D_UPDATE_VIEW
(  515)   PROCEDURE :: EXTRACT_VIEW => FIELD_INT5D_EXTRACT_VIEW
(  516)   PROCEDURE :: GET_VIEW => FIELD_INT5D_GET_VIEW
(  517)   PROCEDURE :: FINAL => FIELD_INT5D_FINAL
(  518) # 519 "field_module.F90"
(  519)   ! GPU-specific device data transfer API
(  520)   PROCEDURE :: CREATE_DEVICE => FIELD_INT5D_CREATE_DEVICE
(  521)   PROCEDURE :: UPDATE_DEVICE => FIELD_INT5D_UPDATE_DEVICE
(  522)   PROCEDURE :: UPDATE_HOST => FIELD_INT5D_UPDATE_HOST
(  523)   PROCEDURE :: DELETE_DEVICE => FIELD_INT5D_DELETE_DEVICE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 96

(  524) END TYPE FIELD_INT5D
(  525) # 526 "field_module.F90"
(  526) TYPE FIELD_LOG2D
(  527)   ! A FIELD encapsulates a single multi-dimensional array and can
(  528)   ! provide block-indexed "views" of the data for automating the
(  529)   ! allocation and parallel iterration of NPROMA blocks.
(  530) # 531 "field_module.F90"
(  531)   ! The data view to be used in thread-parallel sections
(  532)   !
(  533)   ! The underlying view pointer is of rank-1, since we always
(  534)   ! the horizontal component as a single dimension.
(  535)   LOGICAL, POINTER :: VIEW(:) => NULL()
(  536) # 537 "field_module.F90"
(  537)   ! TODO: Atlas-based field data storage field
(  538)   ! TODO: Do we still need to use pointers here?
(  539)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  540) # 541 "field_module.F90"
(  541)   ! Storage pointer for non-Atlas backward-compatibility mode
(  542)   !
(  543)   ! The underlying storage pointer has the rank as the dimension,
(  544)   ! where the innermost dimension represents the horizontal and
(  545)   ! the outermost one is the block index.
(  546)   LOGICAL, POINTER :: PTR(:,:) => NULL()
(  547)   LOGICAL, ALLOCATABLE :: DATA(:,:)
(  548) # 549 "field_module.F90"
(  549)   ! For wrapping discontiguous fields in co-allocated storage
(  550)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  551)   ! and integer index, to allow block pointer extraction that
(  552)   ! conforms with CUDA device pointers in PGI.
(  553)   LOGICAL, POINTER, CONTIGUOUS :: BASE_PTR(:,:,:) => NULL()
(  554)   INTEGER(KIND=JPIM) :: FIDX
(  555) # 556 "field_module.F90"
(  556)   ! A separate data pointer that can be used to create
(  557)   ! a contiguous chunk of host memory to cleanly map to
(  558)   ! device, should the %DATA pointer be discontiguous.
(  559)   LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:) => NULL()
(  560) # 561 "field_module.F90"
(  561)   ! Number of blocks used in the data layout
(  562)   INTEGER :: NBLOCKS
(  563) # 564 "field_module.F90"
(  564)   ! Flag indicating whether this field stores real data
(  565)   LOGICAL :: ACTIVE = .FALSE.
(  566)   ! Flag indicating the use a single block-buffer per thread
(  567)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  568)   ! Flag indicating whether we own the allocated base array
(  569)   LOGICAL :: OWNED = .TRUE.
(  570) # 571 "field_module.F90"
(  571)   INTEGER(KIND=JPIM) :: LBOUNDS (2) = [1, 1]
(  572)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  573) # 574 "field_module.F90"
(  574) CONTAINS
(  575) # 576 "field_module.F90"
(  576)   PROCEDURE :: CLONE => FIELD_LOG2D_CLONE
(  577)   PROCEDURE :: UPDATE_VIEW => FIELD_LOG2D_UPDATE_VIEW
(  578)   PROCEDURE :: EXTRACT_VIEW => FIELD_LOG2D_EXTRACT_VIEW
(  579)   PROCEDURE :: GET_VIEW => FIELD_LOG2D_GET_VIEW
(  580)   PROCEDURE :: FINAL => FIELD_LOG2D_FINAL
(  581) # 582 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 97

(  582)   ! GPU-specific device data transfer API
(  583)   PROCEDURE :: CREATE_DEVICE => FIELD_LOG2D_CREATE_DEVICE
(  584)   PROCEDURE :: UPDATE_DEVICE => FIELD_LOG2D_UPDATE_DEVICE
(  585)   PROCEDURE :: UPDATE_HOST => FIELD_LOG2D_UPDATE_HOST
(  586)   PROCEDURE :: DELETE_DEVICE => FIELD_LOG2D_DELETE_DEVICE
(  587) END TYPE FIELD_LOG2D
(  588) # 589 "field_module.F90"
(  589) TYPE FIELD_LOG3D
(  590)   ! A FIELD encapsulates a single multi-dimensional array and can
(  591)   ! provide block-indexed "views" of the data for automating the
(  592)   ! allocation and parallel iterration of NPROMA blocks.
(  593) # 594 "field_module.F90"
(  594)   ! The data view to be used in thread-parallel sections
(  595)   !
(  596)   ! The underlying view pointer is of rank-1, since we always
(  597)   ! the horizontal component as a single dimension.
(  598)   LOGICAL, POINTER :: VIEW(:,:) => NULL()
(  599) # 600 "field_module.F90"
(  600)   ! TODO: Atlas-based field data storage field
(  601)   ! TODO: Do we still need to use pointers here?
(  602)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  603) # 604 "field_module.F90"
(  604)   ! Storage pointer for non-Atlas backward-compatibility mode
(  605)   !
(  606)   ! The underlying storage pointer has the rank as the dimension,
(  607)   ! where the innermost dimension represents the horizontal and
(  608)   ! the outermost one is the block index.
(  609)   LOGICAL, POINTER :: PTR(:,:,:) => NULL()
(  610)   LOGICAL, ALLOCATABLE :: DATA(:,:,:)
(  611) # 612 "field_module.F90"
(  612)   ! For wrapping discontiguous fields in co-allocated storage
(  613)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  614)   ! and integer index, to allow block pointer extraction that
(  615)   ! conforms with CUDA device pointers in PGI.
(  616)   LOGICAL, POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:) => NULL()
(  617)   INTEGER(KIND=JPIM) :: FIDX
(  618) # 619 "field_module.F90"
(  619)   ! A separate data pointer that can be used to create
(  620)   ! a contiguous chunk of host memory to cleanly map to
(  621)   ! device, should the %DATA pointer be discontiguous.
(  622)   LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:) => NULL()
(  623) # 624 "field_module.F90"
(  624)   ! Number of blocks used in the data layout
(  625)   INTEGER :: NBLOCKS
(  626) # 627 "field_module.F90"
(  627)   ! Flag indicating whether this field stores real data
(  628)   LOGICAL :: ACTIVE = .FALSE.
(  629)   ! Flag indicating the use a single block-buffer per thread
(  630)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  631)   ! Flag indicating whether we own the allocated base array
(  632)   LOGICAL :: OWNED = .TRUE.
(  633) # 634 "field_module.F90"
(  634)   INTEGER(KIND=JPIM) :: LBOUNDS (3) = [1, 1, 1]
(  635)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  636) # 637 "field_module.F90"
(  637) CONTAINS
(  638) # 639 "field_module.F90"
(  639)   PROCEDURE :: CLONE => FIELD_LOG3D_CLONE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 98

(  640)   PROCEDURE :: UPDATE_VIEW => FIELD_LOG3D_UPDATE_VIEW
(  641)   PROCEDURE :: EXTRACT_VIEW => FIELD_LOG3D_EXTRACT_VIEW
(  642)   PROCEDURE :: GET_VIEW => FIELD_LOG3D_GET_VIEW
(  643)   PROCEDURE :: FINAL => FIELD_LOG3D_FINAL
(  644) # 645 "field_module.F90"
(  645)   ! GPU-specific device data transfer API
(  646)   PROCEDURE :: CREATE_DEVICE => FIELD_LOG3D_CREATE_DEVICE
(  647)   PROCEDURE :: UPDATE_DEVICE => FIELD_LOG3D_UPDATE_DEVICE
(  648)   PROCEDURE :: UPDATE_HOST => FIELD_LOG3D_UPDATE_HOST
(  649)   PROCEDURE :: DELETE_DEVICE => FIELD_LOG3D_DELETE_DEVICE
(  650) END TYPE FIELD_LOG3D
(  651) # 652 "field_module.F90"
(  652) TYPE FIELD_LOG4D
(  653)   ! A FIELD encapsulates a single multi-dimensional array and can
(  654)   ! provide block-indexed "views" of the data for automating the
(  655)   ! allocation and parallel iterration of NPROMA blocks.
(  656) # 657 "field_module.F90"
(  657)   ! The data view to be used in thread-parallel sections
(  658)   !
(  659)   ! The underlying view pointer is of rank-1, since we always
(  660)   ! the horizontal component as a single dimension.
(  661)   LOGICAL, POINTER :: VIEW(:,:,:) => NULL()
(  662) # 663 "field_module.F90"
(  663)   ! TODO: Atlas-based field data storage field
(  664)   ! TODO: Do we still need to use pointers here?
(  665)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  666) # 667 "field_module.F90"
(  667)   ! Storage pointer for non-Atlas backward-compatibility mode
(  668)   !
(  669)   ! The underlying storage pointer has the rank as the dimension,
(  670)   ! where the innermost dimension represents the horizontal and
(  671)   ! the outermost one is the block index.
(  672)   LOGICAL, POINTER :: PTR(:,:,:,:) => NULL()
(  673)   LOGICAL, ALLOCATABLE :: DATA(:,:,:,:)
(  674) # 675 "field_module.F90"
(  675)   ! For wrapping discontiguous fields in co-allocated storage
(  676)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  677)   ! and integer index, to allow block pointer extraction that
(  678)   ! conforms with CUDA device pointers in PGI.
(  679)   LOGICAL, POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:) => NULL()
(  680)   INTEGER(KIND=JPIM) :: FIDX
(  681) # 682 "field_module.F90"
(  682)   ! A separate data pointer that can be used to create
(  683)   ! a contiguous chunk of host memory to cleanly map to
(  684)   ! device, should the %DATA pointer be discontiguous.
(  685)   LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:) => NULL()
(  686) # 687 "field_module.F90"
(  687)   ! Number of blocks used in the data layout
(  688)   INTEGER :: NBLOCKS
(  689) # 690 "field_module.F90"
(  690)   ! Flag indicating whether this field stores real data
(  691)   LOGICAL :: ACTIVE = .FALSE.
(  692)   ! Flag indicating the use a single block-buffer per thread
(  693)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  694)   ! Flag indicating whether we own the allocated base array
(  695)   LOGICAL :: OWNED = .TRUE.
(  696) # 697 "field_module.F90"
(  697)   INTEGER(KIND=JPIM) :: LBOUNDS (4) = [1, 1, 1, 1]






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 99

(  698)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  699) # 700 "field_module.F90"
(  700) CONTAINS
(  701) # 702 "field_module.F90"
(  702)   PROCEDURE :: CLONE => FIELD_LOG4D_CLONE
(  703)   PROCEDURE :: UPDATE_VIEW => FIELD_LOG4D_UPDATE_VIEW
(  704)   PROCEDURE :: EXTRACT_VIEW => FIELD_LOG4D_EXTRACT_VIEW
(  705)   PROCEDURE :: GET_VIEW => FIELD_LOG4D_GET_VIEW
(  706)   PROCEDURE :: FINAL => FIELD_LOG4D_FINAL
(  707) # 708 "field_module.F90"
(  708)   ! GPU-specific device data transfer API
(  709)   PROCEDURE :: CREATE_DEVICE => FIELD_LOG4D_CREATE_DEVICE
(  710)   PROCEDURE :: UPDATE_DEVICE => FIELD_LOG4D_UPDATE_DEVICE
(  711)   PROCEDURE :: UPDATE_HOST => FIELD_LOG4D_UPDATE_HOST
(  712)   PROCEDURE :: DELETE_DEVICE => FIELD_LOG4D_DELETE_DEVICE
(  713) END TYPE FIELD_LOG4D
(  714) # 715 "field_module.F90"
(  715) TYPE FIELD_LOG5D
(  716)   ! A FIELD encapsulates a single multi-dimensional array and can
(  717)   ! provide block-indexed "views" of the data for automating the
(  718)   ! allocation and parallel iterration of NPROMA blocks.
(  719) # 720 "field_module.F90"
(  720)   ! The data view to be used in thread-parallel sections
(  721)   !
(  722)   ! The underlying view pointer is of rank-1, since we always
(  723)   ! the horizontal component as a single dimension.
(  724)   LOGICAL, POINTER :: VIEW(:,:,:,:) => NULL()
(  725) # 726 "field_module.F90"
(  726)   ! TODO: Atlas-based field data storage field
(  727)   ! TODO: Do we still need to use pointers here?
(  728)   ! TYPE(ATLAS_FIELD), POINTER :: DATA
(  729) # 730 "field_module.F90"
(  730)   ! Storage pointer for non-Atlas backward-compatibility mode
(  731)   !
(  732)   ! The underlying storage pointer has the rank as the dimension,
(  733)   ! where the innermost dimension represents the horizontal and
(  734)   ! the outermost one is the block index.
(  735)   LOGICAL, POINTER :: PTR(:,:,:,:,:) => NULL()
(  736)   LOGICAL, ALLOCATABLE :: DATA(:,:,:,:,:)
(  737) # 738 "field_module.F90"
(  738)   ! For wrapping discontiguous fields in co-allocated storage
(  739)   ! arrays (eg. GFL/GMV) also store a CONTIGUOUS base pointer
(  740)   ! and integer index, to allow block pointer extraction that
(  741)   ! conforms with CUDA device pointers in PGI.
(  742)   LOGICAL, POINTER, CONTIGUOUS :: BASE_PTR(:,:,:,:,:,:) => NULL()
(  743)   INTEGER(KIND=JPIM) :: FIDX
(  744) # 745 "field_module.F90"
(  745)   ! A separate data pointer that can be used to create
(  746)   ! a contiguous chunk of host memory to cleanly map to
(  747)   ! device, should the %DATA pointer be discontiguous.
(  748)   LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:) => NULL()
(  749) # 750 "field_module.F90"
(  750)   ! Number of blocks used in the data layout
(  751)   INTEGER :: NBLOCKS
(  752) # 753 "field_module.F90"
(  753)   ! Flag indicating whether this field stores real data
(  754)   LOGICAL :: ACTIVE = .FALSE.
(  755)   ! Flag indicating the use a single block-buffer per thread






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 100

(  756)   LOGICAL :: THREAD_BUFFER = .FALSE.
(  757)   ! Flag indicating whether we own the allocated base array
(  758)   LOGICAL :: OWNED = .TRUE.
(  759) # 760 "field_module.F90"
(  760)   INTEGER(KIND=JPIM) :: LBOUNDS (5) = [1, 1, 1, 1, 1]
(  761)   INTEGER(KIND=JPIM) :: ISTATUS = 0
(  762) # 763 "field_module.F90"
(  763) CONTAINS
(  764) # 765 "field_module.F90"
(  765)   PROCEDURE :: CLONE => FIELD_LOG5D_CLONE
(  766)   PROCEDURE :: UPDATE_VIEW => FIELD_LOG5D_UPDATE_VIEW
(  767)   PROCEDURE :: EXTRACT_VIEW => FIELD_LOG5D_EXTRACT_VIEW
(  768)   PROCEDURE :: GET_VIEW => FIELD_LOG5D_GET_VIEW
(  769)   PROCEDURE :: FINAL => FIELD_LOG5D_FINAL
(  770) # 771 "field_module.F90"
(  771)   ! GPU-specific device data transfer API
(  772)   PROCEDURE :: CREATE_DEVICE => FIELD_LOG5D_CREATE_DEVICE
(  773)   PROCEDURE :: UPDATE_DEVICE => FIELD_LOG5D_UPDATE_DEVICE
(  774)   PROCEDURE :: UPDATE_HOST => FIELD_LOG5D_UPDATE_HOST
(  775)   PROCEDURE :: DELETE_DEVICE => FIELD_LOG5D_DELETE_DEVICE
(  776) END TYPE FIELD_LOG5D
(  777) # 779 "field_module.F90"
(  779) INTEGER (KIND=JPIM), PARAMETER :: NDEVFRESH = B'00000001', NHSTFRESH = B'00000010'
(  780) # 781 "field_module.F90"
(  781) TYPE FIELD_2D_PTR
(  782)   ! Struct to hold references to field objects
(  783)   TYPE(FIELD_2D), POINTER :: PTR => NULL()
(  784) END TYPE FIELD_2D_PTR
(  785) # 786 "field_module.F90"
(  786) TYPE FIELD_2D_VIEW
(  787)   ! Struct to hold array views, so we can make arrays of them
(  788)   REAL(KIND=JPRB), POINTER :: P(:) => NULL()
(  789) END TYPE FIELD_2D_VIEW
(  790) # 791 "field_module.F90"
(  791) TYPE FIELD_3D_PTR
(  792)   ! Struct to hold references to field objects
(  793)   TYPE(FIELD_3D), POINTER :: PTR => NULL()
(  794) END TYPE FIELD_3D_PTR
(  795) # 796 "field_module.F90"
(  796) TYPE FIELD_3D_VIEW
(  797)   ! Struct to hold array views, so we can make arrays of them
(  798)   REAL(KIND=JPRB), POINTER :: P(:,:) => NULL()
(  799) END TYPE FIELD_3D_VIEW
(  800) # 801 "field_module.F90"
(  801) TYPE FIELD_4D_PTR
(  802)   ! Struct to hold references to field objects
(  803)   TYPE(FIELD_4D), POINTER :: PTR => NULL()
(  804) END TYPE FIELD_4D_PTR
(  805) # 806 "field_module.F90"
(  806) TYPE FIELD_4D_VIEW
(  807)   ! Struct to hold array views, so we can make arrays of them
(  808)   REAL(KIND=JPRB), POINTER :: P(:,:,:) => NULL()
(  809) END TYPE FIELD_4D_VIEW
(  810) # 811 "field_module.F90"
(  811) TYPE FIELD_5D_PTR
(  812)   ! Struct to hold references to field objects
(  813)   TYPE(FIELD_5D), POINTER :: PTR => NULL()
(  814) END TYPE FIELD_5D_PTR






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 101

(  815) # 816 "field_module.F90"
(  816) TYPE FIELD_5D_VIEW
(  817)   ! Struct to hold array views, so we can make arrays of them
(  818)   REAL(KIND=JPRB), POINTER :: P(:,:,:,:) => NULL()
(  819) END TYPE FIELD_5D_VIEW
(  820) # 822 "field_module.F90"
(  822) INTERFACE FIELD_2D
(  823)   MODULE PROCEDURE :: FIELD_2D_WRAP
(  824)   MODULE PROCEDURE :: FIELD_2D_WRAP_PACKED
(  825)   ! MODULE PROCEDURE :: FIELD_2D_EMPTY
(  826)   MODULE PROCEDURE :: FIELD_2D_ALLOCATE
(  827) END INTERFACE
(  828) # 829 "field_module.F90"
(  829) INTERFACE FIELD_3D
(  830)   MODULE PROCEDURE :: FIELD_3D_WRAP
(  831)   MODULE PROCEDURE :: FIELD_3D_WRAP_PACKED
(  832)   ! MODULE PROCEDURE :: FIELD_3D_EMPTY
(  833)   MODULE PROCEDURE :: FIELD_3D_ALLOCATE
(  834) END INTERFACE
(  835) # 836 "field_module.F90"
(  836) INTERFACE FIELD_4D
(  837)   MODULE PROCEDURE :: FIELD_4D_WRAP
(  838)   MODULE PROCEDURE :: FIELD_4D_WRAP_PACKED
(  839)   ! MODULE PROCEDURE :: FIELD_4D_EMPTY
(  840)   MODULE PROCEDURE :: FIELD_4D_ALLOCATE
(  841) END INTERFACE
(  842) # 843 "field_module.F90"
(  843) INTERFACE FIELD_5D
(  844)   MODULE PROCEDURE :: FIELD_5D_WRAP
(  845)   MODULE PROCEDURE :: FIELD_5D_WRAP_PACKED
(  846)   ! MODULE PROCEDURE :: FIELD_5D_EMPTY
(  847)   MODULE PROCEDURE :: FIELD_5D_ALLOCATE
(  848) END INTERFACE
(  849) # 850 "field_module.F90"
(  850) INTERFACE FIELD_INT2D
(  851)   MODULE PROCEDURE :: FIELD_INT2D_WRAP
(  852)   MODULE PROCEDURE :: FIELD_INT2D_WRAP_PACKED
(  853)   ! MODULE PROCEDURE :: FIELD_INT2D_EMPTY
(  854)   MODULE PROCEDURE :: FIELD_INT2D_ALLOCATE
(  855) END INTERFACE
(  856) # 857 "field_module.F90"
(  857) INTERFACE FIELD_INT3D
(  858)   MODULE PROCEDURE :: FIELD_INT3D_WRAP
(  859)   MODULE PROCEDURE :: FIELD_INT3D_WRAP_PACKED
(  860)   ! MODULE PROCEDURE :: FIELD_INT3D_EMPTY
(  861)   MODULE PROCEDURE :: FIELD_INT3D_ALLOCATE
(  862) END INTERFACE
(  863) # 864 "field_module.F90"
(  864) INTERFACE FIELD_INT4D
(  865)   MODULE PROCEDURE :: FIELD_INT4D_WRAP
(  866)   MODULE PROCEDURE :: FIELD_INT4D_WRAP_PACKED
(  867)   ! MODULE PROCEDURE :: FIELD_INT4D_EMPTY
(  868)   MODULE PROCEDURE :: FIELD_INT4D_ALLOCATE
(  869) END INTERFACE
(  870) # 871 "field_module.F90"
(  871) INTERFACE FIELD_INT5D
(  872)   MODULE PROCEDURE :: FIELD_INT5D_WRAP
(  873)   MODULE PROCEDURE :: FIELD_INT5D_WRAP_PACKED






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 102

(  874)   ! MODULE PROCEDURE :: FIELD_INT5D_EMPTY
(  875)   MODULE PROCEDURE :: FIELD_INT5D_ALLOCATE
(  876) END INTERFACE
(  877) # 878 "field_module.F90"
(  878) INTERFACE FIELD_LOG2D
(  879)   MODULE PROCEDURE :: FIELD_LOG2D_WRAP
(  880)   MODULE PROCEDURE :: FIELD_LOG2D_WRAP_PACKED
(  881)   ! MODULE PROCEDURE :: FIELD_LOG2D_EMPTY
(  882)   MODULE PROCEDURE :: FIELD_LOG2D_ALLOCATE
(  883) END INTERFACE
(  884) # 885 "field_module.F90"
(  885) INTERFACE FIELD_LOG3D
(  886)   MODULE PROCEDURE :: FIELD_LOG3D_WRAP
(  887)   MODULE PROCEDURE :: FIELD_LOG3D_WRAP_PACKED
(  888)   ! MODULE PROCEDURE :: FIELD_LOG3D_EMPTY
(  889)   MODULE PROCEDURE :: FIELD_LOG3D_ALLOCATE
(  890) END INTERFACE
(  891) # 892 "field_module.F90"
(  892) INTERFACE FIELD_LOG4D
(  893)   MODULE PROCEDURE :: FIELD_LOG4D_WRAP
(  894)   MODULE PROCEDURE :: FIELD_LOG4D_WRAP_PACKED
(  895)   ! MODULE PROCEDURE :: FIELD_LOG4D_EMPTY
(  896)   MODULE PROCEDURE :: FIELD_LOG4D_ALLOCATE
(  897) END INTERFACE
(  898) # 899 "field_module.F90"
(  899) INTERFACE FIELD_LOG5D
(  900)   MODULE PROCEDURE :: FIELD_LOG5D_WRAP
(  901)   MODULE PROCEDURE :: FIELD_LOG5D_WRAP_PACKED
(  902)   ! MODULE PROCEDURE :: FIELD_LOG5D_EMPTY
(  903)   MODULE PROCEDURE :: FIELD_LOG5D_ALLOCATE
(  904) END INTERFACE
(  905) # 907 "field_module.F90"
(  907) INTERFACE ALLOCATE_FIELD
(  908)   MODULE PROCEDURE :: ALLOCATE_FIELD_2D
(  909)   MODULE PROCEDURE :: ALLOCATE_FIELD_3D
(  910)   MODULE PROCEDURE :: ALLOCATE_FIELD_4D
(  911)   MODULE PROCEDURE :: ALLOCATE_FIELD_5D
(  912)   MODULE PROCEDURE :: ALLOCATE_FIELD_INT2D
(  913)   MODULE PROCEDURE :: ALLOCATE_FIELD_INT3D
(  914)   MODULE PROCEDURE :: ALLOCATE_FIELD_INT4D
(  915)   MODULE PROCEDURE :: ALLOCATE_FIELD_INT5D
(  916)   MODULE PROCEDURE :: ALLOCATE_FIELD_LOG2D
(  917)   MODULE PROCEDURE :: ALLOCATE_FIELD_LOG3D
(  918)   MODULE PROCEDURE :: ALLOCATE_FIELD_LOG4D
(  919)   MODULE PROCEDURE :: ALLOCATE_FIELD_LOG5D
(  920) END INTERFACE
(  921) # 923 "field_module.F90"
(  923) INTERFACE FILL_BUFFER
(  924)   MODULE PROCEDURE :: FILL_BUFFER_2D, FILL_BUFFER_3D
(  925)   MODULE PROCEDURE :: FILL_BUFFER_4D, FILL_BUFFER_5D
(  926)   MODULE PROCEDURE :: FILL_BUFFER_INT2D, FILL_BUFFER_INT3D
(  927)   MODULE PROCEDURE :: FILL_BUFFER_INT4D, FILL_BUFFER_INT5D
(  928)   MODULE PROCEDURE :: FILL_BUFFER_LOG2D, FILL_BUFFER_LOG3D
(  929)   MODULE PROCEDURE :: FILL_BUFFER_LOG4D, FILL_BUFFER_LOG5D
(  930) END INTERFACE FILL_BUFFER
(  931) # 933 "field_module.F90"
(  933) INTERFACE FIELD_CREATE_DEVICE
(  934)   MODULE PROCEDURE :: FIELD_2D_CREATE_DEVICE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 103

(  935)   MODULE PROCEDURE :: FIELD_3D_CREATE_DEVICE
(  936)   MODULE PROCEDURE :: FIELD_4D_CREATE_DEVICE
(  937)   MODULE PROCEDURE :: FIELD_5D_CREATE_DEVICE
(  938)   MODULE PROCEDURE :: FIELD_INT2D_CREATE_DEVICE
(  939)   MODULE PROCEDURE :: FIELD_INT3D_CREATE_DEVICE
(  940)   MODULE PROCEDURE :: FIELD_INT4D_CREATE_DEVICE
(  941)   MODULE PROCEDURE :: FIELD_INT5D_CREATE_DEVICE
(  942)   MODULE PROCEDURE :: FIELD_LOG2D_CREATE_DEVICE
(  943)   MODULE PROCEDURE :: FIELD_LOG3D_CREATE_DEVICE
(  944)   MODULE PROCEDURE :: FIELD_LOG4D_CREATE_DEVICE
(  945)   MODULE PROCEDURE :: FIELD_LOG5D_CREATE_DEVICE
(  946) END INTERFACE FIELD_CREATE_DEVICE
(  947) # 948 "field_module.F90"
(  948) INTERFACE FIELD_UPDATE_DEVICE
(  949)   MODULE PROCEDURE :: FIELD_2D_UPDATE_DEVICE
(  950)   MODULE PROCEDURE :: FIELD_3D_UPDATE_DEVICE
(  951)   MODULE PROCEDURE :: FIELD_4D_UPDATE_DEVICE
(  952)   MODULE PROCEDURE :: FIELD_5D_UPDATE_DEVICE
(  953)   MODULE PROCEDURE :: FIELD_INT2D_UPDATE_DEVICE
(  954)   MODULE PROCEDURE :: FIELD_INT3D_UPDATE_DEVICE
(  955)   MODULE PROCEDURE :: FIELD_INT4D_UPDATE_DEVICE
(  956)   MODULE PROCEDURE :: FIELD_INT5D_UPDATE_DEVICE
(  957)   MODULE PROCEDURE :: FIELD_LOG2D_UPDATE_DEVICE
(  958)   MODULE PROCEDURE :: FIELD_LOG3D_UPDATE_DEVICE
(  959)   MODULE PROCEDURE :: FIELD_LOG4D_UPDATE_DEVICE
(  960)   MODULE PROCEDURE :: FIELD_LOG5D_UPDATE_DEVICE
(  961) END INTERFACE FIELD_UPDATE_DEVICE
(  962) # 963 "field_module.F90"
(  963) INTERFACE FIELD_UPDATE_HOST
(  964)   MODULE PROCEDURE :: FIELD_2D_UPDATE_HOST
(  965)   MODULE PROCEDURE :: FIELD_3D_UPDATE_HOST
(  966)   MODULE PROCEDURE :: FIELD_4D_UPDATE_HOST
(  967)   MODULE PROCEDURE :: FIELD_5D_UPDATE_HOST
(  968)   MODULE PROCEDURE :: FIELD_INT2D_UPDATE_HOST
(  969)   MODULE PROCEDURE :: FIELD_INT3D_UPDATE_HOST
(  970)   MODULE PROCEDURE :: FIELD_INT4D_UPDATE_HOST
(  971)   MODULE PROCEDURE :: FIELD_INT5D_UPDATE_HOST
(  972)   MODULE PROCEDURE :: FIELD_LOG2D_UPDATE_HOST
(  973)   MODULE PROCEDURE :: FIELD_LOG3D_UPDATE_HOST
(  974)   MODULE PROCEDURE :: FIELD_LOG4D_UPDATE_HOST
(  975)   MODULE PROCEDURE :: FIELD_LOG5D_UPDATE_HOST
(  976) END INTERFACE FIELD_UPDATE_HOST
(  977) # 978 "field_module.F90"
(  978) INTERFACE FIELD_DELETE_DEVICE
(  979)   MODULE PROCEDURE :: FIELD_2D_DELETE_DEVICE
(  980)   MODULE PROCEDURE :: FIELD_3D_DELETE_DEVICE
(  981)   MODULE PROCEDURE :: FIELD_4D_DELETE_DEVICE
(  982)   MODULE PROCEDURE :: FIELD_5D_DELETE_DEVICE
(  983)   MODULE PROCEDURE :: FIELD_INT2D_DELETE_DEVICE
(  984)   MODULE PROCEDURE :: FIELD_INT3D_DELETE_DEVICE
(  985)   MODULE PROCEDURE :: FIELD_INT4D_DELETE_DEVICE
(  986)   MODULE PROCEDURE :: FIELD_INT5D_DELETE_DEVICE
(  987)   MODULE PROCEDURE :: FIELD_LOG2D_DELETE_DEVICE
(  988)   MODULE PROCEDURE :: FIELD_LOG3D_DELETE_DEVICE
(  989)   MODULE PROCEDURE :: FIELD_LOG4D_DELETE_DEVICE
(  990)   MODULE PROCEDURE :: FIELD_LOG5D_DELETE_DEVICE
(  991) END INTERFACE FIELD_DELETE_DEVICE
(  992) # 993 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 104

(  993) INTERFACE GET_DEVICE_DATA
(  994)   MODULE PROCEDURE :: FIELD_2D_GET_DEVICE_DATA
(  995)   MODULE PROCEDURE :: FIELD_3D_GET_DEVICE_DATA
(  996)   MODULE PROCEDURE :: FIELD_4D_GET_DEVICE_DATA
(  997)   MODULE PROCEDURE :: FIELD_5D_GET_DEVICE_DATA
(  998)   MODULE PROCEDURE :: FIELD_INT2D_GET_DEVICE_DATA
(  999)   MODULE PROCEDURE :: FIELD_INT3D_GET_DEVICE_DATA
( 1000)   MODULE PROCEDURE :: FIELD_INT4D_GET_DEVICE_DATA
( 1001)   MODULE PROCEDURE :: FIELD_INT5D_GET_DEVICE_DATA
( 1002)   MODULE PROCEDURE :: FIELD_LOG2D_GET_DEVICE_DATA
( 1003)   MODULE PROCEDURE :: FIELD_LOG3D_GET_DEVICE_DATA
( 1004)   MODULE PROCEDURE :: FIELD_LOG4D_GET_DEVICE_DATA
( 1005)   MODULE PROCEDURE :: FIELD_LOG5D_GET_DEVICE_DATA
( 1006) END INTERFACE GET_DEVICE_DATA
( 1007) # 1009 "field_module.F90"
( 1009) CONTAINS
( 1010) # 1011 "field_module.F90"
( 1011)   SUBROUTINE FILL_BUFFER_2D(BUFFER, INDEX)
( 1012)     ! Utility routine to fill data buffers (views)
( 1013)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:)
( 1014)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1015)     INTEGER(KIND=JPIM) :: IDX
( 1016) # 1017 "field_module.F90"
( 1017)     IDX = INDEX+1
( 1018)     BUFFER(IDX:) = BUFFER(INDEX)
( 1019)   END SUBROUTINE FILL_BUFFER_2D
( 1020) # 1021 "field_module.F90"
( 1021)   SUBROUTINE FILL_BUFFER_3D(BUFFER, INDEX)
( 1022)     ! Utility routine to fill data buffers (views)
( 1023)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:,:)
( 1024)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1025)     INTEGER(KIND=JPIM) :: I, IDX
( 1026) # 1027 "field_module.F90"
( 1027)     IDX = INDEX+1
( 1028)     DO I=1, SIZE(BUFFER, 2)
( 1029)       BUFFER(IDX:,I) = BUFFER(INDEX,I)
( 1030)     END DO
( 1031)   END SUBROUTINE FILL_BUFFER_3D
( 1032) # 1033 "field_module.F90"
( 1033)   SUBROUTINE FILL_BUFFER_4D(BUFFER, INDEX)
( 1034)     ! Utility routine to fill data buffers (views)
( 1035)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:,:,:)
( 1036)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1037)     INTEGER(KIND=JPIM) :: I, J, IDX
( 1038) # 1039 "field_module.F90"
( 1039)     IDX = INDEX+1
( 1040)     DO I=1, SIZE(BUFFER, 2)
( 1041)       DO J=1, SIZE(BUFFER, 3)
( 1042)         BUFFER(IDX:,I,J) = BUFFER(INDEX,I,J)
( 1043)       END DO
( 1044)     END DO
( 1045)   END SUBROUTINE FILL_BUFFER_4D
( 1046) # 1047 "field_module.F90"
( 1047)   SUBROUTINE FILL_BUFFER_5D(BUFFER, INDEX)
( 1048)     ! Utility routine to fill data buffers (views)
( 1049)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: BUFFER(:,:,:,:)
( 1050)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1051)     INTEGER(KIND=JPIM) :: I, J, K, IDX






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 105

( 1052) # 1053 "field_module.F90"
( 1053)     IDX = INDEX+1
( 1054)     DO I=1, SIZE(BUFFER, 2)
( 1055)       DO J=1, SIZE(BUFFER, 3)
( 1056)         DO K=1, SIZE(BUFFER, 4)
( 1057)           BUFFER(IDX:,I,J,K) = BUFFER(INDEX,I,J,K)
( 1058)         END DO
( 1059)       END DO
( 1060)     END DO
( 1061)   END SUBROUTINE FILL_BUFFER_5D
( 1062) # 1063 "field_module.F90"
( 1063)   SUBROUTINE FILL_BUFFER_INT2D(BUFFER, INDEX)
( 1064)     ! Utility routine to fill data buffers (views)
( 1065)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: BUFFER(:)
( 1066)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1067)     INTEGER(KIND=JPIM) :: IDX
( 1068) # 1069 "field_module.F90"
( 1069)     IDX = INDEX+1
( 1070)     BUFFER(IDX:) = BUFFER(INDEX)
( 1071)   END SUBROUTINE FILL_BUFFER_INT2D
( 1072) # 1073 "field_module.F90"
( 1073)   SUBROUTINE FILL_BUFFER_INT3D(BUFFER, INDEX)
( 1074)     ! Utility routine to fill data buffers (views)
( 1075)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: BUFFER(:,:)
( 1076)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1077)     INTEGER(KIND=JPIM) :: I, IDX
( 1078) # 1079 "field_module.F90"
( 1079)     IDX = INDEX+1
( 1080)     DO I=1, SIZE(BUFFER, 2)
( 1081)       BUFFER(IDX:,I) = BUFFER(INDEX,I)
( 1082)     END DO
( 1083)   END SUBROUTINE FILL_BUFFER_INT3D
( 1084) # 1085 "field_module.F90"
( 1085)   SUBROUTINE FILL_BUFFER_INT4D(BUFFER, INDEX)
( 1086)     ! Utility routine to fill data buffers (views)
( 1087)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: BUFFER(:,:,:)
( 1088)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1089)     INTEGER(KIND=JPIM) :: I, J, IDX
( 1090) # 1091 "field_module.F90"
( 1091)     IDX = INDEX+1
( 1092)     DO I=1, SIZE(BUFFER, 2)
( 1093)       DO J=1, SIZE(BUFFER, 3)
( 1094)         BUFFER(IDX:,I,J) = BUFFER(INDEX,I,J)
( 1095)       END DO
( 1096)     END DO
( 1097)   END SUBROUTINE FILL_BUFFER_INT4D
( 1098) # 1099 "field_module.F90"
( 1099)   SUBROUTINE FILL_BUFFER_INT5D(BUFFER, INDEX)
( 1100)     ! Utility routine to fill data buffers (views)
( 1101)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: BUFFER(:,:,:,:)
( 1102)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1103)     INTEGER(KIND=JPIM) :: I, J, K, IDX
( 1104) # 1105 "field_module.F90"
( 1105)     IDX = INDEX+1
( 1106)     DO I=1, SIZE(BUFFER, 2)
( 1107)       DO J=1, SIZE(BUFFER, 3)
( 1108)         DO K=1, SIZE(BUFFER, 4)
( 1109)           BUFFER(IDX:,I,J,K) = BUFFER(INDEX,I,J,K)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 106

( 1110)         END DO
( 1111)       END DO
( 1112)     END DO
( 1113)   END SUBROUTINE FILL_BUFFER_INT5D
( 1114) # 1115 "field_module.F90"
( 1115)   SUBROUTINE FILL_BUFFER_LOG2D(BUFFER, INDEX)
( 1116)     ! Utility routine to fill data buffers (views)
( 1117)     LOGICAL, POINTER, INTENT(INOUT) :: BUFFER(:)
( 1118)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1119)     INTEGER(KIND=JPIM) :: IDX
( 1120) # 1121 "field_module.F90"
( 1121)     IDX = INDEX+1
( 1122)     BUFFER(IDX:) = BUFFER(INDEX)
( 1123)   END SUBROUTINE FILL_BUFFER_LOG2D
( 1124) # 1125 "field_module.F90"
( 1125)   SUBROUTINE FILL_BUFFER_LOG3D(BUFFER, INDEX)
( 1126)     ! Utility routine to fill data buffers (views)
( 1127)     LOGICAL, POINTER, INTENT(INOUT) :: BUFFER(:,:)
( 1128)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1129)     INTEGER(KIND=JPIM) :: I, IDX
( 1130) # 1131 "field_module.F90"
( 1131)     IDX = INDEX+1
( 1132)     DO I=1, SIZE(BUFFER, 2)
( 1133)       BUFFER(IDX:,I) = BUFFER(INDEX,I)
( 1134)     END DO
( 1135)   END SUBROUTINE FILL_BUFFER_LOG3D
( 1136) # 1137 "field_module.F90"
( 1137)   SUBROUTINE FILL_BUFFER_LOG4D(BUFFER, INDEX)
( 1138)     ! Utility routine to fill data buffers (views)
( 1139)     LOGICAL, POINTER, INTENT(INOUT) :: BUFFER(:,:,:)
( 1140)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1141)     INTEGER(KIND=JPIM) :: I, J, IDX
( 1142) # 1143 "field_module.F90"
( 1143)     IDX = INDEX+1
( 1144)     DO I=1, SIZE(BUFFER, 2)
( 1145)       DO J=1, SIZE(BUFFER, 3)
( 1146)         BUFFER(IDX:,I,J) = BUFFER(INDEX,I,J)
( 1147)       END DO
( 1148)     END DO
( 1149)   END SUBROUTINE FILL_BUFFER_LOG4D
( 1150) # 1151 "field_module.F90"
( 1151)   SUBROUTINE FILL_BUFFER_LOG5D(BUFFER, INDEX)
( 1152)     ! Utility routine to fill data buffers (views)
( 1153)     LOGICAL, POINTER, INTENT(INOUT) :: BUFFER(:,:,:,:)
( 1154)     INTEGER(KIND=JPIM), INTENT(IN) :: INDEX
( 1155)     INTEGER(KIND=JPIM) :: I, J, K, IDX
( 1156) # 1157 "field_module.F90"
( 1157)     IDX = INDEX+1
( 1158)     DO I=1, SIZE(BUFFER, 2)
( 1159)       DO J=1, SIZE(BUFFER, 3)
( 1160)         DO K=1, SIZE(BUFFER, 4)
( 1161)           BUFFER(IDX:,I,J,K) = BUFFER(INDEX,I,J,K)
( 1162)         END DO
( 1163)       END DO
( 1164)     END DO
( 1165)   END SUBROUTINE FILL_BUFFER_LOG5D
( 1166) # 1168 "field_module.F90"
( 1168)   FUNCTION FIELD_2D_EMPTY(SHAPE) RESULT(SELF)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 107

( 1169)     ! Create FIELD object by wrapping existing data
( 1170)     !
( 1171)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1172)     ! will be allocated under %VIEW and used by all threads in a
( 1173)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1174)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1175)     TYPE(FIELD_2D) :: SELF
( 1176)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(1)
( 1177) # 1178 "field_module.F90"
( 1178)     SELF%PTR => NULL()
( 1179)     IF (PRESENT(SHAPE)) THEN
( 1180)       ALLOCATE(SELF%VIEW(SHAPE(1)))
( 1181)     END IF
( 1182)     SELF%ACTIVE = .FALSE.
( 1183)     SELF%THREAD_BUFFER = .FALSE.
( 1184)     SELF%OWNED = .FALSE.
( 1185)     SELF%NBLOCKS = 0
( 1186)     SELF%BASE_PTR => NULL()
( 1187)     SELF%FIDX = -1
( 1188)   END FUNCTION FIELD_2D_EMPTY
( 1189) # 1190 "field_module.F90"
( 1190)   FUNCTION FIELD_3D_EMPTY(SHAPE) RESULT(SELF)
( 1191)     ! Create FIELD object by wrapping existing data
( 1192)     !
( 1193)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1194)     ! will be allocated under %VIEW and used by all threads in a
( 1195)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1196)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1197)     TYPE(FIELD_3D) :: SELF
( 1198)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(2)
( 1199) # 1200 "field_module.F90"
( 1200)     SELF%PTR => NULL()
( 1201)     IF (PRESENT(SHAPE)) THEN
( 1202)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2)))
( 1203)     END IF
( 1204)     SELF%ACTIVE = .FALSE.
( 1205)     SELF%THREAD_BUFFER = .FALSE.
( 1206)     SELF%OWNED = .FALSE.
( 1207)     SELF%NBLOCKS = 0
( 1208)     SELF%BASE_PTR => NULL()
( 1209)     SELF%FIDX = -1
( 1210)   END FUNCTION FIELD_3D_EMPTY
( 1211) # 1212 "field_module.F90"
( 1212)   FUNCTION FIELD_4D_EMPTY(SHAPE) RESULT(SELF)
( 1213)     ! Create FIELD object by wrapping existing data
( 1214)     !
( 1215)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1216)     ! will be allocated under %VIEW and used by all threads in a
( 1217)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1218)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1219)     TYPE(FIELD_4D) :: SELF
( 1220)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(3)
( 1221) # 1222 "field_module.F90"
( 1222)     SELF%PTR => NULL()
( 1223)     IF (PRESENT(SHAPE)) THEN
( 1224)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3)))
( 1225)     END IF
( 1226)     SELF%ACTIVE = .FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 108

( 1227)     SELF%THREAD_BUFFER = .FALSE.
( 1228)     SELF%OWNED = .FALSE.
( 1229)     SELF%NBLOCKS = 0
( 1230)     SELF%BASE_PTR => NULL()
( 1231)     SELF%FIDX = -1
( 1232)   END FUNCTION FIELD_4D_EMPTY
( 1233) # 1234 "field_module.F90"
( 1234)   FUNCTION FIELD_5D_EMPTY(SHAPE) RESULT(SELF)
( 1235)     ! Create FIELD object by wrapping existing data
( 1236)     !
( 1237)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1238)     ! will be allocated under %VIEW and used by all threads in a
( 1239)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1240)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1241)     TYPE(FIELD_5D) :: SELF
( 1242)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(4)
( 1243) # 1244 "field_module.F90"
( 1244)     SELF%PTR => NULL()
( 1245)     IF (PRESENT(SHAPE)) THEN
( 1246)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4)))
( 1247)     END IF
( 1248)     SELF%ACTIVE = .FALSE.
( 1249)     SELF%THREAD_BUFFER = .FALSE.
( 1250)     SELF%OWNED = .FALSE.
( 1251)     SELF%NBLOCKS = 0
( 1252)     SELF%BASE_PTR => NULL()
( 1253)     SELF%FIDX = -1
( 1254)   END FUNCTION FIELD_5D_EMPTY
( 1255) # 1256 "field_module.F90"
( 1256)   FUNCTION FIELD_INT2D_EMPTY(SHAPE) RESULT(SELF)
( 1257)     ! Create FIELD object by wrapping existing data
( 1258)     !
( 1259)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1260)     ! will be allocated under %VIEW and used by all threads in a
( 1261)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1262)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1263)     TYPE(FIELD_INT2D) :: SELF
( 1264)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(1)
( 1265) # 1266 "field_module.F90"
( 1266)     SELF%PTR => NULL()
( 1267)     IF (PRESENT(SHAPE)) THEN
( 1268)       ALLOCATE(SELF%VIEW(SHAPE(1)))
( 1269)     END IF
( 1270)     SELF%ACTIVE = .FALSE.
( 1271)     SELF%THREAD_BUFFER = .FALSE.
( 1272)     SELF%OWNED = .FALSE.
( 1273)     SELF%NBLOCKS = 0
( 1274)     SELF%BASE_PTR => NULL()
( 1275)     SELF%FIDX = -1
( 1276)   END FUNCTION FIELD_INT2D_EMPTY
( 1277) # 1278 "field_module.F90"
( 1278)   FUNCTION FIELD_INT3D_EMPTY(SHAPE) RESULT(SELF)
( 1279)     ! Create FIELD object by wrapping existing data
( 1280)     !
( 1281)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1282)     ! will be allocated under %VIEW and used by all threads in a
( 1283)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1284)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 109

( 1285)     TYPE(FIELD_INT3D) :: SELF
( 1286)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(2)
( 1287) # 1288 "field_module.F90"
( 1288)     SELF%PTR => NULL()
( 1289)     IF (PRESENT(SHAPE)) THEN
( 1290)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2)))
( 1291)     END IF
( 1292)     SELF%ACTIVE = .FALSE.
( 1293)     SELF%THREAD_BUFFER = .FALSE.
( 1294)     SELF%OWNED = .FALSE.
( 1295)     SELF%NBLOCKS = 0
( 1296)     SELF%BASE_PTR => NULL()
( 1297)     SELF%FIDX = -1
( 1298)   END FUNCTION FIELD_INT3D_EMPTY
( 1299) # 1300 "field_module.F90"
( 1300)   FUNCTION FIELD_INT4D_EMPTY(SHAPE) RESULT(SELF)
( 1301)     ! Create FIELD object by wrapping existing data
( 1302)     !
( 1303)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1304)     ! will be allocated under %VIEW and used by all threads in a
( 1305)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1306)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1307)     TYPE(FIELD_INT4D) :: SELF
( 1308)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(3)
( 1309) # 1310 "field_module.F90"
( 1310)     SELF%PTR => NULL()
( 1311)     IF (PRESENT(SHAPE)) THEN
( 1312)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3)))
( 1313)     END IF
( 1314)     SELF%ACTIVE = .FALSE.
( 1315)     SELF%THREAD_BUFFER = .FALSE.
( 1316)     SELF%OWNED = .FALSE.
( 1317)     SELF%NBLOCKS = 0
( 1318)     SELF%BASE_PTR => NULL()
( 1319)     SELF%FIDX = -1
( 1320)   END FUNCTION FIELD_INT4D_EMPTY
( 1321) # 1322 "field_module.F90"
( 1322)   FUNCTION FIELD_INT5D_EMPTY(SHAPE) RESULT(SELF)
( 1323)     ! Create FIELD object by wrapping existing data
( 1324)     !
( 1325)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1326)     ! will be allocated under %VIEW and used by all threads in a
( 1327)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1328)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1329)     TYPE(FIELD_INT5D) :: SELF
( 1330)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(4)
( 1331) # 1332 "field_module.F90"
( 1332)     SELF%PTR => NULL()
( 1333)     IF (PRESENT(SHAPE)) THEN
( 1334)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4)))
( 1335)     END IF
( 1336)     SELF%ACTIVE = .FALSE.
( 1337)     SELF%THREAD_BUFFER = .FALSE.
( 1338)     SELF%OWNED = .FALSE.
( 1339)     SELF%NBLOCKS = 0
( 1340)     SELF%BASE_PTR => NULL()
( 1341)     SELF%FIDX = -1
( 1342)   END FUNCTION FIELD_INT5D_EMPTY






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 110

( 1343) # 1344 "field_module.F90"
( 1344)   FUNCTION FIELD_LOG2D_EMPTY(SHAPE) RESULT(SELF)
( 1345)     ! Create FIELD object by wrapping existing data
( 1346)     !
( 1347)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1348)     ! will be allocated under %VIEW and used by all threads in a
( 1349)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1350)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1351)     TYPE(FIELD_LOG2D) :: SELF
( 1352)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(1)
( 1353) # 1354 "field_module.F90"
( 1354)     SELF%PTR => NULL()
( 1355)     IF (PRESENT(SHAPE)) THEN
( 1356)       ALLOCATE(SELF%VIEW(SHAPE(1)))
( 1357)     END IF
( 1358)     SELF%ACTIVE = .FALSE.
( 1359)     SELF%THREAD_BUFFER = .FALSE.
( 1360)     SELF%OWNED = .FALSE.
( 1361)     SELF%NBLOCKS = 0
( 1362)     SELF%BASE_PTR => NULL()
( 1363)     SELF%FIDX = -1
( 1364)   END FUNCTION FIELD_LOG2D_EMPTY
( 1365) # 1366 "field_module.F90"
( 1366)   FUNCTION FIELD_LOG3D_EMPTY(SHAPE) RESULT(SELF)
( 1367)     ! Create FIELD object by wrapping existing data
( 1368)     !
( 1369)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1370)     ! will be allocated under %VIEW and used by all threads in a
( 1371)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1372)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1373)     TYPE(FIELD_LOG3D) :: SELF
( 1374)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(2)
( 1375) # 1376 "field_module.F90"
( 1376)     SELF%PTR => NULL()
( 1377)     IF (PRESENT(SHAPE)) THEN
( 1378)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2)))
( 1379)     END IF
( 1380)     SELF%ACTIVE = .FALSE.
( 1381)     SELF%THREAD_BUFFER = .FALSE.
( 1382)     SELF%OWNED = .FALSE.
( 1383)     SELF%NBLOCKS = 0
( 1384)     SELF%BASE_PTR => NULL()
( 1385)     SELF%FIDX = -1
( 1386)   END FUNCTION FIELD_LOG3D_EMPTY
( 1387) # 1388 "field_module.F90"
( 1388)   FUNCTION FIELD_LOG4D_EMPTY(SHAPE) RESULT(SELF)
( 1389)     ! Create FIELD object by wrapping existing data
( 1390)     !
( 1391)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1392)     ! will be allocated under %VIEW and used by all threads in a
( 1393)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1394)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1395)     TYPE(FIELD_LOG4D) :: SELF
( 1396)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(3)
( 1397) # 1398 "field_module.F90"
( 1398)     SELF%PTR => NULL()
( 1399)     IF (PRESENT(SHAPE)) THEN
( 1400)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3)))






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 111

( 1401)     END IF
( 1402)     SELF%ACTIVE = .FALSE.
( 1403)     SELF%THREAD_BUFFER = .FALSE.
( 1404)     SELF%OWNED = .FALSE.
( 1405)     SELF%NBLOCKS = 0
( 1406)     SELF%BASE_PTR => NULL()
( 1407)     SELF%FIDX = -1
( 1408)   END FUNCTION FIELD_LOG4D_EMPTY
( 1409) # 1410 "field_module.F90"
( 1410)   FUNCTION FIELD_LOG5D_EMPTY(SHAPE) RESULT(SELF)
( 1411)     ! Create FIELD object by wrapping existing data
( 1412)     !
( 1413)     ! If a SHAPE is provided, a single empty buffer block-sized buffer
( 1414)     ! will be allocated under %VIEW and used by all threads in a
( 1415)     ! thread-parallel region to avoid segfault when dereferencing NULL
( 1416)     ! pointers. Otherwise %DATA and %VIEW will always be unassociated.
( 1417)     TYPE(FIELD_LOG5D) :: SELF
( 1418)     INTEGER(KIND=JPIM), OPTIONAL, INTENT(IN) :: SHAPE(4)
( 1419) # 1420 "field_module.F90"
( 1420)     SELF%PTR => NULL()
( 1421)     IF (PRESENT(SHAPE)) THEN
( 1422)       ALLOCATE(SELF%VIEW(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4)))
( 1423)     END IF
( 1424)     SELF%ACTIVE = .FALSE.
( 1425)     SELF%THREAD_BUFFER = .FALSE.
( 1426)     SELF%OWNED = .FALSE.
( 1427)     SELF%NBLOCKS = 0
( 1428)     SELF%BASE_PTR => NULL()
( 1429)     SELF%FIDX = -1
( 1430)   END FUNCTION FIELD_LOG5D_EMPTY
( 1431) # 1433 "field_module.F90"
( 1433)   FUNCTION FIELD_2D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1434)     ! Create FIELD object by wrapping existing data
( 1435)     TYPE(FIELD_2D), TARGET :: SELF
( 1436)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:)
( 1437)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1438)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1439)     LOGICAL :: LLPERSISTENT
( 1440) # 1441 "field_module.F90"
( 1441)     LLPERSISTENT = .TRUE.
( 1442)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1443)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1444) # 1445 "field_module.F90"
( 1445)     SELF%PTR => DATA
( 1446)     SELF%ACTIVE = .TRUE.
( 1447)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1448)     SELF%OWNED = .FALSE.
( 1449)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1450)     SELF%BASE_PTR => NULL()
( 1451)     SELF%FIDX = -1
( 1452) # 1453 "field_module.F90"
( 1453)     SELF%ISTATUS = NHSTFRESH
( 1454) # 1455 "field_module.F90"
( 1455)     IF (.NOT. LLPERSISTENT) THEN
( 1456)       IF (OML_MAX_THREADS() /= SIZE (DATA, 2)) THEN
( 1457)         CALL ABOR1 ('FIELD_2D_WRAP: DIMENSION MISMATCH')
( 1458)       ENDIF
( 1459)     ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 112

( 1460) # 1461 "field_module.F90"
( 1461)   END FUNCTION FIELD_2D_WRAP
( 1462) # 1463 "field_module.F90"
( 1463)   FUNCTION FIELD_3D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1464)     ! Create FIELD object by wrapping existing data
( 1465)     TYPE(FIELD_3D), TARGET :: SELF
( 1466)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
( 1467)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1468)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1469)     LOGICAL :: LLPERSISTENT
( 1470) # 1471 "field_module.F90"
( 1471)     LLPERSISTENT = .TRUE.
( 1472)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1473)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1474) # 1475 "field_module.F90"
( 1475)     SELF%PTR => DATA
( 1476)     SELF%ACTIVE = .TRUE.
( 1477)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1478)     SELF%OWNED = .FALSE.
( 1479)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1480)     SELF%BASE_PTR => NULL()
( 1481)     SELF%FIDX = -1
( 1482) # 1483 "field_module.F90"
( 1483)     SELF%ISTATUS = NHSTFRESH
( 1484) # 1485 "field_module.F90"
( 1485)     IF (.NOT. LLPERSISTENT) THEN
( 1486)       IF (OML_MAX_THREADS() /= SIZE (DATA, 3)) THEN
( 1487)         CALL ABOR1 ('FIELD_3D_WRAP: DIMENSION MISMATCH')
( 1488)       ENDIF
( 1489)     ENDIF
( 1490) # 1491 "field_module.F90"
( 1491)   END FUNCTION FIELD_3D_WRAP
( 1492) # 1493 "field_module.F90"
( 1493)   FUNCTION FIELD_4D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1494)     ! Create FIELD object by wrapping existing data
( 1495)     TYPE(FIELD_4D), TARGET :: SELF
( 1496)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1497)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1498)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1499)     LOGICAL :: LLPERSISTENT
( 1500) # 1501 "field_module.F90"
( 1501)     LLPERSISTENT = .TRUE.
( 1502)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1503)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1504) # 1505 "field_module.F90"
( 1505)     SELF%PTR => DATA
( 1506)     SELF%ACTIVE = .TRUE.
( 1507)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1508)     SELF%OWNED = .FALSE.
( 1509)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1510)     SELF%BASE_PTR => NULL()
( 1511)     SELF%FIDX = -1
( 1512) # 1513 "field_module.F90"
( 1513)     SELF%ISTATUS = NHSTFRESH
( 1514) # 1515 "field_module.F90"
( 1515)     IF (.NOT. LLPERSISTENT) THEN
( 1516)       IF (OML_MAX_THREADS() /= SIZE (DATA, 4)) THEN
( 1517)         CALL ABOR1 ('FIELD_4D_WRAP: DIMENSION MISMATCH')






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 113

( 1518)       ENDIF
( 1519)     ENDIF
( 1520) # 1521 "field_module.F90"
( 1521)   END FUNCTION FIELD_4D_WRAP
( 1522) # 1523 "field_module.F90"
( 1523)   FUNCTION FIELD_5D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1524)     ! Create FIELD object by wrapping existing data
( 1525)     TYPE(FIELD_5D), TARGET :: SELF
( 1526)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1527)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1528)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1529)     LOGICAL :: LLPERSISTENT
( 1530) # 1531 "field_module.F90"
( 1531)     LLPERSISTENT = .TRUE.
( 1532)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1533)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1534) # 1535 "field_module.F90"
( 1535)     SELF%PTR => DATA
( 1536)     SELF%ACTIVE = .TRUE.
( 1537)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1538)     SELF%OWNED = .FALSE.
( 1539)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1540)     SELF%BASE_PTR => NULL()
( 1541)     SELF%FIDX = -1
( 1542) # 1543 "field_module.F90"
( 1543)     SELF%ISTATUS = NHSTFRESH
( 1544) # 1545 "field_module.F90"
( 1545)     IF (.NOT. LLPERSISTENT) THEN
( 1546)       IF (OML_MAX_THREADS() /= SIZE (DATA, 5)) THEN
( 1547)         CALL ABOR1 ('FIELD_5D_WRAP: DIMENSION MISMATCH')
( 1548)       ENDIF
( 1549)     ENDIF
( 1550) # 1551 "field_module.F90"
( 1551)   END FUNCTION FIELD_5D_WRAP
( 1552) # 1553 "field_module.F90"
( 1553)   FUNCTION FIELD_INT2D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1554)     ! Create FIELD object by wrapping existing data
( 1555)     TYPE(FIELD_INT2D), TARGET :: SELF
( 1556)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:)
( 1557)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1558)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1559)     LOGICAL :: LLPERSISTENT
( 1560) # 1561 "field_module.F90"
( 1561)     LLPERSISTENT = .TRUE.
( 1562)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1563)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1564) # 1565 "field_module.F90"
( 1565)     SELF%PTR => DATA
( 1566)     SELF%ACTIVE = .TRUE.
( 1567)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1568)     SELF%OWNED = .FALSE.
( 1569)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1570)     SELF%BASE_PTR => NULL()
( 1571)     SELF%FIDX = -1
( 1572) # 1573 "field_module.F90"
( 1573)     SELF%ISTATUS = NHSTFRESH
( 1574) # 1575 "field_module.F90"
( 1575)     IF (.NOT. LLPERSISTENT) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 114

( 1576)       IF (OML_MAX_THREADS() /= SIZE (DATA, 2)) THEN
( 1577)         CALL ABOR1 ('FIELD_INT2D_WRAP: DIMENSION MISMATCH')
( 1578)       ENDIF
( 1579)     ENDIF
( 1580) # 1581 "field_module.F90"
( 1581)   END FUNCTION FIELD_INT2D_WRAP
( 1582) # 1583 "field_module.F90"
( 1583)   FUNCTION FIELD_INT3D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1584)     ! Create FIELD object by wrapping existing data
( 1585)     TYPE(FIELD_INT3D), TARGET :: SELF
( 1586)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:)
( 1587)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1588)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1589)     LOGICAL :: LLPERSISTENT
( 1590) # 1591 "field_module.F90"
( 1591)     LLPERSISTENT = .TRUE.
( 1592)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1593)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1594) # 1595 "field_module.F90"
( 1595)     SELF%PTR => DATA
( 1596)     SELF%ACTIVE = .TRUE.
( 1597)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1598)     SELF%OWNED = .FALSE.
( 1599)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1600)     SELF%BASE_PTR => NULL()
( 1601)     SELF%FIDX = -1
( 1602) # 1603 "field_module.F90"
( 1603)     SELF%ISTATUS = NHSTFRESH
( 1604) # 1605 "field_module.F90"
( 1605)     IF (.NOT. LLPERSISTENT) THEN
( 1606)       IF (OML_MAX_THREADS() /= SIZE (DATA, 3)) THEN
( 1607)         CALL ABOR1 ('FIELD_INT3D_WRAP: DIMENSION MISMATCH')
( 1608)       ENDIF
( 1609)     ENDIF
( 1610) # 1611 "field_module.F90"
( 1611)   END FUNCTION FIELD_INT3D_WRAP
( 1612) # 1613 "field_module.F90"
( 1613)   FUNCTION FIELD_INT4D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1614)     ! Create FIELD object by wrapping existing data
( 1615)     TYPE(FIELD_INT4D), TARGET :: SELF
( 1616)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1617)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1618)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1619)     LOGICAL :: LLPERSISTENT
( 1620) # 1621 "field_module.F90"
( 1621)     LLPERSISTENT = .TRUE.
( 1622)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1623)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1624) # 1625 "field_module.F90"
( 1625)     SELF%PTR => DATA
( 1626)     SELF%ACTIVE = .TRUE.
( 1627)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1628)     SELF%OWNED = .FALSE.
( 1629)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1630)     SELF%BASE_PTR => NULL()
( 1631)     SELF%FIDX = -1
( 1632) # 1633 "field_module.F90"
( 1633)     SELF%ISTATUS = NHSTFRESH






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 115

( 1634) # 1635 "field_module.F90"
( 1635)     IF (.NOT. LLPERSISTENT) THEN
( 1636)       IF (OML_MAX_THREADS() /= SIZE (DATA, 4)) THEN
( 1637)         CALL ABOR1 ('FIELD_INT4D_WRAP: DIMENSION MISMATCH')
( 1638)       ENDIF
( 1639)     ENDIF
( 1640) # 1641 "field_module.F90"
( 1641)   END FUNCTION FIELD_INT4D_WRAP
( 1642) # 1643 "field_module.F90"
( 1643)   FUNCTION FIELD_INT5D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1644)     ! Create FIELD object by wrapping existing data
( 1645)     TYPE(FIELD_INT5D), TARGET :: SELF
( 1646)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1647)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1648)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1649)     LOGICAL :: LLPERSISTENT
( 1650) # 1651 "field_module.F90"
( 1651)     LLPERSISTENT = .TRUE.
( 1652)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1653)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1654) # 1655 "field_module.F90"
( 1655)     SELF%PTR => DATA
( 1656)     SELF%ACTIVE = .TRUE.
( 1657)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1658)     SELF%OWNED = .FALSE.
( 1659)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1660)     SELF%BASE_PTR => NULL()
( 1661)     SELF%FIDX = -1
( 1662) # 1663 "field_module.F90"
( 1663)     SELF%ISTATUS = NHSTFRESH
( 1664) # 1665 "field_module.F90"
( 1665)     IF (.NOT. LLPERSISTENT) THEN
( 1666)       IF (OML_MAX_THREADS() /= SIZE (DATA, 5)) THEN
( 1667)         CALL ABOR1 ('FIELD_INT5D_WRAP: DIMENSION MISMATCH')
( 1668)       ENDIF
( 1669)     ENDIF
( 1670) # 1671 "field_module.F90"
( 1671)   END FUNCTION FIELD_INT5D_WRAP
( 1672) # 1673 "field_module.F90"
( 1673)   FUNCTION FIELD_LOG2D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1674)     ! Create FIELD object by wrapping existing data
( 1675)     TYPE(FIELD_LOG2D), TARGET :: SELF
( 1676)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:)
( 1677)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1678)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1679)     LOGICAL :: LLPERSISTENT
( 1680) # 1681 "field_module.F90"
( 1681)     LLPERSISTENT = .TRUE.
( 1682)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1683)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1684) # 1685 "field_module.F90"
( 1685)     SELF%PTR => DATA
( 1686)     SELF%ACTIVE = .TRUE.
( 1687)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1688)     SELF%OWNED = .FALSE.
( 1689)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1690)     SELF%BASE_PTR => NULL()
( 1691)     SELF%FIDX = -1






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 116

( 1692) # 1693 "field_module.F90"
( 1693)     SELF%ISTATUS = NHSTFRESH
( 1694) # 1695 "field_module.F90"
( 1695)     IF (.NOT. LLPERSISTENT) THEN
( 1696)       IF (OML_MAX_THREADS() /= SIZE (DATA, 2)) THEN
( 1697)         CALL ABOR1 ('FIELD_LOG2D_WRAP: DIMENSION MISMATCH')
( 1698)       ENDIF
( 1699)     ENDIF
( 1700) # 1701 "field_module.F90"
( 1701)   END FUNCTION FIELD_LOG2D_WRAP
( 1702) # 1703 "field_module.F90"
( 1703)   FUNCTION FIELD_LOG3D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1704)     ! Create FIELD object by wrapping existing data
( 1705)     TYPE(FIELD_LOG3D), TARGET :: SELF
( 1706)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:)
( 1707)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1708)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1709)     LOGICAL :: LLPERSISTENT
( 1710) # 1711 "field_module.F90"
( 1711)     LLPERSISTENT = .TRUE.
( 1712)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1713)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1714) # 1715 "field_module.F90"
( 1715)     SELF%PTR => DATA
( 1716)     SELF%ACTIVE = .TRUE.
( 1717)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1718)     SELF%OWNED = .FALSE.
( 1719)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1720)     SELF%BASE_PTR => NULL()
( 1721)     SELF%FIDX = -1
( 1722) # 1723 "field_module.F90"
( 1723)     SELF%ISTATUS = NHSTFRESH
( 1724) # 1725 "field_module.F90"
( 1725)     IF (.NOT. LLPERSISTENT) THEN
( 1726)       IF (OML_MAX_THREADS() /= SIZE (DATA, 3)) THEN
( 1727)         CALL ABOR1 ('FIELD_LOG3D_WRAP: DIMENSION MISMATCH')
( 1728)       ENDIF
( 1729)     ENDIF
( 1730) # 1731 "field_module.F90"
( 1731)   END FUNCTION FIELD_LOG3D_WRAP
( 1732) # 1733 "field_module.F90"
( 1733)   FUNCTION FIELD_LOG4D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1734)     ! Create FIELD object by wrapping existing data
( 1735)     TYPE(FIELD_LOG4D), TARGET :: SELF
( 1736)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1737)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1738)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1739)     LOGICAL :: LLPERSISTENT
( 1740) # 1741 "field_module.F90"
( 1741)     LLPERSISTENT = .TRUE.
( 1742)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1743)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1744) # 1745 "field_module.F90"
( 1745)     SELF%PTR => DATA
( 1746)     SELF%ACTIVE = .TRUE.
( 1747)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1748)     SELF%OWNED = .FALSE.
( 1749)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 117

( 1750)     SELF%BASE_PTR => NULL()
( 1751)     SELF%FIDX = -1
( 1752) # 1753 "field_module.F90"
( 1753)     SELF%ISTATUS = NHSTFRESH
( 1754) # 1755 "field_module.F90"
( 1755)     IF (.NOT. LLPERSISTENT) THEN
( 1756)       IF (OML_MAX_THREADS() /= SIZE (DATA, 4)) THEN
( 1757)         CALL ABOR1 ('FIELD_LOG4D_WRAP: DIMENSION MISMATCH')
( 1758)       ENDIF
( 1759)     ENDIF
( 1760) # 1761 "field_module.F90"
( 1761)   END FUNCTION FIELD_LOG4D_WRAP
( 1762) # 1763 "field_module.F90"
( 1763)   FUNCTION FIELD_LOG5D_WRAP(DATA, PERSISTENT, LBOUNDS) RESULT(SELF)
( 1764)     ! Create FIELD object by wrapping existing data
( 1765)     TYPE(FIELD_LOG5D), TARGET :: SELF
( 1766)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1767)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 1768)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1769)     LOGICAL :: LLPERSISTENT
( 1770) # 1771 "field_module.F90"
( 1771)     LLPERSISTENT = .TRUE.
( 1772)     IF (PRESENT (PERSISTENT)) LLPERSISTENT = PERSISTENT
( 1773)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1774) # 1775 "field_module.F90"
( 1775)     SELF%PTR => DATA
( 1776)     SELF%ACTIVE = .TRUE.
( 1777)     SELF%THREAD_BUFFER = .NOT. LLPERSISTENT
( 1778)     SELF%OWNED = .FALSE.
( 1779)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1780)     SELF%BASE_PTR => NULL()
( 1781)     SELF%FIDX = -1
( 1782) # 1783 "field_module.F90"
( 1783)     SELF%ISTATUS = NHSTFRESH
( 1784) # 1785 "field_module.F90"
( 1785)     IF (.NOT. LLPERSISTENT) THEN
( 1786)       IF (OML_MAX_THREADS() /= SIZE (DATA, 5)) THEN
( 1787)         CALL ABOR1 ('FIELD_LOG5D_WRAP: DIMENSION MISMATCH')
( 1788)       ENDIF
( 1789)     ENDIF
( 1790) # 1791 "field_module.F90"
( 1791)   END FUNCTION FIELD_LOG5D_WRAP
( 1792) # 1794 "field_module.F90"
( 1794)   FUNCTION FIELD_2D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1795)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1796)     ! contiguous pointer to existing data and an index.
( 1797)     TYPE(FIELD_2D), TARGET :: SELF
( 1798)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:)
( 1799)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1800)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1801) # 1802 "field_module.F90"
( 1802)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1803) # 1804 "field_module.F90"
( 1804)     SELF%PTR => DATA(:,IDX,:)
( 1805)     SELF%ACTIVE = .TRUE.
( 1806)     SELF%THREAD_BUFFER = .FALSE.
( 1807)     SELF%OWNED = .FALSE.
( 1808)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 118

( 1809)     SELF%BASE_PTR => DATA
( 1810)     SELF%FIDX = IDX
( 1811) # 1812 "field_module.F90"
( 1812)     SELF%ISTATUS = NHSTFRESH
( 1813) # 1814 "field_module.F90"
( 1814)   END FUNCTION FIELD_2D_WRAP_PACKED
( 1815) # 1816 "field_module.F90"
( 1816)   FUNCTION FIELD_3D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1817)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1818)     ! contiguous pointer to existing data and an index.
( 1819)     TYPE(FIELD_3D), TARGET :: SELF
( 1820)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1821)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1822)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1823) # 1824 "field_module.F90"
( 1824)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1825) # 1826 "field_module.F90"
( 1826)     SELF%PTR => DATA(:,:,IDX,:)
( 1827)     SELF%ACTIVE = .TRUE.
( 1828)     SELF%THREAD_BUFFER = .FALSE.
( 1829)     SELF%OWNED = .FALSE.
( 1830)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1831)     SELF%BASE_PTR => DATA
( 1832)     SELF%FIDX = IDX
( 1833) # 1834 "field_module.F90"
( 1834)     SELF%ISTATUS = NHSTFRESH
( 1835) # 1836 "field_module.F90"
( 1836)   END FUNCTION FIELD_3D_WRAP_PACKED
( 1837) # 1838 "field_module.F90"
( 1838)   FUNCTION FIELD_4D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1839)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1840)     ! contiguous pointer to existing data and an index.
( 1841)     TYPE(FIELD_4D), TARGET :: SELF
( 1842)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1843)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1844)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1845) # 1846 "field_module.F90"
( 1846)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1847) # 1848 "field_module.F90"
( 1848)     SELF%PTR => DATA(:,:,:,IDX,:)
( 1849)     SELF%ACTIVE = .TRUE.
( 1850)     SELF%THREAD_BUFFER = .FALSE.
( 1851)     SELF%OWNED = .FALSE.
( 1852)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1853)     SELF%BASE_PTR => DATA
( 1854)     SELF%FIDX = IDX
( 1855) # 1856 "field_module.F90"
( 1856)     SELF%ISTATUS = NHSTFRESH
( 1857) # 1858 "field_module.F90"
( 1858)   END FUNCTION FIELD_4D_WRAP_PACKED
( 1859) # 1860 "field_module.F90"
( 1860)   FUNCTION FIELD_5D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1861)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1862)     ! contiguous pointer to existing data and an index.
( 1863)     TYPE(FIELD_5D), TARGET :: SELF
( 1864)     REAL(KIND=JPRB), TARGET, INTENT(IN) :: DATA(:,:,:,:,:,:)
( 1865)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1866)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 119

( 1867) # 1868 "field_module.F90"
( 1868)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1869) # 1870 "field_module.F90"
( 1870)     SELF%PTR => DATA(:,:,:,:,IDX,:)
( 1871)     SELF%ACTIVE = .TRUE.
( 1872)     SELF%THREAD_BUFFER = .FALSE.
( 1873)     SELF%OWNED = .FALSE.
( 1874)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1875)     SELF%BASE_PTR => DATA
( 1876)     SELF%FIDX = IDX
( 1877) # 1878 "field_module.F90"
( 1878)     SELF%ISTATUS = NHSTFRESH
( 1879) # 1880 "field_module.F90"
( 1880)   END FUNCTION FIELD_5D_WRAP_PACKED
( 1881) # 1882 "field_module.F90"
( 1882)   FUNCTION FIELD_INT2D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1883)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1884)     ! contiguous pointer to existing data and an index.
( 1885)     TYPE(FIELD_INT2D), TARGET :: SELF
( 1886)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:)
( 1887)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1888)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1889) # 1890 "field_module.F90"
( 1890)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1891) # 1892 "field_module.F90"
( 1892)     SELF%PTR => DATA(:,IDX,:)
( 1893)     SELF%ACTIVE = .TRUE.
( 1894)     SELF%THREAD_BUFFER = .FALSE.
( 1895)     SELF%OWNED = .FALSE.
( 1896)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1897)     SELF%BASE_PTR => DATA
( 1898)     SELF%FIDX = IDX
( 1899) # 1900 "field_module.F90"
( 1900)     SELF%ISTATUS = NHSTFRESH
( 1901) # 1902 "field_module.F90"
( 1902)   END FUNCTION FIELD_INT2D_WRAP_PACKED
( 1903) # 1904 "field_module.F90"
( 1904)   FUNCTION FIELD_INT3D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1905)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1906)     ! contiguous pointer to existing data and an index.
( 1907)     TYPE(FIELD_INT3D), TARGET :: SELF
( 1908)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1909)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1910)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1911) # 1912 "field_module.F90"
( 1912)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1913) # 1914 "field_module.F90"
( 1914)     SELF%PTR => DATA(:,:,IDX,:)
( 1915)     SELF%ACTIVE = .TRUE.
( 1916)     SELF%THREAD_BUFFER = .FALSE.
( 1917)     SELF%OWNED = .FALSE.
( 1918)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 1919)     SELF%BASE_PTR => DATA
( 1920)     SELF%FIDX = IDX
( 1921) # 1922 "field_module.F90"
( 1922)     SELF%ISTATUS = NHSTFRESH
( 1923) # 1924 "field_module.F90"
( 1924)   END FUNCTION FIELD_INT3D_WRAP_PACKED






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 120

( 1925) # 1926 "field_module.F90"
( 1926)   FUNCTION FIELD_INT4D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1927)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1928)     ! contiguous pointer to existing data and an index.
( 1929)     TYPE(FIELD_INT4D), TARGET :: SELF
( 1930)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 1931)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1932)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 1933) # 1934 "field_module.F90"
( 1934)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1935) # 1936 "field_module.F90"
( 1936)     SELF%PTR => DATA(:,:,:,IDX,:)
( 1937)     SELF%ACTIVE = .TRUE.
( 1938)     SELF%THREAD_BUFFER = .FALSE.
( 1939)     SELF%OWNED = .FALSE.
( 1940)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 1941)     SELF%BASE_PTR => DATA
( 1942)     SELF%FIDX = IDX
( 1943) # 1944 "field_module.F90"
( 1944)     SELF%ISTATUS = NHSTFRESH
( 1945) # 1946 "field_module.F90"
( 1946)   END FUNCTION FIELD_INT4D_WRAP_PACKED
( 1947) # 1948 "field_module.F90"
( 1948)   FUNCTION FIELD_INT5D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1949)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1950)     ! contiguous pointer to existing data and an index.
( 1951)     TYPE(FIELD_INT5D), TARGET :: SELF
( 1952)     INTEGER(KIND=JPIM), TARGET, INTENT(IN) :: DATA(:,:,:,:,:,:)
( 1953)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1954)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 1955) # 1956 "field_module.F90"
( 1956)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1957) # 1958 "field_module.F90"
( 1958)     SELF%PTR => DATA(:,:,:,:,IDX,:)
( 1959)     SELF%ACTIVE = .TRUE.
( 1960)     SELF%THREAD_BUFFER = .FALSE.
( 1961)     SELF%OWNED = .FALSE.
( 1962)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 1963)     SELF%BASE_PTR => DATA
( 1964)     SELF%FIDX = IDX
( 1965) # 1966 "field_module.F90"
( 1966)     SELF%ISTATUS = NHSTFRESH
( 1967) # 1968 "field_module.F90"
( 1968)   END FUNCTION FIELD_INT5D_WRAP_PACKED
( 1969) # 1970 "field_module.F90"
( 1970)   FUNCTION FIELD_LOG2D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1971)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1972)     ! contiguous pointer to existing data and an index.
( 1973)     TYPE(FIELD_LOG2D), TARGET :: SELF
( 1974)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:)
( 1975)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1976)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 1977) # 1978 "field_module.F90"
( 1978)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 1979) # 1980 "field_module.F90"
( 1980)     SELF%PTR => DATA(:,IDX,:)
( 1981)     SELF%ACTIVE = .TRUE.
( 1982)     SELF%THREAD_BUFFER = .FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 121

( 1983)     SELF%OWNED = .FALSE.
( 1984)     SELF%NBLOCKS = SIZE(SELF%PTR, 2)
( 1985)     SELF%BASE_PTR => DATA
( 1986)     SELF%FIDX = IDX
( 1987) # 1988 "field_module.F90"
( 1988)     SELF%ISTATUS = NHSTFRESH
( 1989) # 1990 "field_module.F90"
( 1990)   END FUNCTION FIELD_LOG2D_WRAP_PACKED
( 1991) # 1992 "field_module.F90"
( 1992)   FUNCTION FIELD_LOG3D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 1993)     ! Create FIELD object packed in a multi-field buffer by storing a
( 1994)     ! contiguous pointer to existing data and an index.
( 1995)     TYPE(FIELD_LOG3D), TARGET :: SELF
( 1996)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:)
( 1997)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 1998)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 1999) # 2000 "field_module.F90"
( 2000)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2001) # 2002 "field_module.F90"
( 2002)     SELF%PTR => DATA(:,:,IDX,:)
( 2003)     SELF%ACTIVE = .TRUE.
( 2004)     SELF%THREAD_BUFFER = .FALSE.
( 2005)     SELF%OWNED = .FALSE.
( 2006)     SELF%NBLOCKS = SIZE(SELF%PTR, 3)
( 2007)     SELF%BASE_PTR => DATA
( 2008)     SELF%FIDX = IDX
( 2009) # 2010 "field_module.F90"
( 2010)     SELF%ISTATUS = NHSTFRESH
( 2011) # 2012 "field_module.F90"
( 2012)   END FUNCTION FIELD_LOG3D_WRAP_PACKED
( 2013) # 2014 "field_module.F90"
( 2014)   FUNCTION FIELD_LOG4D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 2015)     ! Create FIELD object packed in a multi-field buffer by storing a
( 2016)     ! contiguous pointer to existing data and an index.
( 2017)     TYPE(FIELD_LOG4D), TARGET :: SELF
( 2018)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:,:)
( 2019)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 2020)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2021) # 2022 "field_module.F90"
( 2022)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2023) # 2024 "field_module.F90"
( 2024)     SELF%PTR => DATA(:,:,:,IDX,:)
( 2025)     SELF%ACTIVE = .TRUE.
( 2026)     SELF%THREAD_BUFFER = .FALSE.
( 2027)     SELF%OWNED = .FALSE.
( 2028)     SELF%NBLOCKS = SIZE(SELF%PTR, 4)
( 2029)     SELF%BASE_PTR => DATA
( 2030)     SELF%FIDX = IDX
( 2031) # 2032 "field_module.F90"
( 2032)     SELF%ISTATUS = NHSTFRESH
( 2033) # 2034 "field_module.F90"
( 2034)   END FUNCTION FIELD_LOG4D_WRAP_PACKED
( 2035) # 2036 "field_module.F90"
( 2036)   FUNCTION FIELD_LOG5D_WRAP_PACKED(DATA, IDX, LBOUNDS) RESULT(SELF)
( 2037)     ! Create FIELD object packed in a multi-field buffer by storing a
( 2038)     ! contiguous pointer to existing data and an index.
( 2039)     TYPE(FIELD_LOG5D), TARGET :: SELF
( 2040)     LOGICAL, TARGET, INTENT(IN) :: DATA(:,:,:,:,:,:)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 122

( 2041)     INTEGER(KIND=JPIM), INTENT(IN) :: IDX
( 2042)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2043) # 2044 "field_module.F90"
( 2044)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2045) # 2046 "field_module.F90"
( 2046)     SELF%PTR => DATA(:,:,:,:,IDX,:)
( 2047)     SELF%ACTIVE = .TRUE.
( 2048)     SELF%THREAD_BUFFER = .FALSE.
( 2049)     SELF%OWNED = .FALSE.
( 2050)     SELF%NBLOCKS = SIZE(SELF%PTR, 5)
( 2051)     SELF%BASE_PTR => DATA
( 2052)     SELF%FIDX = IDX
( 2053) # 2054 "field_module.F90"
( 2054)     SELF%ISTATUS = NHSTFRESH
( 2055) # 2056 "field_module.F90"
( 2056)   END FUNCTION FIELD_LOG5D_WRAP_PACKED
( 2057) # 2059 "field_module.F90"
( 2059)   SUBROUTINE ALLOCATE_FIELD_2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2060)     ! Create FIELD object by explicitly allocating new data
( 2061)     !
( 2062)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2063)     TYPE(FIELD_2D), TARGET :: SELF
( 2064)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2065)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2066)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2067)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2068)     INTEGER(KIND=JPIM) :: NBLK
( 2069) # 2070 "field_module.F90"
( 2070)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2071) # 2072 "field_module.F90"
( 2072)     ! By default we allocate thread-local temporaries
( 2073)     SELF%THREAD_BUFFER = .TRUE.
( 2074)     NBLK = OML_MAX_THREADS()
( 2075) # 2076 "field_module.F90"
( 2076)     IF (PRESENT(PERSISTENT)) THEN
( 2077)       IF (PERSISTENT) THEN
( 2078)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2079)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2080)          & ABOR1('FIELD_2D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2081)         SELF%THREAD_BUFFER = .FALSE.
( 2082)         NBLK = NBLOCKS
( 2083)       END IF
( 2084)     END IF
( 2085) # 2086 "field_module.F90"
( 2086)     ! Allocate storage array and store metadata
( 2087)     ALLOCATE(SELF%DATA(SHAPE(1),NBLK))
( 2088)     SELF%PTR => SELF%DATA
( 2089)     SELF%ACTIVE = .TRUE.
( 2090)     SELF%OWNED = .TRUE.
( 2091)     SELF%NBLOCKS = SIZE(SELF%DATA, 2)
( 2092)     SELF%BASE_PTR => NULL()
( 2093)     SELF%FIDX = -1
( 2094) # 2095 "field_module.F90"
( 2095)     SELF%ISTATUS = NHSTFRESH
( 2096) # 2097 "field_module.F90"
( 2097)   END SUBROUTINE ALLOCATE_FIELD_2D
( 2098) # 2099 "field_module.F90"
( 2099)   FUNCTION FIELD_2D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 123

( 2100)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2101)     TYPE(FIELD_2D), TARGET :: SELF
( 2102)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2103)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2104)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2105)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2106)     INTEGER(KIND=JPIM) :: NBLK
( 2107)    
( 2108)     CALL ALLOCATE_FIELD_2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2109) # 2110 "field_module.F90"
( 2110)   END FUNCTION FIELD_2D_ALLOCATE
( 2111) # 2112 "field_module.F90"
( 2112)   SUBROUTINE ALLOCATE_FIELD_3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2113)     ! Create FIELD object by explicitly allocating new data
( 2114)     !
( 2115)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2116)     TYPE(FIELD_3D), TARGET :: SELF
( 2117)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2118)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2119)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2120)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2121)     INTEGER(KIND=JPIM) :: NBLK
( 2122) # 2123 "field_module.F90"
( 2123)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2124) # 2125 "field_module.F90"
( 2125)     ! By default we allocate thread-local temporaries
( 2126)     SELF%THREAD_BUFFER = .TRUE.
( 2127)     NBLK = OML_MAX_THREADS()
( 2128) # 2129 "field_module.F90"
( 2129)     IF (PRESENT(PERSISTENT)) THEN
( 2130)       IF (PERSISTENT) THEN
( 2131)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2132)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2133)          & ABOR1('FIELD_3D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2134)         SELF%THREAD_BUFFER = .FALSE.
( 2135)         NBLK = NBLOCKS
( 2136)       END IF
( 2137)     END IF
( 2138) # 2139 "field_module.F90"
( 2139)     ! Allocate storage array and store metadata
( 2140)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),NBLK))
( 2141)     SELF%PTR => SELF%DATA
( 2142)     SELF%ACTIVE = .TRUE.
( 2143)     SELF%OWNED = .TRUE.
( 2144)     SELF%NBLOCKS = SIZE(SELF%DATA, 3)
( 2145)     SELF%BASE_PTR => NULL()
( 2146)     SELF%FIDX = -1
( 2147) # 2148 "field_module.F90"
( 2148)     SELF%ISTATUS = NHSTFRESH
( 2149) # 2150 "field_module.F90"
( 2150)   END SUBROUTINE ALLOCATE_FIELD_3D
( 2151) # 2152 "field_module.F90"
( 2152)   FUNCTION FIELD_3D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2153)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2154)     TYPE(FIELD_3D), TARGET :: SELF
( 2155)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2156)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2157)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 124

( 2158)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2159)     INTEGER(KIND=JPIM) :: NBLK
( 2160)    
( 2161)     CALL ALLOCATE_FIELD_3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2162) # 2163 "field_module.F90"
( 2163)   END FUNCTION FIELD_3D_ALLOCATE
( 2164) # 2165 "field_module.F90"
( 2165)   SUBROUTINE ALLOCATE_FIELD_4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2166)     ! Create FIELD object by explicitly allocating new data
( 2167)     !
( 2168)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2169)     TYPE(FIELD_4D), TARGET :: SELF
( 2170)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2171)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2172)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2173)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2174)     INTEGER(KIND=JPIM) :: NBLK
( 2175) # 2176 "field_module.F90"
( 2176)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2177) # 2178 "field_module.F90"
( 2178)     ! By default we allocate thread-local temporaries
( 2179)     SELF%THREAD_BUFFER = .TRUE.
( 2180)     NBLK = OML_MAX_THREADS()
( 2181) # 2182 "field_module.F90"
( 2182)     IF (PRESENT(PERSISTENT)) THEN
( 2183)       IF (PERSISTENT) THEN
( 2184)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2185)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2186)          & ABOR1('FIELD_4D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2187)         SELF%THREAD_BUFFER = .FALSE.
( 2188)         NBLK = NBLOCKS
( 2189)       END IF
( 2190)     END IF
( 2191) # 2192 "field_module.F90"
( 2192)     ! Allocate storage array and store metadata
( 2193)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),NBLK))
( 2194)     SELF%PTR => SELF%DATA
( 2195)     SELF%ACTIVE = .TRUE.
( 2196)     SELF%OWNED = .TRUE.
( 2197)     SELF%NBLOCKS = SIZE(SELF%DATA, 4)
( 2198)     SELF%BASE_PTR => NULL()
( 2199)     SELF%FIDX = -1
( 2200) # 2201 "field_module.F90"
( 2201)     SELF%ISTATUS = NHSTFRESH
( 2202) # 2203 "field_module.F90"
( 2203)   END SUBROUTINE ALLOCATE_FIELD_4D
( 2204) # 2205 "field_module.F90"
( 2205)   FUNCTION FIELD_4D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2206)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2207)     TYPE(FIELD_4D), TARGET :: SELF
( 2208)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2209)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2210)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2211)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2212)     INTEGER(KIND=JPIM) :: NBLK
( 2213)    
( 2214)     CALL ALLOCATE_FIELD_4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2215) # 2216 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 125

( 2216)   END FUNCTION FIELD_4D_ALLOCATE
( 2217) # 2218 "field_module.F90"
( 2218)   SUBROUTINE ALLOCATE_FIELD_5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2219)     ! Create FIELD object by explicitly allocating new data
( 2220)     !
( 2221)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2222)     TYPE(FIELD_5D), TARGET :: SELF
( 2223)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2224)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2225)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2226)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2227)     INTEGER(KIND=JPIM) :: NBLK
( 2228) # 2229 "field_module.F90"
( 2229)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2230) # 2231 "field_module.F90"
( 2231)     ! By default we allocate thread-local temporaries
( 2232)     SELF%THREAD_BUFFER = .TRUE.
( 2233)     NBLK = OML_MAX_THREADS()
( 2234) # 2235 "field_module.F90"
( 2235)     IF (PRESENT(PERSISTENT)) THEN
( 2236)       IF (PERSISTENT) THEN
( 2237)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2238)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2239)          & ABOR1('FIELD_5D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2240)         SELF%THREAD_BUFFER = .FALSE.
( 2241)         NBLK = NBLOCKS
( 2242)       END IF
( 2243)     END IF
( 2244) # 2245 "field_module.F90"
( 2245)     ! Allocate storage array and store metadata
( 2246)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4),NBLK))
( 2247)     SELF%PTR => SELF%DATA
( 2248)     SELF%ACTIVE = .TRUE.
( 2249)     SELF%OWNED = .TRUE.
( 2250)     SELF%NBLOCKS = SIZE(SELF%DATA, 5)
( 2251)     SELF%BASE_PTR => NULL()
( 2252)     SELF%FIDX = -1
( 2253) # 2254 "field_module.F90"
( 2254)     SELF%ISTATUS = NHSTFRESH
( 2255) # 2256 "field_module.F90"
( 2256)   END SUBROUTINE ALLOCATE_FIELD_5D
( 2257) # 2258 "field_module.F90"
( 2258)   FUNCTION FIELD_5D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2259)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2260)     TYPE(FIELD_5D), TARGET :: SELF
( 2261)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2262)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2263)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2264)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2265)     INTEGER(KIND=JPIM) :: NBLK
( 2266)    
( 2267)     CALL ALLOCATE_FIELD_5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2268) # 2269 "field_module.F90"
( 2269)   END FUNCTION FIELD_5D_ALLOCATE
( 2270) # 2271 "field_module.F90"
( 2271)   SUBROUTINE ALLOCATE_FIELD_INT2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2272)     ! Create FIELD object by explicitly allocating new data
( 2273)     !






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 126

( 2274)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2275)     TYPE(FIELD_INT2D), TARGET :: SELF
( 2276)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2277)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2278)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2279)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2280)     INTEGER(KIND=JPIM) :: NBLK
( 2281) # 2282 "field_module.F90"
( 2282)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2283) # 2284 "field_module.F90"
( 2284)     ! By default we allocate thread-local temporaries
( 2285)     SELF%THREAD_BUFFER = .TRUE.
( 2286)     NBLK = OML_MAX_THREADS()
( 2287) # 2288 "field_module.F90"
( 2288)     IF (PRESENT(PERSISTENT)) THEN
( 2289)       IF (PERSISTENT) THEN
( 2290)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2291)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2292)          & ABOR1('FIELD_INT2D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2293)         SELF%THREAD_BUFFER = .FALSE.
( 2294)         NBLK = NBLOCKS
( 2295)       END IF
( 2296)     END IF
( 2297) # 2298 "field_module.F90"
( 2298)     ! Allocate storage array and store metadata
( 2299)     ALLOCATE(SELF%DATA(SHAPE(1),NBLK))
( 2300)     SELF%PTR => SELF%DATA
( 2301)     SELF%ACTIVE = .TRUE.
( 2302)     SELF%OWNED = .TRUE.
( 2303)     SELF%NBLOCKS = SIZE(SELF%DATA, 2)
( 2304)     SELF%BASE_PTR => NULL()
( 2305)     SELF%FIDX = -1
( 2306) # 2307 "field_module.F90"
( 2307)     SELF%ISTATUS = NHSTFRESH
( 2308) # 2309 "field_module.F90"
( 2309)   END SUBROUTINE ALLOCATE_FIELD_INT2D
( 2310) # 2311 "field_module.F90"
( 2311)   FUNCTION FIELD_INT2D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2312)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2313)     TYPE(FIELD_INT2D), TARGET :: SELF
( 2314)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2315)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2316)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2317)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2318)     INTEGER(KIND=JPIM) :: NBLK
( 2319)    
( 2320)     CALL ALLOCATE_FIELD_INT2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2321) # 2322 "field_module.F90"
( 2322)   END FUNCTION FIELD_INT2D_ALLOCATE
( 2323) # 2324 "field_module.F90"
( 2324)   SUBROUTINE ALLOCATE_FIELD_INT3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2325)     ! Create FIELD object by explicitly allocating new data
( 2326)     !
( 2327)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2328)     TYPE(FIELD_INT3D), TARGET :: SELF
( 2329)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2330)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2331)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 127

( 2332)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2333)     INTEGER(KIND=JPIM) :: NBLK
( 2334) # 2335 "field_module.F90"
( 2335)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2336) # 2337 "field_module.F90"
( 2337)     ! By default we allocate thread-local temporaries
( 2338)     SELF%THREAD_BUFFER = .TRUE.
( 2339)     NBLK = OML_MAX_THREADS()
( 2340) # 2341 "field_module.F90"
( 2341)     IF (PRESENT(PERSISTENT)) THEN
( 2342)       IF (PERSISTENT) THEN
( 2343)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2344)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2345)          & ABOR1('FIELD_INT3D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2346)         SELF%THREAD_BUFFER = .FALSE.
( 2347)         NBLK = NBLOCKS
( 2348)       END IF
( 2349)     END IF
( 2350) # 2351 "field_module.F90"
( 2351)     ! Allocate storage array and store metadata
( 2352)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),NBLK))
( 2353)     SELF%PTR => SELF%DATA
( 2354)     SELF%ACTIVE = .TRUE.
( 2355)     SELF%OWNED = .TRUE.
( 2356)     SELF%NBLOCKS = SIZE(SELF%DATA, 3)
( 2357)     SELF%BASE_PTR => NULL()
( 2358)     SELF%FIDX = -1
( 2359) # 2360 "field_module.F90"
( 2360)     SELF%ISTATUS = NHSTFRESH
( 2361) # 2362 "field_module.F90"
( 2362)   END SUBROUTINE ALLOCATE_FIELD_INT3D
( 2363) # 2364 "field_module.F90"
( 2364)   FUNCTION FIELD_INT3D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2365)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2366)     TYPE(FIELD_INT3D), TARGET :: SELF
( 2367)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2368)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2369)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2370)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2371)     INTEGER(KIND=JPIM) :: NBLK
( 2372)    
( 2373)     CALL ALLOCATE_FIELD_INT3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2374) # 2375 "field_module.F90"
( 2375)   END FUNCTION FIELD_INT3D_ALLOCATE
( 2376) # 2377 "field_module.F90"
( 2377)   SUBROUTINE ALLOCATE_FIELD_INT4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2378)     ! Create FIELD object by explicitly allocating new data
( 2379)     !
( 2380)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2381)     TYPE(FIELD_INT4D), TARGET :: SELF
( 2382)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2383)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2384)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2385)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2386)     INTEGER(KIND=JPIM) :: NBLK
( 2387) # 2388 "field_module.F90"
( 2388)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2389) # 2390 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 128

( 2390)     ! By default we allocate thread-local temporaries
( 2391)     SELF%THREAD_BUFFER = .TRUE.
( 2392)     NBLK = OML_MAX_THREADS()
( 2393) # 2394 "field_module.F90"
( 2394)     IF (PRESENT(PERSISTENT)) THEN
( 2395)       IF (PERSISTENT) THEN
( 2396)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2397)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2398)          & ABOR1('FIELD_INT4D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2399)         SELF%THREAD_BUFFER = .FALSE.
( 2400)         NBLK = NBLOCKS
( 2401)       END IF
( 2402)     END IF
( 2403) # 2404 "field_module.F90"
( 2404)     ! Allocate storage array and store metadata
( 2405)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),NBLK))
( 2406)     SELF%PTR => SELF%DATA
( 2407)     SELF%ACTIVE = .TRUE.
( 2408)     SELF%OWNED = .TRUE.
( 2409)     SELF%NBLOCKS = SIZE(SELF%DATA, 4)
( 2410)     SELF%BASE_PTR => NULL()
( 2411)     SELF%FIDX = -1
( 2412) # 2413 "field_module.F90"
( 2413)     SELF%ISTATUS = NHSTFRESH
( 2414) # 2415 "field_module.F90"
( 2415)   END SUBROUTINE ALLOCATE_FIELD_INT4D
( 2416) # 2417 "field_module.F90"
( 2417)   FUNCTION FIELD_INT4D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2418)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2419)     TYPE(FIELD_INT4D), TARGET :: SELF
( 2420)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2421)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2422)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2423)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2424)     INTEGER(KIND=JPIM) :: NBLK
( 2425)    
( 2426)     CALL ALLOCATE_FIELD_INT4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2427) # 2428 "field_module.F90"
( 2428)   END FUNCTION FIELD_INT4D_ALLOCATE
( 2429) # 2430 "field_module.F90"
( 2430)   SUBROUTINE ALLOCATE_FIELD_INT5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2431)     ! Create FIELD object by explicitly allocating new data
( 2432)     !
( 2433)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2434)     TYPE(FIELD_INT5D), TARGET :: SELF
( 2435)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2436)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2437)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2438)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2439)     INTEGER(KIND=JPIM) :: NBLK
( 2440) # 2441 "field_module.F90"
( 2441)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2442) # 2443 "field_module.F90"
( 2443)     ! By default we allocate thread-local temporaries
( 2444)     SELF%THREAD_BUFFER = .TRUE.
( 2445)     NBLK = OML_MAX_THREADS()
( 2446) # 2447 "field_module.F90"
( 2447)     IF (PRESENT(PERSISTENT)) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 129

( 2448)       IF (PERSISTENT) THEN
( 2449)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2450)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2451)          & ABOR1('FIELD_INT5D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2452)         SELF%THREAD_BUFFER = .FALSE.
( 2453)         NBLK = NBLOCKS
( 2454)       END IF
( 2455)     END IF
( 2456) # 2457 "field_module.F90"
( 2457)     ! Allocate storage array and store metadata
( 2458)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4),NBLK))
( 2459)     SELF%PTR => SELF%DATA
( 2460)     SELF%ACTIVE = .TRUE.
( 2461)     SELF%OWNED = .TRUE.
( 2462)     SELF%NBLOCKS = SIZE(SELF%DATA, 5)
( 2463)     SELF%BASE_PTR => NULL()
( 2464)     SELF%FIDX = -1
( 2465) # 2466 "field_module.F90"
( 2466)     SELF%ISTATUS = NHSTFRESH
( 2467) # 2468 "field_module.F90"
( 2468)   END SUBROUTINE ALLOCATE_FIELD_INT5D
( 2469) # 2470 "field_module.F90"
( 2470)   FUNCTION FIELD_INT5D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2471)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2472)     TYPE(FIELD_INT5D), TARGET :: SELF
( 2473)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2474)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2475)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2476)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2477)     INTEGER(KIND=JPIM) :: NBLK
( 2478)    
( 2479)     CALL ALLOCATE_FIELD_INT5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2480) # 2481 "field_module.F90"
( 2481)   END FUNCTION FIELD_INT5D_ALLOCATE
( 2482) # 2483 "field_module.F90"
( 2483)   SUBROUTINE ALLOCATE_FIELD_LOG2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2484)     ! Create FIELD object by explicitly allocating new data
( 2485)     !
( 2486)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2487)     TYPE(FIELD_LOG2D), TARGET :: SELF
( 2488)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2489)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2490)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2491)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2492)     INTEGER(KIND=JPIM) :: NBLK
( 2493) # 2494 "field_module.F90"
( 2494)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2495) # 2496 "field_module.F90"
( 2496)     ! By default we allocate thread-local temporaries
( 2497)     SELF%THREAD_BUFFER = .TRUE.
( 2498)     NBLK = OML_MAX_THREADS()
( 2499) # 2500 "field_module.F90"
( 2500)     IF (PRESENT(PERSISTENT)) THEN
( 2501)       IF (PERSISTENT) THEN
( 2502)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2503)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2504)          & ABOR1('FIELD_LOG2D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2505)         SELF%THREAD_BUFFER = .FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 130

( 2506)         NBLK = NBLOCKS
( 2507)       END IF
( 2508)     END IF
( 2509) # 2510 "field_module.F90"
( 2510)     ! Allocate storage array and store metadata
( 2511)     ALLOCATE(SELF%DATA(SHAPE(1),NBLK))
( 2512)     SELF%PTR => SELF%DATA
( 2513)     SELF%ACTIVE = .TRUE.
( 2514)     SELF%OWNED = .TRUE.
( 2515)     SELF%NBLOCKS = SIZE(SELF%DATA, 2)
( 2516)     SELF%BASE_PTR => NULL()
( 2517)     SELF%FIDX = -1
( 2518) # 2519 "field_module.F90"
( 2519)     SELF%ISTATUS = NHSTFRESH
( 2520) # 2521 "field_module.F90"
( 2521)   END SUBROUTINE ALLOCATE_FIELD_LOG2D
( 2522) # 2523 "field_module.F90"
( 2523)   FUNCTION FIELD_LOG2D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2524)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2525)     TYPE(FIELD_LOG2D), TARGET :: SELF
( 2526)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(1)
( 2527)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2528)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2529)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(2)
( 2530)     INTEGER(KIND=JPIM) :: NBLK
( 2531)    
( 2532)     CALL ALLOCATE_FIELD_LOG2D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2533) # 2534 "field_module.F90"
( 2534)   END FUNCTION FIELD_LOG2D_ALLOCATE
( 2535) # 2536 "field_module.F90"
( 2536)   SUBROUTINE ALLOCATE_FIELD_LOG3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2537)     ! Create FIELD object by explicitly allocating new data
( 2538)     !
( 2539)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2540)     TYPE(FIELD_LOG3D), TARGET :: SELF
( 2541)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2542)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2543)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2544)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2545)     INTEGER(KIND=JPIM) :: NBLK
( 2546) # 2547 "field_module.F90"
( 2547)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2548) # 2549 "field_module.F90"
( 2549)     ! By default we allocate thread-local temporaries
( 2550)     SELF%THREAD_BUFFER = .TRUE.
( 2551)     NBLK = OML_MAX_THREADS()
( 2552) # 2553 "field_module.F90"
( 2553)     IF (PRESENT(PERSISTENT)) THEN
( 2554)       IF (PERSISTENT) THEN
( 2555)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2556)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2557)          & ABOR1('FIELD_LOG3D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2558)         SELF%THREAD_BUFFER = .FALSE.
( 2559)         NBLK = NBLOCKS
( 2560)       END IF
( 2561)     END IF
( 2562) # 2563 "field_module.F90"
( 2563)     ! Allocate storage array and store metadata






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 131

( 2564)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),NBLK))
( 2565)     SELF%PTR => SELF%DATA
( 2566)     SELF%ACTIVE = .TRUE.
( 2567)     SELF%OWNED = .TRUE.
( 2568)     SELF%NBLOCKS = SIZE(SELF%DATA, 3)
( 2569)     SELF%BASE_PTR => NULL()
( 2570)     SELF%FIDX = -1
( 2571) # 2572 "field_module.F90"
( 2572)     SELF%ISTATUS = NHSTFRESH
( 2573) # 2574 "field_module.F90"
( 2574)   END SUBROUTINE ALLOCATE_FIELD_LOG3D
( 2575) # 2576 "field_module.F90"
( 2576)   FUNCTION FIELD_LOG3D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2577)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2578)     TYPE(FIELD_LOG3D), TARGET :: SELF
( 2579)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(2)
( 2580)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2581)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2582)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(3)
( 2583)     INTEGER(KIND=JPIM) :: NBLK
( 2584)    
( 2585)     CALL ALLOCATE_FIELD_LOG3D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2586) # 2587 "field_module.F90"
( 2587)   END FUNCTION FIELD_LOG3D_ALLOCATE
( 2588) # 2589 "field_module.F90"
( 2589)   SUBROUTINE ALLOCATE_FIELD_LOG4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2590)     ! Create FIELD object by explicitly allocating new data
( 2591)     !
( 2592)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2593)     TYPE(FIELD_LOG4D), TARGET :: SELF
( 2594)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2595)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2596)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2597)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2598)     INTEGER(KIND=JPIM) :: NBLK
( 2599) # 2600 "field_module.F90"
( 2600)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2601) # 2602 "field_module.F90"
( 2602)     ! By default we allocate thread-local temporaries
( 2603)     SELF%THREAD_BUFFER = .TRUE.
( 2604)     NBLK = OML_MAX_THREADS()
( 2605) # 2606 "field_module.F90"
( 2606)     IF (PRESENT(PERSISTENT)) THEN
( 2607)       IF (PERSISTENT) THEN
( 2608)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2609)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2610)          & ABOR1('FIELD_LOG4D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2611)         SELF%THREAD_BUFFER = .FALSE.
( 2612)         NBLK = NBLOCKS
( 2613)       END IF
( 2614)     END IF
( 2615) # 2616 "field_module.F90"
( 2616)     ! Allocate storage array and store metadata
( 2617)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),NBLK))
( 2618)     SELF%PTR => SELF%DATA
( 2619)     SELF%ACTIVE = .TRUE.
( 2620)     SELF%OWNED = .TRUE.
( 2621)     SELF%NBLOCKS = SIZE(SELF%DATA, 4)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 132

( 2622)     SELF%BASE_PTR => NULL()
( 2623)     SELF%FIDX = -1
( 2624) # 2625 "field_module.F90"
( 2625)     SELF%ISTATUS = NHSTFRESH
( 2626) # 2627 "field_module.F90"
( 2627)   END SUBROUTINE ALLOCATE_FIELD_LOG4D
( 2628) # 2629 "field_module.F90"
( 2629)   FUNCTION FIELD_LOG4D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2630)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2631)     TYPE(FIELD_LOG4D), TARGET :: SELF
( 2632)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(3)
( 2633)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2634)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2635)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(4)
( 2636)     INTEGER(KIND=JPIM) :: NBLK
( 2637)    
( 2638)     CALL ALLOCATE_FIELD_LOG4D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2639) # 2640 "field_module.F90"
( 2640)   END FUNCTION FIELD_LOG4D_ALLOCATE
( 2641) # 2642 "field_module.F90"
( 2642)   SUBROUTINE ALLOCATE_FIELD_LOG5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) 
( 2643)     ! Create FIELD object by explicitly allocating new data
( 2644)     !
( 2645)     ! Please note that SHAPE is the conceptual shape without the block dimension
( 2646)     TYPE(FIELD_LOG5D), TARGET :: SELF
( 2647)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2648)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2649)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2650)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2651)     INTEGER(KIND=JPIM) :: NBLK
( 2652) # 2653 "field_module.F90"
( 2653)     IF (PRESENT (LBOUNDS)) SELF%LBOUNDS = LBOUNDS
( 2654) # 2655 "field_module.F90"
( 2655)     ! By default we allocate thread-local temporaries
( 2656)     SELF%THREAD_BUFFER = .TRUE.
( 2657)     NBLK = OML_MAX_THREADS()
( 2658) # 2659 "field_module.F90"
( 2659)     IF (PRESENT(PERSISTENT)) THEN
( 2660)       IF (PERSISTENT) THEN
( 2661)         ! Adjust outer dim for full-sized persistent blocked arrays
( 2662)         IF (.NOT. PRESENT(NBLOCKS)) CALL &
( 2663)          & ABOR1('FIELD_LOG5D_ALLOCATE : NBLOCKS not given for persistent allocation!')
( 2664)         SELF%THREAD_BUFFER = .FALSE.
( 2665)         NBLK = NBLOCKS
( 2666)       END IF
( 2667)     END IF
( 2668) # 2669 "field_module.F90"
( 2669)     ! Allocate storage array and store metadata
( 2670)     ALLOCATE(SELF%DATA(SHAPE(1),SHAPE(2),SHAPE(3),SHAPE(4),NBLK))
( 2671)     SELF%PTR => SELF%DATA
( 2672)     SELF%ACTIVE = .TRUE.
( 2673)     SELF%OWNED = .TRUE.
( 2674)     SELF%NBLOCKS = SIZE(SELF%DATA, 5)
( 2675)     SELF%BASE_PTR => NULL()
( 2676)     SELF%FIDX = -1
( 2677) # 2678 "field_module.F90"
( 2678)     SELF%ISTATUS = NHSTFRESH
( 2679) # 2680 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 133

( 2680)   END SUBROUTINE ALLOCATE_FIELD_LOG5D
( 2681) # 2682 "field_module.F90"
( 2682)   FUNCTION FIELD_LOG5D_ALLOCATE(SHAPE, NBLOCKS, PERSISTENT, LBOUNDS) RESULT(SELF)
( 2683)     ! WARNING : Using this function kills performance when the %DATA member is allocated
( 2684)     TYPE(FIELD_LOG5D), TARGET :: SELF
( 2685)     INTEGER(KIND=JPIM), INTENT(IN) :: SHAPE(4)
( 2686)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NBLOCKS
( 2687)     LOGICAL, INTENT(IN), OPTIONAL :: PERSISTENT
( 2688)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: LBOUNDS(5)
( 2689)     INTEGER(KIND=JPIM) :: NBLK
( 2690)    
( 2691)     CALL ALLOCATE_FIELD_LOG5D (SELF, SHAPE, NBLOCKS, PERSISTENT, LBOUNDS)
( 2692) # 2693 "field_module.F90"
( 2693)   END FUNCTION FIELD_LOG5D_ALLOCATE
( 2694) # 2696 "field_module.F90"
( 2696)   FUNCTION FIELD_2D_CLONE(SELF) RESULT(NEWOBJ)
( 2697)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2698)     ! intact, but replicating view pointers.
( 2699)     CLASS(FIELD_2D) :: SELF
( 2700)     TYPE(FIELD_2D), POINTER :: NEWOBJ
( 2701) # 2702 "field_module.F90"
( 2702)     ALLOCATE(NEWOBJ)
( 2703)     ! For owned storage data, re-allocate but do not copy data over
( 2704)     IF (SELF%OWNED) THEN
( 2705)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2706)       NEWOBJ%PTR => NEWOBJ%DATA
( 2707)     ELSE
( 2708)       NEWOBJ%PTR => SELF%PTR
( 2709)     END IF
( 2710)     NEWOBJ%VIEW => NULL()
( 2711)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2712)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2713)     NEWOBJ%OWNED = .FALSE.
( 2714)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2715)   END FUNCTION FIELD_2D_CLONE
( 2716) # 2717 "field_module.F90"
( 2717)   FUNCTION FIELD_3D_CLONE(SELF) RESULT(NEWOBJ)
( 2718)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2719)     ! intact, but replicating view pointers.
( 2720)     CLASS(FIELD_3D) :: SELF
( 2721)     TYPE(FIELD_3D), POINTER :: NEWOBJ
( 2722) # 2723 "field_module.F90"
( 2723)     ALLOCATE(NEWOBJ)
( 2724)     ! For owned storage data, re-allocate but do not copy data over
( 2725)     IF (SELF%OWNED) THEN
( 2726)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2727)       NEWOBJ%PTR => NEWOBJ%DATA
( 2728)     ELSE
( 2729)       NEWOBJ%PTR => SELF%PTR
( 2730)     END IF
( 2731)     NEWOBJ%VIEW => NULL()
( 2732)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2733)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2734)     NEWOBJ%OWNED = .FALSE.
( 2735)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2736)   END FUNCTION FIELD_3D_CLONE
( 2737) # 2738 "field_module.F90"
( 2738)   FUNCTION FIELD_4D_CLONE(SELF) RESULT(NEWOBJ)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 134

( 2739)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2740)     ! intact, but replicating view pointers.
( 2741)     CLASS(FIELD_4D) :: SELF
( 2742)     TYPE(FIELD_4D), POINTER :: NEWOBJ
( 2743) # 2744 "field_module.F90"
( 2744)     ALLOCATE(NEWOBJ)
( 2745)     ! For owned storage data, re-allocate but do not copy data over
( 2746)     IF (SELF%OWNED) THEN
( 2747)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2748)       NEWOBJ%PTR => NEWOBJ%DATA
( 2749)     ELSE
( 2750)       NEWOBJ%PTR => SELF%PTR
( 2751)     END IF
( 2752)     NEWOBJ%VIEW => NULL()
( 2753)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2754)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2755)     NEWOBJ%OWNED = .FALSE.
( 2756)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2757)   END FUNCTION FIELD_4D_CLONE
( 2758) # 2759 "field_module.F90"
( 2759)   FUNCTION FIELD_5D_CLONE(SELF) RESULT(NEWOBJ)
( 2760)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2761)     ! intact, but replicating view pointers.
( 2762)     CLASS(FIELD_5D) :: SELF
( 2763)     TYPE(FIELD_5D), POINTER :: NEWOBJ
( 2764) # 2765 "field_module.F90"
( 2765)     ALLOCATE(NEWOBJ)
( 2766)     ! For owned storage data, re-allocate but do not copy data over
( 2767)     IF (SELF%OWNED) THEN
( 2768)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2769)       NEWOBJ%PTR => NEWOBJ%DATA
( 2770)     ELSE
( 2771)       NEWOBJ%PTR => SELF%PTR
( 2772)     END IF
( 2773)     NEWOBJ%VIEW => NULL()
( 2774)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2775)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2776)     NEWOBJ%OWNED = .FALSE.
( 2777)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2778)   END FUNCTION FIELD_5D_CLONE
( 2779) # 2780 "field_module.F90"
( 2780)   FUNCTION FIELD_INT2D_CLONE(SELF) RESULT(NEWOBJ)
( 2781)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2782)     ! intact, but replicating view pointers.
( 2783)     CLASS(FIELD_INT2D) :: SELF
( 2784)     TYPE(FIELD_INT2D), POINTER :: NEWOBJ
( 2785) # 2786 "field_module.F90"
( 2786)     ALLOCATE(NEWOBJ)
( 2787)     ! For owned storage data, re-allocate but do not copy data over
( 2788)     IF (SELF%OWNED) THEN
( 2789)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2790)       NEWOBJ%PTR => NEWOBJ%DATA
( 2791)     ELSE
( 2792)       NEWOBJ%PTR => SELF%PTR
( 2793)     END IF
( 2794)     NEWOBJ%VIEW => NULL()
( 2795)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2796)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 135

( 2797)     NEWOBJ%OWNED = .FALSE.
( 2798)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2799)   END FUNCTION FIELD_INT2D_CLONE
( 2800) # 2801 "field_module.F90"
( 2801)   FUNCTION FIELD_INT3D_CLONE(SELF) RESULT(NEWOBJ)
( 2802)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2803)     ! intact, but replicating view pointers.
( 2804)     CLASS(FIELD_INT3D) :: SELF
( 2805)     TYPE(FIELD_INT3D), POINTER :: NEWOBJ
( 2806) # 2807 "field_module.F90"
( 2807)     ALLOCATE(NEWOBJ)
( 2808)     ! For owned storage data, re-allocate but do not copy data over
( 2809)     IF (SELF%OWNED) THEN
( 2810)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2811)       NEWOBJ%PTR => NEWOBJ%DATA
( 2812)     ELSE
( 2813)       NEWOBJ%PTR => SELF%PTR
( 2814)     END IF
( 2815)     NEWOBJ%VIEW => NULL()
( 2816)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2817)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2818)     NEWOBJ%OWNED = .FALSE.
( 2819)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2820)   END FUNCTION FIELD_INT3D_CLONE
( 2821) # 2822 "field_module.F90"
( 2822)   FUNCTION FIELD_INT4D_CLONE(SELF) RESULT(NEWOBJ)
( 2823)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2824)     ! intact, but replicating view pointers.
( 2825)     CLASS(FIELD_INT4D) :: SELF
( 2826)     TYPE(FIELD_INT4D), POINTER :: NEWOBJ
( 2827) # 2828 "field_module.F90"
( 2828)     ALLOCATE(NEWOBJ)
( 2829)     ! For owned storage data, re-allocate but do not copy data over
( 2830)     IF (SELF%OWNED) THEN
( 2831)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2832)       NEWOBJ%PTR => NEWOBJ%DATA
( 2833)     ELSE
( 2834)       NEWOBJ%PTR => SELF%PTR
( 2835)     END IF
( 2836)     NEWOBJ%VIEW => NULL()
( 2837)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2838)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2839)     NEWOBJ%OWNED = .FALSE.
( 2840)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2841)   END FUNCTION FIELD_INT4D_CLONE
( 2842) # 2843 "field_module.F90"
( 2843)   FUNCTION FIELD_INT5D_CLONE(SELF) RESULT(NEWOBJ)
( 2844)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2845)     ! intact, but replicating view pointers.
( 2846)     CLASS(FIELD_INT5D) :: SELF
( 2847)     TYPE(FIELD_INT5D), POINTER :: NEWOBJ
( 2848) # 2849 "field_module.F90"
( 2849)     ALLOCATE(NEWOBJ)
( 2850)     ! For owned storage data, re-allocate but do not copy data over
( 2851)     IF (SELF%OWNED) THEN
( 2852)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2853)       NEWOBJ%PTR => NEWOBJ%DATA
( 2854)     ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 136

( 2855)       NEWOBJ%PTR => SELF%PTR
( 2856)     END IF
( 2857)     NEWOBJ%VIEW => NULL()
( 2858)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2859)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2860)     NEWOBJ%OWNED = .FALSE.
( 2861)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2862)   END FUNCTION FIELD_INT5D_CLONE
( 2863) # 2864 "field_module.F90"
( 2864)   FUNCTION FIELD_LOG2D_CLONE(SELF) RESULT(NEWOBJ)
( 2865)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2866)     ! intact, but replicating view pointers.
( 2867)     CLASS(FIELD_LOG2D) :: SELF
( 2868)     TYPE(FIELD_LOG2D), POINTER :: NEWOBJ
( 2869) # 2870 "field_module.F90"
( 2870)     ALLOCATE(NEWOBJ)
( 2871)     ! For owned storage data, re-allocate but do not copy data over
( 2872)     IF (SELF%OWNED) THEN
( 2873)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2874)       NEWOBJ%PTR => NEWOBJ%DATA
( 2875)     ELSE
( 2876)       NEWOBJ%PTR => SELF%PTR
( 2877)     END IF
( 2878)     NEWOBJ%VIEW => NULL()
( 2879)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2880)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2881)     NEWOBJ%OWNED = .FALSE.
( 2882)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2883)   END FUNCTION FIELD_LOG2D_CLONE
( 2884) # 2885 "field_module.F90"
( 2885)   FUNCTION FIELD_LOG3D_CLONE(SELF) RESULT(NEWOBJ)
( 2886)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2887)     ! intact, but replicating view pointers.
( 2888)     CLASS(FIELD_LOG3D) :: SELF
( 2889)     TYPE(FIELD_LOG3D), POINTER :: NEWOBJ
( 2890) # 2891 "field_module.F90"
( 2891)     ALLOCATE(NEWOBJ)
( 2892)     ! For owned storage data, re-allocate but do not copy data over
( 2893)     IF (SELF%OWNED) THEN
( 2894)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2895)       NEWOBJ%PTR => NEWOBJ%DATA
( 2896)     ELSE
( 2897)       NEWOBJ%PTR => SELF%PTR
( 2898)     END IF
( 2899)     NEWOBJ%VIEW => NULL()
( 2900)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2901)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2902)     NEWOBJ%OWNED = .FALSE.
( 2903)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2904)   END FUNCTION FIELD_LOG3D_CLONE
( 2905) # 2906 "field_module.F90"
( 2906)   FUNCTION FIELD_LOG4D_CLONE(SELF) RESULT(NEWOBJ)
( 2907)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2908)     ! intact, but replicating view pointers.
( 2909)     CLASS(FIELD_LOG4D) :: SELF
( 2910)     TYPE(FIELD_LOG4D), POINTER :: NEWOBJ
( 2911) # 2912 "field_module.F90"
( 2912)     ALLOCATE(NEWOBJ)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 137

( 2913)     ! For owned storage data, re-allocate but do not copy data over
( 2914)     IF (SELF%OWNED) THEN
( 2915)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2916)       NEWOBJ%PTR => NEWOBJ%DATA
( 2917)     ELSE
( 2918)       NEWOBJ%PTR => SELF%PTR
( 2919)     END IF
( 2920)     NEWOBJ%VIEW => NULL()
( 2921)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2922)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2923)     NEWOBJ%OWNED = .FALSE.
( 2924)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2925)   END FUNCTION FIELD_LOG4D_CLONE
( 2926) # 2927 "field_module.F90"
( 2927)   FUNCTION FIELD_LOG5D_CLONE(SELF) RESULT(NEWOBJ)
( 2928)     ! Clone (deep-copy) this FIELD object, keeping the DATA pointer
( 2929)     ! intact, but replicating view pointers.
( 2930)     CLASS(FIELD_LOG5D) :: SELF
( 2931)     TYPE(FIELD_LOG5D), POINTER :: NEWOBJ
( 2932) # 2933 "field_module.F90"
( 2933)     ALLOCATE(NEWOBJ)
( 2934)     ! For owned storage data, re-allocate but do not copy data over
( 2935)     IF (SELF%OWNED) THEN
( 2936)       ALLOCATE(NEWOBJ%DATA, MOLD=SELF%DATA)
( 2937)       NEWOBJ%PTR => NEWOBJ%DATA
( 2938)     ELSE
( 2939)       NEWOBJ%PTR => SELF%PTR
( 2940)     END IF
( 2941)     NEWOBJ%VIEW => NULL()
( 2942)     NEWOBJ%NBLOCKS = SELF%NBLOCKS
( 2943)     NEWOBJ%THREAD_BUFFER = SELF%THREAD_BUFFER
( 2944)     NEWOBJ%OWNED = .FALSE.
( 2945)     NEWOBJ%LBOUNDS = SELF%LBOUNDS
( 2946)   END FUNCTION FIELD_LOG5D_CLONE
( 2947) # 2949 "field_module.F90"
( 2949)   SUBROUTINE FIELD_2D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 2950)     ! Sets the view pointer FIELD%MP to the block of the given index
( 2951)     CLASS(FIELD_2D), TARGET :: SELF
( 2952)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 2953)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 2954)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 2955)     INTEGER(KIND=JPIM) :: IDX
( 2956) # 2957 "field_module.F90"
( 2957)     IDX = BLOCK_INDEX
( 2958)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 2959)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 2960)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 2961)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 2962)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 2963)     END IF
( 2964) # 2965 "field_module.F90"
( 2965)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 2966)       ! Fill the the buffer by replicating the last entry
( 2967)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 2968)     END IF
( 2969) # 2970 "field_module.F90"
( 2970)     IF (PRESENT(ZERO)) THEN
( 2971)       IF (ZERO) SELF%VIEW(:) = 0.0_JPRB






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 138

( 2972)     END IF
( 2973)   END SUBROUTINE FIELD_2D_UPDATE_VIEW
( 2974) # 2975 "field_module.F90"
( 2975)   SUBROUTINE FIELD_3D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 2976)     ! Sets the view pointer FIELD%MP to the block of the given index
( 2977)     CLASS(FIELD_3D), TARGET :: SELF
( 2978)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 2979)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 2980)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 2981)     INTEGER(KIND=JPIM) :: IDX
( 2982) # 2983 "field_module.F90"
( 2983)     IDX = BLOCK_INDEX
( 2984)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 2985)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 2986)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 2987)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 2988)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 2989)     END IF
( 2990) # 2991 "field_module.F90"
( 2991)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 2992)       ! Fill the the buffer by replicating the last entry
( 2993)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 2994)     END IF
( 2995) # 2996 "field_module.F90"
( 2996)     IF (PRESENT(ZERO)) THEN
( 2997)       IF (ZERO) SELF%VIEW(:,:) = 0.0_JPRB
( 2998)     END IF
( 2999)   END SUBROUTINE FIELD_3D_UPDATE_VIEW
( 3000) # 3001 "field_module.F90"
( 3001)   SUBROUTINE FIELD_4D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3002)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3003)     CLASS(FIELD_4D), TARGET :: SELF
( 3004)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3005)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3006)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3007)     INTEGER(KIND=JPIM) :: IDX
( 3008) # 3009 "field_module.F90"
( 3009)     IDX = BLOCK_INDEX
( 3010)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3011)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3012)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3013)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3014)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3015)     END IF
( 3016) # 3017 "field_module.F90"
( 3017)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3018)       ! Fill the the buffer by replicating the last entry
( 3019)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3020)     END IF
( 3021) # 3022 "field_module.F90"
( 3022)     IF (PRESENT(ZERO)) THEN
( 3023)       IF (ZERO) SELF%VIEW(:,:,:) = 0.0_JPRB
( 3024)     END IF
( 3025)   END SUBROUTINE FIELD_4D_UPDATE_VIEW
( 3026) # 3027 "field_module.F90"
( 3027)   SUBROUTINE FIELD_5D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3028)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3029)     CLASS(FIELD_5D), TARGET :: SELF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 139

( 3030)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3031)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3032)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3033)     INTEGER(KIND=JPIM) :: IDX
( 3034) # 3035 "field_module.F90"
( 3035)     IDX = BLOCK_INDEX
( 3036)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3037)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3038)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3039)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3040)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3041)     END IF
( 3042) # 3043 "field_module.F90"
( 3043)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3044)       ! Fill the the buffer by replicating the last entry
( 3045)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3046)     END IF
( 3047) # 3048 "field_module.F90"
( 3048)     IF (PRESENT(ZERO)) THEN
( 3049)       IF (ZERO) SELF%VIEW(:,:,:,:) = 0.0_JPRB
( 3050)     END IF
( 3051)   END SUBROUTINE FIELD_5D_UPDATE_VIEW
( 3052) # 3053 "field_module.F90"
( 3053)   SUBROUTINE FIELD_INT2D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3054)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3055)     CLASS(FIELD_INT2D), TARGET :: SELF
( 3056)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3057)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3058)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3059)     INTEGER(KIND=JPIM) :: IDX
( 3060) # 3061 "field_module.F90"
( 3061)     IDX = BLOCK_INDEX
( 3062)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3063)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3064)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3065)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3066)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3067)     END IF
( 3068) # 3069 "field_module.F90"
( 3069)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3070)       ! Fill the the buffer by replicating the last entry
( 3071)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3072)     END IF
( 3073) # 3074 "field_module.F90"
( 3074)     IF (PRESENT(ZERO)) THEN
( 3075)       IF (ZERO) SELF%VIEW(:) = 0.0_JPIM
( 3076)     END IF
( 3077)   END SUBROUTINE FIELD_INT2D_UPDATE_VIEW
( 3078) # 3079 "field_module.F90"
( 3079)   SUBROUTINE FIELD_INT3D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3080)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3081)     CLASS(FIELD_INT3D), TARGET :: SELF
( 3082)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3083)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3084)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3085)     INTEGER(KIND=JPIM) :: IDX
( 3086) # 3087 "field_module.F90"
( 3087)     IDX = BLOCK_INDEX






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 140

( 3088)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3089)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3090)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3091)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3092)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3093)     END IF
( 3094) # 3095 "field_module.F90"
( 3095)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3096)       ! Fill the the buffer by replicating the last entry
( 3097)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3098)     END IF
( 3099) # 3100 "field_module.F90"
( 3100)     IF (PRESENT(ZERO)) THEN
( 3101)       IF (ZERO) SELF%VIEW(:,:) = 0.0_JPIM
( 3102)     END IF
( 3103)   END SUBROUTINE FIELD_INT3D_UPDATE_VIEW
( 3104) # 3105 "field_module.F90"
( 3105)   SUBROUTINE FIELD_INT4D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3106)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3107)     CLASS(FIELD_INT4D), TARGET :: SELF
( 3108)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3109)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3110)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3111)     INTEGER(KIND=JPIM) :: IDX
( 3112) # 3113 "field_module.F90"
( 3113)     IDX = BLOCK_INDEX
( 3114)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3115)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3116)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3117)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3118)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3119)     END IF
( 3120) # 3121 "field_module.F90"
( 3121)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3122)       ! Fill the the buffer by replicating the last entry
( 3123)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3124)     END IF
( 3125) # 3126 "field_module.F90"
( 3126)     IF (PRESENT(ZERO)) THEN
( 3127)       IF (ZERO) SELF%VIEW(:,:,:) = 0.0_JPIM
( 3128)     END IF
( 3129)   END SUBROUTINE FIELD_INT4D_UPDATE_VIEW
( 3130) # 3131 "field_module.F90"
( 3131)   SUBROUTINE FIELD_INT5D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3132)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3133)     CLASS(FIELD_INT5D), TARGET :: SELF
( 3134)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3135)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3136)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3137)     INTEGER(KIND=JPIM) :: IDX
( 3138) # 3139 "field_module.F90"
( 3139)     IDX = BLOCK_INDEX
( 3140)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3141)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3142)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3143)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3144)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3145)     END IF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 141

( 3146) # 3147 "field_module.F90"
( 3147)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3148)       ! Fill the the buffer by replicating the last entry
( 3149)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3150)     END IF
( 3151) # 3152 "field_module.F90"
( 3152)     IF (PRESENT(ZERO)) THEN
( 3153)       IF (ZERO) SELF%VIEW(:,:,:,:) = 0.0_JPIM
( 3154)     END IF
( 3155)   END SUBROUTINE FIELD_INT5D_UPDATE_VIEW
( 3156) # 3157 "field_module.F90"
( 3157)   SUBROUTINE FIELD_LOG2D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3158)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3159)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 3160)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3161)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3162)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3163)     INTEGER(KIND=JPIM) :: IDX
( 3164) # 3165 "field_module.F90"
( 3165)     IDX = BLOCK_INDEX
( 3166)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3167)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3168)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3169)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3170)       SELF%VIEW (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3171)     END IF
( 3172) # 3173 "field_module.F90"
( 3173)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3174)       ! Fill the the buffer by replicating the last entry
( 3175)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3176)     END IF
( 3177) # 3178 "field_module.F90"
( 3178)     IF (PRESENT(ZERO)) THEN
( 3179)       IF (ZERO) SELF%VIEW(:) = .FALSE.
( 3180)     END IF
( 3181)   END SUBROUTINE FIELD_LOG2D_UPDATE_VIEW
( 3182) # 3183 "field_module.F90"
( 3183)   SUBROUTINE FIELD_LOG3D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3184)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3185)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 3186)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3187)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3188)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3189)     INTEGER(KIND=JPIM) :: IDX
( 3190) # 3191 "field_module.F90"
( 3191)     IDX = BLOCK_INDEX
( 3192)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3193)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3194)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3195)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3196)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3197)     END IF
( 3198) # 3199 "field_module.F90"
( 3199)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3200)       ! Fill the the buffer by replicating the last entry
( 3201)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3202)     END IF
( 3203) # 3204 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 142

( 3204)     IF (PRESENT(ZERO)) THEN
( 3205)       IF (ZERO) SELF%VIEW(:,:) = .FALSE.
( 3206)     END IF
( 3207)   END SUBROUTINE FIELD_LOG3D_UPDATE_VIEW
( 3208) # 3209 "field_module.F90"
( 3209)   SUBROUTINE FIELD_LOG4D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3210)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3211)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 3212)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3213)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3214)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3215)     INTEGER(KIND=JPIM) :: IDX
( 3216) # 3217 "field_module.F90"
( 3217)     IDX = BLOCK_INDEX
( 3218)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3219)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3220)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3221)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3222)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3223)     END IF
( 3224) # 3225 "field_module.F90"
( 3225)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3226)       ! Fill the the buffer by replicating the last entry
( 3227)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3228)     END IF
( 3229) # 3230 "field_module.F90"
( 3230)     IF (PRESENT(ZERO)) THEN
( 3231)       IF (ZERO) SELF%VIEW(:,:,:) = .FALSE.
( 3232)     END IF
( 3233)   END SUBROUTINE FIELD_LOG4D_UPDATE_VIEW
( 3234) # 3235 "field_module.F90"
( 3235)   SUBROUTINE FIELD_LOG5D_UPDATE_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3236)     ! Sets the view pointer FIELD%MP to the block of the given index
( 3237)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 3238)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3239)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3240)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3241)     INTEGER(KIND=JPIM) :: IDX
( 3242) # 3243 "field_module.F90"
( 3243)     IDX = BLOCK_INDEX
( 3244)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3245)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3246)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3247)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3248)       SELF%VIEW (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3249)     END IF
( 3250) # 3251 "field_module.F90"
( 3251)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3252)       ! Fill the the buffer by replicating the last entry
( 3253)       CALL FILL_BUFFER(SELF%VIEW, INDEX=BLOCK_SIZE)
( 3254)     END IF
( 3255) # 3256 "field_module.F90"
( 3256)     IF (PRESENT(ZERO)) THEN
( 3257)       IF (ZERO) SELF%VIEW(:,:,:,:) = .FALSE.
( 3258)     END IF
( 3259)   END SUBROUTINE FIELD_LOG5D_UPDATE_VIEW
( 3260) # 3262 "field_module.F90"
( 3262)   SUBROUTINE FIELD_2D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 143

( 3263)     ! Updates internal view and exports it to an external pointer
( 3264)     CLASS(FIELD_2D), TARGET :: SELF
( 3265)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: VIEW_PTR(:)
( 3266)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3267)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3268)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3269)     INTEGER(KIND=JPIM) :: IDX
( 3270) # 3271 "field_module.F90"
( 3271)     IDX = BLOCK_INDEX
( 3272)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3273)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3274)       VIEW_PTR (SELF%LBOUNDS(1):)  => SELF%DATA(:,IDX)
( 3275)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3276)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3277)     ELSE
( 3278)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3279)     END IF
( 3280) # 3281 "field_module.F90"
( 3281)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3282)       ! Fill the the buffer by replicating the last entry
( 3283)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3284)     END IF
( 3285) # 3286 "field_module.F90"
( 3286)     IF (PRESENT(ZERO)) THEN
( 3287)       IF (ZERO) VIEW_PTR(:) = 0.0_JPRB
( 3288)     END IF
( 3289)   END SUBROUTINE FIELD_2D_EXTRACT_VIEW
( 3290) # 3291 "field_module.F90"
( 3291)   SUBROUTINE FIELD_3D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3292)     ! Updates internal view and exports it to an external pointer
( 3293)     CLASS(FIELD_3D), TARGET :: SELF
( 3294)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:)
( 3295)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3296)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3297)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3298)     INTEGER(KIND=JPIM) :: IDX
( 3299) # 3300 "field_module.F90"
( 3300)     IDX = BLOCK_INDEX
( 3301)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3302)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3303)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):)  => SELF%DATA(:,:,IDX)
( 3304)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3305)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3306)     ELSE
( 3307)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3308)     END IF
( 3309) # 3310 "field_module.F90"
( 3310)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3311)       ! Fill the the buffer by replicating the last entry
( 3312)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3313)     END IF
( 3314) # 3315 "field_module.F90"
( 3315)     IF (PRESENT(ZERO)) THEN
( 3316)       IF (ZERO) VIEW_PTR(:,:) = 0.0_JPRB
( 3317)     END IF
( 3318)   END SUBROUTINE FIELD_3D_EXTRACT_VIEW
( 3319) # 3320 "field_module.F90"
( 3320)   SUBROUTINE FIELD_4D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 144

( 3321)     ! Updates internal view and exports it to an external pointer
( 3322)     CLASS(FIELD_4D), TARGET :: SELF
( 3323)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:)
( 3324)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3325)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3326)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3327)     INTEGER(KIND=JPIM) :: IDX
( 3328) # 3329 "field_module.F90"
( 3329)     IDX = BLOCK_INDEX
( 3330)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3331)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3332)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):)  => SELF%DATA(:,:,:,IDX)
( 3333)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3334)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3335)     ELSE
( 3336)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3337)     END IF
( 3338) # 3339 "field_module.F90"
( 3339)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3340)       ! Fill the the buffer by replicating the last entry
( 3341)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3342)     END IF
( 3343) # 3344 "field_module.F90"
( 3344)     IF (PRESENT(ZERO)) THEN
( 3345)       IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPRB
( 3346)     END IF
( 3347)   END SUBROUTINE FIELD_4D_EXTRACT_VIEW
( 3348) # 3349 "field_module.F90"
( 3349)   SUBROUTINE FIELD_5D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3350)     ! Updates internal view and exports it to an external pointer
( 3351)     CLASS(FIELD_5D), TARGET :: SELF
( 3352)     REAL(KIND=JPRB), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:,:)
( 3353)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3354)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3355)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3356)     INTEGER(KIND=JPIM) :: IDX
( 3357) # 3358 "field_module.F90"
( 3358)     IDX = BLOCK_INDEX
( 3359)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3360)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3361)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):)  => SELF%DATA(:,:,:,:,IDX)
( 3362)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3363)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3364)     ELSE
( 3365)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3366)     END IF
( 3367) # 3368 "field_module.F90"
( 3368)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3369)       ! Fill the the buffer by replicating the last entry
( 3370)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3371)     END IF
( 3372) # 3373 "field_module.F90"
( 3373)     IF (PRESENT(ZERO)) THEN
( 3374)       IF (ZERO) VIEW_PTR(:,:,:,:) = 0.0_JPRB
( 3375)     END IF
( 3376)   END SUBROUTINE FIELD_5D_EXTRACT_VIEW
( 3377) # 3378 "field_module.F90"
( 3378)   SUBROUTINE FIELD_INT2D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 145

( 3379)     ! Updates internal view and exports it to an external pointer
( 3380)     CLASS(FIELD_INT2D), TARGET :: SELF
( 3381)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: VIEW_PTR(:)
( 3382)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3383)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3384)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3385)     INTEGER(KIND=JPIM) :: IDX
( 3386) # 3387 "field_module.F90"
( 3387)     IDX = BLOCK_INDEX
( 3388)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3389)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3390)       VIEW_PTR (SELF%LBOUNDS(1):)  => SELF%DATA(:,IDX)
( 3391)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3392)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3393)     ELSE
( 3394)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3395)     END IF
( 3396) # 3397 "field_module.F90"
( 3397)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3398)       ! Fill the the buffer by replicating the last entry
( 3399)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3400)     END IF
( 3401) # 3402 "field_module.F90"
( 3402)     IF (PRESENT(ZERO)) THEN
( 3403)       IF (ZERO) VIEW_PTR(:) = 0.0_JPIM
( 3404)     END IF
( 3405)   END SUBROUTINE FIELD_INT2D_EXTRACT_VIEW
( 3406) # 3407 "field_module.F90"
( 3407)   SUBROUTINE FIELD_INT3D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3408)     ! Updates internal view and exports it to an external pointer
( 3409)     CLASS(FIELD_INT3D), TARGET :: SELF
( 3410)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:)
( 3411)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3412)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3413)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3414)     INTEGER(KIND=JPIM) :: IDX
( 3415) # 3416 "field_module.F90"
( 3416)     IDX = BLOCK_INDEX
( 3417)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3418)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3419)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):)  => SELF%DATA(:,:,IDX)
( 3420)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3421)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3422)     ELSE
( 3423)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3424)     END IF
( 3425) # 3426 "field_module.F90"
( 3426)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3427)       ! Fill the the buffer by replicating the last entry
( 3428)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3429)     END IF
( 3430) # 3431 "field_module.F90"
( 3431)     IF (PRESENT(ZERO)) THEN
( 3432)       IF (ZERO) VIEW_PTR(:,:) = 0.0_JPIM
( 3433)     END IF
( 3434)   END SUBROUTINE FIELD_INT3D_EXTRACT_VIEW
( 3435) # 3436 "field_module.F90"
( 3436)   SUBROUTINE FIELD_INT4D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 146

( 3437)     ! Updates internal view and exports it to an external pointer
( 3438)     CLASS(FIELD_INT4D), TARGET :: SELF
( 3439)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:)
( 3440)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3441)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3442)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3443)     INTEGER(KIND=JPIM) :: IDX
( 3444) # 3445 "field_module.F90"
( 3445)     IDX = BLOCK_INDEX
( 3446)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3447)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3448)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):)  => SELF%DATA(:,:,:,IDX)
( 3449)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3450)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3451)     ELSE
( 3452)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3453)     END IF
( 3454) # 3455 "field_module.F90"
( 3455)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3456)       ! Fill the the buffer by replicating the last entry
( 3457)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3458)     END IF
( 3459) # 3460 "field_module.F90"
( 3460)     IF (PRESENT(ZERO)) THEN
( 3461)       IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPIM
( 3462)     END IF
( 3463)   END SUBROUTINE FIELD_INT4D_EXTRACT_VIEW
( 3464) # 3465 "field_module.F90"
( 3465)   SUBROUTINE FIELD_INT5D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3466)     ! Updates internal view and exports it to an external pointer
( 3467)     CLASS(FIELD_INT5D), TARGET :: SELF
( 3468)     INTEGER(KIND=JPIM), POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:,:)
( 3469)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3470)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3471)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3472)     INTEGER(KIND=JPIM) :: IDX
( 3473) # 3474 "field_module.F90"
( 3474)     IDX = BLOCK_INDEX
( 3475)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3476)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3477)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):)  => SELF%DATA(:,:,:,:,IDX)
( 3478)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3479)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3480)     ELSE
( 3481)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3482)     END IF
( 3483) # 3484 "field_module.F90"
( 3484)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3485)       ! Fill the the buffer by replicating the last entry
( 3486)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3487)     END IF
( 3488) # 3489 "field_module.F90"
( 3489)     IF (PRESENT(ZERO)) THEN
( 3490)       IF (ZERO) VIEW_PTR(:,:,:,:) = 0.0_JPIM
( 3491)     END IF
( 3492)   END SUBROUTINE FIELD_INT5D_EXTRACT_VIEW
( 3493) # 3494 "field_module.F90"
( 3494)   SUBROUTINE FIELD_LOG2D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 147

( 3495)     ! Updates internal view and exports it to an external pointer
( 3496)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 3497)     LOGICAL, POINTER, INTENT(INOUT) :: VIEW_PTR(:)
( 3498)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3499)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3500)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3501)     INTEGER(KIND=JPIM) :: IDX
( 3502) # 3503 "field_module.F90"
( 3503)     IDX = BLOCK_INDEX
( 3504)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3505)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3506)       VIEW_PTR (SELF%LBOUNDS(1):)  => SELF%DATA(:,IDX)
( 3507)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3508)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3509)     ELSE
( 3510)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3511)     END IF
( 3512) # 3513 "field_module.F90"
( 3513)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3514)       ! Fill the the buffer by replicating the last entry
( 3515)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3516)     END IF
( 3517) # 3518 "field_module.F90"
( 3518)     IF (PRESENT(ZERO)) THEN
( 3519)       IF (ZERO) VIEW_PTR(:) = .FALSE.
( 3520)     END IF
( 3521)   END SUBROUTINE FIELD_LOG2D_EXTRACT_VIEW
( 3522) # 3523 "field_module.F90"
( 3523)   SUBROUTINE FIELD_LOG3D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3524)     ! Updates internal view and exports it to an external pointer
( 3525)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 3526)     LOGICAL, POINTER, INTENT(INOUT) :: VIEW_PTR(:,:)
( 3527)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3528)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3529)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3530)     INTEGER(KIND=JPIM) :: IDX
( 3531) # 3532 "field_module.F90"
( 3532)     IDX = BLOCK_INDEX
( 3533)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3534)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3535)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):)  => SELF%DATA(:,:,IDX)
( 3536)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3537)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3538)     ELSE
( 3539)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3540)     END IF
( 3541) # 3542 "field_module.F90"
( 3542)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3543)       ! Fill the the buffer by replicating the last entry
( 3544)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3545)     END IF
( 3546) # 3547 "field_module.F90"
( 3547)     IF (PRESENT(ZERO)) THEN
( 3548)       IF (ZERO) VIEW_PTR(:,:) = .FALSE.
( 3549)     END IF
( 3550)   END SUBROUTINE FIELD_LOG3D_EXTRACT_VIEW
( 3551) # 3552 "field_module.F90"
( 3552)   SUBROUTINE FIELD_LOG4D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 148

( 3553)     ! Updates internal view and exports it to an external pointer
( 3554)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 3555)     LOGICAL, POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:)
( 3556)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3557)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3558)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3559)     INTEGER(KIND=JPIM) :: IDX
( 3560) # 3561 "field_module.F90"
( 3561)     IDX = BLOCK_INDEX
( 3562)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3563)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3564)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):)  => SELF%DATA(:,:,:,IDX)
( 3565)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3566)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3567)     ELSE
( 3568)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3569)     END IF
( 3570) # 3571 "field_module.F90"
( 3571)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3572)       ! Fill the the buffer by replicating the last entry
( 3573)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3574)     END IF
( 3575) # 3576 "field_module.F90"
( 3576)     IF (PRESENT(ZERO)) THEN
( 3577)       IF (ZERO) VIEW_PTR(:,:,:) = .FALSE.
( 3578)     END IF
( 3579)   END SUBROUTINE FIELD_LOG4D_EXTRACT_VIEW
( 3580) # 3581 "field_module.F90"
( 3581)   SUBROUTINE FIELD_LOG5D_EXTRACT_VIEW(SELF, VIEW_PTR, BLOCK_INDEX, BLOCK_SIZE, ZERO)
( 3582)     ! Updates internal view and exports it to an external pointer
( 3583)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 3584)     LOGICAL, POINTER, INTENT(INOUT) :: VIEW_PTR(:,:,:,:)
( 3585)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3586)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3587)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3588)     INTEGER(KIND=JPIM) :: IDX
( 3589) # 3590 "field_module.F90"
( 3590)     IDX = BLOCK_INDEX
( 3591)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3592)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3593)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):)  => SELF%DATA(:,:,:,:,IDX)
( 3594)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3595)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3596)     ELSE
( 3597)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3598)     END IF
( 3599) # 3600 "field_module.F90"
( 3600)     IF (PRESENT(BLOCK_SIZE) .AND. BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3601)       ! Fill the the buffer by replicating the last entry
( 3602)       CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3603)     END IF
( 3604) # 3605 "field_module.F90"
( 3605)     IF (PRESENT(ZERO)) THEN
( 3606)       IF (ZERO) VIEW_PTR(:,:,:,:) = .FALSE.
( 3607)     END IF
( 3608)   END SUBROUTINE FIELD_LOG5D_EXTRACT_VIEW
( 3609) # 3611 "field_module.F90"
( 3611)   FUNCTION FIELD_2D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 149

( 3612)     ! Updates internal view and exports it to an external pointer
( 3613)     CLASS(FIELD_2D), TARGET :: SELF
( 3614)     REAL(KIND=JPRB), POINTER :: VIEW_PTR(:)
( 3615)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3616)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3617)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3618)     INTEGER(KIND=JPIM) :: IDX
( 3619) # 3620 "field_module.F90"
( 3620)     IDX = BLOCK_INDEX
( 3621)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3622)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3623)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3624)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3625)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3626)     ELSE
( 3627)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3628)     END IF
( 3629) # 3630 "field_module.F90"
( 3630)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3631)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3632)         ! Fill the the buffer by replicating the last entry
( 3633)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3634)       END IF
( 3635)     END IF
( 3636) # 3637 "field_module.F90"
( 3637)     IF (PRESENT(ZERO)) THEN
( 3638)       IF (ZERO) VIEW_PTR(:) = 0.0_JPRB
( 3639)     END IF
( 3640)   END FUNCTION FIELD_2D_GET_VIEW
( 3641) # 3642 "field_module.F90"
( 3642)   FUNCTION FIELD_3D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3643)     ! Updates internal view and exports it to an external pointer
( 3644)     CLASS(FIELD_3D), TARGET :: SELF
( 3645)     REAL(KIND=JPRB), POINTER :: VIEW_PTR(:,:)
( 3646)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3647)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3648)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3649)     INTEGER(KIND=JPIM) :: IDX
( 3650) # 3651 "field_module.F90"
( 3651)     IDX = BLOCK_INDEX
( 3652)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3653)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3654)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3655)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3656)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3657)     ELSE
( 3658)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3659)     END IF
( 3660) # 3661 "field_module.F90"
( 3661)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3662)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3663)         ! Fill the the buffer by replicating the last entry
( 3664)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3665)       END IF
( 3666)     END IF
( 3667) # 3668 "field_module.F90"
( 3668)     IF (PRESENT(ZERO)) THEN
( 3669)       IF (ZERO) VIEW_PTR(:,:) = 0.0_JPRB






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 150

( 3670)     END IF
( 3671)   END FUNCTION FIELD_3D_GET_VIEW
( 3672) # 3673 "field_module.F90"
( 3673)   FUNCTION FIELD_4D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3674)     ! Updates internal view and exports it to an external pointer
( 3675)     CLASS(FIELD_4D), TARGET :: SELF
( 3676)     REAL(KIND=JPRB), POINTER :: VIEW_PTR(:,:,:)
( 3677)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3678)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3679)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3680)     INTEGER(KIND=JPIM) :: IDX
( 3681) # 3682 "field_module.F90"
( 3682)     IDX = BLOCK_INDEX
( 3683)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3684)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3685)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3686)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3687)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3688)     ELSE
( 3689)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3690)     END IF
( 3691) # 3692 "field_module.F90"
( 3692)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3693)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3694)         ! Fill the the buffer by replicating the last entry
( 3695)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3696)       END IF
( 3697)     END IF
( 3698) # 3699 "field_module.F90"
( 3699)     IF (PRESENT(ZERO)) THEN
( 3700)       IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPRB
( 3701)     END IF
( 3702)   END FUNCTION FIELD_4D_GET_VIEW
( 3703) # 3704 "field_module.F90"
( 3704)   FUNCTION FIELD_5D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3705)     ! Updates internal view and exports it to an external pointer
( 3706)     CLASS(FIELD_5D), TARGET :: SELF
( 3707)     REAL(KIND=JPRB), POINTER :: VIEW_PTR(:,:,:,:)
( 3708)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3709)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3710)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3711)     INTEGER(KIND=JPIM) :: IDX
( 3712) # 3713 "field_module.F90"
( 3713)     IDX = BLOCK_INDEX
( 3714)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3715)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3716)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3717)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3718)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3719)     ELSE
( 3720)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3721)     END IF
( 3722) # 3723 "field_module.F90"
( 3723)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3724)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3725)         ! Fill the the buffer by replicating the last entry
( 3726)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3727)       END IF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 151

( 3728)     END IF
( 3729) # 3730 "field_module.F90"
( 3730)     IF (PRESENT(ZERO)) THEN
( 3731)       IF (ZERO) VIEW_PTR(:,:,:,:) = 0.0_JPRB
( 3732)     END IF
( 3733)   END FUNCTION FIELD_5D_GET_VIEW
( 3734) # 3735 "field_module.F90"
( 3735)   FUNCTION FIELD_INT2D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3736)     ! Updates internal view and exports it to an external pointer
( 3737)     CLASS(FIELD_INT2D), TARGET :: SELF
( 3738)     INTEGER(KIND=JPIM), POINTER :: VIEW_PTR(:)
( 3739)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3740)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3741)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3742)     INTEGER(KIND=JPIM) :: IDX
( 3743) # 3744 "field_module.F90"
( 3744)     IDX = BLOCK_INDEX
( 3745)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3746)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3747)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3748)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3749)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3750)     ELSE
( 3751)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3752)     END IF
( 3753) # 3754 "field_module.F90"
( 3754)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3755)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3756)         ! Fill the the buffer by replicating the last entry
( 3757)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3758)       END IF
( 3759)     END IF
( 3760) # 3761 "field_module.F90"
( 3761)     IF (PRESENT(ZERO)) THEN
( 3762)       IF (ZERO) VIEW_PTR(:) = 0.0_JPIM
( 3763)     END IF
( 3764)   END FUNCTION FIELD_INT2D_GET_VIEW
( 3765) # 3766 "field_module.F90"
( 3766)   FUNCTION FIELD_INT3D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3767)     ! Updates internal view and exports it to an external pointer
( 3768)     CLASS(FIELD_INT3D), TARGET :: SELF
( 3769)     INTEGER(KIND=JPIM), POINTER :: VIEW_PTR(:,:)
( 3770)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3771)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3772)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3773)     INTEGER(KIND=JPIM) :: IDX
( 3774) # 3775 "field_module.F90"
( 3775)     IDX = BLOCK_INDEX
( 3776)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3777)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3778)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3779)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3780)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3781)     ELSE
( 3782)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3783)     END IF
( 3784) # 3785 "field_module.F90"
( 3785)     IF (PRESENT(BLOCK_SIZE)) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 152

( 3786)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3787)         ! Fill the the buffer by replicating the last entry
( 3788)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3789)       END IF
( 3790)     END IF
( 3791) # 3792 "field_module.F90"
( 3792)     IF (PRESENT(ZERO)) THEN
( 3793)       IF (ZERO) VIEW_PTR(:,:) = 0.0_JPIM
( 3794)     END IF
( 3795)   END FUNCTION FIELD_INT3D_GET_VIEW
( 3796) # 3797 "field_module.F90"
( 3797)   FUNCTION FIELD_INT4D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3798)     ! Updates internal view and exports it to an external pointer
( 3799)     CLASS(FIELD_INT4D), TARGET :: SELF
( 3800)     INTEGER(KIND=JPIM), POINTER :: VIEW_PTR(:,:,:)
( 3801)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3802)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3803)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3804)     INTEGER(KIND=JPIM) :: IDX
( 3805) # 3806 "field_module.F90"
( 3806)     IDX = BLOCK_INDEX
( 3807)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3808)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3809)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3810)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3811)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3812)     ELSE
( 3813)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3814)     END IF
( 3815) # 3816 "field_module.F90"
( 3816)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3817)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3818)         ! Fill the the buffer by replicating the last entry
( 3819)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3820)       END IF
( 3821)     END IF
( 3822) # 3823 "field_module.F90"
( 3823)     IF (PRESENT(ZERO)) THEN
( 3824)       IF (ZERO) VIEW_PTR(:,:,:) = 0.0_JPIM
( 3825)     END IF
( 3826)   END FUNCTION FIELD_INT4D_GET_VIEW
( 3827) # 3828 "field_module.F90"
( 3828)   FUNCTION FIELD_INT5D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3829)     ! Updates internal view and exports it to an external pointer
( 3830)     CLASS(FIELD_INT5D), TARGET :: SELF
( 3831)     INTEGER(KIND=JPIM), POINTER :: VIEW_PTR(:,:,:,:)
( 3832)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3833)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3834)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3835)     INTEGER(KIND=JPIM) :: IDX
( 3836) # 3837 "field_module.F90"
( 3837)     IDX = BLOCK_INDEX
( 3838)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3839)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3840)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3841)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3842)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3843)     ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 153

( 3844)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3845)     END IF
( 3846) # 3847 "field_module.F90"
( 3847)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3848)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3849)         ! Fill the the buffer by replicating the last entry
( 3850)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3851)       END IF
( 3852)     END IF
( 3853) # 3854 "field_module.F90"
( 3854)     IF (PRESENT(ZERO)) THEN
( 3855)       IF (ZERO) VIEW_PTR(:,:,:,:) = 0.0_JPIM
( 3856)     END IF
( 3857)   END FUNCTION FIELD_INT5D_GET_VIEW
( 3858) # 3859 "field_module.F90"
( 3859)   FUNCTION FIELD_LOG2D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3860)     ! Updates internal view and exports it to an external pointer
( 3861)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 3862)     LOGICAL, POINTER :: VIEW_PTR(:)
( 3863)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3864)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3865)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3866)     INTEGER(KIND=JPIM) :: IDX
( 3867) # 3868 "field_module.F90"
( 3868)     IDX = BLOCK_INDEX
( 3869)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3870)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3871)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%DATA(:,IDX)
( 3872)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3873)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%PTR(:,IDX)
( 3874)     ELSE
( 3875)       VIEW_PTR (SELF%LBOUNDS(1):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3876)     END IF
( 3877) # 3878 "field_module.F90"
( 3878)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3879)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3880)         ! Fill the the buffer by replicating the last entry
( 3881)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3882)       END IF
( 3883)     END IF
( 3884) # 3885 "field_module.F90"
( 3885)     IF (PRESENT(ZERO)) THEN
( 3886)       IF (ZERO) VIEW_PTR(:) = .FALSE.
( 3887)     END IF
( 3888)   END FUNCTION FIELD_LOG2D_GET_VIEW
( 3889) # 3890 "field_module.F90"
( 3890)   FUNCTION FIELD_LOG3D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3891)     ! Updates internal view and exports it to an external pointer
( 3892)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 3893)     LOGICAL, POINTER :: VIEW_PTR(:,:)
( 3894)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3895)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3896)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3897)     INTEGER(KIND=JPIM) :: IDX
( 3898) # 3899 "field_module.F90"
( 3899)     IDX = BLOCK_INDEX
( 3900)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3901)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 154

( 3902)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA(:,:,IDX)
( 3903)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3904)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%PTR(:,:,IDX)
( 3905)     ELSE
( 3906)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3907)     END IF
( 3908) # 3909 "field_module.F90"
( 3909)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3910)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3911)         ! Fill the the buffer by replicating the last entry
( 3912)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3913)       END IF
( 3914)     END IF
( 3915) # 3916 "field_module.F90"
( 3916)     IF (PRESENT(ZERO)) THEN
( 3917)       IF (ZERO) VIEW_PTR(:,:) = .FALSE.
( 3918)     END IF
( 3919)   END FUNCTION FIELD_LOG3D_GET_VIEW
( 3920) # 3921 "field_module.F90"
( 3921)   FUNCTION FIELD_LOG4D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3922)     ! Updates internal view and exports it to an external pointer
( 3923)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 3924)     LOGICAL, POINTER :: VIEW_PTR(:,:,:)
( 3925)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3926)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3927)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3928)     INTEGER(KIND=JPIM) :: IDX
( 3929) # 3930 "field_module.F90"
( 3930)     IDX = BLOCK_INDEX
( 3931)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3932)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3933)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA(:,:,:,IDX)
( 3934)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3935)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%PTR(:,:,:,IDX)
( 3936)     ELSE
( 3937)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3938)     END IF
( 3939) # 3940 "field_module.F90"
( 3940)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3941)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3942)         ! Fill the the buffer by replicating the last entry
( 3943)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3944)       END IF
( 3945)     END IF
( 3946) # 3947 "field_module.F90"
( 3947)     IF (PRESENT(ZERO)) THEN
( 3948)       IF (ZERO) VIEW_PTR(:,:,:) = .FALSE.
( 3949)     END IF
( 3950)   END FUNCTION FIELD_LOG4D_GET_VIEW
( 3951) # 3952 "field_module.F90"
( 3952)   FUNCTION FIELD_LOG5D_GET_VIEW(SELF, BLOCK_INDEX, BLOCK_SIZE, ZERO) RESULT(VIEW_PTR)
( 3953)     ! Updates internal view and exports it to an external pointer
( 3954)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 3955)     LOGICAL, POINTER :: VIEW_PTR(:,:,:,:)
( 3956)     INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
( 3957)     INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: BLOCK_SIZE
( 3958)     LOGICAL, OPTIONAL, INTENT(IN) :: ZERO
( 3959)     INTEGER(KIND=JPIM) :: IDX






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 155

( 3960) # 3961 "field_module.F90"
( 3961)     IDX = BLOCK_INDEX
( 3962)     IF (SELF%THREAD_BUFFER) IDX = OML_MY_THREAD()
( 3963)     IF (SELF%ACTIVE .AND. SELF%OWNED) THEN
( 3964)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA(:,:,:,:,IDX)
( 3965)     ELSEIF (SELF%ACTIVE .AND. .NOT. SELF%OWNED) THEN
( 3966)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%PTR(:,:,:,:,IDX)
( 3967)     ELSE
( 3968)       VIEW_PTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%VIEW  ! Set to NaN'd field buffer
( 3969)     END IF
( 3970) # 3971 "field_module.F90"
( 3971)     IF (PRESENT(BLOCK_SIZE)) THEN
( 3972)       IF (BLOCK_INDEX == SELF%NBLOCKS) THEN
( 3973)         ! Fill the the buffer by replicating the last entry
( 3974)         CALL FILL_BUFFER(VIEW_PTR, INDEX=BLOCK_SIZE)
( 3975)       END IF
( 3976)     END IF
( 3977) # 3978 "field_module.F90"
( 3978)     IF (PRESENT(ZERO)) THEN
( 3979)       IF (ZERO) VIEW_PTR(:,:,:,:) = .FALSE.
( 3980)     END IF
( 3981)   END FUNCTION FIELD_LOG5D_GET_VIEW
( 3982) # 3984 "field_module.F90"
( 3984)   SUBROUTINE FIELD_2D_CREATE_DEVICE(SELF)
( 3985)     ! Initialize a copy of this field on GPU device
( 3986)     CLASS(FIELD_2D), TARGET :: SELF
( 3987) # 3988 "field_module.F90"
( 3988)     SELF%DEVPTR => SELF%DATA
( 3989) !$acc enter data create(SELF%DATA)
( 3990)   END SUBROUTINE FIELD_2D_CREATE_DEVICE
( 3991) # 3992 "field_module.F90"
( 3992)   SUBROUTINE FIELD_3D_CREATE_DEVICE(SELF)
( 3993)     ! Initialize a copy of this field on GPU device
( 3994)     CLASS(FIELD_3D), TARGET :: SELF
( 3995) # 3996 "field_module.F90"
( 3996)     SELF%DEVPTR => SELF%DATA
( 3997) !$acc enter data create(SELF%DATA)
( 3998)   END SUBROUTINE FIELD_3D_CREATE_DEVICE
( 3999) # 4000 "field_module.F90"
( 4000)   SUBROUTINE FIELD_4D_CREATE_DEVICE(SELF)
( 4001)     ! Initialize a copy of this field on GPU device
( 4002)     CLASS(FIELD_4D), TARGET :: SELF
( 4003) # 4004 "field_module.F90"
( 4004)     SELF%DEVPTR => SELF%DATA
( 4005) !$acc enter data create(SELF%DATA)
( 4006)   END SUBROUTINE FIELD_4D_CREATE_DEVICE
( 4007) # 4008 "field_module.F90"
( 4008)   SUBROUTINE FIELD_5D_CREATE_DEVICE(SELF)
( 4009)     ! Initialize a copy of this field on GPU device
( 4010)     CLASS(FIELD_5D), TARGET :: SELF
( 4011) # 4012 "field_module.F90"
( 4012)     SELF%DEVPTR => SELF%DATA
( 4013) !$acc enter data create(SELF%DATA)
( 4014)   END SUBROUTINE FIELD_5D_CREATE_DEVICE
( 4015) # 4016 "field_module.F90"
( 4016)   SUBROUTINE FIELD_INT2D_CREATE_DEVICE(SELF)
( 4017)     ! Initialize a copy of this field on GPU device
( 4018)     CLASS(FIELD_INT2D), TARGET :: SELF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 156

( 4019) # 4020 "field_module.F90"
( 4020)     SELF%DEVPTR => SELF%DATA
( 4021) !$acc enter data create(SELF%DATA)
( 4022)   END SUBROUTINE FIELD_INT2D_CREATE_DEVICE
( 4023) # 4024 "field_module.F90"
( 4024)   SUBROUTINE FIELD_INT3D_CREATE_DEVICE(SELF)
( 4025)     ! Initialize a copy of this field on GPU device
( 4026)     CLASS(FIELD_INT3D), TARGET :: SELF
( 4027) # 4028 "field_module.F90"
( 4028)     SELF%DEVPTR => SELF%DATA
( 4029) !$acc enter data create(SELF%DATA)
( 4030)   END SUBROUTINE FIELD_INT3D_CREATE_DEVICE
( 4031) # 4032 "field_module.F90"
( 4032)   SUBROUTINE FIELD_INT4D_CREATE_DEVICE(SELF)
( 4033)     ! Initialize a copy of this field on GPU device
( 4034)     CLASS(FIELD_INT4D), TARGET :: SELF
( 4035) # 4036 "field_module.F90"
( 4036)     SELF%DEVPTR => SELF%DATA
( 4037) !$acc enter data create(SELF%DATA)
( 4038)   END SUBROUTINE FIELD_INT4D_CREATE_DEVICE
( 4039) # 4040 "field_module.F90"
( 4040)   SUBROUTINE FIELD_INT5D_CREATE_DEVICE(SELF)
( 4041)     ! Initialize a copy of this field on GPU device
( 4042)     CLASS(FIELD_INT5D), TARGET :: SELF
( 4043) # 4044 "field_module.F90"
( 4044)     SELF%DEVPTR => SELF%DATA
( 4045) !$acc enter data create(SELF%DATA)
( 4046)   END SUBROUTINE FIELD_INT5D_CREATE_DEVICE
( 4047) # 4048 "field_module.F90"
( 4048)   SUBROUTINE FIELD_LOG2D_CREATE_DEVICE(SELF)
( 4049)     ! Initialize a copy of this field on GPU device
( 4050)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 4051) # 4052 "field_module.F90"
( 4052)     SELF%DEVPTR => SELF%DATA
( 4053) !$acc enter data create(SELF%DATA)
( 4054)   END SUBROUTINE FIELD_LOG2D_CREATE_DEVICE
( 4055) # 4056 "field_module.F90"
( 4056)   SUBROUTINE FIELD_LOG3D_CREATE_DEVICE(SELF)
( 4057)     ! Initialize a copy of this field on GPU device
( 4058)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 4059) # 4060 "field_module.F90"
( 4060)     SELF%DEVPTR => SELF%DATA
( 4061) !$acc enter data create(SELF%DATA)
( 4062)   END SUBROUTINE FIELD_LOG3D_CREATE_DEVICE
( 4063) # 4064 "field_module.F90"
( 4064)   SUBROUTINE FIELD_LOG4D_CREATE_DEVICE(SELF)
( 4065)     ! Initialize a copy of this field on GPU device
( 4066)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 4067) # 4068 "field_module.F90"
( 4068)     SELF%DEVPTR => SELF%DATA
( 4069) !$acc enter data create(SELF%DATA)
( 4070)   END SUBROUTINE FIELD_LOG4D_CREATE_DEVICE
( 4071) # 4072 "field_module.F90"
( 4072)   SUBROUTINE FIELD_LOG5D_CREATE_DEVICE(SELF)
( 4073)     ! Initialize a copy of this field on GPU device
( 4074)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 4075) # 4076 "field_module.F90"
( 4076)     SELF%DEVPTR => SELF%DATA






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 157

( 4077) !$acc enter data create(SELF%DATA)
( 4078)   END SUBROUTINE FIELD_LOG5D_CREATE_DEVICE
( 4079) # 4081 "field_module.F90"
( 4081)   FUNCTION FIELD_2D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4082)     ! Initialize a copy of this field on GPU device
( 4083)     CLASS(FIELD_2D), TARGET :: SELF
( 4084)     REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:)
( 4085) # 4086 "field_module.F90"
( 4086)     IF (SELF%OWNED) THEN
( 4087)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA
( 4088)     ELSE
( 4089)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DEVPTR
( 4090)     END IF
( 4091)   END FUNCTION FIELD_2D_GET_DEVICE_DATA
( 4092) # 4093 "field_module.F90"
( 4093)   FUNCTION FIELD_3D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4094)     ! Initialize a copy of this field on GPU device
( 4095)     CLASS(FIELD_3D), TARGET :: SELF
( 4096)     REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:)
( 4097) # 4098 "field_module.F90"
( 4098)     IF (SELF%OWNED) THEN
( 4099)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA
( 4100)     ELSE
( 4101)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DEVPTR
( 4102)     END IF
( 4103)   END FUNCTION FIELD_3D_GET_DEVICE_DATA
( 4104) # 4105 "field_module.F90"
( 4105)   FUNCTION FIELD_4D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4106)     ! Initialize a copy of this field on GPU device
( 4107)     CLASS(FIELD_4D), TARGET :: SELF
( 4108)     REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:)
( 4109) # 4110 "field_module.F90"
( 4110)     IF (SELF%OWNED) THEN
( 4111)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA
( 4112)     ELSE
( 4113)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DEVPTR
( 4114)     END IF
( 4115)   END FUNCTION FIELD_4D_GET_DEVICE_DATA
( 4116) # 4117 "field_module.F90"
( 4117)   FUNCTION FIELD_5D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4118)     ! Initialize a copy of this field on GPU device
( 4119)     CLASS(FIELD_5D), TARGET :: SELF
( 4120)     REAL(KIND=JPRB), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:)
( 4121) # 4122 "field_module.F90"
( 4122)     IF (SELF%OWNED) THEN
( 4123)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DATA
( 4124)     ELSE
( 4125)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DEVPTR
( 4126)     END IF
( 4127)   END FUNCTION FIELD_5D_GET_DEVICE_DATA
( 4128) # 4129 "field_module.F90"
( 4129)   FUNCTION FIELD_INT2D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4130)     ! Initialize a copy of this field on GPU device
( 4131)     CLASS(FIELD_INT2D), TARGET :: SELF
( 4132)     INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:)
( 4133) # 4134 "field_module.F90"
( 4134)     IF (SELF%OWNED) THEN
( 4135)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 158

( 4136)     ELSE
( 4137)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DEVPTR
( 4138)     END IF
( 4139)   END FUNCTION FIELD_INT2D_GET_DEVICE_DATA
( 4140) # 4141 "field_module.F90"
( 4141)   FUNCTION FIELD_INT3D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4142)     ! Initialize a copy of this field on GPU device
( 4143)     CLASS(FIELD_INT3D), TARGET :: SELF
( 4144)     INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:)
( 4145) # 4146 "field_module.F90"
( 4146)     IF (SELF%OWNED) THEN
( 4147)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA
( 4148)     ELSE
( 4149)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DEVPTR
( 4150)     END IF
( 4151)   END FUNCTION FIELD_INT3D_GET_DEVICE_DATA
( 4152) # 4153 "field_module.F90"
( 4153)   FUNCTION FIELD_INT4D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4154)     ! Initialize a copy of this field on GPU device
( 4155)     CLASS(FIELD_INT4D), TARGET :: SELF
( 4156)     INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:)
( 4157) # 4158 "field_module.F90"
( 4158)     IF (SELF%OWNED) THEN
( 4159)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA
( 4160)     ELSE
( 4161)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DEVPTR
( 4162)     END IF
( 4163)   END FUNCTION FIELD_INT4D_GET_DEVICE_DATA
( 4164) # 4165 "field_module.F90"
( 4165)   FUNCTION FIELD_INT5D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4166)     ! Initialize a copy of this field on GPU device
( 4167)     CLASS(FIELD_INT5D), TARGET :: SELF
( 4168)     INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:)
( 4169) # 4170 "field_module.F90"
( 4170)     IF (SELF%OWNED) THEN
( 4171)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DATA
( 4172)     ELSE
( 4173)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DEVPTR
( 4174)     END IF
( 4175)   END FUNCTION FIELD_INT5D_GET_DEVICE_DATA
( 4176) # 4177 "field_module.F90"
( 4177)   FUNCTION FIELD_LOG2D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4178)     ! Initialize a copy of this field on GPU device
( 4179)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 4180)     LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:)
( 4181) # 4182 "field_module.F90"
( 4182)     IF (SELF%OWNED) THEN
( 4183)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DATA
( 4184)     ELSE
( 4185)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):) => SELF%DEVPTR
( 4186)     END IF
( 4187)   END FUNCTION FIELD_LOG2D_GET_DEVICE_DATA
( 4188) # 4189 "field_module.F90"
( 4189)   FUNCTION FIELD_LOG3D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4190)     ! Initialize a copy of this field on GPU device
( 4191)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 4192)     LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:)
( 4193) # 4194 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 159

( 4194)     IF (SELF%OWNED) THEN
( 4195)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DATA
( 4196)     ELSE
( 4197)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):) => SELF%DEVPTR
( 4198)     END IF
( 4199)   END FUNCTION FIELD_LOG3D_GET_DEVICE_DATA
( 4200) # 4201 "field_module.F90"
( 4201)   FUNCTION FIELD_LOG4D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4202)     ! Initialize a copy of this field on GPU device
( 4203)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 4204)     LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:)
( 4205) # 4206 "field_module.F90"
( 4206)     IF (SELF%OWNED) THEN
( 4207)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DATA
( 4208)     ELSE
( 4209)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):) => SELF%DEVPTR
( 4210)     END IF
( 4211)   END FUNCTION FIELD_LOG4D_GET_DEVICE_DATA
( 4212) # 4213 "field_module.F90"
( 4213)   FUNCTION FIELD_LOG5D_GET_DEVICE_DATA(SELF) RESULT(DEVPTR)
( 4214)     ! Initialize a copy of this field on GPU device
( 4215)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 4216)     LOGICAL, POINTER, CONTIGUOUS :: DEVPTR(:,:,:,:,:)
( 4217) # 4218 "field_module.F90"
( 4218)     IF (SELF%OWNED) THEN
( 4219)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DATA
( 4220)     ELSE
( 4221)       DEVPTR (SELF%LBOUNDS(1):, SELF%LBOUNDS(2):, SELF%LBOUNDS(3):, SELF%LBOUNDS(4):, SELF%LBOUNDS(5):) => SELF%DEVPTR
( 4222)     END IF
( 4223)   END FUNCTION FIELD_LOG5D_GET_DEVICE_DATA
( 4224) # 4226 "field_module.F90"
( 4226)   SUBROUTINE FIELD_2D_UPDATE_DEVICE(SELF)
( 4227)     ! Create a copy of this field on device and copy data over
( 4228)     CLASS(FIELD_2D), TARGET :: SELF
( 4229) # 4230 "field_module.F90"
( 4230)     IF (SELF%OWNED) THEN
( 4231) !$acc enter data copyin(SELF%DATA)
( 4232)       SELF%DEVPTR => SELF%DATA
( 4233)     ELSE
( 4234)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4235) !$acc enter data copyin(SELF%DEVPTR)
( 4236)     END IF
( 4237)   END SUBROUTINE FIELD_2D_UPDATE_DEVICE
( 4238) # 4239 "field_module.F90"
( 4239)   SUBROUTINE FIELD_3D_UPDATE_DEVICE(SELF)
( 4240)     ! Create a copy of this field on device and copy data over
( 4241)     CLASS(FIELD_3D), TARGET :: SELF
( 4242) # 4243 "field_module.F90"
( 4243)     IF (SELF%OWNED) THEN
( 4244) !$acc enter data copyin(SELF%DATA)
( 4245)       SELF%DEVPTR => SELF%DATA
( 4246)     ELSE
( 4247)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4248) !$acc enter data copyin(SELF%DEVPTR)
( 4249)     END IF
( 4250)   END SUBROUTINE FIELD_3D_UPDATE_DEVICE
( 4251) # 4252 "field_module.F90"
( 4252)   SUBROUTINE FIELD_4D_UPDATE_DEVICE(SELF)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 160

( 4253)     ! Create a copy of this field on device and copy data over
( 4254)     CLASS(FIELD_4D), TARGET :: SELF
( 4255) # 4256 "field_module.F90"
( 4256)     IF (SELF%OWNED) THEN
( 4257) !$acc enter data copyin(SELF%DATA)
( 4258)       SELF%DEVPTR => SELF%DATA
( 4259)     ELSE
( 4260)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4261) !$acc enter data copyin(SELF%DEVPTR)
( 4262)     END IF
( 4263)   END SUBROUTINE FIELD_4D_UPDATE_DEVICE
( 4264) # 4265 "field_module.F90"
( 4265)   SUBROUTINE FIELD_5D_UPDATE_DEVICE(SELF)
( 4266)     ! Create a copy of this field on device and copy data over
( 4267)     CLASS(FIELD_5D), TARGET :: SELF
( 4268) # 4269 "field_module.F90"
( 4269)     IF (SELF%OWNED) THEN
( 4270) !$acc enter data copyin(SELF%DATA)
( 4271)       SELF%DEVPTR => SELF%DATA
( 4272)     ELSE
( 4273)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4274) !$acc enter data copyin(SELF%DEVPTR)
( 4275)     END IF
( 4276)   END SUBROUTINE FIELD_5D_UPDATE_DEVICE
( 4277) # 4278 "field_module.F90"
( 4278)   SUBROUTINE FIELD_INT2D_UPDATE_DEVICE(SELF)
( 4279)     ! Create a copy of this field on device and copy data over
( 4280)     CLASS(FIELD_INT2D), TARGET :: SELF
( 4281) # 4282 "field_module.F90"
( 4282)     IF (SELF%OWNED) THEN
( 4283) !$acc enter data copyin(SELF%DATA)
( 4284)       SELF%DEVPTR => SELF%DATA
( 4285)     ELSE
( 4286)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4287) !$acc enter data copyin(SELF%DEVPTR)
( 4288)     END IF
( 4289)   END SUBROUTINE FIELD_INT2D_UPDATE_DEVICE
( 4290) # 4291 "field_module.F90"
( 4291)   SUBROUTINE FIELD_INT3D_UPDATE_DEVICE(SELF)
( 4292)     ! Create a copy of this field on device and copy data over
( 4293)     CLASS(FIELD_INT3D), TARGET :: SELF
( 4294) # 4295 "field_module.F90"
( 4295)     IF (SELF%OWNED) THEN
( 4296) !$acc enter data copyin(SELF%DATA)
( 4297)       SELF%DEVPTR => SELF%DATA
( 4298)     ELSE
( 4299)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4300) !$acc enter data copyin(SELF%DEVPTR)
( 4301)     END IF
( 4302)   END SUBROUTINE FIELD_INT3D_UPDATE_DEVICE
( 4303) # 4304 "field_module.F90"
( 4304)   SUBROUTINE FIELD_INT4D_UPDATE_DEVICE(SELF)
( 4305)     ! Create a copy of this field on device and copy data over
( 4306)     CLASS(FIELD_INT4D), TARGET :: SELF
( 4307) # 4308 "field_module.F90"
( 4308)     IF (SELF%OWNED) THEN
( 4309) !$acc enter data copyin(SELF%DATA)
( 4310)       SELF%DEVPTR => SELF%DATA






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 161

( 4311)     ELSE
( 4312)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4313) !$acc enter data copyin(SELF%DEVPTR)
( 4314)     END IF
( 4315)   END SUBROUTINE FIELD_INT4D_UPDATE_DEVICE
( 4316) # 4317 "field_module.F90"
( 4317)   SUBROUTINE FIELD_INT5D_UPDATE_DEVICE(SELF)
( 4318)     ! Create a copy of this field on device and copy data over
( 4319)     CLASS(FIELD_INT5D), TARGET :: SELF
( 4320) # 4321 "field_module.F90"
( 4321)     IF (SELF%OWNED) THEN
( 4322) !$acc enter data copyin(SELF%DATA)
( 4323)       SELF%DEVPTR => SELF%DATA
( 4324)     ELSE
( 4325)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4326) !$acc enter data copyin(SELF%DEVPTR)
( 4327)     END IF
( 4328)   END SUBROUTINE FIELD_INT5D_UPDATE_DEVICE
( 4329) # 4330 "field_module.F90"
( 4330)   SUBROUTINE FIELD_LOG2D_UPDATE_DEVICE(SELF)
( 4331)     ! Create a copy of this field on device and copy data over
( 4332)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 4333) # 4334 "field_module.F90"
( 4334)     IF (SELF%OWNED) THEN
( 4335) !$acc enter data copyin(SELF%DATA)
( 4336)       SELF%DEVPTR => SELF%DATA
( 4337)     ELSE
( 4338)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4339) !$acc enter data copyin(SELF%DEVPTR)
( 4340)     END IF
( 4341)   END SUBROUTINE FIELD_LOG2D_UPDATE_DEVICE
( 4342) # 4343 "field_module.F90"
( 4343)   SUBROUTINE FIELD_LOG3D_UPDATE_DEVICE(SELF)
( 4344)     ! Create a copy of this field on device and copy data over
( 4345)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 4346) # 4347 "field_module.F90"
( 4347)     IF (SELF%OWNED) THEN
( 4348) !$acc enter data copyin(SELF%DATA)
( 4349)       SELF%DEVPTR => SELF%DATA
( 4350)     ELSE
( 4351)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4352) !$acc enter data copyin(SELF%DEVPTR)
( 4353)     END IF
( 4354)   END SUBROUTINE FIELD_LOG3D_UPDATE_DEVICE
( 4355) # 4356 "field_module.F90"
( 4356)   SUBROUTINE FIELD_LOG4D_UPDATE_DEVICE(SELF)
( 4357)     ! Create a copy of this field on device and copy data over
( 4358)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 4359) # 4360 "field_module.F90"
( 4360)     IF (SELF%OWNED) THEN
( 4361) !$acc enter data copyin(SELF%DATA)
( 4362)       SELF%DEVPTR => SELF%DATA
( 4363)     ELSE
( 4364)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4365) !$acc enter data copyin(SELF%DEVPTR)
( 4366)     END IF
( 4367)   END SUBROUTINE FIELD_LOG4D_UPDATE_DEVICE
( 4368) # 4369 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 162

( 4369)   SUBROUTINE FIELD_LOG5D_UPDATE_DEVICE(SELF)
( 4370)     ! Create a copy of this field on device and copy data over
( 4371)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 4372) # 4373 "field_module.F90"
( 4373)     IF (SELF%OWNED) THEN
( 4374) !$acc enter data copyin(SELF%DATA)
( 4375)       SELF%DEVPTR => SELF%DATA
( 4376)     ELSE
( 4377)       ALLOCATE(SELF%DEVPTR, SOURCE=SELF%PTR)
( 4378) !$acc enter data copyin(SELF%DEVPTR)
( 4379)     END IF
( 4380)   END SUBROUTINE FIELD_LOG5D_UPDATE_DEVICE
( 4381) # 4383 "field_module.F90"
( 4383)   SUBROUTINE FIELD_2D_UPDATE_HOST(SELF)
( 4384)     ! Synchronize device data back to host
( 4385)     CLASS(FIELD_2D) :: SELF
( 4386) # 4387 "field_module.F90"
( 4387)     IF (SELF%OWNED) THEN
( 4388)       !$acc exit data copyout(SELF%DATA)
( 4389)     ELSE
( 4390)       !$acc exit data copyout(SELF%DEVPTR)
( 4391)       SELF%PTR(:,:) = SELF%DEVPTR(:,:)
( 4392)     END IF
( 4393)   END SUBROUTINE FIELD_2D_UPDATE_HOST
( 4394) # 4395 "field_module.F90"
( 4395)   SUBROUTINE FIELD_3D_UPDATE_HOST(SELF)
( 4396)     ! Synchronize device data back to host
( 4397)     CLASS(FIELD_3D) :: SELF
( 4398) # 4399 "field_module.F90"
( 4399)     IF (SELF%OWNED) THEN
( 4400)       !$acc exit data copyout(SELF%DATA)
( 4401)     ELSE
( 4402)       !$acc exit data copyout(SELF%DEVPTR)
( 4403)       SELF%PTR(:,:,:) = SELF%DEVPTR(:,:,:)
( 4404)     END IF
( 4405)   END SUBROUTINE FIELD_3D_UPDATE_HOST
( 4406) # 4407 "field_module.F90"
( 4407)   SUBROUTINE FIELD_4D_UPDATE_HOST(SELF)
( 4408)     ! Synchronize device data back to host
( 4409)     CLASS(FIELD_4D) :: SELF
( 4410) # 4411 "field_module.F90"
( 4411)     IF (SELF%OWNED) THEN
( 4412)       !$acc exit data copyout(SELF%DATA)
( 4413)     ELSE
( 4414)       !$acc exit data copyout(SELF%DEVPTR)
( 4415)       SELF%PTR(:,:,:,:) = SELF%DEVPTR(:,:,:,:)
( 4416)     END IF
( 4417)   END SUBROUTINE FIELD_4D_UPDATE_HOST
( 4418) # 4419 "field_module.F90"
( 4419)   SUBROUTINE FIELD_5D_UPDATE_HOST(SELF)
( 4420)     ! Synchronize device data back to host
( 4421)     CLASS(FIELD_5D) :: SELF
( 4422) # 4423 "field_module.F90"
( 4423)     IF (SELF%OWNED) THEN
( 4424)       !$acc exit data copyout(SELF%DATA)
( 4425)     ELSE
( 4426)       !$acc exit data copyout(SELF%DEVPTR)
( 4427)       SELF%PTR(:,:,:,:,:) = SELF%DEVPTR(:,:,:,:,:)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 163

( 4428)     END IF
( 4429)   END SUBROUTINE FIELD_5D_UPDATE_HOST
( 4430) # 4431 "field_module.F90"
( 4431)   SUBROUTINE FIELD_INT2D_UPDATE_HOST(SELF)
( 4432)     ! Synchronize device data back to host
( 4433)     CLASS(FIELD_INT2D) :: SELF
( 4434) # 4435 "field_module.F90"
( 4435)     IF (SELF%OWNED) THEN
( 4436)       !$acc exit data copyout(SELF%DATA)
( 4437)     ELSE
( 4438)       !$acc exit data copyout(SELF%DEVPTR)
( 4439)       SELF%PTR(:,:) = SELF%DEVPTR(:,:)
( 4440)     END IF
( 4441)   END SUBROUTINE FIELD_INT2D_UPDATE_HOST
( 4442) # 4443 "field_module.F90"
( 4443)   SUBROUTINE FIELD_INT3D_UPDATE_HOST(SELF)
( 4444)     ! Synchronize device data back to host
( 4445)     CLASS(FIELD_INT3D) :: SELF
( 4446) # 4447 "field_module.F90"
( 4447)     IF (SELF%OWNED) THEN
( 4448)       !$acc exit data copyout(SELF%DATA)
( 4449)     ELSE
( 4450)       !$acc exit data copyout(SELF%DEVPTR)
( 4451)       SELF%PTR(:,:,:) = SELF%DEVPTR(:,:,:)
( 4452)     END IF
( 4453)   END SUBROUTINE FIELD_INT3D_UPDATE_HOST
( 4454) # 4455 "field_module.F90"
( 4455)   SUBROUTINE FIELD_INT4D_UPDATE_HOST(SELF)
( 4456)     ! Synchronize device data back to host
( 4457)     CLASS(FIELD_INT4D) :: SELF
( 4458) # 4459 "field_module.F90"
( 4459)     IF (SELF%OWNED) THEN
( 4460)       !$acc exit data copyout(SELF%DATA)
( 4461)     ELSE
( 4462)       !$acc exit data copyout(SELF%DEVPTR)
( 4463)       SELF%PTR(:,:,:,:) = SELF%DEVPTR(:,:,:,:)
( 4464)     END IF
( 4465)   END SUBROUTINE FIELD_INT4D_UPDATE_HOST
( 4466) # 4467 "field_module.F90"
( 4467)   SUBROUTINE FIELD_INT5D_UPDATE_HOST(SELF)
( 4468)     ! Synchronize device data back to host
( 4469)     CLASS(FIELD_INT5D) :: SELF
( 4470) # 4471 "field_module.F90"
( 4471)     IF (SELF%OWNED) THEN
( 4472)       !$acc exit data copyout(SELF%DATA)
( 4473)     ELSE
( 4474)       !$acc exit data copyout(SELF%DEVPTR)
( 4475)       SELF%PTR(:,:,:,:,:) = SELF%DEVPTR(:,:,:,:,:)
( 4476)     END IF
( 4477)   END SUBROUTINE FIELD_INT5D_UPDATE_HOST
( 4478) # 4479 "field_module.F90"
( 4479)   SUBROUTINE FIELD_LOG2D_UPDATE_HOST(SELF)
( 4480)     ! Synchronize device data back to host
( 4481)     CLASS(FIELD_LOG2D) :: SELF
( 4482) # 4483 "field_module.F90"
( 4483)     IF (SELF%OWNED) THEN
( 4484)       !$acc exit data copyout(SELF%DATA)
( 4485)     ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 164

( 4486)       !$acc exit data copyout(SELF%DEVPTR)
( 4487)       SELF%PTR(:,:) = SELF%DEVPTR(:,:)
( 4488)     END IF
( 4489)   END SUBROUTINE FIELD_LOG2D_UPDATE_HOST
( 4490) # 4491 "field_module.F90"
( 4491)   SUBROUTINE FIELD_LOG3D_UPDATE_HOST(SELF)
( 4492)     ! Synchronize device data back to host
( 4493)     CLASS(FIELD_LOG3D) :: SELF
( 4494) # 4495 "field_module.F90"
( 4495)     IF (SELF%OWNED) THEN
( 4496)       !$acc exit data copyout(SELF%DATA)
( 4497)     ELSE
( 4498)       !$acc exit data copyout(SELF%DEVPTR)
( 4499)       SELF%PTR(:,:,:) = SELF%DEVPTR(:,:,:)
( 4500)     END IF
( 4501)   END SUBROUTINE FIELD_LOG3D_UPDATE_HOST
( 4502) # 4503 "field_module.F90"
( 4503)   SUBROUTINE FIELD_LOG4D_UPDATE_HOST(SELF)
( 4504)     ! Synchronize device data back to host
( 4505)     CLASS(FIELD_LOG4D) :: SELF
( 4506) # 4507 "field_module.F90"
( 4507)     IF (SELF%OWNED) THEN
( 4508)       !$acc exit data copyout(SELF%DATA)
( 4509)     ELSE
( 4510)       !$acc exit data copyout(SELF%DEVPTR)
( 4511)       SELF%PTR(:,:,:,:) = SELF%DEVPTR(:,:,:,:)
( 4512)     END IF
( 4513)   END SUBROUTINE FIELD_LOG4D_UPDATE_HOST
( 4514) # 4515 "field_module.F90"
( 4515)   SUBROUTINE FIELD_LOG5D_UPDATE_HOST(SELF)
( 4516)     ! Synchronize device data back to host
( 4517)     CLASS(FIELD_LOG5D) :: SELF
( 4518) # 4519 "field_module.F90"
( 4519)     IF (SELF%OWNED) THEN
( 4520)       !$acc exit data copyout(SELF%DATA)
( 4521)     ELSE
( 4522)       !$acc exit data copyout(SELF%DEVPTR)
( 4523)       SELF%PTR(:,:,:,:,:) = SELF%DEVPTR(:,:,:,:,:)
( 4524)     END IF
( 4525)   END SUBROUTINE FIELD_LOG5D_UPDATE_HOST
( 4526) # 4528 "field_module.F90"
( 4528)   SUBROUTINE FIELD_2D_DELETE_DEVICE(SELF)
( 4529)     ! Initialize a copy of this field on GPU device
( 4530)     CLASS(FIELD_2D), TARGET :: SELF
( 4531) # 4532 "field_module.F90"
( 4532) !$acc exit data delete(SELF%DEVPTR)
( 4533)     IF (SELF%OWNED) THEN
( 4534)       NULLIFY(SELF%DEVPTR)
( 4535)     ELSE
( 4536)       DEALLOCATE(SELF%DEVPTR)
( 4537)     END IF
( 4538)   END SUBROUTINE FIELD_2D_DELETE_DEVICE
( 4539) # 4540 "field_module.F90"
( 4540)   SUBROUTINE FIELD_3D_DELETE_DEVICE(SELF)
( 4541)     ! Initialize a copy of this field on GPU device
( 4542)     CLASS(FIELD_3D), TARGET :: SELF
( 4543) # 4544 "field_module.F90"
( 4544) !$acc exit data delete(SELF%DEVPTR)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 165

( 4545)     IF (SELF%OWNED) THEN
( 4546)       NULLIFY(SELF%DEVPTR)
( 4547)     ELSE
( 4548)       DEALLOCATE(SELF%DEVPTR)
( 4549)     END IF
( 4550)   END SUBROUTINE FIELD_3D_DELETE_DEVICE
( 4551) # 4552 "field_module.F90"
( 4552)   SUBROUTINE FIELD_4D_DELETE_DEVICE(SELF)
( 4553)     ! Initialize a copy of this field on GPU device
( 4554)     CLASS(FIELD_4D), TARGET :: SELF
( 4555) # 4556 "field_module.F90"
( 4556) !$acc exit data delete(SELF%DEVPTR)
( 4557)     IF (SELF%OWNED) THEN
( 4558)       NULLIFY(SELF%DEVPTR)
( 4559)     ELSE
( 4560)       DEALLOCATE(SELF%DEVPTR)
( 4561)     END IF
( 4562)   END SUBROUTINE FIELD_4D_DELETE_DEVICE
( 4563) # 4564 "field_module.F90"
( 4564)   SUBROUTINE FIELD_5D_DELETE_DEVICE(SELF)
( 4565)     ! Initialize a copy of this field on GPU device
( 4566)     CLASS(FIELD_5D), TARGET :: SELF
( 4567) # 4568 "field_module.F90"
( 4568) !$acc exit data delete(SELF%DEVPTR)
( 4569)     IF (SELF%OWNED) THEN
( 4570)       NULLIFY(SELF%DEVPTR)
( 4571)     ELSE
( 4572)       DEALLOCATE(SELF%DEVPTR)
( 4573)     END IF
( 4574)   END SUBROUTINE FIELD_5D_DELETE_DEVICE
( 4575) # 4576 "field_module.F90"
( 4576)   SUBROUTINE FIELD_INT2D_DELETE_DEVICE(SELF)
( 4577)     ! Initialize a copy of this field on GPU device
( 4578)     CLASS(FIELD_INT2D), TARGET :: SELF
( 4579) # 4580 "field_module.F90"
( 4580) !$acc exit data delete(SELF%DEVPTR)
( 4581)     IF (SELF%OWNED) THEN
( 4582)       NULLIFY(SELF%DEVPTR)
( 4583)     ELSE
( 4584)       DEALLOCATE(SELF%DEVPTR)
( 4585)     END IF
( 4586)   END SUBROUTINE FIELD_INT2D_DELETE_DEVICE
( 4587) # 4588 "field_module.F90"
( 4588)   SUBROUTINE FIELD_INT3D_DELETE_DEVICE(SELF)
( 4589)     ! Initialize a copy of this field on GPU device
( 4590)     CLASS(FIELD_INT3D), TARGET :: SELF
( 4591) # 4592 "field_module.F90"
( 4592) !$acc exit data delete(SELF%DEVPTR)
( 4593)     IF (SELF%OWNED) THEN
( 4594)       NULLIFY(SELF%DEVPTR)
( 4595)     ELSE
( 4596)       DEALLOCATE(SELF%DEVPTR)
( 4597)     END IF
( 4598)   END SUBROUTINE FIELD_INT3D_DELETE_DEVICE
( 4599) # 4600 "field_module.F90"
( 4600)   SUBROUTINE FIELD_INT4D_DELETE_DEVICE(SELF)
( 4601)     ! Initialize a copy of this field on GPU device
( 4602)     CLASS(FIELD_INT4D), TARGET :: SELF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 166

( 4603) # 4604 "field_module.F90"
( 4604) !$acc exit data delete(SELF%DEVPTR)
( 4605)     IF (SELF%OWNED) THEN
( 4606)       NULLIFY(SELF%DEVPTR)
( 4607)     ELSE
( 4608)       DEALLOCATE(SELF%DEVPTR)
( 4609)     END IF
( 4610)   END SUBROUTINE FIELD_INT4D_DELETE_DEVICE
( 4611) # 4612 "field_module.F90"
( 4612)   SUBROUTINE FIELD_INT5D_DELETE_DEVICE(SELF)
( 4613)     ! Initialize a copy of this field on GPU device
( 4614)     CLASS(FIELD_INT5D), TARGET :: SELF
( 4615) # 4616 "field_module.F90"
( 4616) !$acc exit data delete(SELF%DEVPTR)
( 4617)     IF (SELF%OWNED) THEN
( 4618)       NULLIFY(SELF%DEVPTR)
( 4619)     ELSE
( 4620)       DEALLOCATE(SELF%DEVPTR)
( 4621)     END IF
( 4622)   END SUBROUTINE FIELD_INT5D_DELETE_DEVICE
( 4623) # 4624 "field_module.F90"
( 4624)   SUBROUTINE FIELD_LOG2D_DELETE_DEVICE(SELF)
( 4625)     ! Initialize a copy of this field on GPU device
( 4626)     CLASS(FIELD_LOG2D), TARGET :: SELF
( 4627) # 4628 "field_module.F90"
( 4628) !$acc exit data delete(SELF%DEVPTR)
( 4629)     IF (SELF%OWNED) THEN
( 4630)       NULLIFY(SELF%DEVPTR)
( 4631)     ELSE
( 4632)       DEALLOCATE(SELF%DEVPTR)
( 4633)     END IF
( 4634)   END SUBROUTINE FIELD_LOG2D_DELETE_DEVICE
( 4635) # 4636 "field_module.F90"
( 4636)   SUBROUTINE FIELD_LOG3D_DELETE_DEVICE(SELF)
( 4637)     ! Initialize a copy of this field on GPU device
( 4638)     CLASS(FIELD_LOG3D), TARGET :: SELF
( 4639) # 4640 "field_module.F90"
( 4640) !$acc exit data delete(SELF%DEVPTR)
( 4641)     IF (SELF%OWNED) THEN
( 4642)       NULLIFY(SELF%DEVPTR)
( 4643)     ELSE
( 4644)       DEALLOCATE(SELF%DEVPTR)
( 4645)     END IF
( 4646)   END SUBROUTINE FIELD_LOG3D_DELETE_DEVICE
( 4647) # 4648 "field_module.F90"
( 4648)   SUBROUTINE FIELD_LOG4D_DELETE_DEVICE(SELF)
( 4649)     ! Initialize a copy of this field on GPU device
( 4650)     CLASS(FIELD_LOG4D), TARGET :: SELF
( 4651) # 4652 "field_module.F90"
( 4652) !$acc exit data delete(SELF%DEVPTR)
( 4653)     IF (SELF%OWNED) THEN
( 4654)       NULLIFY(SELF%DEVPTR)
( 4655)     ELSE
( 4656)       DEALLOCATE(SELF%DEVPTR)
( 4657)     END IF
( 4658)   END SUBROUTINE FIELD_LOG4D_DELETE_DEVICE
( 4659) # 4660 "field_module.F90"
( 4660)   SUBROUTINE FIELD_LOG5D_DELETE_DEVICE(SELF)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 167

( 4661)     ! Initialize a copy of this field on GPU device
( 4662)     CLASS(FIELD_LOG5D), TARGET :: SELF
( 4663) # 4664 "field_module.F90"
( 4664) !$acc exit data delete(SELF%DEVPTR)
( 4665)     IF (SELF%OWNED) THEN
( 4666)       NULLIFY(SELF%DEVPTR)
( 4667)     ELSE
( 4668)       DEALLOCATE(SELF%DEVPTR)
( 4669)     END IF
( 4670)   END SUBROUTINE FIELD_LOG5D_DELETE_DEVICE
( 4671) # 4673 "field_module.F90"
( 4673)   SUBROUTINE FIELD_2D_FINAL(SELF)
( 4674)     ! Finalizes field and dealloactes owned data
( 4675)     CLASS(FIELD_2D) :: SELF
( 4676)     IF (SELF%OWNED) THEN
( 4677)       DEALLOCATE(SELF%DATA)
( 4678)     END IF
( 4679)     NULLIFY(SELF%PTR)
( 4680)     NULLIFY(SELF%VIEW)
( 4681)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4682)       !$acc exit data delete (SELF%DEVPTR)
( 4683)       DEALLOCATE (SELF%DEVPTR)
( 4684)       NULLIFY (SELF%DEVPTR)
( 4685)     ENDIF
( 4686)   END SUBROUTINE FIELD_2D_FINAL
( 4687) # 4688 "field_module.F90"
( 4688)   SUBROUTINE FIELD_3D_FINAL(SELF)
( 4689)     ! Finalizes field and dealloactes owned data
( 4690)     CLASS(FIELD_3D) :: SELF
( 4691)     IF (SELF%OWNED) THEN
( 4692)       DEALLOCATE(SELF%DATA)
( 4693)     END IF
( 4694)     NULLIFY(SELF%PTR)
( 4695)     NULLIFY(SELF%VIEW)
( 4696)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4697)       !$acc exit data delete (SELF%DEVPTR)
( 4698)       DEALLOCATE (SELF%DEVPTR)
( 4699)       NULLIFY (SELF%DEVPTR)
( 4700)     ENDIF
( 4701)   END SUBROUTINE FIELD_3D_FINAL
( 4702) # 4703 "field_module.F90"
( 4703)   SUBROUTINE FIELD_4D_FINAL(SELF)
( 4704)     ! Finalizes field and dealloactes owned data
( 4705)     CLASS(FIELD_4D) :: SELF
( 4706)     IF (SELF%OWNED) THEN
( 4707)       DEALLOCATE(SELF%DATA)
( 4708)     END IF
( 4709)     NULLIFY(SELF%PTR)
( 4710)     NULLIFY(SELF%VIEW)
( 4711)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4712)       !$acc exit data delete (SELF%DEVPTR)
( 4713)       DEALLOCATE (SELF%DEVPTR)
( 4714)       NULLIFY (SELF%DEVPTR)
( 4715)     ENDIF
( 4716)   END SUBROUTINE FIELD_4D_FINAL
( 4717) # 4718 "field_module.F90"
( 4718)   SUBROUTINE FIELD_5D_FINAL(SELF)
( 4719)     ! Finalizes field and dealloactes owned data






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 168

( 4720)     CLASS(FIELD_5D) :: SELF
( 4721)     IF (SELF%OWNED) THEN
( 4722)       DEALLOCATE(SELF%DATA)
( 4723)     END IF
( 4724)     NULLIFY(SELF%PTR)
( 4725)     NULLIFY(SELF%VIEW)
( 4726)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4727)       !$acc exit data delete (SELF%DEVPTR)
( 4728)       DEALLOCATE (SELF%DEVPTR)
( 4729)       NULLIFY (SELF%DEVPTR)
( 4730)     ENDIF
( 4731)   END SUBROUTINE FIELD_5D_FINAL
( 4732) # 4733 "field_module.F90"
( 4733)   SUBROUTINE FIELD_INT2D_FINAL(SELF)
( 4734)     ! Finalizes field and dealloactes owned data
( 4735)     CLASS(FIELD_INT2D) :: SELF
( 4736)     IF (SELF%OWNED) THEN
( 4737)       DEALLOCATE(SELF%DATA)
( 4738)     END IF
( 4739)     NULLIFY(SELF%PTR)
( 4740)     NULLIFY(SELF%VIEW)
( 4741)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4742)       !$acc exit data delete (SELF%DEVPTR)
( 4743)       DEALLOCATE (SELF%DEVPTR)
( 4744)       NULLIFY (SELF%DEVPTR)
( 4745)     ENDIF
( 4746)   END SUBROUTINE FIELD_INT2D_FINAL
( 4747) # 4748 "field_module.F90"
( 4748)   SUBROUTINE FIELD_INT3D_FINAL(SELF)
( 4749)     ! Finalizes field and dealloactes owned data
( 4750)     CLASS(FIELD_INT3D) :: SELF
( 4751)     IF (SELF%OWNED) THEN
( 4752)       DEALLOCATE(SELF%DATA)
( 4753)     END IF
( 4754)     NULLIFY(SELF%PTR)
( 4755)     NULLIFY(SELF%VIEW)
( 4756)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4757)       !$acc exit data delete (SELF%DEVPTR)
( 4758)       DEALLOCATE (SELF%DEVPTR)
( 4759)       NULLIFY (SELF%DEVPTR)
( 4760)     ENDIF
( 4761)   END SUBROUTINE FIELD_INT3D_FINAL
( 4762) # 4763 "field_module.F90"
( 4763)   SUBROUTINE FIELD_INT4D_FINAL(SELF)
( 4764)     ! Finalizes field and dealloactes owned data
( 4765)     CLASS(FIELD_INT4D) :: SELF
( 4766)     IF (SELF%OWNED) THEN
( 4767)       DEALLOCATE(SELF%DATA)
( 4768)     END IF
( 4769)     NULLIFY(SELF%PTR)
( 4770)     NULLIFY(SELF%VIEW)
( 4771)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4772)       !$acc exit data delete (SELF%DEVPTR)
( 4773)       DEALLOCATE (SELF%DEVPTR)
( 4774)       NULLIFY (SELF%DEVPTR)
( 4775)     ENDIF
( 4776)   END SUBROUTINE FIELD_INT4D_FINAL
( 4777) # 4778 "field_module.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 169

( 4778)   SUBROUTINE FIELD_INT5D_FINAL(SELF)
( 4779)     ! Finalizes field and dealloactes owned data
( 4780)     CLASS(FIELD_INT5D) :: SELF
( 4781)     IF (SELF%OWNED) THEN
( 4782)       DEALLOCATE(SELF%DATA)
( 4783)     END IF
( 4784)     NULLIFY(SELF%PTR)
( 4785)     NULLIFY(SELF%VIEW)
( 4786)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4787)       !$acc exit data delete (SELF%DEVPTR)
( 4788)       DEALLOCATE (SELF%DEVPTR)
( 4789)       NULLIFY (SELF%DEVPTR)
( 4790)     ENDIF
( 4791)   END SUBROUTINE FIELD_INT5D_FINAL
( 4792) # 4793 "field_module.F90"
( 4793)   SUBROUTINE FIELD_LOG2D_FINAL(SELF)
( 4794)     ! Finalizes field and dealloactes owned data
( 4795)     CLASS(FIELD_LOG2D) :: SELF
( 4796)     IF (SELF%OWNED) THEN
( 4797)       DEALLOCATE(SELF%DATA)
( 4798)     END IF
( 4799)     NULLIFY(SELF%PTR)
( 4800)     NULLIFY(SELF%VIEW)
( 4801)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4802)       !$acc exit data delete (SELF%DEVPTR)
( 4803)       DEALLOCATE (SELF%DEVPTR)
( 4804)       NULLIFY (SELF%DEVPTR)
( 4805)     ENDIF
( 4806)   END SUBROUTINE FIELD_LOG2D_FINAL
( 4807) # 4808 "field_module.F90"
( 4808)   SUBROUTINE FIELD_LOG3D_FINAL(SELF)
( 4809)     ! Finalizes field and dealloactes owned data
( 4810)     CLASS(FIELD_LOG3D) :: SELF
( 4811)     IF (SELF%OWNED) THEN
( 4812)       DEALLOCATE(SELF%DATA)
( 4813)     END IF
( 4814)     NULLIFY(SELF%PTR)
( 4815)     NULLIFY(SELF%VIEW)
( 4816)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4817)       !$acc exit data delete (SELF%DEVPTR)
( 4818)       DEALLOCATE (SELF%DEVPTR)
( 4819)       NULLIFY (SELF%DEVPTR)
( 4820)     ENDIF
( 4821)   END SUBROUTINE FIELD_LOG3D_FINAL
( 4822) # 4823 "field_module.F90"
( 4823)   SUBROUTINE FIELD_LOG4D_FINAL(SELF)
( 4824)     ! Finalizes field and dealloactes owned data
( 4825)     CLASS(FIELD_LOG4D) :: SELF
( 4826)     IF (SELF%OWNED) THEN
( 4827)       DEALLOCATE(SELF%DATA)
( 4828)     END IF
( 4829)     NULLIFY(SELF%PTR)
( 4830)     NULLIFY(SELF%VIEW)
( 4831)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4832)       !$acc exit data delete (SELF%DEVPTR)
( 4833)       DEALLOCATE (SELF%DEVPTR)
( 4834)       NULLIFY (SELF%DEVPTR)
( 4835)     ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:47:02      page 170

( 4836)   END SUBROUTINE FIELD_LOG4D_FINAL
( 4837) # 4838 "field_module.F90"
( 4838)   SUBROUTINE FIELD_LOG5D_FINAL(SELF)
( 4839)     ! Finalizes field and dealloactes owned data
( 4840)     CLASS(FIELD_LOG5D) :: SELF
( 4841)     IF (SELF%OWNED) THEN
( 4842)       DEALLOCATE(SELF%DATA)
( 4843)     END IF
( 4844)     NULLIFY(SELF%PTR)
( 4845)     NULLIFY(SELF%VIEW)
( 4846)     IF (ASSOCIATED (SELF%DEVPTR)) THEN
( 4847)       !$acc exit data delete (SELF%DEVPTR)
( 4848)       DEALLOCATE (SELF%DEVPTR)
( 4849)       NULLIFY (SELF%DEVPTR)
( 4850)     ENDIF
( 4851)   END SUBROUTINE FIELD_LOG5D_FINAL
( 4852) # 4854 "field_module.F90"
( 4854) END MODULE FIELD_MODULE
