program L1B_ee2bufr
  !  #[ Documentation

  !---------------------------------
  ! Description:
  ! - program to convert L1B
  !   from EarthExplorer format 
  !   into BUFR presentation 
  !
  ! - based on
  !   program for the ReadL1Bdata module
  !   written by: J. de Kloe (KNMI)
  !
  ! created    : 24-11-2005 M.Rohn
  !
  ! Modifications:
  !
  !   17-Jan-2006 M.Rohn     adopt single template (OBS+MEAS)
  !                          remove write XML-header
  !   18-Dec-2006 D.Tan      Activate reading of Cal_Char_GADS (via ReadAll)
  !   19-Jan-2007 J. de Kloe Fixed memory leak, and added proper program
  !                          termination when an error occurs
  !   31-May-2007 J. de Kloe reorganised a bit, and interfaced to the 
  !                          new BufrWrapper module.
  !   03-Sep-2007 P. Poli    Introduced L1B_Headers
  !   04-Sep-2007 P. Poli    change L1B_DataType to L1B_HDR_DataType and
  !                          L1B_BRC_DataType
  !   16-Jan-2008 J. de Kloe phase out integer kind i_, added folding marks
  !   21-Feb-2008 J. de Kloe added commandline handling to allow inserting
  !                          a fake datetime
  !   12-Mar-2008 J. de Kloe adapted to changed interface of DirectBinaryIO
  !   09-May-2008 J. de Kloe added an optional FakeDate commandline option
  !   05-Jun-2008 J. de Kloe imported changes from branch nl8_CY32R1_Jun04
  !   17-Jul-2008 J. de Kloe added an initialisation for nobservation, and
  !                          made a conversion to real*8 explicit
  !   27-Oct-2008 J. de Kloe adapted interface to Init_L1B_BRC_DataStructure
  !   08-Dec-2008 J. de Kloe added an optional FakeYear commandline option
  !   01-Apr-2009 J. de Kloe add calls to InitBufrMsg and DeleteBufrMsg
  !   23-Apr-2009 J. de Kloe tiny fix: add i4_ to one integer constant
  !   19-Jun-2009 J. de Kloe added option -AllowOldL1Bfiles
  !   07-May-2010 D.Tan      More interfacing to BufrWrapper module
  !   22-Mar-2011 J. de Kloe import get_N_Meas_Max from L1B_SPH
  !   24-Mar-2011 J. de Kloe added a sanity check on nmeasurement_max
  !   02-Nov-2012 J. de Kloe remove unused use imports
  !   27-Feb-2014 J. de Kloe adapt to changes in DirectBinary module
  !   31-Mar-2014 J. de Kloe add error check
  !   09-Jun-2015 J. de Kloe adapt to changed missing_datetime handling
  !   06-Jul-2015 J. de Kloe update to changed L1B reader
  !   06-Oct-2015 J. de Kloe disable workarounds
  !
  !  #]
  !  #[ Modules used

  ! L2BP datastructures
  USE L1B_DataStructure, only: L1B_HDR_DataType, &
                               L1B_BRC_DataType, &
                               Init_L1B_HDR_DataStructure, &
                               Init_L1B_BRC_DataStructure, &
                               Delete_L1B_HDR_DataStructure, &
                               Delete_L1B_BRC_DataStructure
  USE L1B_SPH, only: get_N_Meas_Max
  USE EE_CFI_DataTypes, only: IntAl, GetIntAl, DateTimeType, &
                              Convert_XML_to_Num_DateTime, &
                              InitDateTime, DateTimeMissing
!                              IntAul
  USE ReadL1Bdata, only: ReadL1Bfile, InitReadL1BfileModule

  ! BUFR related modules
  USE L1B_BufrUtil, only: L1B_bufr_encode, &
                          L1B_bufr_encode_init, &
                          L1B_bufr_encode_finish, &
                          NMAX_OBS_SUBSET
!                          NOBSERVATION_FOR_DEVELOPMENT
  USE BufrWrapper, only: InitBufrFile, SetBufrFileName, SetBufrFileMode, &
                         BufrFileType, BufrMessageType, mode_write, &
                         OpenBufrFile, WriteBufrMsg, CloseBufrFile, &
                         InitBufrMsg, DeleteBufrMsg
                         ! for debugging:
                         !PrintBufrFileProperties

  ! support modules
  USE ErrorHandler, only: no_error, error_cmdline_options, &
                          error_reading_file
  USE Compiler_Features, only: iargc_aeolus,getarg_aeolus
  USE Logging, only: Init_Logging, program_abort, &
       CheckIfFatalErrorOccurred,GetFatalError
  USE Numerics, only: r8_ ! i4_, 

  ! Modules used for testing
  !USE L1B_Geoloc_ADS, only: Print_L1B_Geoloc_ADS
  !USE L1B_PCD_ADS, only: Print_L1B_PCD_ADS
  !USE L1B_GWD_ADS, only: Print_L1B_GWD_ADS
  !USE L1B_Meas_ADS, only: Print_L1B_Meas_ADS
  !USE L1B_US_MDS, only: Print_L1B_US_MDS
  !USE L1B_WV_MDS, only: Print_L1B_WV_MDS
  !USE L1B_Cal_ADS, only: Print_L1B_Cal_ADS

  !  #]
  !  #[ variables
  implicit none

  integer :: error_flag, nr_of_arguments, current_arg_nr

  character(len=256) :: filename        ! without extension
  character(len=256) :: arg_name, arg_value

  TYPE(L1B_BRC_DataType) :: L1B
  TYPE(L1B_HDR_DataType) :: L1B_Headers
  TYPE(DateTimeType)     :: FakeDateTime
  TYPE(DateTimeType)     :: FakeDate
  integer                :: FakeYear
  TYPE(BufrFileType)     :: BufrFile
  TYPE(BufrMessageType)  :: BufrMsg

  ! BUFR related
  character(len=256) :: filename_bufr   ! with    extension
  integer            :: iobservation, &
                        nmeasurement_max, &
                        nsubset,    isubset, &
                        nbufr_msgs, ibufrmsg, ios
  integer(IntAl)     :: nobservation, requested_nobservation
  logical            :: ReadCal, ReadMieCorePars
  !  #]
  !---------------------------------
  !  #[ init

  ! normal logging
  call Init_Logging(Stdout_Log_Level_txt="INFO",&
                    Stderr_Log_Level_txt="NOOP",&
                    error_flag=error_flag)
  IF (error_flag .ne. no_error) &
       call program_abort(error_flag,"Init_Logging")

  ! init to missing
  call InitDateTime(FakeDateTime)
  call InitDateTime(FakeDate)

  FakeYear = 0
  requested_nobservation    = -1

  ! 1.1 L1B read access
  call InitReadL1BfileModule(error_flag=error_flag)
  IF (error_flag .ne. no_error) &
       call program_abort(error_flag,"InitReadL1BfileModule")
  !  #]
  !  #[ handle the commandline arguments
  nr_of_arguments = iargc_aeolus()
  IF (nr_of_arguments .lt. 1) THEN
     print *,"ERROR: at least one commandline argument holding the input L1B"
     print *,"ERROR: filename should be supplied !!!"
     print *,"ERROR: nr_of_arguments = ",nr_of_arguments
     call PrintUsage
     call program_abort(error_cmdline_options,"L1B_ee2bufr")
  END IF

  ! fetch the filename without extension as 1st commandline parameter:
  call getarg_aeolus(1,filename)
  filename_bufr = trim(filename)//".BUFR"

  current_arg_nr = 1
  argloop: do while (current_arg_nr .lt. nr_of_arguments)
     current_arg_nr = current_arg_nr + 1
     call getarg_aeolus(current_arg_nr,arg_name)
     current_arg_nr = current_arg_nr + 1
     call getarg_aeolus(current_arg_nr,arg_value)
     select case (arg_name)
     case("-NumBRC")
        ! read NumBRC from the commandline and store in nobservation
        read(arg_value,*,err=999) requested_nobservation
     case("-FakeDateTime")
        ! read a datetime from the commandline and store in FakeDateTime
        print *,"Using fake Datetime: "//trim(arg_value)
        FakeDateTime = Convert_XML_to_Num_DateTime(&
             "UTC="//trim(arg_value),'commandline arg: FakeDateTime')
        if (CheckIfFatalErrorOccurred()) then
           error_flag = GetFatalError()
           call program_abort(error_flag,"Convert_XML_to_Num_DateTime()")
        end if
     case("-FakeDate")
        ! read a datetime from the commandline and store in FakeDate
        ! fill the time part with zeros, since that part is not used
        print *,"Using fake Datetime: "//trim(arg_value)
        FakeDate = Convert_XML_to_Num_DateTime(&
             "UTC="//trim(arg_value)//"T00:00:00.000000",&
             'commandline arg: FakeDate')
        if (CheckIfFatalErrorOccurred()) then
           error_flag = GetFatalError()
           call program_abort(error_flag,"Convert_XML_to_Num_DateTime()")
        end if
     case("-FakeYear")
        ! read a year from the commandline and store in FakeYear
        print *,"Using fake DateYear: "//trim(arg_value)
        read(arg_value,*,iostat=ios) FakeYear
        if (ios .ne. 0) then
           print *,"ERROR: could not convert string: ["//trim(arg_value)//&
                "] to a valid year..."
           call PrintUsage
           call program_abort(error_cmdline_options,"L1B_ee2bufr")
        end if
     case default
        print *,"ERROR: invalid commandline argument: "
        print *,"ERROR: trim(arg_name)  = ["//trim(arg_name)//"]"
        print *,"ERROR: trim(arg_value) = ["//trim(arg_value)//"]"
        call PrintUsage
        call program_abort(error_cmdline_options,"L1B_ee2bufr")
     end select
  end do argloop

  ! sanity checks
  if ( (.not. DateTimeMissing(FakeDateTime)) .and. &
       (.not. DateTimeMissing(FakeDate)    )       ) then
     print *,"ERROR: the options -FakeDateTime and -FakeDate"
     print *,"ERROR: should NOT be used simultaneously!"
     print *,"ERROR: Please select one of the two only"
     call program_abort(error_cmdline_options,"L1B_ee2bufr")  
  end if

  if ( (.not. DateTimeMissing(FakeDateTime)) .and. &
       (FakeYear .ne. 0) ) then
     print *,"ERROR: the options -FakeDateTime and -FakeYear"
     print *,"ERROR: should NOT be used simultaneously!"
     print *,"ERROR: Please select one of the two only"
     call program_abort(error_cmdline_options,"L1B_ee2bufr")  
  end if

  if ( (.not. DateTimeMissing(FakeDate)) .and. &
       (FakeYear .ne. 0) ) then
     print *,"ERROR: the options -FakeDate and -FakeYear"
     print *,"ERROR: should NOT be used simultaneously!"
     print *,"ERROR: Please select one of the two only"
     call program_abort(error_cmdline_options,"L1B_ee2bufr")  
  end if
  !  #]
  !  #[ open BUFR file
  call InitBufrFile(BufrFile,error_flag,filename_bufr,mode_write)
  if (error_flag .ne. no_error) &
       call program_abort(error_flag,"InitBufrFile")

  call OpenBufrFile(BufrFile,error_flag)
  if (error_flag .ne. no_error) &
       call program_abort(error_flag,"OpenBufrFile")

  !call PrintBufrFileProperties(BufrFile,"L1B_BufrFile")
  !stop
  !  #]
  !  #[ prepare reading the L1B data and filling the subsets
  !
  call Init_L1B_HDR_DataStructure(L1B_Headers,error_flag )
  IF (error_flag .ne. no_error) &
     call program_abort(error_flag,"Init_L1B_HDR_DataStructure")

  ! Call ReadL1Bfile and only specify to ReadHeaders, no binary DSR.
  ! The optional flags for the binary datasets are false by default.
  ! So no need to update this call when more binary datasets are added.
  call ReadL1Bfile(L1B_Headers, filename, error_flag, ReadHeaders = .true.)
  IF (error_flag .ne. no_error) &
     call program_abort(error_flag,"ReadL1Bfile")  

  ! init (to prevent g95 warnings)
  nobservation = -1

  ! init message dimensions, i.e. get nobservation from 
  ! the L1B_Headers datastructure
  call GetIntAl(L1B_Headers%SPH%TOTAL_NUM_OF_OBSERVATIONS,&
                nobservation,error_flag)
  IF (error_flag .ne. no_error) &
     call program_abort(error_flag,"GetIntAl")  

  if (requested_nobservation .ne. -1) then
     ! sanity check
     ! note that this one can only be done after nobservation has been
     ! extracted from the L1B file
     if (requested_nobservation .le. nobservation) then
        print *,"Reducing number of read BRC's from ",nobservation
        print *,"to ",requested_nobservation
        nobservation = requested_nobservation
     else
        print *,"ERROR: this BUFR file only contains ",nobservation
        print *,"ERROR: observations, but you requested ",&
             requested_nobservation
        print *,"ERROR: observations to be extracted !!!"
        call program_abort(error_cmdline_options,"L1B_ee2bufr")  
     end if
  end if
  !  #]

  nmeasurement_max = get_N_Meas_Max(L1B_Headers%SPH)
  if (nmeasurement_max .eq. -1) then
     call program_abort(error_reading_file,'L1B_ee2bufr:get_N_Meas_Max')
  end if

  nbufr_msgs = ceiling(real(nobservation,r8_)/NMAX_OBS_SUBSET)
  ReadMieCorePars=.true.
  ReadCal=.true.

  bufrmsgloop: do ibufrmsg = 1,nbufr_msgs
     ! build obs message
     nsubset = 0

     ! allocate the needed memory to store the encoded BUFR message
     call InitBufrMsg(BufrMsg,error_flag,AllocateArrays=.true.)
     if (error_flag .ne. no_error) call program_abort(error_flag,"InitBufrMsg")
     ! optional input: MaxBufrMsgSizeWords=25000 ! words
     ! default for this setting is: 1600000 words
     
     ! initialise the next BUFR msg
     call L1B_bufr_encode_init( nmeasurement_max, BufrMsg, error_flag)
     if (error_flag .ne. no_error) &
          call program_abort(error_flag,"L1B_bufr_encode_init")
   
     nsubset = NMAX_OBS_SUBSET
     if ((ibufrmsg-1)*NMAX_OBS_SUBSET+nsubset .ge. nobservation) &
          nsubset = nobservation - (ibufrmsg-1)*NMAX_OBS_SUBSET

     subsetloop: do isubset = 1,nsubset
        !  #[
        iobservation = (ibufrmsg-1)*NMAX_OBS_SUBSET+isubset

        if (iobservation .ne. 1) then
           ReadMieCorePars=.false.
           ReadCal=.false.
        end if
        
        ! init before each read
        call Init_L1B_BRC_DataStructure(L1B)
        ! allocation is done inside ReadL1Bfile now, so an explicit
        ! call to Allocate_L1B_BRC_DataStructure is not needed here
        
        ! Call ReadL1Bfile and now specify to ReadAll.
        ! The optional flags for the binary datasets are automatically updated.
        ! So no need to update this call when more binary datasets are added.
        call ReadL1Bfile(L1B_Headers, filename, error_flag, L1B, &
             Which_DSR = iobservation,&
             ReadGeoloc = .true., ReadPCD = .true., &
             ReadGWD = .true., ReadMeas = .true., &
             ReadMieCorePars = ReadMieCorePars, ReadCal = ReadCal, &
             ReadUS = .true., ReadWV = .true.)
        IF (error_flag .ne. no_error) &
             call program_abort(error_flag,"ReadL1Bfile")
     
        ! encode L1B observations
        if ( DateTimeMissing(FakeDateTime) .and. &
             DateTimeMissing(FakeDate)     .and. &
             (FakeYear .eq. 0)                   ) then
           call L1B_bufr_encode( L1B_Headers, L1B, isubset, &
                                 BufrMsg, error_flag, &
                                 workaround=.false.)
        else
           if (.not. DateTimeMissing(FakeDateTime)) then
              call L1B_bufr_encode( L1B_Headers, L1B, isubset, &
                                    BufrMsg, error_flag, &
                                    workaround=.false., FakeDateTime=FakeDateTime)
           end if
           if (.not. DateTimeMissing(FakeDate)) then
              call L1B_bufr_encode( L1B_Headers, L1B, isubset, &
                                    BufrMsg, error_flag, &
                                    workaround=.false., FakeDate=FakeDate)
           end if
           if (FakeYear .ne. 0) then
              call L1B_bufr_encode( L1B_Headers, L1B, isubset, &
                                    BufrMsg, error_flag, &
                                    workaround=.false., FakeYear=FakeYear)
           end if
        end if

        if (error_flag .ne. no_error) &
             call program_abort(error_flag,"L1B_bufr_encode")
        
        ! free L1B structure
        call Delete_L1B_BRC_DataStructure( L1B )

        !  #]
     enddo subsetloop
     !  #[ encode and write message L1B observations

     ! encode message
     call L1B_bufr_encode_finish( nsubset, BufrMsg )
     
     ! write message
     call WriteBufrMsg(BufrFile,BufrMsg,error_flag)
     if (error_flag .ne. no_error) &
          call program_abort(error_flag,"WriteBufrMsg")

     ! free the memory used by the encoded BUFR message
     call DeleteBufrMsg(BufrMsg,error_flag)
     if (error_flag .ne. no_error) call program_abort(error_flag,"DeleteBufrMsg")

     !  #]
  end do bufrmsgloop
  !  #[ close BUFR file and free memory

  ! free L1B structure (header only)
  call Delete_L1B_HDR_DataStructure( L1B_Headers )

  ! close BUFR file
  call CloseBufrFile(BufrFile,error_flag)
  if (error_flag .ne. no_error) &
       call program_abort(error_flag,"CloseBufrFile")

  !  #]
  !  #[ error handler
  goto 111 ! goto the end of the program without using stop
           ! (that messes up our testsuite for certain compilers)

999 print *,"ERROR: could not convert NumBRC given on the command line"
    print *,"into an integer ...."
    print *,"argument string value is: "//trim(arg_value)
    call PrintUsage
    call program_abort(error_cmdline_options,"L1B_ee2bufr")

111 continue
  !  #]    
contains
  !-------------------
  subroutine PrintUsage
    !  #[
    print *,"Usage: L1B_ee2bufr <filename[without extension]>"
    print *,"                   [optional: -NumBRC <count>]"
    print *,"                   [optional: -FakeDateTime <DateTime>]"
    print *,"                   [optional: -AllowOldL1Bfiles]"
    print *,"with <DateTime> having the format:"
    print *,"                   <2004-10-02T00:00:00.000000>"
    print *,"                   [optional: -FakeDate <Date>]"
    print *,"with <Date> having the format:"
    print *,"                   <2004-10-02>"
    print *,"                   [optional: -FakeYear <Year>]"
    print *,"with <Year> having the format:"
    print *,"                   <2004>"
    print *,""
  end subroutine PrintUsage
    !  #]
  !-------------------
end program L1B_ee2bufr
