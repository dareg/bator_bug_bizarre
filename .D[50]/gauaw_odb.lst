


NVFORTRAN (Version     23.1)          02/24/2023  13:33:55      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:33:55      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: gauaw_odb.F90

(    1) SUBROUTINE GAUAW_ODB(PA,PW,K,KRET)
(    2) 
(    3) !**** *GAUAW_ODB* - COMPUTE ABSCISSAS AND WEIGHTS FOR *GAUSSIAN INTEGRATION.
(    4) 
(    5) !     PURPOSE.
(    6) !     --------
(    7) 
(    8) !          *GAUAW_ODB* IS CALLED TO COMPUTE THE ABSCISSAS AND WEIGHTS REQUIR
(    9) !     TO PERFORM *GAUSSIAN INTEGRATION.
(   10) 
(   11) !**   INTERFACE.
(   12) !     ----------
(   13) 
(   14) !          *CALL* *GAUAW_ODB(PA,PW,K)*
(   15) 
(   16) !               *PA*     - ARRAY, LENGTH AT LEAST *K,* TO RECEIVE ABSCISSAS.
(   17) !               *PW*     - ARRAY, LENGTH AT LEAST *K,* TO RECEIVE WEIGHTS.
(   18) 
(   19) !     METHOD.
(   20) !     -------
(   21) 
(   22) !     -------
(   23) 
(   24) !          THE ZEROS OF THE *BESSEL FUNCTIONS ARE USED AS STARTING
(   25) !     APPROXIMATIONS FOR THE ABSCISSAS. NEWTON ITERATION IS USED TO
(   26) !     IMPROVE THE VALUES TO WITHIN A TOLLERENCE OF *EPS.*
(   27) 
(   28) !     EXTERNAL.
(   29) !     ---------
(   30) 






NVFORTRAN (Version     23.1)          02/24/2023  13:33:55      page 3

(   31) !          *BSSLZR_ODB* - ROUTINE TO OBTAIN ZEROS OF *BESSEL FUNCTIONS.
(   32) 
(   33) USE PARKIND1  ,ONLY : JPIM     ,JPRD
(   34) 
(   35) IMPLICIT NONE
(   36) 
(   37) #include "bsslzr_odb.h"
(   38) 
(   39) INTEGER(KIND=JPIM), intent(in)  :: K
(   40) REAL(KIND=JPRD), intent(out)    :: PA(K),PW(K)
(   41) INTEGER(KIND=JPIM), intent(out) :: KRET
(   42) ! === END OF INTERFACE BLOCK ===
(   43) 
(   44) REAL(KIND=JPRD) :: ZEPS = 1E-14_JPRD
(   45) REAL(KIND=JPRD) :: ZPI, ZC, ZXZ, ZKM2, ZKM1, ZFN, ZPK, ZKMRK, ZSP, ZVSP
(   46) INTEGER(KIND=JPIM) :: IFK, IKK, JS, ITER, JN, IL
(   47) 
(   48) !     ------------------------------------------------------------------
(   49) 
(   50) !*         1.     SET CONSTANTS AND FIND ZEROS OF BESSEL FUNCTION.
(   51) !                 --- --------- --- ---- ----- -- ------ ---------
(   52) 
(   53) KRET = 0
(   54) 
(   55) ZPI=2.0_JPRD*ASIN(1.0_JPRD)
(   56) ZC=(1.0_JPRD-(2.0_JPRD/ZPI)**2)*0.25_JPRD
(   57) IFK=K
(   58) IKK=K/2
(   59) 
(   60) CALL BSSLZR_ODB(PA,IKK)
(   61) 
(   62) DO JS=1,IKK
(   63)   ZXZ=COS(PA(JS)/SQRT((IFK+0.5_JPRD)**2+ZC))
(   64) !*                 GIVING THE FIRST APPROXIMATION FOR *ZXZ.*
(   65)   ITER=0
(   66) 
(   67) !     ------------------------------------------------------------------
(   68) 
(   69) !*         2.     COMPUTE ABSCISSAS AND WEIGHTS.
(   70) !                 ------- --------- --- -------
(   71) 
(   72) !*         2.1     SET VALUES FOR NEXT ITERATION.
(   73) 
(   74)   210    CONTINUE
(   75)   ZKM2=1.0_JPRD
(   76)   ZKM1=ZXZ
(   77)   ITER=ITER+1
(   78)   IF(ITER > 10) GO TO 300
(   79) 
(   80) !*         2.2     COMPUTATION OF THE *LEGENDRE POLYNOMIAL.
(   81) 
(   82)   DO JN=2,K
(   83)     ZFN=JN
(   84)     ZPK=((2.0_JPRD*ZFN-1.0_JPRD)*ZXZ*ZKM1-(ZFN-1.0_JPRD)*ZKM2)/ZFN
(   85)     ZKM2=ZKM1
(   86)     ZKM1=ZPK
(   87)   ENDDO
(   88) 






NVFORTRAN (Version     23.1)          02/24/2023  13:33:55      page 4

(   89)   ZKM1=ZKM2
(   90)   ZKMRK=(IFK*(ZKM1-ZXZ*ZPK))/(1.0_JPRD-ZXZ**2)
(   91)   ZSP=ZPK/ZKMRK
(   92)   ZXZ=ZXZ-ZSP
(   93)   ZVSP=ABS(ZSP)
(   94)   IF(ZVSP > ZEPS) GO TO 210
(   95) 
(   96) !*         2.3     ABSCISSAS AND WEIGHTS.
(   97) 
(   98)   PA(JS)=ZXZ
(   99)   PW(JS)=(2.0_JPRD*(1.0_JPRD-ZXZ**2))/(IFK*ZKM1)**2
(  100) 
(  101) !*         2.4     ODD *K* COMPUTATION OF WEIGHT AT THE EQUATOR.
(  102) 
(  103)   IF (K /= IKK*2) THEN
(  104)     PA(IKK+1)=0.
(  105)     ZPK=2.0_JPRD/IFK**2
(  106) 
(  107)     DO JN=2,K,2
(  108)       ZFN=JN
(  109)       ZPK=ZPK*ZFN**2/(ZFN-1.0_JPRD)**2
(  110)     ENDDO
(  111) 
(  112)     PW(IKK+1)=ZPK
(  113)   ELSE
(  114) 
(  115) !*         2.5     USE SYMMETRY TO OBTAIN REMAINING VALUES.
(  116) 
(  117)     DO JN=1,IKK
(  118)       IL=K+1-JN
(  119)       PA(IL)=-PA(JN)
(  120)       PW(IL)=PW(JN)
(  121)     ENDDO
(  122) 
(  123)   ENDIF
(  124) ENDDO
(  125) 
(  126) RETURN
(  127) 
(  128) !     ------------------------------------------------------------------
(  129) 
(  130) !*         3.     ERROR PROCESSING.
(  131) !                 ----- -----------
(  132) 
(  133) 300 CONTINUE
(  134) !WRITE(6,9901)
(  135) ! 9901 FORMAT(//,'  GAUAW_ODB FAILED TO CONVERGE AFTER 10 ITERATIONS.')
(  136) !STOP
(  137) KRET = 10
(  138) 
(  139) !     ------------------------------------------------------------------
(  140) 
(  141) END











NVFORTRAN (Version     23.1)          02/24/2023  13:33:55      page 5

(    1) # 1 "gauaw_odb.F90"
(    1) SUBROUTINE GAUAW_ODB(PA,PW,K,KRET)
(    2) # 3 "gauaw_odb.F90"
(    3) !**** *GAUAW_ODB* - COMPUTE ABSCISSAS AND WEIGHTS FOR *GAUSSIAN INTEGRATION.
(    4) # 5 "gauaw_odb.F90"
(    5) !     PURPOSE.
(    6) !     --------
(    7) # 8 "gauaw_odb.F90"
(    8) !          *GAUAW_ODB* IS CALLED TO COMPUTE THE ABSCISSAS AND WEIGHTS REQUIR
(    9) !     TO PERFORM *GAUSSIAN INTEGRATION.
(   10) # 11 "gauaw_odb.F90"
(   11) !**   INTERFACE.
(   12) !     ----------
(   13) # 14 "gauaw_odb.F90"
(   14) !          *CALL* *GAUAW_ODB(PA,PW,K)*
(   15) # 16 "gauaw_odb.F90"
(   16) !               *PA*     - ARRAY, LENGTH AT LEAST *K,* TO RECEIVE ABSCISSAS.
(   17) !               *PW*     - ARRAY, LENGTH AT LEAST *K,* TO RECEIVE WEIGHTS.
(   18) # 19 "gauaw_odb.F90"
(   19) !     METHOD.
(   20) !     -------
(   21) # 22 "gauaw_odb.F90"
(   22) !     -------
(   23) # 24 "gauaw_odb.F90"
(   24) !          THE ZEROS OF THE *BESSEL FUNCTIONS ARE USED AS STARTING
(   25) !     APPROXIMATIONS FOR THE ABSCISSAS. NEWTON ITERATION IS USED TO
(   26) !     IMPROVE THE VALUES TO WITHIN A TOLLERENCE OF *EPS.*
(   27) # 28 "gauaw_odb.F90"
(   28) !     EXTERNAL.
(   29) !     ---------
(   30) # 31 "gauaw_odb.F90"
(   31) !          *BSSLZR_ODB* - ROUTINE TO OBTAIN ZEROS OF *BESSEL FUNCTIONS.
(   32) # 33 "gauaw_odb.F90"
(   33) USE PARKIND1  ,ONLY : JPIM     ,JPRD
(   34) # 35 "gauaw_odb.F90"
(   35) IMPLICIT NONE
(   36) # 37 "gauaw_odb.F90"
(   37) # 1 ".D[65]/bsslzr_odb.h"
(    1) INTERFACE
(    2) SUBROUTINE BSSLZR_ODB(PBES,KNUM)
(    3) USE PARKIND1  ,ONLY : JPIM     ,JPRD
(    4) IMPLICIT NONE
(    5) INTEGER(KIND=JPIM), intent(in) :: KNUM
(    6) REAL(KIND=JPRD), intent(out)   :: PBES(KNUM)
(    7) END SUBROUTINE BSSLZR_ODB
(    8) END INTERFACE
(    9) # 38 "gauaw_odb.F90"
(   38) # 39 "gauaw_odb.F90"
(   39) INTEGER(KIND=JPIM), intent(in)  :: K
(   40) REAL(KIND=JPRD), intent(out)    :: PA(K),PW(K)
(   41) INTEGER(KIND=JPIM), intent(out) :: KRET
(   42) ! === END OF INTERFACE BLOCK ===
(   43) # 44 "gauaw_odb.F90"
(   44) REAL(KIND=JPRD) :: ZEPS = 1E-14_JPRD
(   45) REAL(KIND=JPRD) :: ZPI, ZC, ZXZ, ZKM2, ZKM1, ZFN, ZPK, ZKMRK, ZSP, ZVSP
(   46) INTEGER(KIND=JPIM) :: IFK, IKK, JS, ITER, JN, IL
(   47) # 48 "gauaw_odb.F90"
(   48) !     ------------------------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:33:55      page 6

(   49) # 50 "gauaw_odb.F90"
(   50) !*         1.     SET CONSTANTS AND FIND ZEROS OF BESSEL FUNCTION.
(   51) !                 --- --------- --- ---- ----- -- ------ ---------
(   52) # 53 "gauaw_odb.F90"
(   53) KRET = 0
(   54) # 55 "gauaw_odb.F90"
(   55) ZPI=2.0_JPRD*ASIN(1.0_JPRD)
(   56) ZC=(1.0_JPRD-(2.0_JPRD/ZPI)**2)*0.25_JPRD
(   57) IFK=K
(   58) IKK=K/2
(   59) # 60 "gauaw_odb.F90"
(   60) CALL BSSLZR_ODB(PA,IKK)
(   61) # 62 "gauaw_odb.F90"
(   62) DO JS=1,IKK
(   63)   ZXZ=COS(PA(JS)/SQRT((IFK+0.5_JPRD)**2+ZC))
(   64) !*                 GIVING THE FIRST APPROXIMATION FOR *ZXZ.*
(   65)   ITER=0
(   66) # 67 "gauaw_odb.F90"
(   67) !     ------------------------------------------------------------------
(   68) # 69 "gauaw_odb.F90"
(   69) !*         2.     COMPUTE ABSCISSAS AND WEIGHTS.
(   70) !                 ------- --------- --- -------
(   71) # 72 "gauaw_odb.F90"
(   72) !*         2.1     SET VALUES FOR NEXT ITERATION.
(   73) # 74 "gauaw_odb.F90"
(   74)   210    CONTINUE
(   75)   ZKM2=1.0_JPRD
(   76)   ZKM1=ZXZ
(   77)   ITER=ITER+1
(   78)   IF(ITER > 10) GO TO 300
(   79) # 80 "gauaw_odb.F90"
(   80) !*         2.2     COMPUTATION OF THE *LEGENDRE POLYNOMIAL.
(   81) # 82 "gauaw_odb.F90"
(   82)   DO JN=2,K
(   83)     ZFN=JN
(   84)     ZPK=((2.0_JPRD*ZFN-1.0_JPRD)*ZXZ*ZKM1-(ZFN-1.0_JPRD)*ZKM2)/ZFN
(   85)     ZKM2=ZKM1
(   86)     ZKM1=ZPK
(   87)   ENDDO
(   88) # 89 "gauaw_odb.F90"
(   89)   ZKM1=ZKM2
(   90)   ZKMRK=(IFK*(ZKM1-ZXZ*ZPK))/(1.0_JPRD-ZXZ**2)
(   91)   ZSP=ZPK/ZKMRK
(   92)   ZXZ=ZXZ-ZSP
(   93)   ZVSP=ABS(ZSP)
(   94)   IF(ZVSP > ZEPS) GO TO 210
(   95) # 96 "gauaw_odb.F90"
(   96) !*         2.3     ABSCISSAS AND WEIGHTS.
(   97) # 98 "gauaw_odb.F90"
(   98)   PA(JS)=ZXZ
(   99)   PW(JS)=(2.0_JPRD*(1.0_JPRD-ZXZ**2))/(IFK*ZKM1)**2
(  100) # 101 "gauaw_odb.F90"
(  101) !*         2.4     ODD *K* COMPUTATION OF WEIGHT AT THE EQUATOR.
(  102) # 103 "gauaw_odb.F90"
(  103)   IF (K /= IKK*2) THEN
(  104)     PA(IKK+1)=0.
(  105)     ZPK=2.0_JPRD/IFK**2
(  106) # 107 "gauaw_odb.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:55      page 7

(  107)     DO JN=2,K,2
(  108)       ZFN=JN
(  109)       ZPK=ZPK*ZFN**2/(ZFN-1.0_JPRD)**2
(  110)     ENDDO
(  111) # 112 "gauaw_odb.F90"
(  112)     PW(IKK+1)=ZPK
(  113)   ELSE
(  114) # 115 "gauaw_odb.F90"
(  115) !*         2.5     USE SYMMETRY TO OBTAIN REMAINING VALUES.
(  116) # 117 "gauaw_odb.F90"
(  117)     DO JN=1,IKK
(  118)       IL=K+1-JN
(  119)       PA(IL)=-PA(JN)
(  120)       PW(IL)=PW(JN)
(  121)     ENDDO
(  122) # 123 "gauaw_odb.F90"
(  123)   ENDIF
(  124) ENDDO
(  125) # 126 "gauaw_odb.F90"
(  126) RETURN
(  127) # 128 "gauaw_odb.F90"
(  128) !     ------------------------------------------------------------------
(  129) # 130 "gauaw_odb.F90"
(  130) !*         3.     ERROR PROCESSING.
(  131) !                 ----- -----------
(  132) # 133 "gauaw_odb.F90"
(  133) 300 CONTINUE
(  134) !WRITE(6,9901)
(  135) ! 9901 FORMAT(//,'  GAUAW_ODB FAILED TO CONVERGE AFTER 10 ITERATIONS.')
(  136) !STOP
(  137) KRET = 10
(  138) # 139 "gauaw_odb.F90"
(  139) !     ------------------------------------------------------------------
(  140) # 141 "gauaw_odb.F90"
(  141) END
