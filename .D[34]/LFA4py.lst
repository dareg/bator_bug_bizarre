


NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: LFA4py.F90

(    1) 
(    2) ! Wrappers to LFA library for Python (epygram)
(    3) 
(    4) subroutine wlfaouv(kreturncode, cdnomf, cdtypo, kul)
(    5) ! --------------------------------------------------------------------------
(    6) ! **** *WLFAOUV* Open a LFA file.
(    7) ! --------------------------------------------------------------------------
(    8) ! Input:
(    9) ! cdnomf      file name.
(   10) ! cdtypo      opening type: 'R' READ, 'W' WRITE, 'A' APPEND, 'S' SCRATCH.
(   11) ! Output:
(   12) ! kreturncode code error code
(   13) ! kul         logical unit of LFA file.
(   14) ! --------------------------------------------------------------------------
(   15) implicit none
(   16) #include"lfatail.h"
(   17) character*(*), intent(in) :: cdnomf
(   18) character*(*), intent(in) :: cdtypo
(   19) integer(kind=8), intent(out) :: kreturncode
(   20) integer(kind=8), intent(out) :: kul
(   21) 
(   22) INTEGER(KIND=jpintusr), PARAMETER :: JPMAXLOGICALUNITNUMBER=5000
(   23) INTEGER(KIND=jpintusr) :: INUMER
(   24) LOGICAL :: LLEXISTS, LLOPEN
(   25) 
(   26) integer(kind=jpintusr) :: iul
(   27) 
(   28) ! find a free logical unit
(   29) INUMER=10
(   30) LLEXISTS=.FALSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 3

(   31) LLOPEN=.TRUE.
(   32) DO WHILE(INUMER.LT.JPMAXLOGICALUNITNUMBER .AND. (LLOPEN .OR. .NOT. LLEXISTS))
(   33)   INUMER=INUMER+1
(   34)   INQUIRE(UNIT=INUMER, EXIST=LLEXISTS, OPENED=LLOPEN)
(   35) ENDDO
(   36) IF(LLOPEN .OR. .NOT. LLEXISTS) THEN
(   37)   KRETURNCODE=-999
(   38) ENDIF
(   39) 
(   40) ! (Re)-init of libgfortran to enable big_endian file reading
(   41) #ifdef __GFORTRAN__
(   42) CALL INIT_GFORTRAN_BIG_ENDIAN()
(   43) #endif
(   44) 
(   45) ! call lfaouv
(   46) iul = inumer
(   47) call lfaouv(iul, cdnomf, cdtypo)
(   48) kul = int(iul, 8)
(   49) ! (Re)-init of libgfortran to enable native endianess file reading
(   50) #ifdef __GFORTRAN__
(   51) CALL INIT_GFORTRAN_NATIVE_ENDIAN()
(   52) #endif
(   53) 
(   54) end subroutine wlfaouv
(   55) 
(   56) 
(   57) 
(   58) subroutine wlfafer(kul)
(   59) ! --------------------------------------------------------------------------
(   60) ! **** *WLFAFER* Close a LFA file.
(   61) ! --------------------------------------------------------------------------
(   62) ! Input:
(   63) ! kul        logical unit of LFA file.
(   64) ! Output:
(   65) ! --------------------------------------------------------------------------
(   66) implicit none
(   67) #include"lfatail.h"
(   68) integer(kind=8), intent(in) :: kul
(   69) 
(   70) integer(kind=jpintusr) :: iul
(   71) 
(   72) iul = int(kul, jpintusr)
(   73) call lfafer(iul)
(   74) 
(   75) end subroutine wlfafer
(   76) 
(   77) 
(   78) 
(   79) subroutine wlfaecrr(kul, cdna, preel, klong)
(   80) ! --------------------------------------------------------------------------
(   81) ! **** *WLFAECRR* Write real data on LFA file.
(   82) ! --------------------------------------------------------------------------
(   83) ! Input:
(   84) ! kul              logical unit of LFA file.
(   85) ! cdna             name of article to write.
(   86) ! preel(1,klong)   real data to write.
(   87) ! klong            length of article to write.
(   88) ! Output:






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 4

(   89) ! --------------------------------------------------------------------------
(   90) implicit none
(   91) #include"lfatail.h"
(   92) integer(kind=8), intent(in) :: kul, klong
(   93) character*(*), intent(in)   :: cdna
(   94) real(kind=8), intent(out)   :: preel(klong)
(   95) 
(   96) integer(kind=jpintusr) :: iul, ilong
(   97) real(kind=jpreeusr)    :: zreel(klong)
(   98) 
(   99) zreel = real(preel, jpreeusr)
(  100) iul = int(kul, jpintusr)
(  101) ilong = int(klong, jpintusr)
(  102) call lfaecrr(iul, cdna, zreel, ilong)
(  103) 
(  104) end subroutine wlfaecrr
(  105) 
(  106) 
(  107) 
(  108) subroutine wlfaecri(kul, cdna, kentier, klong)
(  109) ! --------------------------------------------------------------------------
(  110) ! **** *WLFAECRI* Write integer data of LFA file.
(  111) ! --------------------------------------------------------------------------
(  112) ! Input:
(  113) ! kul                  logical unit of LFA file.
(  114) ! cdna                 name of article to write.
(  115) ! kentier(1,klong)     integers to write.
(  116) ! klong                length of article to write.
(  117) ! Output:
(  118) ! --------------------------------------------------------------------------
(  119) implicit none
(  120) #include"lfatail.h"
(  121) integer(kind=8), intent(in) :: kul, klong
(  122) character*(*), intent(in) :: cdna
(  123) integer(kind=8), intent(in) :: kentier(klong)
(  124) 
(  125) integer(kind=jpintusr) :: iul, ilong
(  126) real(kind=jpreeusr)    :: ientier(klong)
(  127) 
(  128) ientier = real(kentier, jpreeusr)
(  129) iul = int(kul, jpintusr)
(  130) ilong = int(klong, jpintusr)
(  131) call lfaecri(iul, cdna, ientier, ilong)
(  132) 
(  133) end subroutine wlfaecri
(  134) 
(  135) 
(  136) 
(  137) subroutine wlfaecrc(kul, cdna, cdcar, klong)
(  138) ! --------------------------------------------------------------------------
(  139) ! **** *WLFAECRC* Write character data on LFA file.
(  140) ! --------------------------------------------------------------------------
(  141) ! Input:
(  142) ! kul              logical unit of LFA file.
(  143) ! cdna             name of article to write.
(  144) ! cdcar(1,klong)   characters to write.
(  145) ! klong            length of article to write.
(  146) ! Output:






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 5

(  147) ! --------------------------------------------------------------------------
(  148) implicit none
(  149) #include"lfatail.h"
(  150) integer(kind=8), intent(in) :: kul, klong
(  151) character*(*), intent(in) :: cdna
(  152) character*(*), intent(in) :: cdcar(klong)
(  153) 
(  154) integer(kind=jpintusr) :: iul, ilong
(  155) 
(  156) iul = int(kul, jpintusr)
(  157) ilong = int(klong, jpintusr)
(  158) call lfaecrc(iul, cdna, cdcar, ilong)
(  159) 
(  160) end subroutine wlfaecrc
(  161) 
(  162) 
(  163) 
(  164) subroutine wlfalecr(kreturncode, kul, cdna, kdimb, preel, klong)
(  165) ! --------------------------------------------------------------------------
(  166) ! **** *WLFALECR* Read real data on LFA file.
(  167) ! --------------------------------------------------------------------------
(  168) ! Input:
(  169) ! kul              logical unit of LFA file.
(  170) ! cdna             article name.
(  171) ! kdimb            physical dimension of array preel.
(  172) ! Output:
(  173) ! kreturncode error code
(  174) ! preel(1,klong)   real elements read.
(  175) ! klong            number of real elements read.
(  176) ! --------------------------------------------------------------------------
(  177) implicit none
(  178) #include"lfatail.h"
(  179) integer(kind=8), intent(in) :: kul, kdimb
(  180) character*(*), intent(in) :: cdna
(  181) integer(kind=8), intent(out) :: kreturncode
(  182) real(kind=8), intent(out) :: preel(kdimb)
(  183) integer(kind=8), intent(out) :: klong
(  184) 
(  185) real(kind=jpreeusr)    :: zreel(kdimb)
(  186) integer(kind=jpintusr) :: iul, idimb
(  187) integer(kind=jpintusr) :: ilong
(  188) integer(kind=jpintusr) :: ierr
(  189) 
(  190) iul = int(kul, jpintusr)
(  191) idimb = int(kdimb, jpintusr)
(  192) call lfalecr(iul, cdna, idimb, zreel, ilong, ierr)
(  193) preel = real(zreel, 8)
(  194) klong = int(ilong, 8)
(  195) kreturncode = int(ierr, 8)
(  196) 
(  197) end subroutine wlfalecr
(  198) 
(  199) 
(  200) 
(  201) subroutine wlfaleci(kreturncode, kul, cdna, kdimb, kentier, klong)
(  202) ! --------------------------------------------------------------------------
(  203) ! **** *WLFALECI* Read integer data on LFA file.
(  204) ! --------------------------------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 6

(  205) ! Input:
(  206) ! kul              logical unit of LFA file.
(  207) ! cdna             article name.
(  208) ! kdimb            physical dimension of array kentier.
(  209) ! Output:
(  210) ! kreturncode      error code
(  211) ! kentier(1,klong) integer elements read.
(  212) ! klong            number of integer elements read.
(  213) ! --------------------------------------------------------------------------
(  214) implicit none
(  215) #include"lfatail.h"
(  216) integer(kind=8), intent(in) :: kul, kdimb
(  217) character*(*), intent(in) :: cdna
(  218) integer(kind=8), intent(out) :: kreturncode
(  219) integer(kind=8), intent(out) :: kentier(kdimb)
(  220) integer(kind=8), intent(out) :: klong
(  221) 
(  222) integer(kind=jpintusr) :: ientier(kdimb)
(  223) integer(kind=jpintusr) :: iul, idimb
(  224) integer(kind=jpintusr) :: ilong
(  225) integer(kind=jpintusr) :: ierr
(  226) 
(  227) iul = int(kul, jpintusr)
(  228) idimb = int(kdimb, jpintusr)
(  229) call lfaleci(iul, cdna, idimb, ientier, ilong, ierr)
(  230) kentier = int(ientier, 8)
(  231) kreturncode = int(ierr, 8)
(  232) klong = int(ilong, 8)
(  233) 
(  234) end subroutine wlfaleci
(  235) 
(  236) 
(  237) 
(  238) subroutine wlfalecc(kreturncode, kul, cdna, kdimb, klenc, clcar, klong)
(  239) ! --------------------------------------------------------------------------
(  240) ! **** *WLFALECC* Read character data on LFA file.
(  241) ! --------------------------------------------------------------------------
(  242) ! Input:
(  243) ! kul              logical unit of LFA file.
(  244) ! cdna             article name.
(  245) ! kdimb            physical dimension of array clcar.
(  246) ! klenc            max length of strings in clcar
(  247) ! Output:
(  248) ! kreturncode      error code
(  249) ! clcar            array of elements read. 
(  250) ! klong            number of character elements read.
(  251) ! --------------------------------------------------------------------------
(  252) implicit none
(  253) #include"lfatail.h"
(  254) integer(kind=8), intent(in) :: kul, kdimb, klenc
(  255) character*(*), intent(in) :: cdna
(  256) integer(kind=8), intent(out) :: kreturncode
(  257) character(len=klenc), intent(out) :: clcar(kdimb)
(  258) integer(kind=8), intent(out) :: klong
(  259) 
(  260) integer(kind=jpintusr) :: iul, idimb
(  261) integer(kind=jpintusr) :: ireturncode
(  262) integer(kind=jpintusr) :: ilong






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 7

(  263) 
(  264) iul = int(kul, jpintusr)
(  265) idimb = int(kdimb, jpintusr)
(  266) call lfalecc(iul, cdna, idimb, clcar, ilong, ireturncode)
(  267) klong = int(ilong, 8)
(  268) kreturncode = int(ireturncode, 8)
(  269) 
(  270) end subroutine wlfalecc
(  271) 
(  272) 
(  273) 
(  274) subroutine wlfacas(kreturncode, kul, cdna, cdtype, klong)
(  275) ! --------------------------------------------------------------------------
(  276) ! **** *WLFACAS* Get documentation about a LFA article.
(  277) ! --------------------------------------------------------------------------
(  278) ! Input:
(  279) ! kul               file logical unit.
(  280) ! cdna:             name of required article.
(  281) ! Output:
(  282) ! kreturncode       error code
(  283) ! cdtype            article type: 'R4', 'I8', 'C '.
(  284) ! klong             number of elements in this article.
(  285) ! --------------------------------------------------------------------------
(  286) implicit none
(  287) #include"lfatail.h"
(  288) integer(kind=8), intent(in) :: kul
(  289) character*(*), intent(in) :: cdna
(  290) integer(kind=8), intent(out) :: kreturncode
(  291) character(len=2), intent(out) :: cdtype
(  292) integer(kind=8), intent(out) :: klong
(  293) 
(  294) integer(kind=jpintusr) :: ierr
(  295) integer(kind=jpintusr) :: iul
(  296) integer(kind=jpintusr) :: ilong
(  297) 
(  298) iul = int(kul, jpintusr)
(  299) call lfacas(iul, cdna, cdtype, ilong, ierr)
(  300) klong = int(ilong, 8)
(  301) kreturncode=int(ierr, 8)
(  302) 
(  303) end subroutine wlfacas
(  304) 
(  305) 
(  306) 
(  307) subroutine wlfalaft(kul, kdlis, klenc, knlis, cclis)
(  308) ! --------------------------------------------------------------------------
(  309) ! **** *WLFALAFT* Article list of a LFA file, on an array.
(  310) ! --------------------------------------------------------------------------
(  311) ! Input:
(  312) ! kul            logical unit of LFA file.
(  313) ! kdlis          physical dimension of array cdlis.
(  314) ! klenc            max length of strings in clcar
(  315) ! Output:
(  316) ! knlis          number of articles on the file. This number is also
(  317) !                the number of elements written on cclis.
(  318) ! cclis          array of article names.
(  319) ! --------------------------------------------------------------------------
(  320) implicit none






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 8

(  321) #include"lfatail.h"
(  322) integer(kind=8), intent(in) :: kul, kdlis, klenc
(  323) integer(kind=8), intent(out) :: knlis
(  324) character(len=klenc), intent(out) :: cclis(kdlis)
(  325) 
(  326) integer(kind=jpintusr) :: iul, idlis
(  327) integer(kind=jpintusr) :: inlis
(  328) 
(  329) iul = int(kul, jpintusr)
(  330) idlis = int(kdlis, jpintusr)
(  331) call lfalaft(iul, cclis, idlis, inlis)
(  332) knlis = int(inlis, 8)
(  333) 
(  334) end subroutine wlfalaft
(  335) 
(  336) 
(  337) 
(  338) subroutine wlfatest(kreturncode, cdnomf, ldlfa)
(  339) ! --------------------------------------------------------------------------
(  340) ! **** *WLFATEST* Test if a file is a LFA one.
(  341) ! --------------------------------------------------------------------------
(  342) ! Input:
(  343) ! cdnomf      file name.
(  344) ! Output:
(  345) ! kreturncode     code error code
(  346) ! ldlfa=.true. if the file is a LFA one, .false. else case.
(  347) ! --------------------------------------------------------------------------
(  348) implicit none
(  349) #include"lfatail.h"
(  350) character*(*), intent(in) :: cdnomf
(  351) integer(kind=8), intent(out) :: kreturncode
(  352) logical, intent(out) :: ldlfa
(  353) 
(  354) INTEGER(KIND=jpintusr), PARAMETER :: JPMAXLOGICALUNITNUMBER=5000
(  355) INTEGER(KIND=jpintusr) :: INUMER
(  356) LOGICAL :: LLEXISTS, LLOPEN
(  357) 
(  358) ! find a free logical unit
(  359) INUMER=10
(  360) LLEXISTS=.FALSE.
(  361) LLOPEN=.TRUE.
(  362) DO WHILE(INUMER.LT.JPMAXLOGICALUNITNUMBER .AND. (LLOPEN .OR. .NOT. LLEXISTS))
(  363)   INUMER=INUMER+1
(  364)   INQUIRE(UNIT=INUMER, EXIST=LLEXISTS, OPENED=LLOPEN)
(  365) ENDDO
(  366) IF(LLOPEN .OR. .NOT. LLEXISTS) THEN
(  367)   KRETURNCODE=-999
(  368) ENDIF
(  369) 
(  370) ! (Re)-init of libgfortran to enable big_endian file reading
(  371) #ifdef __GFORTRAN__
(  372) CALL INIT_GFORTRAN_BIG_ENDIAN()
(  373) #endif
(  374) 
(  375) call lfatest(INUMER, cdnomf, ldlfa)
(  376) 
(  377) ! (Re)-init of libgfortran to enable native endianess file reading
(  378) #ifdef __GFORTRAN__






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 9

(  379) CALL INIT_GFORTRAN_NATIVE_ENDIAN()
(  380) #endif
(  381) 
(  382) end subroutine wlfatest
(  383) 
(  384) 
(  385) 

























































NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 10

(    1) # 1 "LFA4py.F90"
(    1) # 2 "LFA4py.F90"
(    2) ! Wrappers to LFA library for Python (epygram)
(    3) # 4 "LFA4py.F90"
(    4) subroutine wlfaouv(kreturncode, cdnomf, cdtypo, kul)
(    5) ! --------------------------------------------------------------------------
(    6) ! **** *WLFAOUV* Open a LFA file.
(    7) ! --------------------------------------------------------------------------
(    8) ! Input:
(    9) ! cdnomf      file name.
(   10) ! cdtypo      opening type: 'R' READ, 'W' WRITE, 'A' APPEND, 'S' SCRATCH.
(   11) ! Output:
(   12) ! kreturncode code error code
(   13) ! kul         logical unit of LFA file.
(   14) ! --------------------------------------------------------------------------
(   15) implicit none
(   16) # 16 "LFA4py.F90"
(   16) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 17 "LFA4py.F90"
(   17) # 17 "LFA4py.F90"
(   17) character*(*), intent(in) :: cdnomf
(   18) character*(*), intent(in) :: cdtypo
(   19) integer(kind=8), intent(out) :: kreturncode
(   20) integer(kind=8), intent(out) :: kul
(   21) # 22 "LFA4py.F90"
(   22) INTEGER(KIND=jpintusr), PARAMETER :: JPMAXLOGICALUNITNUMBER=5000






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 11

(   23) INTEGER(KIND=jpintusr) :: INUMER
(   24) LOGICAL :: LLEXISTS, LLOPEN
(   25) # 26 "LFA4py.F90"
(   26) integer(kind=jpintusr) :: iul
(   27) # 28 "LFA4py.F90"
(   28) ! find a free logical unit
(   29) INUMER=10
(   30) LLEXISTS=.FALSE.
(   31) LLOPEN=.TRUE.
(   32) DO WHILE(INUMER.LT.JPMAXLOGICALUNITNUMBER .AND. (LLOPEN .OR. .NOT. LLEXISTS))
(   33)   INUMER=INUMER+1
(   34)   INQUIRE(UNIT=INUMER, EXIST=LLEXISTS, OPENED=LLOPEN)
(   35) ENDDO
(   36) IF(LLOPEN .OR. .NOT. LLEXISTS) THEN
(   37)   KRETURNCODE=-999
(   38) ENDIF
(   39) # 40 "LFA4py.F90"
(   40) ! (Re)-init of libgfortran to enable big_endian file reading
(   41) # 45 "LFA4py.F90"
(   45) ! call lfaouv
(   46) iul = inumer
(   47) call lfaouv(iul, cdnomf, cdtypo)
(   48) kul = int(iul, 8)
(   49) ! (Re)-init of libgfortran to enable native endianess file reading
(   50) # 54 "LFA4py.F90"
(   54) end subroutine wlfaouv
(   55) # 58 "LFA4py.F90"
(   58) subroutine wlfafer(kul)
(   59) ! --------------------------------------------------------------------------
(   60) ! **** *WLFAFER* Close a LFA file.
(   61) ! --------------------------------------------------------------------------
(   62) ! Input:
(   63) ! kul        logical unit of LFA file.
(   64) ! Output:
(   65) ! --------------------------------------------------------------------------
(   66) implicit none
(   67) # 67 "LFA4py.F90"
(   67) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 12

(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 68 "LFA4py.F90"
(   68) # 68 "LFA4py.F90"
(   68) integer(kind=8), intent(in) :: kul
(   69) # 70 "LFA4py.F90"
(   70) integer(kind=jpintusr) :: iul
(   71) # 72 "LFA4py.F90"
(   72) iul = int(kul, jpintusr)
(   73) call lfafer(iul)
(   74) # 75 "LFA4py.F90"
(   75) end subroutine wlfafer
(   76) # 79 "LFA4py.F90"
(   79) subroutine wlfaecrr(kul, cdna, preel, klong)
(   80) ! --------------------------------------------------------------------------
(   81) ! **** *WLFAECRR* Write real data on LFA file.
(   82) ! --------------------------------------------------------------------------
(   83) ! Input:
(   84) ! kul              logical unit of LFA file.
(   85) ! cdna             name of article to write.
(   86) ! preel(1,klong)   real data to write.
(   87) ! klong            length of article to write.
(   88) ! Output:
(   89) ! --------------------------------------------------------------------------
(   90) implicit none
(   91) # 91 "LFA4py.F90"
(   91) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 13

(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 92 "LFA4py.F90"
(   92) # 92 "LFA4py.F90"
(   92) integer(kind=8), intent(in) :: kul, klong
(   93) character*(*), intent(in)   :: cdna
(   94) real(kind=8), intent(out)   :: preel(klong)
(   95) # 96 "LFA4py.F90"
(   96) integer(kind=jpintusr) :: iul, ilong
(   97) real(kind=jpreeusr)    :: zreel(klong)
(   98) # 99 "LFA4py.F90"
(   99) zreel = real(preel, jpreeusr)
(  100) iul = int(kul, jpintusr)
(  101) ilong = int(klong, jpintusr)
(  102) call lfaecrr(iul, cdna, zreel, ilong)
(  103) # 104 "LFA4py.F90"
(  104) end subroutine wlfaecrr
(  105) # 108 "LFA4py.F90"
(  108) subroutine wlfaecri(kul, cdna, kentier, klong)
(  109) ! --------------------------------------------------------------------------
(  110) ! **** *WLFAECRI* Write integer data of LFA file.
(  111) ! --------------------------------------------------------------------------
(  112) ! Input:
(  113) ! kul                  logical unit of LFA file.
(  114) ! cdna                 name of article to write.
(  115) ! kentier(1,klong)     integers to write.
(  116) ! klong                length of article to write.
(  117) ! Output:
(  118) ! --------------------------------------------------------------------------
(  119) implicit none
(  120) # 120 "LFA4py.F90"
(  120) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 14

(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 121 "LFA4py.F90"
(  121) # 121 "LFA4py.F90"
(  121) integer(kind=8), intent(in) :: kul, klong
(  122) character*(*), intent(in) :: cdna
(  123) integer(kind=8), intent(in) :: kentier(klong)
(  124) # 125 "LFA4py.F90"
(  125) integer(kind=jpintusr) :: iul, ilong
(  126) real(kind=jpreeusr)    :: ientier(klong)
(  127) # 128 "LFA4py.F90"
(  128) ientier = real(kentier, jpreeusr)
(  129) iul = int(kul, jpintusr)
(  130) ilong = int(klong, jpintusr)
(  131) call lfaecri(iul, cdna, ientier, ilong)
(  132) # 133 "LFA4py.F90"
(  133) end subroutine wlfaecri
(  134) # 137 "LFA4py.F90"
(  137) subroutine wlfaecrc(kul, cdna, cdcar, klong)
(  138) ! --------------------------------------------------------------------------
(  139) ! **** *WLFAECRC* Write character data on LFA file.
(  140) ! --------------------------------------------------------------------------
(  141) ! Input:
(  142) ! kul              logical unit of LFA file.
(  143) ! cdna             name of article to write.
(  144) ! cdcar(1,klong)   characters to write.
(  145) ! klong            length of article to write.
(  146) ! Output:
(  147) ! --------------------------------------------------------------------------
(  148) implicit none
(  149) # 149 "LFA4py.F90"
(  149) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 15

(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 150 "LFA4py.F90"
(  150) # 150 "LFA4py.F90"
(  150) integer(kind=8), intent(in) :: kul, klong
(  151) character*(*), intent(in) :: cdna
(  152) character*(*), intent(in) :: cdcar(klong)
(  153) # 154 "LFA4py.F90"
(  154) integer(kind=jpintusr) :: iul, ilong
(  155) # 156 "LFA4py.F90"
(  156) iul = int(kul, jpintusr)
(  157) ilong = int(klong, jpintusr)
(  158) call lfaecrc(iul, cdna, cdcar, ilong)
(  159) # 160 "LFA4py.F90"
(  160) end subroutine wlfaecrc
(  161) # 164 "LFA4py.F90"
(  164) subroutine wlfalecr(kreturncode, kul, cdna, kdimb, preel, klong)
(  165) ! --------------------------------------------------------------------------
(  166) ! **** *WLFALECR* Read real data on LFA file.
(  167) ! --------------------------------------------------------------------------
(  168) ! Input:
(  169) ! kul              logical unit of LFA file.
(  170) ! cdna             article name.
(  171) ! kdimb            physical dimension of array preel.
(  172) ! Output:
(  173) ! kreturncode error code
(  174) ! preel(1,klong)   real elements read.
(  175) ! klong            number of real elements read.
(  176) ! --------------------------------------------------------------------------
(  177) implicit none
(  178) # 178 "LFA4py.F90"
(  178) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 16

(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 179 "LFA4py.F90"
(  179) # 179 "LFA4py.F90"
(  179) integer(kind=8), intent(in) :: kul, kdimb
(  180) character*(*), intent(in) :: cdna
(  181) integer(kind=8), intent(out) :: kreturncode
(  182) real(kind=8), intent(out) :: preel(kdimb)
(  183) integer(kind=8), intent(out) :: klong
(  184) # 185 "LFA4py.F90"
(  185) real(kind=jpreeusr)    :: zreel(kdimb)
(  186) integer(kind=jpintusr) :: iul, idimb
(  187) integer(kind=jpintusr) :: ilong
(  188) integer(kind=jpintusr) :: ierr
(  189) # 190 "LFA4py.F90"
(  190) iul = int(kul, jpintusr)
(  191) idimb = int(kdimb, jpintusr)
(  192) call lfalecr(iul, cdna, idimb, zreel, ilong, ierr)
(  193) preel = real(zreel, 8)
(  194) klong = int(ilong, 8)
(  195) kreturncode = int(ierr, 8)
(  196) # 197 "LFA4py.F90"
(  197) end subroutine wlfalecr
(  198) # 201 "LFA4py.F90"
(  201) subroutine wlfaleci(kreturncode, kul, cdna, kdimb, kentier, klong)
(  202) ! --------------------------------------------------------------------------
(  203) ! **** *WLFALECI* Read integer data on LFA file.
(  204) ! --------------------------------------------------------------------------
(  205) ! Input:
(  206) ! kul              logical unit of LFA file.
(  207) ! cdna             article name.
(  208) ! kdimb            physical dimension of array kentier.
(  209) ! Output:
(  210) ! kreturncode      error code
(  211) ! kentier(1,klong) integer elements read.
(  212) ! klong            number of integer elements read.
(  213) ! --------------------------------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 17

(  214) implicit none
(  215) # 215 "LFA4py.F90"
(  215) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 216 "LFA4py.F90"
(  216) # 216 "LFA4py.F90"
(  216) integer(kind=8), intent(in) :: kul, kdimb
(  217) character*(*), intent(in) :: cdna
(  218) integer(kind=8), intent(out) :: kreturncode
(  219) integer(kind=8), intent(out) :: kentier(kdimb)
(  220) integer(kind=8), intent(out) :: klong
(  221) # 222 "LFA4py.F90"
(  222) integer(kind=jpintusr) :: ientier(kdimb)
(  223) integer(kind=jpintusr) :: iul, idimb
(  224) integer(kind=jpintusr) :: ilong
(  225) integer(kind=jpintusr) :: ierr
(  226) # 227 "LFA4py.F90"
(  227) iul = int(kul, jpintusr)
(  228) idimb = int(kdimb, jpintusr)
(  229) call lfaleci(iul, cdna, idimb, ientier, ilong, ierr)
(  230) kentier = int(ientier, 8)
(  231) kreturncode = int(ierr, 8)
(  232) klong = int(ilong, 8)
(  233) # 234 "LFA4py.F90"
(  234) end subroutine wlfaleci
(  235) # 238 "LFA4py.F90"
(  238) subroutine wlfalecc(kreturncode, kul, cdna, kdimb, klenc, clcar, klong)






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 18

(  239) ! --------------------------------------------------------------------------
(  240) ! **** *WLFALECC* Read character data on LFA file.
(  241) ! --------------------------------------------------------------------------
(  242) ! Input:
(  243) ! kul              logical unit of LFA file.
(  244) ! cdna             article name.
(  245) ! kdimb            physical dimension of array clcar.
(  246) ! klenc            max length of strings in clcar
(  247) ! Output:
(  248) ! kreturncode      error code
(  249) ! clcar            array of elements read. 
(  250) ! klong            number of character elements read.
(  251) ! --------------------------------------------------------------------------
(  252) implicit none
(  253) # 253 "LFA4py.F90"
(  253) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 254 "LFA4py.F90"
(  254) # 254 "LFA4py.F90"
(  254) integer(kind=8), intent(in) :: kul, kdimb, klenc
(  255) character*(*), intent(in) :: cdna
(  256) integer(kind=8), intent(out) :: kreturncode
(  257) character(len=klenc), intent(out) :: clcar(kdimb)
(  258) integer(kind=8), intent(out) :: klong
(  259) # 260 "LFA4py.F90"
(  260) integer(kind=jpintusr) :: iul, idimb
(  261) integer(kind=jpintusr) :: ireturncode






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 19

(  262) integer(kind=jpintusr) :: ilong
(  263) # 264 "LFA4py.F90"
(  264) iul = int(kul, jpintusr)
(  265) idimb = int(kdimb, jpintusr)
(  266) call lfalecc(iul, cdna, idimb, clcar, ilong, ireturncode)
(  267) klong = int(ilong, 8)
(  268) kreturncode = int(ireturncode, 8)
(  269) # 270 "LFA4py.F90"
(  270) end subroutine wlfalecc
(  271) # 274 "LFA4py.F90"
(  274) subroutine wlfacas(kreturncode, kul, cdna, cdtype, klong)
(  275) ! --------------------------------------------------------------------------
(  276) ! **** *WLFACAS* Get documentation about a LFA article.
(  277) ! --------------------------------------------------------------------------
(  278) ! Input:
(  279) ! kul               file logical unit.
(  280) ! cdna:             name of required article.
(  281) ! Output:
(  282) ! kreturncode       error code
(  283) ! cdtype            article type: 'R4', 'I8', 'C '.
(  284) ! klong             number of elements in this article.
(  285) ! --------------------------------------------------------------------------
(  286) implicit none
(  287) # 287 "LFA4py.F90"
(  287) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 288 "LFA4py.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 20

(  288) # 288 "LFA4py.F90"
(  288) integer(kind=8), intent(in) :: kul
(  289) character*(*), intent(in) :: cdna
(  290) integer(kind=8), intent(out) :: kreturncode
(  291) character(len=2), intent(out) :: cdtype
(  292) integer(kind=8), intent(out) :: klong
(  293) # 294 "LFA4py.F90"
(  294) integer(kind=jpintusr) :: ierr
(  295) integer(kind=jpintusr) :: iul
(  296) integer(kind=jpintusr) :: ilong
(  297) # 298 "LFA4py.F90"
(  298) iul = int(kul, jpintusr)
(  299) call lfacas(iul, cdna, cdtype, ilong, ierr)
(  300) klong = int(ilong, 8)
(  301) kreturncode=int(ierr, 8)
(  302) # 303 "LFA4py.F90"
(  303) end subroutine wlfacas
(  304) # 307 "LFA4py.F90"
(  307) subroutine wlfalaft(kul, kdlis, klenc, knlis, cclis)
(  308) ! --------------------------------------------------------------------------
(  309) ! **** *WLFALAFT* Article list of a LFA file, on an array.
(  310) ! --------------------------------------------------------------------------
(  311) ! Input:
(  312) ! kul            logical unit of LFA file.
(  313) ! kdlis          physical dimension of array cdlis.
(  314) ! klenc            max length of strings in clcar
(  315) ! Output:
(  316) ! knlis          number of articles on the file. This number is also
(  317) !                the number of elements written on cclis.
(  318) ! cclis          array of article names.
(  319) ! --------------------------------------------------------------------------
(  320) implicit none
(  321) # 321 "LFA4py.F90"
(  321) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!
(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 21

(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 322 "LFA4py.F90"
(  322) # 322 "LFA4py.F90"
(  322) integer(kind=8), intent(in) :: kul, kdlis, klenc
(  323) integer(kind=8), intent(out) :: knlis
(  324) character(len=klenc), intent(out) :: cclis(kdlis)
(  325) # 326 "LFA4py.F90"
(  326) integer(kind=jpintusr) :: iul, idlis
(  327) integer(kind=jpintusr) :: inlis
(  328) # 329 "LFA4py.F90"
(  329) iul = int(kul, jpintusr)
(  330) idlis = int(kdlis, jpintusr)
(  331) call lfalaft(iul, cclis, idlis, inlis)
(  332) knlis = int(inlis, 8)
(  333) # 334 "LFA4py.F90"
(  334) end subroutine wlfalaft
(  335) # 338 "LFA4py.F90"
(  338) subroutine wlfatest(kreturncode, cdnomf, ldlfa)
(  339) ! --------------------------------------------------------------------------
(  340) ! **** *WLFATEST* Test if a file is a LFA one.
(  341) ! --------------------------------------------------------------------------
(  342) ! Input:
(  343) ! cdnomf      file name.
(  344) ! Output:
(  345) ! kreturncode     code error code
(  346) ! ldlfa=.true. if the file is a LFA one, .false. else case.
(  347) ! --------------------------------------------------------------------------
(  348) implicit none
(  349) # 349 "LFA4py.F90"
(  349) # 1 ".D[33]/lfatail.h"
(    1) 	!
(    2) 	!-------------------------------------------------
(    3) 	! Taille en octets des entiers et reels
(    4) 	! que l'utilisateur a l'intention de passer
(    5) 	! en argument au logiciel LFA.
(    6) 	!-------------------------------------------------
(    7) 	!
(    8) 	integer, parameter :: jpreeusr=8 ! reels
(    9) 	integer, parameter :: jpintusr=4 ! entiers
(   10) 	!
(   11) 	!-------------------------------------------------
(   12) 	! Taille en octets des entiers et reels
(   13) 	! que l'utilisateur a l'intention d'ecrire par defaut
(   14) 	! sur les fichiers.
(   15) 	! Cette taille peut etre modifiee
(   16) 	! lors de l'execution, par appel a lfaprec.
(   17) 	!-------------------------------------------------
(   18) 	!
(   19) 	integer, parameter :: jpreedef=8 ! reels
(   20) 	integer, parameter :: jpintdef=4 ! entiers
(   21) 	!






NVFORTRAN (Version     23.1)          02/24/2023  13:30:51      page 22

(   22) 	!-------------------------------------------------
(   23) 	! Taille en octets des entiers a usage interne LFA,
(   24) 	! et qui renseignent dans le fichier
(   25) 	! la version du logiciel, la taille des articles, etc...
(   26) 	! Afin que les fichiers soient relisibles 
(   27) 	! entre les differentes versions du logiciel LFA
(   28) 	! et les differentes precisions possibles,
(   29) 	! NE PAS CHANGER la valeur 4 ci-dessous.
(   30) 	!-------------------------------------------------
(   31) 	!
(   32) 	integer, parameter :: jpintesb=4 ! entiers
(   33) # 350 "LFA4py.F90"
(  350) # 350 "LFA4py.F90"
(  350) character*(*), intent(in) :: cdnomf
(  351) integer(kind=8), intent(out) :: kreturncode
(  352) logical, intent(out) :: ldlfa
(  353) # 354 "LFA4py.F90"
(  354) INTEGER(KIND=jpintusr), PARAMETER :: JPMAXLOGICALUNITNUMBER=5000
(  355) INTEGER(KIND=jpintusr) :: INUMER
(  356) LOGICAL :: LLEXISTS, LLOPEN
(  357) # 358 "LFA4py.F90"
(  358) ! find a free logical unit
(  359) INUMER=10
(  360) LLEXISTS=.FALSE.
(  361) LLOPEN=.TRUE.
(  362) DO WHILE(INUMER.LT.JPMAXLOGICALUNITNUMBER .AND. (LLOPEN .OR. .NOT. LLEXISTS))
(  363)   INUMER=INUMER+1
(  364)   INQUIRE(UNIT=INUMER, EXIST=LLEXISTS, OPENED=LLOPEN)
(  365) ENDDO
(  366) IF(LLOPEN .OR. .NOT. LLEXISTS) THEN
(  367)   KRETURNCODE=-999
(  368) ENDIF
(  369) # 370 "LFA4py.F90"
(  370) ! (Re)-init of libgfortran to enable big_endian file reading
(  371) # 375 "LFA4py.F90"
(  375) call lfatest(INUMER, cdnomf, ldlfa)
(  376) # 377 "LFA4py.F90"
(  377) ! (Re)-init of libgfortran to enable native endianess file reading
(  378) # 382 "LFA4py.F90"
(  382) end subroutine wlfatest
