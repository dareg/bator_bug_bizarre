


NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: decompress.F90

(    1) !-----------------------------------------------------------------
(    2) !--------------- special set of characters for RCS information
(    3) !-----------------------------------------------------------------
(    4) ! $Source: /home/cvsroot/mesonh/libtools/lib/COMPRESS/src/decompress.f90,v $ $Revision: 1.1.4.1 $ $Date: 2008/04/10 10:23:35
(    5) !-----------------------------------------------------------------
(    6) SUBROUTINE GET_COMPHEADER(KTAB,SIZEKTAB,KNBELT,KTYPECOD)
(    7) 
(    8) INTEGER, INTENT(IN) :: SIZEKTAB
(    9) INTEGER(KIND=8), DIMENSION(SIZEKTAB), INTENT(IN) :: KTAB
(   10) INTEGER, INTENT(OUT) :: KNBELT    ! size of decompressed array
(   11) INTEGER, INTENT(OUT) :: KTYPECOD  ! code for compression type
(   12) 
(   13) CHARACTER(LEN=8) :: STRKEY
(   14) 
(   15) INTEGER :: INTCHAR
(   16) INTEGER :: JI
(   17) 
(   18) CALL SET_EXTRACTIDX(0,0)
(   19) ! extract string header 
(   20) DO JI=1,8
(   21)   CALL EXTRACT_BBUFF(KTAB,8,INTCHAR)
(   22)   STRKEY(JI:JI) = CHAR(INTCHAR)
(   23) END DO
(   24) 
(   25) ! Treat array if it is compressed
(   26) IF (STRKEY == 'COMPRESS') THEN
(   27)   CALL EXTRACT_BBUFF(KTAB,32,KTYPECOD)
(   28)   CALL EXTRACT_BBUFF(KTAB,32,KNBELT)
(   29) ELSE
(   30)   KNBELT    =-1






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 3

(   31)   KTYPECOD = 0
(   32) END IF
(   33) 
(   34) END SUBROUTINE GET_COMPHEADER
(   35) 
(   36) SUBROUTINE DECOMPRESS_FIELD(XTAB,NBELT,COMPTAB,NBCOMPELT,CODINGTYPE)
(   37) USE MODD_COMPPAR
(   38) USE MODE_SEARCHGRP
(   39) 
(   40) IMPLICIT NONE 
(   41) INTEGER,                                INTENT(IN)  :: NBELT 
(   42) INTEGER,                                INTENT(IN)  :: NBCOMPELT 
(   43) REAL   (KIND=8),DIMENSION(NBELT),TARGET,INTENT(OUT) :: XTAB
(   44) INTEGER(KIND=8),DIMENSION(NBCOMPELT),   INTENT(IN)  :: COMPTAB
(   45) INTEGER,                                INTENT(IN)  :: CODINGTYPE
(   46) 
(   47) INTEGER,DIMENSION(:), ALLOCATABLE  :: ITAB
(   48) LOGICAL,DIMENSION(:), ALLOCATABLE  :: GMASK
(   49) 
(   50) REAL :: XREF, XCOEFF
(   51) INTEGER :: INBLEV
(   52) INTEGER :: ILEVNBELT
(   53) INTEGER :: JI
(   54) INTEGER :: IND1, IND2
(   55) INTEGER :: IDIMX,IDIMY
(   56) INTEGER :: IEXTCOD
(   57) REAL(KIND=8),DIMENSION(:),POINTER  :: XPTRTAB
(   58) REAL :: XMIN,XMAX
(   59) 
(   60) SELECT CASE (CODINGTYPE)
(   61) CASE (JPCSTENCOD)
(   62)   CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(   63)   XTAB(:) = XREF
(   64) 
(   65) CASE (JPSOPENCOD)
(   66)   CALL EXTRACT_BBUFF(COMPTAB,32,IDIMX)
(   67)   CALL EXTRACT_BBUFF(COMPTAB,32,IDIMY)
(   68)   ILEVNBELT = IDIMX * IDIMY
(   69)   INBLEV = NBELT/(ILEVNBELT)
(   70)   ALLOCATE(ITAB(ILEVNBELT))
(   71)   DO JI=1,INBLEV
(   72)     IND1=(JI-1)*ILEVNBELT+1
(   73)     IND2=JI*ILEVNBELT
(   74)     XPTRTAB=>XTAB(IND1:IND2)
(   75)     IF (LPDEBUG) PRINT *,'######   Decompress(SOPENCOD) LEVEL ',JI,'######'
(   76)     CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(   77)     CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(   78)     CALL EXTRACTINTARRAY(ITAB)
(   79)     CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF)
(   80)   END DO
(   81)   
(   82) CASE (JPEXTENCOD)
(   83)   CALL EXTRACT_BBUFF(COMPTAB,32,IDIMX)
(   84)   CALL EXTRACT_BBUFF(COMPTAB,32,IDIMY)
(   85)   ILEVNBELT = IDIMX * IDIMY
(   86)   INBLEV = NBELT/(ILEVNBELT)
(   87)   ALLOCATE(ITAB(ILEVNBELT))
(   88)   ALLOCATE(GMASK(ILEVNBELT))






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 4

(   89)   DO JI=1,INBLEV
(   90) 
(   91)     IF (LPDEBUG) PRINT *,'###### Decompress(EXTENCOD) LEVEL ',JI,'######'
(   92)     IND1=(JI-1)*ILEVNBELT+1
(   93)     IND2=JI*ILEVNBELT
(   94)     XPTRTAB=>XTAB(IND1:IND2)
(   95)     !
(   96)     CALL EXTRACT_BBUFF(COMPTAB,3,IEXTCOD)
(   97)     IF (IEXTCOD == JPOTHER) THEN
(   98)       CALL EXTRACT_BBUFF(COMPTAB,3,IEXTCOD)
(   99)       IEXTCOD = IEXTCOD + 8
(  100)     END IF
(  101)     IF (LPDEBUG) PRINT *, "IEXTCOD = ",IEXTCOD
(  102)     SELECT CASE(IEXTCOD)
(  103)     CASE(JPLOG)
(  104)       ! Conversion to log values of original data 0<=x<1
(  105)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  106)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  107)       CALL EXTRACTINTARRAY(ITAB)
(  108)       GMASK(:) = .TRUE.
(  109)       WHERE (ITAB == 0)
(  110)         GMASK = .FALSE.
(  111)         XPTRTAB = 0.0
(  112)       END WHERE
(  113)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF,GMASK,1)
(  114)       WHERE(GMASK)
(  115)         XPTRTAB = EXP(XPTRTAB)
(  116)       END WHERE
(  117)       
(  118)     CASE(JPCONST)
(  119)       ! constant value array
(  120)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  121)       XPTRTAB(:) = XREF
(  122)       IF (LPDEBUG) PRINT *,"  CONST value=",XREF
(  123) 
(  124)     CASE(JP2VAL)
(  125)       ! 2 different values in array
(  126)       CALL EXTRACT_BBUFF(COMPTAB,32,XMIN)
(  127)       CALL EXTRACT_BBUFF(COMPTAB,32,XMAX)
(  128)       CALL EXTRACTINTARRAY(ITAB)
(  129)       WHERE (ITAB == 0)
(  130)         XPTRTAB = XMIN
(  131)       ELSEWHERE
(  132)         XPTRTAB = XMAX
(  133)       END WHERE
(  134)       IF (LPDEBUG) PRINT *,"  2 values:",XMIN,XMAX
(  135)       
(  136)     CASE(JP3VAL)
(  137)       ! 3 different values in array
(  138)       CALL EXTRACT_BBUFF(COMPTAB,32,XMIN)
(  139)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  140)       CALL EXTRACT_BBUFF(COMPTAB,32,XMAX)
(  141)       CALL EXTRACTINTARRAY(ITAB)
(  142)       WHERE (ITAB == 0)
(  143)         XPTRTAB = XMIN
(  144)       ELSEWHERE
(  145)         XPTRTAB = XREF
(  146)       END WHERE






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 5

(  147)       WHERE (ITAB == 2) XPTRTAB = XMAX
(  148)       IF (LPDEBUG) PRINT *,"  3 values:",XMIN,XREF,XMAX
(  149) 
(  150)     CASE(JPNORM)
(  151)       ! same as JPSOPENCOD
(  152)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  153)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  154)       CALL EXTRACTINTARRAY(ITAB)
(  155)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF)
(  156)       IF (LPDEBUG) PRINT *,"  normal, XREF/XCOEFF = ",XREF,XCOEFF 
(  157) 
(  158)     CASE(JPMINEXCL)
(  159)       ! Min value is isolated
(  160)       CALL EXTRACT_BBUFF(COMPTAB,32,XMIN)
(  161)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  162)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  163)       CALL EXTRACTINTARRAY(ITAB)
(  164)       GMASK(:) = .TRUE.
(  165)       WHERE (ITAB == 0)
(  166)         GMASK = .FALSE.
(  167)         XPTRTAB = XMIN
(  168)       END WHERE
(  169)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF,GMASK,1)
(  170)       IF (LPDEBUG) PRINT *,"  Min exclus, MIN/XREF/XCOEFF = ",XMIN,XREF,XCOEFF
(  171) 
(  172)     CASE(JPMAXEXCL)
(  173)       ! Max value is isolated
(  174)       CALL EXTRACT_BBUFF(COMPTAB,32,XMAX)
(  175)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  176)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  177)       CALL EXTRACTINTARRAY(ITAB)
(  178)       GMASK(:) = .TRUE.
(  179)       WHERE (ITAB == 65535)
(  180)         GMASK = .FALSE.
(  181)         XPTRTAB = XMAX
(  182)       END WHERE
(  183)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF,GMASK,0)   
(  184)       IF (LPDEBUG) PRINT *,"  Max exclus, MAX/XREF/XCOEFF = ",XMAX,XREF,XCOEFF
(  185) 
(  186)     CASE(JPMINMAXEXCL)
(  187)       ! Min&Max value are isolated
(  188)       CALL EXTRACT_BBUFF(COMPTAB,32,XMIN)        
(  189)       CALL EXTRACT_BBUFF(COMPTAB,32,XMAX)
(  190)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  191)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  192)       CALL EXTRACTINTARRAY(ITAB)
(  193)       GMASK(:) = .TRUE.
(  194)       WHERE (ITAB == 0)
(  195)         GMASK = .FALSE.
(  196)         XPTRTAB = XMIN
(  197)       END WHERE
(  198)       WHERE (ITAB == 65535)
(  199)         GMASK = .FALSE.
(  200)         XPTRTAB = XMAX
(  201)       END WHERE
(  202)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF,GMASK,1)
(  203)       IF (LPDEBUG) PRINT *,"  Min et Max exclus, MIN/MAX/XREF/XCOEFF = ",&
(  204)            &XMIN,XMAX,XREF,XCOEFF






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 6

(  205)     END SELECT
(  206)   END DO
(  207)   
(  208) CASE DEFAULT
(  209)   PRINT *,'Error in CODINGTYPE : program aborted'
(  210)   STOP
(  211) END SELECT
(  212) 
(  213) CONTAINS 
(  214) 
(  215) SUBROUTINE DECOMP_FOP(PTAB,KTAB,PREF,PCOEFF,OMASK,KINDCOR)
(  216) REAL(KIND=8), DIMENSION(:), INTENT(INOUT) :: PTAB 
(  217) ! Attention: avec le compilateur PGF, utiliser INTENT(OUT) provoque une recopie
(  218) ! complete du tableau dans PTAB (avec ecrasement possible des valeurs 
(  219) ! presentes a l'appel de la procedure). Le phenomene est genant lorsque
(  220) ! DECOMP_FOP ne calcule que sur une portion de PTAB (valeurs min et/ou max 
(  221) ! sont presentes). En declarant PTAB en INOUT, les valeurs en entree de la routine
(  222) ! sont conservees si elles n'ont pas ete modifiees.
(  223) 
(  224) INTEGER,      DIMENSION(:), INTENT(IN) :: KTAB 
(  225) REAL, INTENT(IN) :: PREF
(  226) REAL, INTENT(IN) :: PCOEFF
(  227) LOGICAL, DIMENSION(:),INTENT(IN),OPTIONAL :: OMASK
(  228) INTEGER,INTENT(IN),OPTIONAL  :: KINDCOR ! 1 if Min value is isolated, 0 otherwise
(  229) 
(  230) INTEGER :: INDCOR
(  231) 
(  232) IF (.NOT. PRESENT(KINDCOR)) THEN
(  233)   INDCOR = 0
(  234) ELSE
(  235)   INDCOR = KINDCOR
(  236) END IF
(  237)   
(  238) IF (PRESENT(OMASK)) THEN
(  239)   WHERE (OMASK)
(  240)     PTAB(:) = PCOEFF*(KTAB(:)-INDCOR)+PREF
(  241)   END WHERE
(  242) ELSE
(  243)   IF (PCOEFF == 0.0) THEN
(  244)     PTAB(:) = PREF
(  245)   ELSE
(  246)     PTAB(:) = PCOEFF*KTAB(:)+PREF
(  247)   END IF
(  248) END IF
(  249) 
(  250) END SUBROUTINE DECOMP_FOP
(  251) 
(  252) SUBROUTINE EXTRACTINTARRAY(KTAB)
(  253) INTEGER,DIMENSION(:),INTENT(OUT) :: KTAB
(  254) !
(  255) ! COMPTAB, IDIMX and IDIMY  are defined in the calling routine
(  256) !
(  257) INTEGER :: NBGRP
(  258) INTEGER :: IBE
(  259) INTEGER :: CPT
(  260) INTEGER :: JJ
(  261) INTEGER :: ALONE
(  262) INTEGER :: NBITCOD,IMIN






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 7

(  263) INTEGER :: GELT
(  264) INTEGER :: JELT
(  265) INTEGER :: IEPS
(  266) 
(  267) CALL EXTRACT_BBUFF(COMPTAB,32,NBGRP)
(  268) !      PRINT *,'Nbre de groupes =',NBGRP
(  269) CALL EXTRACT_BBUFF(COMPTAB,5,IBE)
(  270) !      PRINT *,'Nbre de bits pour coder le nombre d''elements:',IBE
(  271) CPT = 1
(  272) DO JJ=1,NBGRP
(  273)   !      PRINT *,'Groupe ',JJ,' : '
(  274)   CALL EXTRACT_BBUFF(COMPTAB,1,ALONE)
(  275)   CALL EXTRACT_BBUFF(COMPTAB,16,IMIN)
(  276)   !      PRINT *,'IREF=',IMIN
(  277)   
(  278)   IF (ALONE == 1) THEN
(  279)     ! 1 seul elt dans le groupe
(  280)     !        PRINT *,'--> un seul element dans le groupe'
(  281)     KTAB(CPT)=IMIN
(  282)     CPT=CPT+1
(  283)   ELSE
(  284)     CALL EXTRACT_BBUFF(COMPTAB,4,NBITCOD)
(  285)     CALL EXTRACT_BBUFF(COMPTAB,IBE,GELT)
(  286)     !        PRINT *,'--> ',GELT,' elts, codage ecart sur ',nbitcod,'bits'
(  287)     IF (NBITCOD > 0) THEN
(  288)       DO JELT=1,GELT
(  289)         CALL EXTRACT_BBUFF(COMPTAB,NBITCOD,IEPS)
(  290)         KTAB(CPT) = IMIN+IEPS
(  291)         CPT=CPT+1
(  292)       END DO
(  293)     ELSE
(  294)       KTAB(CPT:CPT+GELT-1) = IMIN
(  295)       CPT = CPT+GELT
(  296)     END IF
(  297)   END IF
(  298) END DO
(  299) CALL INVERTCOL(KTAB,IDIMX,IDIMY)        
(  300) END SUBROUTINE EXTRACTINTARRAY
(  301) 
(  302) END SUBROUTINE DECOMPRESS_FIELD
(  303) 























NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 8

(    1) # 1 "decompress.F90"
(    1) !-----------------------------------------------------------------
(    2) !--------------- special set of characters for RCS information
(    3) !-----------------------------------------------------------------
(    4) ! $Source: /home/cvsroot/mesonh/libtools/lib/COMPRESS/src/decompress.f90,v $ $Revision: 1.1.4.1 $ $Date: 2008/04/10 10:23:35 $
(    5) !-----------------------------------------------------------------
(    6) SUBROUTINE GET_COMPHEADER(KTAB,SIZEKTAB,KNBELT,KTYPECOD)
(    7) # 8 "decompress.F90"
(    8) INTEGER, INTENT(IN) :: SIZEKTAB
(    9) INTEGER(KIND=8), DIMENSION(SIZEKTAB), INTENT(IN) :: KTAB
(   10) INTEGER, INTENT(OUT) :: KNBELT    ! size of decompressed array
(   11) INTEGER, INTENT(OUT) :: KTYPECOD  ! code for compression type
(   12) # 13 "decompress.F90"
(   13) CHARACTER(LEN=8) :: STRKEY
(   14) # 15 "decompress.F90"
(   15) INTEGER :: INTCHAR
(   16) INTEGER :: JI
(   17) # 18 "decompress.F90"
(   18) CALL SET_EXTRACTIDX(0,0)
(   19) ! extract string header 
(   20) DO JI=1,8
(   21)   CALL EXTRACT_BBUFF(KTAB,8,INTCHAR)
(   22)   STRKEY(JI:JI) = CHAR(INTCHAR)
(   23) END DO
(   24) # 25 "decompress.F90"
(   25) ! Treat array if it is compressed
(   26) IF (STRKEY == 'COMPRESS') THEN
(   27)   CALL EXTRACT_BBUFF(KTAB,32,KTYPECOD)
(   28)   CALL EXTRACT_BBUFF(KTAB,32,KNBELT)
(   29) ELSE
(   30)   KNBELT    =-1
(   31)   KTYPECOD = 0
(   32) END IF
(   33) # 34 "decompress.F90"
(   34) END SUBROUTINE GET_COMPHEADER
(   35) # 36 "decompress.F90"
(   36) SUBROUTINE DECOMPRESS_FIELD(XTAB,NBELT,COMPTAB,NBCOMPELT,CODINGTYPE)
(   37) USE MODD_COMPPAR
(   38) USE MODE_SEARCHGRP
(   39) # 40 "decompress.F90"
(   40) IMPLICIT NONE 
(   41) INTEGER,                                INTENT(IN)  :: NBELT 
(   42) INTEGER,                                INTENT(IN)  :: NBCOMPELT 
(   43) REAL   (KIND=8),DIMENSION(NBELT),TARGET,INTENT(OUT) :: XTAB
(   44) INTEGER(KIND=8),DIMENSION(NBCOMPELT),   INTENT(IN)  :: COMPTAB
(   45) INTEGER,                                INTENT(IN)  :: CODINGTYPE
(   46) # 47 "decompress.F90"
(   47) INTEGER,DIMENSION(:), ALLOCATABLE  :: ITAB
(   48) LOGICAL,DIMENSION(:), ALLOCATABLE  :: GMASK
(   49) # 50 "decompress.F90"
(   50) REAL :: XREF, XCOEFF
(   51) INTEGER :: INBLEV
(   52) INTEGER :: ILEVNBELT
(   53) INTEGER :: JI
(   54) INTEGER :: IND1, IND2
(   55) INTEGER :: IDIMX,IDIMY
(   56) INTEGER :: IEXTCOD
(   57) REAL(KIND=8),DIMENSION(:),POINTER  :: XPTRTAB






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 9

(   58) REAL :: XMIN,XMAX
(   59) # 60 "decompress.F90"
(   60) SELECT CASE (CODINGTYPE)
(   61) CASE (JPCSTENCOD)
(   62)   CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(   63)   XTAB(:) = XREF
(   64) # 65 "decompress.F90"
(   65) CASE (JPSOPENCOD)
(   66)   CALL EXTRACT_BBUFF(COMPTAB,32,IDIMX)
(   67)   CALL EXTRACT_BBUFF(COMPTAB,32,IDIMY)
(   68)   ILEVNBELT = IDIMX * IDIMY
(   69)   INBLEV = NBELT/(ILEVNBELT)
(   70)   ALLOCATE(ITAB(ILEVNBELT))
(   71)   DO JI=1,INBLEV
(   72)     IND1=(JI-1)*ILEVNBELT+1
(   73)     IND2=JI*ILEVNBELT
(   74)     XPTRTAB=>XTAB(IND1:IND2)
(   75)     IF (LPDEBUG) PRINT *,'######   Decompress(SOPENCOD) LEVEL ',JI,'######'
(   76)     CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(   77)     CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(   78)     CALL EXTRACTINTARRAY(ITAB)
(   79)     CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF)
(   80)   END DO
(   81)   
(   82) CASE (JPEXTENCOD)
(   83)   CALL EXTRACT_BBUFF(COMPTAB,32,IDIMX)
(   84)   CALL EXTRACT_BBUFF(COMPTAB,32,IDIMY)
(   85)   ILEVNBELT = IDIMX * IDIMY
(   86)   INBLEV = NBELT/(ILEVNBELT)
(   87)   ALLOCATE(ITAB(ILEVNBELT))
(   88)   ALLOCATE(GMASK(ILEVNBELT))
(   89)   DO JI=1,INBLEV
(   90) # 91 "decompress.F90"
(   91)     IF (LPDEBUG) PRINT *,'###### Decompress(EXTENCOD) LEVEL ',JI,'######'
(   92)     IND1=(JI-1)*ILEVNBELT+1
(   93)     IND2=JI*ILEVNBELT
(   94)     XPTRTAB=>XTAB(IND1:IND2)
(   95)     !
(   96)     CALL EXTRACT_BBUFF(COMPTAB,3,IEXTCOD)
(   97)     IF (IEXTCOD == JPOTHER) THEN
(   98)       CALL EXTRACT_BBUFF(COMPTAB,3,IEXTCOD)
(   99)       IEXTCOD = IEXTCOD + 8
(  100)     END IF
(  101)     IF (LPDEBUG) PRINT *, "IEXTCOD = ",IEXTCOD
(  102)     SELECT CASE(IEXTCOD)
(  103)     CASE(JPLOG)
(  104)       ! Conversion to log values of original data 0<=x<1
(  105)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  106)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  107)       CALL EXTRACTINTARRAY(ITAB)
(  108)       GMASK(:) = .TRUE.
(  109)       WHERE (ITAB == 0)
(  110)         GMASK = .FALSE.
(  111)         XPTRTAB = 0.0
(  112)       END WHERE
(  113)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF,GMASK,1)
(  114)       WHERE(GMASK)
(  115)         XPTRTAB = EXP(XPTRTAB)






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 10

(  116)       END WHERE
(  117)       
(  118)     CASE(JPCONST)
(  119)       ! constant value array
(  120)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  121)       XPTRTAB(:) = XREF
(  122)       IF (LPDEBUG) PRINT *,"  CONST value=",XREF
(  123) # 124 "decompress.F90"
(  124)     CASE(JP2VAL)
(  125)       ! 2 different values in array
(  126)       CALL EXTRACT_BBUFF(COMPTAB,32,XMIN)
(  127)       CALL EXTRACT_BBUFF(COMPTAB,32,XMAX)
(  128)       CALL EXTRACTINTARRAY(ITAB)
(  129)       WHERE (ITAB == 0)
(  130)         XPTRTAB = XMIN
(  131)       ELSEWHERE
(  132)         XPTRTAB = XMAX
(  133)       END WHERE
(  134)       IF (LPDEBUG) PRINT *,"  2 values:",XMIN,XMAX
(  135)       
(  136)     CASE(JP3VAL)
(  137)       ! 3 different values in array
(  138)       CALL EXTRACT_BBUFF(COMPTAB,32,XMIN)
(  139)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  140)       CALL EXTRACT_BBUFF(COMPTAB,32,XMAX)
(  141)       CALL EXTRACTINTARRAY(ITAB)
(  142)       WHERE (ITAB == 0)
(  143)         XPTRTAB = XMIN
(  144)       ELSEWHERE
(  145)         XPTRTAB = XREF
(  146)       END WHERE
(  147)       WHERE (ITAB == 2) XPTRTAB = XMAX
(  148)       IF (LPDEBUG) PRINT *,"  3 values:",XMIN,XREF,XMAX
(  149) # 150 "decompress.F90"
(  150)     CASE(JPNORM)
(  151)       ! same as JPSOPENCOD
(  152)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  153)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  154)       CALL EXTRACTINTARRAY(ITAB)
(  155)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF)
(  156)       IF (LPDEBUG) PRINT *,"  normal, XREF/XCOEFF = ",XREF,XCOEFF 
(  157) # 158 "decompress.F90"
(  158)     CASE(JPMINEXCL)
(  159)       ! Min value is isolated
(  160)       CALL EXTRACT_BBUFF(COMPTAB,32,XMIN)
(  161)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  162)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  163)       CALL EXTRACTINTARRAY(ITAB)
(  164)       GMASK(:) = .TRUE.
(  165)       WHERE (ITAB == 0)
(  166)         GMASK = .FALSE.
(  167)         XPTRTAB = XMIN
(  168)       END WHERE
(  169)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF,GMASK,1)
(  170)       IF (LPDEBUG) PRINT *,"  Min exclus, MIN/XREF/XCOEFF = ",XMIN,XREF,XCOEFF
(  171) # 172 "decompress.F90"
(  172)     CASE(JPMAXEXCL)
(  173)       ! Max value is isolated






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 11

(  174)       CALL EXTRACT_BBUFF(COMPTAB,32,XMAX)
(  175)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  176)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  177)       CALL EXTRACTINTARRAY(ITAB)
(  178)       GMASK(:) = .TRUE.
(  179)       WHERE (ITAB == 65535)
(  180)         GMASK = .FALSE.
(  181)         XPTRTAB = XMAX
(  182)       END WHERE
(  183)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF,GMASK,0)   
(  184)       IF (LPDEBUG) PRINT *,"  Max exclus, MAX/XREF/XCOEFF = ",XMAX,XREF,XCOEFF
(  185) # 186 "decompress.F90"
(  186)     CASE(JPMINMAXEXCL)
(  187)       ! Min&Max value are isolated
(  188)       CALL EXTRACT_BBUFF(COMPTAB,32,XMIN)        
(  189)       CALL EXTRACT_BBUFF(COMPTAB,32,XMAX)
(  190)       CALL EXTRACT_BBUFF(COMPTAB,32,XREF)
(  191)       CALL EXTRACT_BBUFF(COMPTAB,32,XCOEFF)
(  192)       CALL EXTRACTINTARRAY(ITAB)
(  193)       GMASK(:) = .TRUE.
(  194)       WHERE (ITAB == 0)
(  195)         GMASK = .FALSE.
(  196)         XPTRTAB = XMIN
(  197)       END WHERE
(  198)       WHERE (ITAB == 65535)
(  199)         GMASK = .FALSE.
(  200)         XPTRTAB = XMAX
(  201)       END WHERE
(  202)       CALL DECOMP_FOP(XPTRTAB,ITAB,XREF,XCOEFF,GMASK,1)
(  203)       IF (LPDEBUG) PRINT *,"  Min et Max exclus, MIN/MAX/XREF/XCOEFF = ",&
(  204)            &XMIN,XMAX,XREF,XCOEFF
(  205)     END SELECT
(  206)   END DO
(  207)   
(  208) CASE DEFAULT
(  209)   PRINT *,'Error in CODINGTYPE : program aborted'
(  210)   STOP
(  211) END SELECT
(  212) # 213 "decompress.F90"
(  213) CONTAINS 
(  214) # 215 "decompress.F90"
(  215) SUBROUTINE DECOMP_FOP(PTAB,KTAB,PREF,PCOEFF,OMASK,KINDCOR)
(  216) REAL(KIND=8), DIMENSION(:), INTENT(INOUT) :: PTAB 
(  217) ! Attention: avec le compilateur PGF, utiliser INTENT(OUT) provoque une recopie
(  218) ! complete du tableau dans PTAB (avec ecrasement possible des valeurs 
(  219) ! presentes a l'appel de la procedure). Le phenomene est genant lorsque
(  220) ! DECOMP_FOP ne calcule que sur une portion de PTAB (valeurs min et/ou max 
(  221) ! sont presentes). En declarant PTAB en INOUT, les valeurs en entree de la routine
(  222) ! sont conservees si elles n'ont pas ete modifiees.
(  223) # 224 "decompress.F90"
(  224) INTEGER,      DIMENSION(:), INTENT(IN) :: KTAB 
(  225) REAL, INTENT(IN) :: PREF
(  226) REAL, INTENT(IN) :: PCOEFF
(  227) LOGICAL, DIMENSION(:),INTENT(IN),OPTIONAL :: OMASK
(  228) INTEGER,INTENT(IN),OPTIONAL  :: KINDCOR ! 1 if Min value is isolated, 0 otherwise
(  229) # 230 "decompress.F90"
(  230) INTEGER :: INDCOR
(  231) # 232 "decompress.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 12

(  232) IF (.NOT. PRESENT(KINDCOR)) THEN
(  233)   INDCOR = 0
(  234) ELSE
(  235)   INDCOR = KINDCOR
(  236) END IF
(  237)   
(  238) IF (PRESENT(OMASK)) THEN
(  239)   WHERE (OMASK)
(  240)     PTAB(:) = PCOEFF*(KTAB(:)-INDCOR)+PREF
(  241)   END WHERE
(  242) ELSE
(  243)   IF (PCOEFF == 0.0) THEN
(  244)     PTAB(:) = PREF
(  245)   ELSE
(  246)     PTAB(:) = PCOEFF*KTAB(:)+PREF
(  247)   END IF
(  248) END IF
(  249) # 250 "decompress.F90"
(  250) END SUBROUTINE DECOMP_FOP
(  251) # 252 "decompress.F90"
(  252) SUBROUTINE EXTRACTINTARRAY(KTAB)
(  253) INTEGER,DIMENSION(:),INTENT(OUT) :: KTAB
(  254) !
(  255) ! COMPTAB, IDIMX and IDIMY  are defined in the calling routine
(  256) !
(  257) INTEGER :: NBGRP
(  258) INTEGER :: IBE
(  259) INTEGER :: CPT
(  260) INTEGER :: JJ
(  261) INTEGER :: ALONE
(  262) INTEGER :: NBITCOD,IMIN
(  263) INTEGER :: GELT
(  264) INTEGER :: JELT
(  265) INTEGER :: IEPS
(  266) # 267 "decompress.F90"
(  267) CALL EXTRACT_BBUFF(COMPTAB,32,NBGRP)
(  268) !      PRINT *,'Nbre de groupes =',NBGRP
(  269) CALL EXTRACT_BBUFF(COMPTAB,5,IBE)
(  270) !      PRINT *,'Nbre de bits pour coder le nombre d''elements:',IBE
(  271) CPT = 1
(  272) DO JJ=1,NBGRP
(  273)   !      PRINT *,'Groupe ',JJ,' : '
(  274)   CALL EXTRACT_BBUFF(COMPTAB,1,ALONE)
(  275)   CALL EXTRACT_BBUFF(COMPTAB,16,IMIN)
(  276)   !      PRINT *,'IREF=',IMIN
(  277)   
(  278)   IF (ALONE == 1) THEN
(  279)     ! 1 seul elt dans le groupe
(  280)     !        PRINT *,'--> un seul element dans le groupe'
(  281)     KTAB(CPT)=IMIN
(  282)     CPT=CPT+1
(  283)   ELSE
(  284)     CALL EXTRACT_BBUFF(COMPTAB,4,NBITCOD)
(  285)     CALL EXTRACT_BBUFF(COMPTAB,IBE,GELT)
(  286)     !        PRINT *,'--> ',GELT,' elts, codage ecart sur ',nbitcod,'bits'
(  287)     IF (NBITCOD > 0) THEN
(  288)       DO JELT=1,GELT
(  289)         CALL EXTRACT_BBUFF(COMPTAB,NBITCOD,IEPS)






NVFORTRAN (Version     23.1)          02/24/2023  13:34:30      page 13

(  290)         KTAB(CPT) = IMIN+IEPS
(  291)         CPT=CPT+1
(  292)       END DO
(  293)     ELSE
(  294)       KTAB(CPT:CPT+GELT-1) = IMIN
(  295)       CPT = CPT+GELT
(  296)     END IF
(  297)   END IF
(  298) END DO
(  299) CALL INVERTCOL(KTAB,IDIMX,IDIMY)        
(  300) END SUBROUTINE EXTRACTINTARRAY
(  301) # 302 "decompress.F90"
(  302) END SUBROUTINE DECOMPRESS_FIELD
