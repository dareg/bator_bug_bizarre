


NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: transforms4py.F90

(    1) SUBROUTINE W_SPEC_SETUP(KRETURNCODE, KSIZEI, KSIZEJ, KPHYSICALSIZEI, KPHYSICALSIZEJ, &
(    2)                        &KTRUNCX, KTRUNCY, KNUMMAXRESOL, KLOEN, LDLAM, &
(    3)                        &KSIZEKLOEN, PDELTAX, PDELTAY, &
(    4)                        &KIDENTRESOL, LDSTOP)
(    5) ! ** PURPOSE
(    6) !    Setup spectral transform for LAM and global
(    7) !
(    8) ! ** DUMMY ARGUMENTS
(    9) !    KRETURNCODE: error code
(   10) !    KSIZEI, KSIZEJ: size of grid-point field (with extension zone for LAM), put max size for KSIZEI in global
(   11) !    KPHYSICALSIZEI, KPHYSICALSIZEJ: size of physical part of grid-point field for LAM (put 0 for global)
(   12) !    KTRUNCX, KTRUNCY: troncatures for LAM (only KTRUNCX is used for global, put 0 for KTRUNCY)
(   13) !    KNUMMAXRESOL: maximum number of troncatures handled
(   14) !    KLOEN: number of points on each latitude row
(   15) !    KSIZEKLOEN: size of KLOEN array
(   16) !    PDELTAX: x resolution
(   17) !    PDELTAY: y resolution
(   18) !    LDLAM: LAM (.TRUE.) or global (.FALSE.)
(   19) !    KIDENTRESOL: identification of resolution
(   20) !    LDSTOP: exception raised?
(   21) !
(   22) ! ** AUTHOR
(   23) !    9 April 2014, S. Riette
(   24) !
(   25) ! ** MODIFICATIONS
(   26) !    6 Jan 2016, S. Riette: PDELTAX and PDELTAY added
(   27) !    31 Jan 2019 R. El Khatib fix for single precision compilation
(   28) !
(   29) ! I. Dummy arguments declaration
(   30) USE PARKIND1, ONLY : JPRB






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 3

(   31) IMPLICIT NONE
(   32) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(   33) INTEGER, INTENT(IN) :: KSIZEI, KSIZEJ
(   34) INTEGER, INTENT(IN) :: KPHYSICALSIZEI, KPHYSICALSIZEJ
(   35) INTEGER, INTENT(IN) :: KTRUNCX, KTRUNCY
(   36) INTEGER, INTENT(IN) :: KNUMMAXRESOL
(   37) INTEGER, DIMENSION(KSIZEKLOEN), INTENT(IN) :: KLOEN
(   38) LOGICAL, INTENT(IN) :: LDLAM
(   39) INTEGER, INTENT(IN) :: KSIZEKLOEN
(   40) REAL(KIND=8), INTENT(IN) :: PDELTAX
(   41) REAL(KIND=8), INTENT(IN) :: PDELTAY
(   42) INTEGER, INTENT(OUT) :: KIDENTRESOL
(   43) LOGICAL, INTENT(OUT) :: LDSTOP
(   44) !
(   45) ! II. Local variables declaration
(   46) INTEGER, DIMENSION(2*KSIZEJ) :: ILOEN
(   47) INTEGER :: JI
(   48) LOGICAL, SAVE :: LLFIRSTCALL=.TRUE.
(   49) LOGICAL :: LLNEWRESOL
(   50) INTEGER, SAVE :: INBRESOL=0
(   51) INTEGER(KIND=8) :: ICODEILOEN
(   52) INTEGER, SAVE :: INUMMAXRESOLSAVE=-1
(   53) INTEGER, DIMENSION(:), ALLOCATABLE, SAVE :: ITRUNCXSAVE, ITRUNCYSAVE, &
(   54)                                             IPHYSICALSIZEISAVE, &
(   55)                                             IPHYSICALSIZEJSAVE, &
(   56)                                             ISIZEISAVE, ISIZEJSAVE, &
(   57)                                             IIDENTRESOLSAVE
(   58) INTEGER(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE :: ILOENSAVE
(   59) REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE :: ZDELTAXSAVE, &
(   60)                                                         ZDELTAYSAVE
(   61) REAL(KIND=8) :: ZEXWN, ZEYWN
(   62) 
(   63) #include "setup_trans0.h"
(   64) #include "esetup_trans.h"
(   65) #include "setup_trans.h"
(   66) 
(   67) KRETURNCODE=0
(   68) LDSTOP=.FALSE.
(   69) ! III. Setup
(   70) 
(   71) ! III.a Setup LAM and global spectral transform - all resolutions
(   72) ! Maximum number of resolution is set now and cannot be change anymore
(   73) IF (LLFIRSTCALL) THEN
(   74)   !This code is called only once, whatever is the number of resolutions
(   75)   CALL SETUP_TRANS0(KPRINTLEV=0, LDMPOFF=.TRUE., KMAX_RESOL=KNUMMAXRESOL)
(   76)   ALLOCATE(ITRUNCXSAVE(KNUMMAXRESOL))
(   77)   ALLOCATE(ITRUNCYSAVE(KNUMMAXRESOL))
(   78)   ALLOCATE(IPHYSICALSIZEISAVE(KNUMMAXRESOL))
(   79)   ALLOCATE(IPHYSICALSIZEJSAVE(KNUMMAXRESOL))
(   80)   ALLOCATE(ISIZEJSAVE(KNUMMAXRESOL))
(   81)   ALLOCATE(ISIZEISAVE(KNUMMAXRESOL))
(   82)   ALLOCATE(ILOENSAVE(KNUMMAXRESOL))
(   83)   ALLOCATE(IIDENTRESOLSAVE(KNUMMAXRESOL))
(   84)   ALLOCATE(ZDELTAXSAVE(KNUMMAXRESOL))
(   85)   ALLOCATE(ZDELTAYSAVE(KNUMMAXRESOL))
(   86)   ITRUNCXSAVE=-1
(   87)   ITRUNCYSAVE=-1
(   88)   IPHYSICALSIZEISAVE=-1






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 4

(   89)   IPHYSICALSIZEJSAVE=-1
(   90)   ISIZEJSAVE=-1
(   91)   ISIZEISAVE=-1
(   92)   ILOENSAVE=-1
(   93)   IIDENTRESOLSAVE=-1
(   94)   ZDELTAXSAVE=-1.
(   95)   ZDELTAXSAVE=-1.
(   96)   LLFIRSTCALL=.FALSE.
(   97)   INUMMAXRESOLSAVE=KNUMMAXRESOL
(   98) ENDIF
(   99) !
(  100) ! III.b Is-it a new resolution?
(  101) LLNEWRESOL=.TRUE.
(  102) IF(LDLAM) THEN
(  103)   ILOEN(:)=KSIZEI
(  104) ELSE
(  105)   ILOEN(:)=0
(  106)   ILOEN(1:MIN(SIZE(ILOEN),SIZE(KLOEN)))=KLOEN(1:MIN(SIZE(ILOEN),SIZE(KLOEN)))
(  107) ENDIF
(  108) ICODEILOEN=0
(  109) DO JI=1, SIZE(ILOEN)
(  110)   ICODEILOEN=ICODEILOEN+ILOEN(JI)*JI**4
(  111) ENDDO
(  112) DO JI=1, INBRESOL
(  113)   IF (KTRUNCX==ITRUNCXSAVE(JI) .AND. KTRUNCY==ITRUNCYSAVE(JI) .AND. &
(  114)    &KPHYSICALSIZEI==IPHYSICALSIZEISAVE(JI) .AND. &
(  115)    &KPHYSICALSIZEJ==IPHYSICALSIZEJSAVE(JI) .AND. &
(  116)    &KSIZEJ==ISIZEJSAVE(JI) .AND. KSIZEI==ISIZEISAVE(JI) .AND. &
(  117)    &ICODEILOEN==ILOENSAVE(JI) .AND. &
(  118)    &PDELTAX==ZDELTAXSAVE(JI) .AND. PDELTAY==ZDELTAYSAVE(JI)) THEN
(  119)     KIDENTRESOL=IIDENTRESOLSAVE(JI)
(  120)     LLNEWRESOL=.FALSE.
(  121)   ENDIF
(  122) ENDDO
(  123) IF(LLNEWRESOL) THEN
(  124)   INBRESOL=INBRESOL+1
(  125)   IF(INBRESOL>INUMMAXRESOLSAVE) THEN
(  126)     PRINT*, "Error in W_SPEC_SETUP: Maximum number of resolution is exceeded."
(  127)     KRETURNCODE=-999
(  128)     LDSTOP=.TRUE.
(  129)   ENDIF
(  130) ENDIF
(  131) !
(  132) ! III.c Setup LAM or global spectral transform - once by resolution
(  133) IF(LLNEWRESOL .AND. .NOT. LDSTOP) THEN
(  134)   ! The following code is exectuded once for each resolution
(  135)   ITRUNCXSAVE(INBRESOL)=KTRUNCX
(  136)   ITRUNCYSAVE(INBRESOL)=KTRUNCY
(  137)   IPHYSICALSIZEISAVE(INBRESOL)=KPHYSICALSIZEI
(  138)   IPHYSICALSIZEJSAVE(INBRESOL)=KPHYSICALSIZEJ
(  139)   ISIZEISAVE(INBRESOL)=KSIZEI
(  140)   ISIZEJSAVE(INBRESOL)=KSIZEJ
(  141)   ILOENSAVE(INBRESOL)=ICODEILOEN
(  142)   ZDELTAXSAVE(INBRESOL)=PDELTAX
(  143)   ZDELTAYSAVE(INBRESOL)=PDELTAY
(  144)   IF(LDLAM) THEN
(  145)     ZEXWN=2*3.141592653589797/(KSIZEI*PDELTAX)
(  146)     ZEYWN=2*3.141592653589797/(KSIZEJ*PDELTAY)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 5

(  147)     CALL ESETUP_TRANS(KMSMAX=ITRUNCXSAVE(INBRESOL), KSMAX=ITRUNCYSAVE(INBRESOL), &
(  148)                      &KDGUX=IPHYSICALSIZEJSAVE(INBRESOL), &
(  149)                      &KDGL=ISIZEJSAVE(INBRESOL), KLOEN=ILOEN(:), KRESOL=IIDENTRESOLSAVE(INBRESOL), &
(  150)                      &PEXWN=REAL(ZEXWN,KIND=JPRB), PEYWN=REAL(ZEYWN,KIND=JPRB))
(  151)   ELSE
(  152)     PRINT*, "Setup spectral transform"
(  153)     CALL SETUP_TRANS(KSMAX=ITRUNCXSAVE(INBRESOL), KDGL=ISIZEJSAVE(INBRESOL), &
(  154)                     &KLOEN=ILOEN(1:ISIZEJSAVE(INBRESOL)), KRESOL=IIDENTRESOLSAVE(INBRESOL))
(  155)     PRINT*, "End Setup spectral transform"
(  156)   ENDIF
(  157)   KIDENTRESOL=IIDENTRESOLSAVE(INBRESOL)
(  158) ENDIF
(  159) END SUBROUTINE W_SPEC_SETUP
(  160) 
(  161) !__________________________________________________________________________
(  162) 
(  163) SUBROUTINE W_TRANS_INQ(KRETURNCODE, KSIZEJ, KTRUNC, KSLOEN, KLOEN, KNUMMAXRESOL, &
(  164)                       &KGPTOT, KSPEC, KNMENG)
(  165) ! ** PURPOSE
(  166) !    Simplified wrapper to TRANS_INQ
(  167) !
(  168) ! ** DUMMY ARGUMENTS
(  169) !    KSIZEJ: number of latitudes in grid-point space
(  170) !    KTRUNC: troncature
(  171) !    KSLOEN: Size of KLOEN
(  172) !    KLOEN: number of points on each latitude row
(  173) !    KNUMMAXRESOL: maximum number of troncatures handled
(  174) !    KGPTOT: number of gridpoints
(  175) !    KSPEC: number of spectral coefficients
(  176) !    KNMENG: cut-off zonal wavenumber
(  177) !
(  178) ! ** AUTHOR
(  179) !    9 April 2014, S. Riette
(  180) !
(  181) ! ** MODIFICATIONS
(  182) !    6 Jan., S. Riette: w_spec_setup interfaced modified
(  183) !
(  184) ! I. Dummy arguments declaration
(  185) IMPLICIT NONE
(  186) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  187) INTEGER(KIND=8), INTENT(IN) :: KSIZEJ
(  188) INTEGER(KIND=8), INTENT(IN) :: KTRUNC
(  189) INTEGER(KIND=8), INTENT(IN) :: KSLOEN
(  190) INTEGER(KIND=8), DIMENSION(KSLOEN), INTENT(IN) :: KLOEN
(  191) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  192) INTEGER(KIND=8), INTENT(OUT) :: KGPTOT
(  193) INTEGER(KIND=8), INTENT(OUT) :: KSPEC
(  194) INTEGER(KIND=8), DIMENSION(KSLOEN), INTENT(OUT) :: KNMENG
(  195) !
(  196) ! II. Local variables declaration
(  197) INTEGER, DIMENSION(SIZE(KLOEN)) :: ILOEN
(  198) INTEGER :: ISIZEI, ISIZEJ, &
(  199)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  200)          & ITRUNCX, ITRUNCY, &
(  201)          & INUMMAXRESOL
(  202) LOGICAL :: LLSTOP
(  203) INTEGER :: IIDENTRESOL
(  204) INTEGER :: IGPTOT, ISPEC






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 6

(  205) INTEGER, DIMENSION(SIZE(KLOEN)) :: INMENG
(  206) REAL(KIND=8) :: ZDELTAX, ZDELTAY
(  207) #include "trans_inq.h"
(  208) 
(  209) ILOEN(:)=KLOEN(:)
(  210) ISIZEI=0
(  211) ISIZEJ=KSIZEJ
(  212) IPHYSICALSIZEI=0
(  213) IPHYSICALSIZEJ=0
(  214) ITRUNCX=KTRUNC
(  215) ITRUNCY=0
(  216) INUMMAXRESOL=KNUMMAXRESOL
(  217) INMENG(:)=KNMENG(:)
(  218) !
(  219) ! III. Setup
(  220) ZDELTAX=0.
(  221) ZDELTAY=0.
(  222) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  223)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .FALSE., SIZE(ILOEN), &
(  224)                   &ZDELTAX, ZDELTAY, IIDENTRESOL, LLSTOP)
(  225) IF (.NOT. LLSTOP) THEN
(  226)   CALL TRANS_INQ(KRESOL=IIDENTRESOL, KGPTOT=IGPTOT, KSPEC=ISPEC, KNMENG=INMENG)
(  227)   KGPTOT=IGPTOT
(  228)   KSPEC=ISPEC
(  229)   KNMENG=INMENG
(  230) ENDIF
(  231) !
(  232) END SUBROUTINE W_TRANS_INQ
(  233) 
(  234) !___________________________________________________________________________________________
(  235) 
(  236) SUBROUTINE W_ETRANS_INQ(KRETURNCODE, KSIZEI, KSIZEJ, KPHYSICALSIZEI, KPHYSICALSIZEJ, &
(  237)                        &KTRUNCX, KTRUNCY, KNUMMAXRESOL, PDELTAX, PDELTAY, &
(  238)                        &KGPTOT, KSPEC)
(  239) ! ** PURPOSE
(  240) !    Simplified wrapper to ETRANS_INQ
(  241) !
(  242) ! ** DUMMY ARGUMENTS
(  243) !    KSIZEI, KSIZEJ: size of grid-point field (with extension zone)
(  244) !    KPHYSICALSIZEI, KPHYSICALSIZEJ: size of physical part of grid-point field
(  245) !    KTRUNCX, KTRUNCY: troncatures
(  246) !    KNUMMAXRESOL: maximum number of troncatures handled
(  247) !    PDELTAX: x resolution
(  248) !    PDELTAY: y resolution
(  249) !    KGPTOT: number of gridpoints
(  250) !    KSPEC: number of spectral coefficients
(  251) !
(  252) ! ** AUTHOR
(  253) !    9 April 2014, S. Riette
(  254) !
(  255) ! ** MODIFICATIONS
(  256) !    6 Jan., S. Riette: PDELTAX and PDELTAY added
(  257) !
(  258) ! I. Dummy arguments declaration
(  259) IMPLICIT NONE
(  260) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  261) INTEGER(KIND=8), INTENT(IN) :: KSIZEI, KSIZEJ
(  262) INTEGER(KIND=8), INTENT(IN) :: KPHYSICALSIZEI, KPHYSICALSIZEJ






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 7

(  263) INTEGER(KIND=8), INTENT(IN) :: KTRUNCX, KTRUNCY
(  264) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  265) REAL(KIND=8), INTENT(IN) :: PDELTAX
(  266) REAL(KIND=8), INTENT(IN) :: PDELTAY
(  267) INTEGER(KIND=8), INTENT(OUT) :: KGPTOT
(  268) INTEGER(KIND=8), INTENT(OUT) :: KSPEC
(  269) !
(  270) ! II. Local variables declaration
(  271) INTEGER, DIMENSION(0:KTRUNCX) :: IESM0
(  272) INTEGER :: ISIZEI, ISIZEJ, &
(  273)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  274)          & ITRUNCX, ITRUNCY, &
(  275)          & INUMMAXRESOL
(  276) LOGICAL :: LLSTOP
(  277) INTEGER :: IIDENTRESOL
(  278) INTEGER, DIMENSION(1) :: ILOEN
(  279) INTEGER :: IGPTOT, ISPEC
(  280) 
(  281) #include "etrans_inq.h"
(  282) 
(  283) ISIZEI=KSIZEI
(  284) ISIZEJ=KSIZEJ
(  285) IPHYSICALSIZEI=KPHYSICALSIZEI
(  286) IPHYSICALSIZEJ=KPHYSICALSIZEJ
(  287) ITRUNCX=KTRUNCX
(  288) ITRUNCY=KTRUNCY
(  289) INUMMAXRESOL=KNUMMAXRESOL
(  290) 
(  291) ! III. Setup
(  292) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  293)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .TRUE., 1, &
(  294)                   &PDELTAX, PDELTAY, IIDENTRESOL, LLSTOP)
(  295) IF (.NOT. LLSTOP) THEN
(  296)   CALL ETRANS_INQ(KRESOL=IIDENTRESOL, KGPTOT=IGPTOT, KSPEC=ISPEC, KESM0=IESM0)
(  297)   KGPTOT=IGPTOT
(  298)   KSPEC=ISPEC
(  299) ENDIF
(  300) !
(  301) END SUBROUTINE W_ETRANS_INQ
(  302) 
(  303) !______________________________________________________________________
(  304) 
(  305) SUBROUTINE W_SPEC2GPT_LAM(KRETURNCODE, KSIZEI, KSIZEJ, KPHYSICALSIZEI, KPHYSICALSIZEJ, &
(  306)                          &KTRUNCX, KTRUNCY, KNUMMAXRESOL, KSIZE, LGRADIENT, LREORDER, PDELTAX, PDELTAY, &
(  307)                          &PSPEC, PGPT, PGPTM, PGPTL)
(  308) ! ** PURPOSE
(  309) !    Transform spectral coefficients into grid-point values
(  310) !
(  311) ! ** DUMMY ARGUMENTS
(  312) !    KRETURNCODE: error code
(  313) !    KSIZEI, KSIZEJ: size of grid-point field (with extension zone)
(  314) !    KPHYSICALSIZEI, KPHYSICALSIZEJ: size of physical part of grid-point field
(  315) !    KTRUNCX, KTRUNCY: troncatures
(  316) !    KNUMMAXRESOL: maximum number of troncatures handled
(  317) !    KSIZE: size of PSPEC
(  318) !    LREORDER: switch to reorder spectral coefficients or not
(  319) !    LGRADIENT: switch to compute or not gradient
(  320) !    PDELTAX: x resolution






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 8

(  321) !    PDELTAY: y resolution
(  322) !    PSPEC: spectral coefficient array
(  323) !    PGPT: grid-point field
(  324) !    PGPTM: N-S derivative if LGRADIENT
(  325) !    PGPTL: E-W derivative if LGRADIENT
(  326) !
(  327) ! ** AUTHOR
(  328) !    9 April 2014, S. Riette
(  329) !
(  330) ! ** MODIFICATIONS
(  331) !    5 Jan., S. Riette: PDELTAX, PDELTAY, LGRADIENT, PGPTM and PGPTL added
(  332) !    March, 2016, A.Mary: LREORDER
(  333) !
(  334) ! I. Dummy arguments declaration
(  335) USE PARKIND1, ONLY : JPRB
(  336) IMPLICIT NONE
(  337) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  338) INTEGER(KIND=8), INTENT(IN) :: KSIZEI, KSIZEJ
(  339) INTEGER(KIND=8), INTENT(IN) :: KPHYSICALSIZEI, KPHYSICALSIZEJ
(  340) INTEGER(KIND=8), INTENT(IN) :: KTRUNCX, KTRUNCY
(  341) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  342) INTEGER(KIND=8), INTENT(IN) :: KSIZE
(  343) LOGICAL, INTENT(IN) :: LGRADIENT
(  344) LOGICAL, INTENT(IN) :: LREORDER
(  345) REAL(KIND=8), INTENT(IN) :: PDELTAX
(  346) REAL(KIND=8), INTENT(IN) :: PDELTAY
(  347) REAL(KIND=8), DIMENSION(KSIZE), INTENT(IN) :: PSPEC
(  348) REAL(KIND=8), DIMENSION(KSIZEI*KSIZEJ), INTENT(OUT) :: PGPT
(  349) REAL(KIND=8), DIMENSION(KSIZEI*KSIZEJ), INTENT(OUT) :: PGPTM
(  350) REAL(KIND=8), DIMENSION(KSIZEI*KSIZEJ), INTENT(OUT) :: PGPTL
(  351) !
(  352) ! II. Local variables declaration
(  353) INTEGER, DIMENSION(0:KTRUNCX) :: IESM0
(  354) INTEGER :: IGPTOT, ISPEC
(  355) INTEGER, DIMENSION(0:KTRUNCY) :: ISPECINI, ISPECEND
(  356) REAL(KIND=8), DIMENSION(1, KSIZE) :: ZSPBUF
(  357) REAL(KIND=JPRB), DIMENSION(KSIZEI*KSIZEJ, 3, 1) :: ZGPBUF
(  358) INTEGER :: JI, JM, JN, IINDEX, IIDENTRESOL
(  359) LOGICAL :: LLSTOP
(  360) INTEGER :: ISIZEI, ISIZEJ, &
(  361)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  362)          & ITRUNCX, ITRUNCY, &
(  363)          & INUMMAXRESOL
(  364) INTEGER, DIMENSION(1) :: ILOEN
(  365) 
(  366) #include "einv_trans.h"
(  367) #include "etrans_inq.h"
(  368) 
(  369) KRETURNCODE=0
(  370) LLSTOP=.FALSE.
(  371) ISIZEI=KSIZEI
(  372) ISIZEJ=KSIZEJ
(  373) IPHYSICALSIZEI=KPHYSICALSIZEI
(  374) IPHYSICALSIZEJ=KPHYSICALSIZEJ
(  375) ITRUNCX=KTRUNCX
(  376) ITRUNCY=KTRUNCY
(  377) INUMMAXRESOL=KNUMMAXRESOL
(  378) ILOEN(:)=0






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 9

(  379) 
(  380) ! III. Setup
(  381) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  382)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .TRUE., 1, &
(  383)                   &PDELTAX, PDELTAY, IIDENTRESOL, LLSTOP)
(  384) 
(  385) ! IV. Transformation
(  386) 
(  387) ! IV.a Shape of coefficient array
(  388) !IGPTOT is the total number of points in grid-point space
(  389) !ISPEC is the number of spectral coefficients
(  390) !IESM0(m) is the index of spectral coefficient (m,0) in model
(  391) !ISPECINI(n) is the index of the first of the 4 spectral coefficient (0,n) in FA file
(  392) !ISPECEND(n) is the index of the last of the last 4 spectral coefficients (:,n) in FA file
(  393) IF (.NOT. LLSTOP) THEN
(  394)   CALL ETRANS_INQ(KRESOL=IIDENTRESOL, KGPTOT=IGPTOT, KSPEC=ISPEC, KESM0=IESM0)
(  395)   JI=1
(  396)   DO JN=0, ITRUNCY
(  397)     ISPECINI(JN)=(JI-1)*4+1
(  398)     JI=JI+COUNT(IESM0(1:ITRUNCX)-IESM0(0:ITRUNCX-1)>JN*4)
(  399)     IF (ISPEC-IESM0(ITRUNCX)>JN*4) JI=JI+1
(  400)     ISPECEND(JN)=(JI-1)*4
(  401)   ENDDO
(  402) ENDIF
(  403) 
(  404) ! III.b Reordering
(  405) ! reorder Aladin :  file ordering = coeffs per blocks of m, 4 reals per coeff
(  406) !           Aladin array ordering = coeffs per blocks of n, 4 reals per coeff
(  407) IF (LREORDER) THEN
(  408)   IF (.NOT. LLSTOP) THEN
(  409)     ZSPBUF(:,:)=0.
(  410)     JI=1
(  411)     DO JM=0,ITRUNCX+1
(  412)       DO JN=0,ITRUNCY
(  413)         IF (ISPECINI(JN)+JM*4+3<=ISPECEND(JN)) THEN
(  414)           DO IINDEX=ISPECINI(JN)+JM*4, ISPECINI(JN)+JM*4+3
(  415)             ZSPBUF(1,JI)=PSPEC(IINDEX)
(  416)             JI=JI+1
(  417)           ENDDO
(  418)         ENDIF
(  419)       ENDDO
(  420)     ENDDO
(  421)     IF (JI/=ISPEC+1) THEN
(  422)       PRINT*, "Internal error in W_SPEC2GPT_LAM (spectral reordering)"
(  423)       KRETURNCODE=-999
(  424)       LLSTOP=.TRUE.
(  425)     ENDIF
(  426)   ENDIF
(  427) ELSE
(  428)   ZSPBUF(1,:) = PSPEC(:)
(  429) ENDIF
(  430) 
(  431) ! III.c Inverse transform
(  432) IF (.NOT. LLSTOP) THEN
(  433)   IF (.NOT. LGRADIENT) THEN
(  434)       CALL EINV_TRANS(PSPSCALAR=REAL(ZSPBUF(:,:),KIND=JPRB), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL)
(  435)       PGPT(:)=REAL(ZGPBUF(:,1,1),KIND=8)
(  436)   ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 10

(  437)       CALL EINV_TRANS(PSPSCALAR=REAL(ZSPBUF(:,:),KIND=JPRB), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL, LDSCDERS=.TRUE.)
(  438)       PGPT(:)=REAL(ZGPBUF(:,1,1),KIND=8)
(  439)       PGPTM(:)=REAL(ZGPBUF(:,2,1),KIND=8)
(  440)       PGPTL(:)=REAL(ZGPBUF(:,3,1),KIND=8)
(  441)   ENDIF
(  442) ENDIF
(  443) 
(  444) END SUBROUTINE W_SPEC2GPT_LAM
(  445) 
(  446) !____________________________________________________________________________
(  447) 
(  448) SUBROUTINE W_SPEC2GPT_GAUSS(KRETURNCODE, KSIZEJ, KTRUNC, KNUMMAXRESOL, KGPTOT, KSLOEN, KLOEN, KSIZE, &
(  449)                           & LGRADIENT, LREORDER, PSPEC, PGPT, PGPTM, PGPTL)
(  450) ! ** PURPOSE
(  451) !    Transform spectral coefficients into grid-point values
(  452) !
(  453) ! ** DUMMY ARGUMENTS
(  454) !    KSIZEJ: Number of latitudes
(  455) !    KTRUNC: troncature
(  456) !    KNUMMAXRESOL: maximum number of troncatures handled
(  457) !    KGPTOT: number of grid-points
(  458) !    KSLOEN: Size of KLOEN
(  459) !    KLOEN:
(  460) !    KSIZE: Size of PSPEC
(  461) !    LREORDER: switch to reorder spectral coefficients or not
(  462) !    LGRADIENT: switch to compute or not gradient
(  463) !    PSPEC: spectral coefficient array
(  464) !    PGPT: grid-point field
(  465) !    PGPTM: N-S derivative if LGRADIENT
(  466) !    PGPTL: E-W derivative if LGRADIENT
(  467) !
(  468) ! ** AUTHOR
(  469) !    9 April 2014, S. Riette
(  470) !
(  471) ! ** MODIFICATIONS
(  472) !    6 Jan., S. Riette: w_spec_setup interface modified
(  473) !    March, 2016, A.Mary: LREORDER
(  474) !    Sept., 2016, A.Mary: LGRADIENT
(  475) !
(  476) ! I. Dummy arguments declaration
(  477) USE PARKIND1, ONLY : JPRB
(  478) IMPLICIT NONE
(  479) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  480) INTEGER(KIND=8), INTENT(IN) :: KSIZEJ
(  481) INTEGER(KIND=8), INTENT(IN) :: KTRUNC
(  482) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  483) INTEGER(KIND=8), INTENT(IN) :: KGPTOT
(  484) INTEGER(KIND=8), INTENT(IN) :: KSLOEN
(  485) INTEGER(KIND=8), DIMENSION(KSLOEN), INTENT(IN) :: KLOEN
(  486) INTEGER(KIND=8), INTENT(IN) :: KSIZE
(  487) LOGICAL, INTENT(IN) :: LGRADIENT
(  488) LOGICAL, INTENT(IN) :: LREORDER
(  489) REAL(KIND=8), DIMENSION(KSIZE),  INTENT(IN)  :: PSPEC
(  490) REAL(KIND=8), DIMENSION(KGPTOT), INTENT(OUT) :: PGPT
(  491) REAL(KIND=8), DIMENSION(KGPTOT), INTENT(OUT) :: PGPTM
(  492) REAL(KIND=8), DIMENSION(KGPTOT), INTENT(OUT) :: PGPTL
(  493) !
(  494) ! II. Local variables declaration






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 11

(  495) INTEGER, DIMENSION(SIZE(KLOEN)) :: ILOEN
(  496) INTEGER :: ISIZEI, ISIZEJ, &
(  497)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  498)          & ITRUNCX, ITRUNCY, &
(  499)          & INUMMAXRESOL
(  500) LOGICAL :: LLSTOP
(  501) INTEGER :: IIDENTRESOL
(  502) INTEGER :: JI, JM, JN
(  503) INTEGER, DIMENSION(0:KTRUNC) :: NASM0
(  504) REAL(KIND=8), DIMENSION(1, KSIZE) :: ZSPBUF
(  505) REAL(KIND=JPRB), DIMENSION(KGPTOT, 3, 1) :: ZGPBUF
(  506) REAL(KIND=8) :: ZDELTAX, ZDELTAY
(  507) #include "trans_inq.h"
(  508) #include "inv_trans.h"
(  509) 
(  510) ILOEN(:)=KLOEN(:)
(  511) ISIZEI=0
(  512) ISIZEJ=KSIZEJ
(  513) IPHYSICALSIZEI=0
(  514) IPHYSICALSIZEJ=0
(  515) ITRUNCX=KTRUNC
(  516) ITRUNCY=0
(  517) INUMMAXRESOL=KNUMMAXRESOL
(  518) !
(  519) ! III. Setup
(  520) ZDELTAX=0.
(  521) ZDELTAY=0.
(  522) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  523)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .FALSE., SIZE(ILOEN), &
(  524)                   &ZDELTAX, ZDELTAY, IIDENTRESOL, LLSTOP)
(  525) !
(  526) ! IV. Transformation
(  527) IF (LREORDER) THEN
(  528)   ! IV.a Shape of coefficient array
(  529)   IF (.NOT. LLSTOP) THEN
(  530)     JI=1
(  531)     DO JN=0, KTRUNC
(  532)       NASM0(JN)=JI
(  533)       JI=JI+1+JN+(JN+1)
(  534)     ENDDO
(  535)   ENDIF
(  536) 
(  537)   ! IV.b Reordering
(  538)   IF(.NOT. LLSTOP) THEN
(  539)     ZSPBUF(1,:)=0.
(  540)     JI=1
(  541)     DO JM=0, KTRUNC
(  542)       DO JN=JM, KTRUNC
(  543)         ZSPBUF(1,JI)=PSPEC(NASM0(JN)+JM)
(  544)         JI=JI+1
(  545)         IF(JM==0) THEN
(  546)           ZSPBUF(1,JI)=0
(  547)         ELSE
(  548)           ZSPBUF(1,JI)=PSPEC(NASM0(JN)-JM)
(  549)         ENDIF
(  550)         JI=JI+1
(  551)       ENDDO
(  552)     ENDDO






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 12

(  553)   ENDIF
(  554) ELSE
(  555)   ZSPBUF(1,:) = PSPEC(:)
(  556) ENDIF
(  557) 
(  558) ! IV.c Inverse transform
(  559) IF (.NOT. LLSTOP) THEN
(  560)   IF (.NOT. LGRADIENT) THEN
(  561)     CALL INV_TRANS(PSPSCALAR=REAL(ZSPBUF(:,:),KIND=JPRB), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL)
(  562)     PGPT(:)=REAL(ZGPBUF(:,1,1),KIND=8)
(  563)   ELSE
(  564)     CALL INV_TRANS(PSPSCALAR=REAL(ZSPBUF(:,:),KIND=JPRB), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL, LDSCDERS=.TRUE.)
(  565)     PGPT(:)=REAL(ZGPBUF(:,1,1),KIND=8)
(  566)     PGPTM(:)=REAL(ZGPBUF(:,2,1),KIND=8)
(  567)     PGPTL(:)=REAL(ZGPBUF(:,3,1),KIND=8)
(  568)   ENDIF
(  569) ENDIF
(  570) END SUBROUTINE W_SPEC2GPT_GAUSS
(  571) 
(  572) !______________________________________________________________________
(  573) 
(  574) SUBROUTINE W_GPT2SPEC_LAM(KRETURNCODE, KSIZE, KSIZEI, KSIZEJ, KPHYSICALSIZEI, KPHYSICALSIZEJ, &
(  575)                          &KTRUNCX, KTRUNCY, KNUMMAXRESOL, PDELTAX, PDELTAY, LREORDER, PGPT, PSPEC)
(  576) ! ** PURPOSE
(  577) !    Transform grid point values into spectral coefficients
(  578) !
(  579) ! ** DUMMY ARGUMENTS
(  580) !    KRETURNCODE: error code
(  581) !    KSIZE: size of spectral field
(  582) !    KSIZEI, KSIZEJ: size of grid-point field (with extension zone)
(  583) !    KPHYSICALSIZEI, KPHYSICALSIZEJ: size of physical part of grid-point field
(  584) !    KTRUNCX, KTRUNCY: troncatures
(  585) !    KNUMMAXRESOL: maximum number of troncatures handled
(  586) !    PDELTAX: x resolution
(  587) !    PDELTAY: y resolution
(  588) !    LREORDER: switch to reorder spectral coefficients or not
(  589) !    PGPT: grid-point field
(  590) !    PSPEC: spectral coefficient array
(  591) !
(  592) ! ** AUTHOR
(  593) !    9 April 2014, S. Riette
(  594) !
(  595) ! ** MODIFICATIONS
(  596) !    6 Jan., S. Riette: PDELTAX and PDELTAY added
(  597) !    March, 2016, A.Mary: LREORDER
(  598) !
(  599) ! I. Dummy arguments declaration
(  600) USE PARKIND1, ONLY : JPRB
(  601) IMPLICIT NONE
(  602) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  603) INTEGER(KIND=8), INTENT(IN) :: KSIZE, KSIZEI, KSIZEJ
(  604) INTEGER(KIND=8), INTENT(IN) :: KPHYSICALSIZEI, KPHYSICALSIZEJ
(  605) INTEGER(KIND=8), INTENT(IN) :: KTRUNCX, KTRUNCY
(  606) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  607) REAL(KIND=8), INTENT(IN) :: PDELTAX
(  608) REAL(KIND=8), INTENT(IN) :: PDELTAY
(  609) LOGICAL, INTENT(IN) :: LREORDER
(  610) REAL(KIND=8), DIMENSION(KSIZEI*KSIZEJ), INTENT(IN) :: PGPT






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 13

(  611) REAL(KIND=8), DIMENSION(KSIZE), INTENT(OUT) :: PSPEC
(  612) !
(  613) ! II. Local variables declaration
(  614) INTEGER, DIMENSION(0:KTRUNCX) :: IESM0
(  615) INTEGER :: IGPTOT, ISPEC
(  616) INTEGER, DIMENSION(0:KTRUNCY) :: ISPECINI, ISPECEND
(  617) REAL(KIND=JPRB), DIMENSION(1, KSIZEI*KSIZEJ) :: ZSPBUF !size over-evaluated
(  618) REAL(KIND=JPRB), DIMENSION(KSIZEI*KSIZEJ, 1, 1) :: ZGPBUF
(  619) INTEGER :: JI, JM, JN, IIDENTRESOL
(  620) LOGICAL :: LLSTOP
(  621) INTEGER :: ISIZEI, ISIZEJ, &
(  622)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  623)          & ITRUNCX, ITRUNCY, &
(  624)          & INUMMAXRESOL
(  625) INTEGER, DIMENSION(1) :: ILOEN
(  626) 
(  627) #include "edir_trans.h"
(  628) #include "etrans_inq.h"
(  629) 
(  630) KRETURNCODE=0
(  631) LLSTOP=.FALSE.
(  632) ISIZEI=KSIZEI
(  633) ISIZEJ=KSIZEJ
(  634) IPHYSICALSIZEI=KPHYSICALSIZEI
(  635) IPHYSICALSIZEJ=KPHYSICALSIZEJ
(  636) ITRUNCX=KTRUNCX
(  637) ITRUNCY=KTRUNCY
(  638) INUMMAXRESOL=KNUMMAXRESOL
(  639) 
(  640) ! III. Setup
(  641) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  642)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .TRUE., 1, &
(  643)                   &PDELTAX, PDELTAY, IIDENTRESOL, LLSTOP)
(  644) 
(  645) ! IV. Transformation
(  646) 
(  647) ! IV.a Shape of coefficient array
(  648) !IGPTOT is the total number of points in grid-point space
(  649) !ISPEC is the number of spectral coefficients
(  650) !IESM0(m) is the index of spectral coefficient (m,0) in model
(  651) !ISPECINI(n) is the index of the first of the 4 spectral coefficient (0,n) in FA file
(  652) !ISPECEND(n) is the index of the last of the last 4 spectral coefficients (:,n) in FA file
(  653) IF (.NOT. LLSTOP) THEN
(  654)   CALL ETRANS_INQ(KRESOL=IIDENTRESOL, KGPTOT=IGPTOT, KSPEC=ISPEC, KESM0=IESM0)
(  655)   JI=1
(  656)   DO JN=0, ITRUNCY
(  657)     ISPECINI(JN)=(JI-1)*4+1
(  658)     JI=JI+COUNT(IESM0(1:ITRUNCX)-IESM0(0:ITRUNCX-1)>JN*4)
(  659)     IF (ISPEC-IESM0(ITRUNCX)>JN*4) JI=JI+1
(  660)     ISPECEND(JN)=(JI-1)*4
(  661)   ENDDO
(  662) ENDIF
(  663) 
(  664) ! III.b transform
(  665) IF (.NOT. LLSTOP) THEN
(  666)   ZGPBUF(:,1,1)=REAL(PGPT(:),KIND=JPRB)
(  667)   CALL EDIR_TRANS(PSPSCALAR=ZSPBUF(:,:), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL)
(  668) ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 14

(  669) 
(  670) ! III.c Reordering
(  671) ! reorder Aladin :  file ordering = coeffs per blocks of m, 4 reals per coeff
(  672) !           Aladin array ordering = coeffs per blocks of n, 4 reals per coeff
(  673) IF (LREORDER) THEN
(  674)   IF (.NOT. LLSTOP) THEN
(  675)     JI=1
(  676)     PSPEC(:)=0.
(  677)     DO JM=0,ITRUNCX*4+4,4
(  678)       DO JN=0,ITRUNCY
(  679)         IF (ISPECINI(JN)+JM+3<=ISPECEND(JN)) THEN
(  680)           PSPEC(ISPECINI(JN)+JM:ISPECINI(JN)+JM+3) = REAL(ZSPBUF(1,JI:JI+3),KIND=8)
(  681)           JI=JI+4
(  682)         ENDIF
(  683)       ENDDO
(  684)     ENDDO
(  685)     IF(JI/=ISPEC+1) THEN
(  686)       PRINT*, "Internal error in W_GPT2SPEC_LAM (spectral reordering)"
(  687)       KRETURNCODE=-999
(  688)     ENDIF
(  689)   ENDIF
(  690) ELSE
(  691)   PSPEC(1:KSIZE) = REAL(ZSPBUF(1,1:KSIZE),KIND=8)
(  692) ENDIF
(  693) 
(  694) END SUBROUTINE W_GPT2SPEC_LAM
(  695) 
(  696) !____________________________________________________________________________
(  697) 
(  698) SUBROUTINE W_GPT2SPEC_GAUSS(KRETURNCODE, KSPEC, KSIZEJ, KTRUNC, KNUMMAXRESOL, KSLOEN, KLOEN, KSIZE, LREORDER, PGPT, PSPEC)
(  699) ! ** PURPOSE
(  700) !    Transform spectral coefficients into grid-point values
(  701) !
(  702) ! ** DUMMY ARGUMENTS
(  703) !    KRETURNCODE: error code
(  704) !    KSPEC: size of spectral coefficients array
(  705) !    KSIZEJ: Number of latitudes
(  706) !    KTRUNC: troncature
(  707) !    KNUMMAXRESOL: maximum number of troncatures handled
(  708) !    KSLOEN: Size ok KLOEN
(  709) !    KLOEN
(  710) !    KSIZE: Size of PGPT
(  711) !    LREORDER: switch to reorder spectral coefficients or not
(  712) !    PGPT: grid-point field
(  713) !    PSPEC: spectral coefficient array
(  714) !
(  715) ! ** AUTHOR
(  716) !    9 April 2014, S. Riette
(  717) !
(  718) ! ** MODIFICATIONS
(  719) !    6 Jan. 2016, S. Riette: w_spec_setup interface modified
(  720) !    March, 2016, A.Mary: LREORDER
(  721) !
(  722) ! I. Dummy arguments declaration
(  723) USE PARKIND1, ONLY : JPRB
(  724) IMPLICIT NONE
(  725) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  726) INTEGER(KIND=8), INTENT(IN) :: KSPEC






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 15

(  727) INTEGER(KIND=8), INTENT(IN) :: KSIZEJ
(  728) INTEGER(KIND=8), INTENT(IN) :: KTRUNC
(  729) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  730) INTEGER(KIND=8), INTENT(IN) :: KSLOEN
(  731) INTEGER(KIND=8), DIMENSION(KSLOEN), INTENT(IN) :: KLOEN
(  732) INTEGER(KIND=8), INTENT(IN) :: KSIZE
(  733) LOGICAL, INTENT(IN) :: LREORDER
(  734) REAL(KIND=8), DIMENSION(KSIZE), INTENT(IN) :: PGPT
(  735) REAL(KIND=8), DIMENSION(KSPEC), INTENT(OUT) :: PSPEC
(  736) !
(  737) ! II. Local variables declaration
(  738) INTEGER, DIMENSION(SIZE(KLOEN)) :: ILOEN
(  739) INTEGER :: ISIZEI, ISIZEJ, &
(  740)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  741)          & ITRUNCX, ITRUNCY, &
(  742)          & INUMMAXRESOL
(  743) LOGICAL :: LLSTOP
(  744) INTEGER :: IIDENTRESOL
(  745) INTEGER :: JI, JM, JN
(  746) INTEGER, DIMENSION(0:KTRUNC) :: NASM0
(  747) REAL(KIND=JPRB), DIMENSION(1, SIZE(PGPT)) :: ZSPBUF !size over-evaluated
(  748) REAL(KIND=JPRB), DIMENSION(SIZE(PGPT), 1, 1) :: ZGPBUF
(  749) REAL(KIND=8) :: ZDELTAX, ZDELTAY
(  750) 
(  751) #include "trans_inq.h"
(  752) #include "dir_trans.h"
(  753) KRETURNCODE=0
(  754) ILOEN(:)=KLOEN(:)
(  755) ISIZEI=0
(  756) ISIZEJ=KSIZEJ
(  757) IPHYSICALSIZEI=0
(  758) IPHYSICALSIZEJ=0
(  759) ITRUNCX=KTRUNC
(  760) ITRUNCY=0
(  761) INUMMAXRESOL=KNUMMAXRESOL
(  762) !
(  763) ! III. Setup
(  764) ZDELTAX=0.
(  765) ZDELTAY=0.
(  766) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  767)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .FALSE., SIZE(ILOEN), &
(  768)                   &ZDELTAX, ZDELTAY, IIDENTRESOL, LLSTOP)
(  769) !
(  770) ! IV. Transformation
(  771) ! IV.a Shape of coefficient array
(  772) IF (.NOT. LLSTOP) THEN
(  773)   JI=1
(  774)   DO JN=0, KTRUNC
(  775)     NASM0(JN)=JI
(  776)     JI=JI+1+JN+(JN+1)
(  777)   ENDDO
(  778) ENDIF
(  779) 
(  780) ! IV.b Direct transform
(  781) IF (.NOT. LLSTOP) THEN
(  782)   ZGPBUF(:,1,1)=REAL(PGPT(:),KIND=JPRB)
(  783)   CALL DIR_TRANS(PSPSCALAR=ZSPBUF(:,:), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL)
(  784) ENDIF






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 16

(  785) 
(  786) ! IV.c Reordering
(  787) IF (LREORDER) THEN
(  788)   IF(.NOT. LLSTOP) THEN
(  789)     PSPEC(:)=0.
(  790)     JI=1
(  791)     DO JM=0, KTRUNC
(  792)       DO JN=JM, KTRUNC
(  793)         PSPEC(NASM0(JN)+JM)=REAL(ZSPBUF(1,JI),KIND=8)
(  794)         JI=JI+1
(  795)         IF(JM/=0) THEN
(  796)           PSPEC(NASM0(JN)-JM)=REAL(ZSPBUF(1,JI),KIND=8)
(  797)         ENDIF
(  798)         JI=JI+1
(  799)       ENDDO
(  800)     ENDDO
(  801)     IF(JI-1/=KSPEC) THEN
(  802)       PRINT*, "Internal error in W_GPT2SPEC_GAUSS (spectral reordering)"
(  803)       KRETURNCODE=-999
(  804)     ENDIF
(  805)   ENDIF
(  806) ELSE
(  807)   PSPEC(1:KSPEC) = REAL(ZSPBUF(1,1:KSPEC),KIND=8)
(  808) ENDIF
(  809) 
(  810) END SUBROUTINE W_GPT2SPEC_GAUSS
(  811) 
(  812) SUBROUTINE W_SPEC2GPT_FFT1D(KSIZES, KTRUNC, PSPEC, KSIZEG, PGPT)
(  813) ! ** PURPOSE
(  814) !    Transform spectral coefficients into grid-point values,
(  815) !    for a 1D array (vertical section academic model)
(  816) !
(  817) ! ** DUMMY ARGUMENTS
(  818) !    KSIZES size of PSPEC
(  819) !    KTRUNC: troncature
(  820) !    PSPEC: spectral coefficient array
(  821) !    KSIZEG: size of grid-point field (with extension zone)
(  822) !    PGPT: grid-point field
(  823) !
(  824) ! ** AUTHOR
(  825) !    26 March 2015, A. Mary, from utilities/pinuts/module/fa_datas_mod.F90
(  826) !
(  827) ! ** MODIFICATIONS
(  828) !
(  829) ! I. Dummy arguments declaration
(  830) IMPLICIT NONE
(  831) 
(  832) INTEGER(KIND=8), INTENT(IN) :: KSIZES
(  833) INTEGER(KIND=8), INTENT(IN) :: KTRUNC
(  834) REAL(KIND=8), DIMENSION(KSIZES), INTENT(IN) :: PSPEC
(  835) INTEGER(KIND=8), INTENT(IN) :: KSIZEG
(  836) REAL(KIND=8), DIMENSION(KSIZEG), INTENT(OUT) :: PGPT
(  837) 
(  838) INTEGER(KIND=8) :: NSEFRE, NFTM, NDGLSUR
(  839) REAL(KIND=8), DIMENSION(:), ALLOCATABLE :: SP2, TRIGSE
(  840) INTEGER(KIND=8), DIMENSION(:), ALLOCATABLE  :: NFAXE
(  841) INTEGER(KIND=8), PARAMETER :: NZERO=0
(  842) 






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 17

(  843) NDGLSUR = KSIZEG+MOD(KSIZEG,2)+2
(  844) NFTM    = 2*(KTRUNC+1)
(  845) ALLOCATE(SP2(NDGLSUR*NFTM))
(  846) SP2     = 0.0
(  847) SP2     = CONVRT2FFT(PSPEC,NZERO,KTRUNC,NDGLSUR)
(  848) ALLOCATE(NFAXE(1:10))
(  849) ALLOCATE(TRIGSE(1:KSIZEG)) 
(  850) CALL SET99(TRIGSE,NFAXE,KSIZEG)
(  851) CALL FFT992(SP2(1:KSIZEG), TRIGSE, NFAXE, 1, NDGLSUR, KSIZEG, 1, 1)
(  852) DEALLOCATE(TRIGSE)
(  853) DEALLOCATE(NFAXE)
(  854) PGPT(:) = SP2(1:KSIZEG)
(  855) 
(  856) CONTAINS
(  857) 
(  858) ! from utilities/pinuts/module/fa_datas_mod.F90
(  859) ! and utilities/pinuts/module/array_lib_mod.F90
(  860) 
(  861) FUNCTION CONVRT2FFT(IN,X,Y,N) RESULT(OU)
(  862) REAL(KIND=8),DIMENSION(:),INTENT(IN)      :: IN
(  863) INTEGER(KIND=8),INTENT(IN)                       :: X, Y, N
(  864) REAL(KIND=8),DIMENSION(N*2*(X+1))         :: OU
(  865) 
(  866) INTEGER(KIND=8),DIMENSION(2*(X+1),(N/2))         :: MINQ 
(  867) INTEGER(KIND=8),DIMENSION((N/2),2*(X+1))         :: TMINQ 
(  868) REAL(KIND=8),DIMENSION(2*(X+1),(N/2))     :: OMINQ, EMINQ
(  869) REAL(KIND=8),DIMENSION((N/2),2*(X+1))     :: TOMINQ, TEMINQ   
(  870) REAL(KIND=8),DIMENSION(N*(X+1))           :: OINI, EINI
(  871) REAL(KIND=8), PARAMETER                   :: ZZERO=0.0
(  872) 
(  873) CALL SPLIT_ODEV(IN,OINI,EINI)
(  874) MINQ   = MASQ(X,Y,N)
(  875) OMINQ  = UNPACK(OINI,MINQ == 1,ZZERO)
(  876) TOMINQ = TRANSPOSE(OMINQ)
(  877) EMINQ  = UNPACK(EINI,MINQ == 1,ZZERO)
(  878) TEMINQ = TRANSPOSE(EMINQ)
(  879) TMINQ  = 1
(  880) OINI   = PACK(TOMINQ,TMINQ > 0)
(  881) EINI   = PACK(TEMINQ,TMINQ > 0)
(  882) OU     = MIX_ODEV(OINI,EINI)
(  883) END FUNCTION CONVRT2FFT
(  884) 
(  885) FUNCTION MASQ(X,Y,N) RESULT(T)
(  886) INTEGER(KIND=8),INTENT(IN)                       :: X, Y, N
(  887) INTEGER(KIND=8),DIMENSION(1:2*(X+1),1:(N/2))     :: T
(  888) 
(  889) INTEGER(KIND=8)                                  :: I, J
(  890) INTEGER(KIND=8),DIMENSION(0:X)                   :: KM
(  891) INTEGER(KIND=8),DIMENSION(0:Y)                   :: KN
(  892) CALL ELLIPS64(X,Y,KN,KM) 
(  893) T = 0
(  894) DO I=0,Y
(  895)   DO J=0,2*KN(I)+1
(  896)     T(J+1,I+1)=1
(  897)   END DO
(  898) END DO
(  899) END FUNCTION MASQ
(  900) 






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 18

(  901) FUNCTION MIX_ODEV(TO,TE) RESULT(T)
(  902) REAL(KIND=8),DIMENSION(:),INTENT(IN)        :: TO,TE
(  903) REAL(KIND=8),DIMENSION(SIZE(TO)+SIZE(TE))   :: T
(  904) 
(  905) INTEGER(KIND=8) :: I
(  906) 
(  907) DO I=1,(SIZE(TO)+SIZE(TE))/2
(  908)   T((2*I)-1)=TE(I)
(  909)   T(2*I)=TO(I)
(  910) END DO
(  911) END FUNCTION MIX_ODEV
(  912) 
(  913) SUBROUTINE SPLIT_ODEV(T,TO,TE)
(  914) REAL(KIND=8),DIMENSION(:),INTENT(IN)          :: T
(  915) REAL(KIND=8),DIMENSION(SIZE(T)/2),INTENT(OUT) :: TO,TE
(  916) 
(  917) INTEGER(KIND=8) :: I
(  918) 
(  919) DO I=1,SIZE(T)/2
(  920)   TO(I)=T(2*I)
(  921)   TE(I)=T((2*I)-1)
(  922) END DO
(  923) END SUBROUTINE SPLIT_ODEV
(  924) 
(  925) END SUBROUTINE W_SPEC2GPT_FFT1D







































NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 19

(    1) # 1 "transforms4py.F90"
(    1) SUBROUTINE W_SPEC_SETUP(KRETURNCODE, KSIZEI, KSIZEJ, KPHYSICALSIZEI, KPHYSICALSIZEJ, &
(    2)                        &KTRUNCX, KTRUNCY, KNUMMAXRESOL, KLOEN, LDLAM, &
(    3)                        &KSIZEKLOEN, PDELTAX, PDELTAY, &
(    4)                        &KIDENTRESOL, LDSTOP)
(    5) ! ** PURPOSE
(    6) !    Setup spectral transform for LAM and global
(    7) !
(    8) ! ** DUMMY ARGUMENTS
(    9) !    KRETURNCODE: error code
(   10) !    KSIZEI, KSIZEJ: size of grid-point field (with extension zone for LAM), put max size for KSIZEI in global
(   11) !    KPHYSICALSIZEI, KPHYSICALSIZEJ: size of physical part of grid-point field for LAM (put 0 for global)
(   12) !    KTRUNCX, KTRUNCY: troncatures for LAM (only KTRUNCX is used for global, put 0 for KTRUNCY)
(   13) !    KNUMMAXRESOL: maximum number of troncatures handled
(   14) !    KLOEN: number of points on each latitude row
(   15) !    KSIZEKLOEN: size of KLOEN array
(   16) !    PDELTAX: x resolution
(   17) !    PDELTAY: y resolution
(   18) !    LDLAM: LAM (.TRUE.) or global (.FALSE.)
(   19) !    KIDENTRESOL: identification of resolution
(   20) !    LDSTOP: exception raised?
(   21) !
(   22) ! ** AUTHOR
(   23) !    9 April 2014, S. Riette
(   24) !
(   25) ! ** MODIFICATIONS
(   26) !    6 Jan 2016, S. Riette: PDELTAX and PDELTAY added
(   27) !    31 Jan 2019 R. El Khatib fix for single precision compilation
(   28) !
(   29) ! I. Dummy arguments declaration
(   30) USE PARKIND1, ONLY : JPRB
(   31) IMPLICIT NONE
(   32) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(   33) INTEGER, INTENT(IN) :: KSIZEI, KSIZEJ
(   34) INTEGER, INTENT(IN) :: KPHYSICALSIZEI, KPHYSICALSIZEJ
(   35) INTEGER, INTENT(IN) :: KTRUNCX, KTRUNCY
(   36) INTEGER, INTENT(IN) :: KNUMMAXRESOL
(   37) INTEGER, DIMENSION(KSIZEKLOEN), INTENT(IN) :: KLOEN
(   38) LOGICAL, INTENT(IN) :: LDLAM
(   39) INTEGER, INTENT(IN) :: KSIZEKLOEN
(   40) REAL(KIND=8), INTENT(IN) :: PDELTAX
(   41) REAL(KIND=8), INTENT(IN) :: PDELTAY
(   42) INTEGER, INTENT(OUT) :: KIDENTRESOL
(   43) LOGICAL, INTENT(OUT) :: LDSTOP
(   44) !
(   45) ! II. Local variables declaration
(   46) INTEGER, DIMENSION(2*KSIZEJ) :: ILOEN
(   47) INTEGER :: JI
(   48) LOGICAL, SAVE :: LLFIRSTCALL=.TRUE.
(   49) LOGICAL :: LLNEWRESOL
(   50) INTEGER, SAVE :: INBRESOL=0
(   51) INTEGER(KIND=8) :: ICODEILOEN
(   52) INTEGER, SAVE :: INUMMAXRESOLSAVE=-1
(   53) INTEGER, DIMENSION(:), ALLOCATABLE, SAVE :: ITRUNCXSAVE, ITRUNCYSAVE, &
(   54)                                             IPHYSICALSIZEISAVE, &
(   55)                                             IPHYSICALSIZEJSAVE, &
(   56)                                             ISIZEISAVE, ISIZEJSAVE, &
(   57)                                             IIDENTRESOLSAVE






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 20

(   58) INTEGER(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE :: ILOENSAVE
(   59) REAL(KIND=8), DIMENSION(:), ALLOCATABLE, SAVE :: ZDELTAXSAVE, &
(   60)                                                         ZDELTAYSAVE
(   61) REAL(KIND=8) :: ZEXWN, ZEYWN
(   62) # 63 "transforms4py.F90"
(   63) # 1 ".D[70]/setup_trans0.h"
(    1) INTERFACE
(    2) SUBROUTINE SETUP_TRANS0(KOUT,KERR,KPRINTLEV,KMAX_RESOL,KPROMATR,&
(    3) &                       KPRGPNS,KPRGPEW,KPRTRW,KCOMBFLEN,&
(    4) &                       LDMPOFF,LDSYNC_TRANS,KTRANS_SYNC_LEVEL,&
(    5) &                       LDEQ_REGIONS,K_REGIONS_NS,K_REGIONS_EW,K_REGIONS,&
(    6) &                       PRAD,LDALLOPERM,KOPT_MEMORY_TR)
(    7) # 8 ".D[70]/setup_trans0.h"
(    8) !**** *SETUP_TRANS0* - General setup routine for transform package
(    9) # 10 ".D[70]/setup_trans0.h"
(   10) !     Purpose.
(   11) !     --------
(   12) !     Resolution independent part of setup of transform package
(   13) !     Has to be called BEFORE SETUP_TRANS
(   14) # 15 ".D[70]/setup_trans0.h"
(   15) !**   Interface.
(   16) !     ----------
(   17) !     CALL SETUP_TRANS0(...)
(   18) # 19 ".D[70]/setup_trans0.h"
(   19) !     Explicit arguments : All arguments are optional, [..] default value
(   20) !     -------------------
(   21) !     KOUT - Unit number for listing output [6]
(   22) !     KERR - Unit number for error messages [0]
(   23) !     KPRINTLEV - level of output to KOUT, 0->no output,1->normal,2->debug [0]
(   24) !     KMAX_RESOL - maximum number of different resolutions for this run [1]
(   25) !     KPRGPNS - splitting level in N-S direction in grid-point space [1]
(   26) !     KPRGPEW - splitting level in E-W direction in grid-point space [1]
(   27) !     KPRTRW  - splitting level in wave direction in spectral space [1]
(   28) !     KCOMBFLEN - Size of communication buffer [1800000 (*8bytes) ]
(   29) !     LDMPOFF - switch off message passing [false]
(   30) !     LDSYNC_TRANS - switch to activate barrier before transforms [false]
(   31) !     KTRANS_SYNC_LEVEL - use of synchronization/blocking [0]
(   32) !     LDEQ_REGIONS - true if new eq_regions partitioning [false]
(   33) !     K_REGIONS    - Number of regions (1D or 2D partitioning)
(   34) !     K_REGIONS_NS - Maximum number of NS partitions
(   35) !     K_REGIONS_EW - Maximum number of EW partitions
(   36) !     PRAD         - Radius of the planet
(   37) !     LDALLOPERM  - Allocate certain arrays permanently
(   38) !     KOPT_MEMORY_TR - memory strategy (stack vs heap) in gripoint transpositions
(   39) # 40 ".D[70]/setup_trans0.h"
(   40) !     The total number of (MPI)-processors has to be equal to KPRGPNS*KPRGPEW
(   41) # 42 ".D[70]/setup_trans0.h"
(   42) !     Method.
(   43) !     -------
(   44) # 45 ".D[70]/setup_trans0.h"
(   45) !     Externals.  SUMP_TRANS0 - initial setup routine
(   46) !     ----------
(   47) # 48 ".D[70]/setup_trans0.h"
(   48) !     Author.
(   49) !     -------
(   50) !        Mats Hamrud *ECMWF*
(   51) # 52 ".D[70]/setup_trans0.h"
(   52) !     Modifications.






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 21

(   53) !     --------------
(   54) !        Original : 00-03-03
(   55) !        R. El Khatib 03-01-24 LDMPOFF
(   56) !        G. Mozdzynski 2006-09-13 LDEQ_REGIONS
(   57) !        N. Wedi  2009-11-30 add radius
(   58) !        R. El Khatib 09-Sep-2020 NSTACK_MEMORY_TR
(   59) # 60 ".D[70]/setup_trans0.h"
(   60) !     ------------------------------------------------------------------
(   61) # 62 ".D[70]/setup_trans0.h"
(   62) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   63) # 64 ".D[70]/setup_trans0.h"
(   64) IMPLICIT NONE
(   65) # 66 ".D[70]/setup_trans0.h"
(   66) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KOUT,KERR,KPRINTLEV,KMAX_RESOL,KPROMATR
(   67) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KPRGPNS,KPRGPEW,KPRTRW,KCOMBFLEN
(   68) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDMPOFF
(   69) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDSYNC_TRANS
(   70) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KTRANS_SYNC_LEVEL
(   71) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDEQ_REGIONS
(   72) LOGICAL            ,OPTIONAL,INTENT(IN)  :: LDALLOPERM
(   73) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN)  :: PRAD
(   74) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN)  :: KOPT_MEMORY_TR
(   75) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS(:)
(   76) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS_NS
(   77) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT) :: K_REGIONS_EW
(   78) # 79 ".D[70]/setup_trans0.h"
(   79) END SUBROUTINE SETUP_TRANS0
(   80) # 83 ".D[70]/setup_trans0.h"
(   83) END INTERFACE
(   84) # 64 "transforms4py.F90"
(   64) # 64 "transforms4py.F90"
(   64) # 1 ".D[60]/esetup_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE ESETUP_TRANS(KMSMAX,KSMAX,KDGL,KDGUX,KLOEN,LDSPLIT,&
(    3)  & KTMAX,KRESOL,PEXWN,PEYWN,PWEIGHT,LDGRIDONLY,KNOEXTZL,KNOEXTZG,&
(    4)  & LDUSEFFTW)
(    5) !**** *ESETUP_TRANS* - Setup transform package for specific resolution
(    6) # 7 ".D[60]/esetup_trans.h"
(    7) !     Purpose.
(    8) !     --------
(    9) !     To setup for making spectral transforms. Each call to this routine
(   10) !     creates a new resolution up to a maximum of NMAX_RESOL set up in
(   11) !     SETUP_TRANS0. You need to call SETUP_TRANS0 before this routine can
(   12) !     be called.
(   13) # 14 ".D[60]/esetup_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL ESETUP_TRANS(...)
(   17) # 18 ".D[60]/esetup_trans.h"
(   18) !     Explicit arguments : KLOEN,LDSPLIT are optional arguments
(   19) !     -------------------- 
(   20) !     KSMAX - spectral truncation required
(   21) !     KDGL  - number of Gaussian latitudes
(   22) !     KLOEN(:) - number of points on each Gaussian latitude [2*KDGL]
(   23) !     LDSPLIT - true if split latitudes in grid-point space [false]
(   24) !     KTMAX - truncation order for tendencies?
(   25) !     KRESOL - the resolution identifier
(   26) !     KSMAX,KDGL,KTMAX and KLOEN are GLOBAL variables desribing the resolution






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 22

(   27) !     in spectral and grid-point space
(   28) !     LDGRIDONLY - true if only grid space is required
(   29) # 31 ".D[60]/esetup_trans.h"
(   31) !     LDSPLIT describe the distribution among processors of
(   32) !     grid-point data and has no relevance if you are using a single processor
(   33)  
(   34) !     LDUSEFFTW   - Use FFTW for FFTs
(   35) # 36 ".D[60]/esetup_trans.h"
(   36) !     Method.
(   37) !     -------
(   38) # 39 ".D[60]/esetup_trans.h"
(   39) !     Externals.  ESET_RESOL   - set resolution
(   40) !     ----------  ESETUP_DIMS  - setup distribution independent dimensions
(   41) !                 SUEMP_TRANS_PRELEG - first part of setup of distr. environment
(   42) !                 SULEG - Compute Legandre polonomial and Gaussian 
(   43) !                         Latitudes and Weights
(   44) !                 ESETUP_GEOM - Compute arrays related to grid-point geometry
(   45) !                 SUEMP_TRANS - Second part of setup of distributed environment
(   46) !                 SUEFFT - setup for FFT
(   47) # 48 ".D[60]/esetup_trans.h"
(   48) !     Author.
(   49) !     -------
(   50) !        Mats Hamrud *ECMWF*
(   51) # 52 ".D[60]/esetup_trans.h"
(   52) !     Modifications.
(   53) !     --------------
(   54) !        Original : 00-03-03
(   55) !        02-04-11 A. Bogatchev: Passing of TCDIS
(   56) !        02-11-14 C. Fischer: soften test on KDGL
(   57) !        M.Hamrud      01-Oct-2003 CY28 Cleaning
(   58) !        A.Nmiri       15-Nov-2007 Phasing with TFL 32R3
(   59) !        A.Bogatchev   16-Sep-2010 Phasing cy37
(   60) !        D. Degrauwe  (Feb 2012): Alternative extension zone (E')
(   61) # 62 ".D[60]/esetup_trans.h"
(   62) !     ------------------------------------------------------------------
(   63) # 64 ".D[60]/esetup_trans.h"
(   64) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   65) # 66 ".D[60]/esetup_trans.h"
(   66) IMPLICIT NONE
(   67) # 68 ".D[60]/esetup_trans.h"
(   68) ! Dummy arguments
(   69) INTEGER(KIND=JPIM),INTENT(IN)    :: KMSMAX 
(   70) INTEGER(KIND=JPIM),INTENT(IN)    :: KSMAX 
(   71) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGL 
(   72) INTEGER(KIND=JPIM),INTENT(IN)    :: KDGUX 
(   73) INTEGER(KIND=JPIM),INTENT(IN)    :: KLOEN(:) 
(   74) LOGICAL           ,OPTIONAL,INTENT(IN)    :: LDSPLIT 
(   75) LOGICAL           ,OPTIONAL,INTENT(IN)    :: LDGRIDONLY
(   76) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KTMAX 
(   77) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KRESOL 
(   78) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PEXWN 
(   79) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PEYWN 
(   80) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(IN)    :: PWEIGHT(:)
(   81) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KNOEXTZL
(   82) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KNOEXTZG
(   83) LOGICAL   ,OPTIONAL,INTENT(IN)            :: LDUSEFFTW
(   84) # 85 ".D[60]/esetup_trans.h"
(   85) END SUBROUTINE ESETUP_TRANS






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 23

(   86) END INTERFACE
(   87) # 65 "transforms4py.F90"
(   65) # 65 "transforms4py.F90"
(   65) # 1 ".D[70]/setup_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE SETUP_TRANS(KSMAX,KDGL,KDLON,KLOEN,LDSPLIT,PSTRET,&
(    3) &KTMAX,KRESOL,PWEIGHT,LDGRIDONLY,LDUSERPNM,LDKEEPRPNM,LDUSEFLT,&
(    4) &LDSPSETUPONLY,LDPNMONLY,LDUSEFFTW,&
(    5) &LDLL,LDSHIFTLL,CDIO_LEGPOL,CDLEGPOLFNAME,KLEGPOLPTR,KLEGPOLPTR_LEN)
(    6) # 7 ".D[70]/setup_trans.h"
(    7) !**** *SETUP_TRANS* - Setup transform package for specific resolution
(    8) # 9 ".D[70]/setup_trans.h"
(    9) !     Purpose.
(   10) !     --------
(   11) !     To setup for making spectral transforms. Each call to this routine
(   12) !     creates a new resolution up to a maximum of NMAX_RESOL set up in
(   13) !     SETUP_TRANS0. You need to call SETUP_TRANS0 before this routine can
(   14) !     be called.
(   15) # 16 ".D[70]/setup_trans.h"
(   16) !**   Interface.
(   17) !     ----------
(   18) !     CALL SETUP_TRANS(...)
(   19) # 20 ".D[70]/setup_trans.h"
(   20) !     Explicit arguments : KLOEN,LDSPLIT are optional arguments
(   21) !     -------------------- 
(   22) !     KSMAX - spectral truncation required
(   23) !     KDGL  - number of Gaussian latitudes
(   24) !     KDLON - number of points on each latitude [2*KDGL]
(   25) !     KLOEN(:) - number of points on each Gaussian latitude [2*KDGL]
(   26) !     LDSPLIT - true if split latitudes in grid-point space [false]
(   27) !     KTMAX - truncation order for tendencies?
(   28) !     KRESOL - the resolution identifier
(   29) !     PWEIGHT - the weight per grid-point (for a weighted distribution)
(   30) !     LDGRIDONLY - true if only grid space is required
(   31) # 32 ".D[70]/setup_trans.h"
(   32) !     KSMAX,KDGL,KTMAX and KLOEN are GLOBAL variables desribing the resolution
(   33) !     in spectral and grid-point space
(   34) # 35 ".D[70]/setup_trans.h"
(   35) !     LDSPLIT describe the distribution among processors of grid-point data and
(   36) !     has no relevance if you are using a single processor
(   37) # 38 ".D[70]/setup_trans.h"
(   38) !     LDUSEFLT   - use Fast Legandre Transform (Butterfly algorithm)
(   39) !     LDUSERPNM  - Use Belusov to compute legendre pol. (else new alg.)
(   40) !     LDKEEPRPNM - Keep Legendre Polynomials (only applicable when using
(   41) !                  FLT, otherwise always kept)
(   42) !     LDPNMONLY  - Compute the Legendre polynomialsonly, not the FFTs.
(   43) !     LDUSEFFTW   - Use FFTW for FFTs
(   44) !     LDLL                 - Setup second set of input/output latitudes
(   45) !                                 the number of input/output latitudes to transform is equal KDGL 
(   46) !                                 or KDGL+2 in the case that includes poles + equator
(   47) !                                 the number of input/output longitudes to transform is 2*KDGL
(   48) !     LDSHIFTLL       - Shift output lon/lat data by 0.5*dx and 0.5*dy
(   49)  
(   50) !     Method.
(   51) !     -------
(   52) # 53 ".D[70]/setup_trans.h"
(   53) !     Externals.  SET_RESOL   - set resolution
(   54) !     ----------  SETUP_DIMS  - setup distribution independent dimensions






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 24

(   55) !                 SUMP_TRANS_PRELEG - first part of setup of distr. environment
(   56) !                 SULEG - Compute Legandre polonomial and Gaussian 
(   57) !                         Latitudes and Weights
(   58) !                 SUMP_TRANS - Second part of setup of distributed environment
(   59) !                 SUFFT - setup for FFT
(   60) # 61 ".D[70]/setup_trans.h"
(   61) !     Author.
(   62) !     -------
(   63) !        Mats Hamrud *ECMWF*
(   64) # 65 ".D[70]/setup_trans.h"
(   65) !     Modifications.
(   66) !     --------------
(   67) !        Original : 00-03-03
(   68) # 69 ".D[70]/setup_trans.h"
(   69) !     ------------------------------------------------------------------
(   70) # 71 ".D[70]/setup_trans.h"
(   71) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(   72)     USE, INTRINSIC :: ISO_C_BINDING, ONLY:  C_PTR, C_INT,C_ASSOCIATED,C_SIZE_T
(   73) # 75 ".D[70]/setup_trans.h"
(   75) IMPLICIT NONE
(   76) # 77 ".D[70]/setup_trans.h"
(   77) ! Dummy arguments
(   78) # 79 ".D[70]/setup_trans.h"
(   79) INTEGER(KIND=JPIM) ,INTENT(IN) :: KSMAX,KDGL
(   80) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KDLON
(   81) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KLOEN(:)
(   82) LOGICAL   ,OPTIONAL,INTENT(IN) :: LDSPLIT
(   83) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(IN) :: KTMAX
(   84) INTEGER(KIND=JPIM) ,OPTIONAL,INTENT(OUT):: KRESOL
(   85) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN) :: PWEIGHT(:)
(   86) REAL(KIND=JPRB)    ,OPTIONAL,INTENT(IN) :: PSTRET
(   87) LOGICAL   ,OPTIONAL,INTENT(IN):: LDGRIDONLY
(   88) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSEFLT
(   89) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSERPNM
(   90) LOGICAL   ,OPTIONAL,INTENT(IN):: LDKEEPRPNM
(   91) LOGICAL   ,OPTIONAL,INTENT(IN):: LDPNMONLY
(   92) LOGICAL   ,OPTIONAL,INTENT(IN):: LDSPSETUPONLY
(   93) LOGICAL   ,OPTIONAL,INTENT(IN):: LDUSEFFTW
(   94) LOGICAL   ,OPTIONAL,INTENT(IN):: LDLL
(   95) LOGICAL   ,OPTIONAL,INTENT(IN):: LDSHIFTLL
(   96) CHARACTER(LEN=*),OPTIONAL,INTENT(IN):: CDIO_LEGPOL
(   97) CHARACTER(LEN=*),OPTIONAL,INTENT(IN):: CDLEGPOLFNAME
(   98) TYPE(C_PTR) ,OPTIONAL,INTENT(IN) :: KLEGPOLPTR
(   99) INTEGER(C_SIZE_T) ,OPTIONAL,INTENT(IN) :: KLEGPOLPTR_LEN
(  100) # 102 ".D[70]/setup_trans.h"
(  102) END SUBROUTINE SETUP_TRANS
(  103) # 105 ".D[70]/setup_trans.h"
(  105) END INTERFACE
(  106) # 66 "transforms4py.F90"
(   66) # 67 "transforms4py.F90"
(   67) KRETURNCODE=0
(   68) LDSTOP=.FALSE.
(   69) ! III. Setup
(   70) # 71 "transforms4py.F90"
(   71) ! III.a Setup LAM and global spectral transform - all resolutions
(   72) ! Maximum number of resolution is set now and cannot be change anymore
(   73) IF (LLFIRSTCALL) THEN
(   74)   !This code is called only once, whatever is the number of resolutions






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 25

(   75)   CALL SETUP_TRANS0(KPRINTLEV=0, LDMPOFF=.TRUE., KMAX_RESOL=KNUMMAXRESOL)
(   76)   ALLOCATE(ITRUNCXSAVE(KNUMMAXRESOL))
(   77)   ALLOCATE(ITRUNCYSAVE(KNUMMAXRESOL))
(   78)   ALLOCATE(IPHYSICALSIZEISAVE(KNUMMAXRESOL))
(   79)   ALLOCATE(IPHYSICALSIZEJSAVE(KNUMMAXRESOL))
(   80)   ALLOCATE(ISIZEJSAVE(KNUMMAXRESOL))
(   81)   ALLOCATE(ISIZEISAVE(KNUMMAXRESOL))
(   82)   ALLOCATE(ILOENSAVE(KNUMMAXRESOL))
(   83)   ALLOCATE(IIDENTRESOLSAVE(KNUMMAXRESOL))
(   84)   ALLOCATE(ZDELTAXSAVE(KNUMMAXRESOL))
(   85)   ALLOCATE(ZDELTAYSAVE(KNUMMAXRESOL))
(   86)   ITRUNCXSAVE=-1
(   87)   ITRUNCYSAVE=-1
(   88)   IPHYSICALSIZEISAVE=-1
(   89)   IPHYSICALSIZEJSAVE=-1
(   90)   ISIZEJSAVE=-1
(   91)   ISIZEISAVE=-1
(   92)   ILOENSAVE=-1
(   93)   IIDENTRESOLSAVE=-1
(   94)   ZDELTAXSAVE=-1.
(   95)   ZDELTAXSAVE=-1.
(   96)   LLFIRSTCALL=.FALSE.
(   97)   INUMMAXRESOLSAVE=KNUMMAXRESOL
(   98) ENDIF
(   99) !
(  100) ! III.b Is-it a new resolution?
(  101) LLNEWRESOL=.TRUE.
(  102) IF(LDLAM) THEN
(  103)   ILOEN(:)=KSIZEI
(  104) ELSE
(  105)   ILOEN(:)=0
(  106)   ILOEN(1:MIN(SIZE(ILOEN),SIZE(KLOEN)))=KLOEN(1:MIN(SIZE(ILOEN),SIZE(KLOEN)))
(  107) ENDIF
(  108) ICODEILOEN=0
(  109) DO JI=1, SIZE(ILOEN)
(  110)   ICODEILOEN=ICODEILOEN+ILOEN(JI)*JI**4
(  111) ENDDO
(  112) DO JI=1, INBRESOL
(  113)   IF (KTRUNCX==ITRUNCXSAVE(JI) .AND. KTRUNCY==ITRUNCYSAVE(JI) .AND. &
(  114)    &KPHYSICALSIZEI==IPHYSICALSIZEISAVE(JI) .AND. &
(  115)    &KPHYSICALSIZEJ==IPHYSICALSIZEJSAVE(JI) .AND. &
(  116)    &KSIZEJ==ISIZEJSAVE(JI) .AND. KSIZEI==ISIZEISAVE(JI) .AND. &
(  117)    &ICODEILOEN==ILOENSAVE(JI) .AND. &
(  118)    &PDELTAX==ZDELTAXSAVE(JI) .AND. PDELTAY==ZDELTAYSAVE(JI)) THEN
(  119)     KIDENTRESOL=IIDENTRESOLSAVE(JI)
(  120)     LLNEWRESOL=.FALSE.
(  121)   ENDIF
(  122) ENDDO
(  123) IF(LLNEWRESOL) THEN
(  124)   INBRESOL=INBRESOL+1
(  125)   IF(INBRESOL>INUMMAXRESOLSAVE) THEN
(  126)     PRINT*, "Error in W_SPEC_SETUP: Maximum number of resolution is exceeded."
(  127)     KRETURNCODE=-999
(  128)     LDSTOP=.TRUE.
(  129)   ENDIF
(  130) ENDIF
(  131) !
(  132) ! III.c Setup LAM or global spectral transform - once by resolution






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 26

(  133) IF(LLNEWRESOL .AND. .NOT. LDSTOP) THEN
(  134)   ! The following code is exectuded once for each resolution
(  135)   ITRUNCXSAVE(INBRESOL)=KTRUNCX
(  136)   ITRUNCYSAVE(INBRESOL)=KTRUNCY
(  137)   IPHYSICALSIZEISAVE(INBRESOL)=KPHYSICALSIZEI
(  138)   IPHYSICALSIZEJSAVE(INBRESOL)=KPHYSICALSIZEJ
(  139)   ISIZEISAVE(INBRESOL)=KSIZEI
(  140)   ISIZEJSAVE(INBRESOL)=KSIZEJ
(  141)   ILOENSAVE(INBRESOL)=ICODEILOEN
(  142)   ZDELTAXSAVE(INBRESOL)=PDELTAX
(  143)   ZDELTAYSAVE(INBRESOL)=PDELTAY
(  144)   IF(LDLAM) THEN
(  145)     ZEXWN=2*3.141592653589797/(KSIZEI*PDELTAX)
(  146)     ZEYWN=2*3.141592653589797/(KSIZEJ*PDELTAY)
(  147)     CALL ESETUP_TRANS(KMSMAX=ITRUNCXSAVE(INBRESOL), KSMAX=ITRUNCYSAVE(INBRESOL), &
(  148)                      &KDGUX=IPHYSICALSIZEJSAVE(INBRESOL), &
(  149)                      &KDGL=ISIZEJSAVE(INBRESOL), KLOEN=ILOEN(:), KRESOL=IIDENTRESOLSAVE(INBRESOL), &
(  150)                      &PEXWN=REAL(ZEXWN,KIND=JPRB), PEYWN=REAL(ZEYWN,KIND=JPRB))
(  151)   ELSE
(  152)     PRINT*, "Setup spectral transform"
(  153)     CALL SETUP_TRANS(KSMAX=ITRUNCXSAVE(INBRESOL), KDGL=ISIZEJSAVE(INBRESOL), &
(  154)                     &KLOEN=ILOEN(1:ISIZEJSAVE(INBRESOL)), KRESOL=IIDENTRESOLSAVE(INBRESOL))
(  155)     PRINT*, "End Setup spectral transform"
(  156)   ENDIF
(  157)   KIDENTRESOL=IIDENTRESOLSAVE(INBRESOL)
(  158) ENDIF
(  159) END SUBROUTINE W_SPEC_SETUP
(  160) # 161 "transforms4py.F90"
(  161) !__________________________________________________________________________
(  162) # 163 "transforms4py.F90"
(  163) SUBROUTINE W_TRANS_INQ(KRETURNCODE, KSIZEJ, KTRUNC, KSLOEN, KLOEN, KNUMMAXRESOL, &
(  164)                       &KGPTOT, KSPEC, KNMENG)
(  165) ! ** PURPOSE
(  166) !    Simplified wrapper to TRANS_INQ
(  167) !
(  168) ! ** DUMMY ARGUMENTS
(  169) !    KSIZEJ: number of latitudes in grid-point space
(  170) !    KTRUNC: troncature
(  171) !    KSLOEN: Size of KLOEN
(  172) !    KLOEN: number of points on each latitude row
(  173) !    KNUMMAXRESOL: maximum number of troncatures handled
(  174) !    KGPTOT: number of gridpoints
(  175) !    KSPEC: number of spectral coefficients
(  176) !    KNMENG: cut-off zonal wavenumber
(  177) !
(  178) ! ** AUTHOR
(  179) !    9 April 2014, S. Riette
(  180) !
(  181) ! ** MODIFICATIONS
(  182) !    6 Jan., S. Riette: w_spec_setup interfaced modified
(  183) !
(  184) ! I. Dummy arguments declaration
(  185) IMPLICIT NONE
(  186) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  187) INTEGER(KIND=8), INTENT(IN) :: KSIZEJ
(  188) INTEGER(KIND=8), INTENT(IN) :: KTRUNC
(  189) INTEGER(KIND=8), INTENT(IN) :: KSLOEN
(  190) INTEGER(KIND=8), DIMENSION(KSLOEN), INTENT(IN) :: KLOEN






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 27

(  191) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  192) INTEGER(KIND=8), INTENT(OUT) :: KGPTOT
(  193) INTEGER(KIND=8), INTENT(OUT) :: KSPEC
(  194) INTEGER(KIND=8), DIMENSION(KSLOEN), INTENT(OUT) :: KNMENG
(  195) !
(  196) ! II. Local variables declaration
(  197) INTEGER, DIMENSION(SIZE(KLOEN)) :: ILOEN
(  198) INTEGER :: ISIZEI, ISIZEJ, &
(  199)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  200)          & ITRUNCX, ITRUNCY, &
(  201)          & INUMMAXRESOL
(  202) LOGICAL :: LLSTOP
(  203) INTEGER :: IIDENTRESOL
(  204) INTEGER :: IGPTOT, ISPEC
(  205) INTEGER, DIMENSION(SIZE(KLOEN)) :: INMENG
(  206) REAL(KIND=8) :: ZDELTAX, ZDELTAY
(  207) # 207 "transforms4py.F90"
(  207) # 1 ".D[70]/trans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE TRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)                     &KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)                     &KMYMS,KASM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)                     &KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)                     &KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)                     &KULTPP,KPTRLS,KNMENG,&
(    8)                     &KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)                     &LDSPLITLAT,&
(   10)                     &KSMAX,PLAPIN,KNVALUE,KDEF_RESOL,LDLAM,&
(   11)                     &PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KDGLU)
(   12) # 13 ".D[70]/trans_inq.h"
(   13) !**** *TRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[70]/trans_inq.h"
(   15) !     Purpose.
(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[70]/trans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL TRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[70]/trans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[70]/trans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 28

(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KASM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation
(   50) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   51) # 52 ".D[70]/trans_inq.h"
(   52) !                 GRIDPOINT SPACE                  
(   53) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   54) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   55) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   56) !     KPTRLAT     - Pointer to the start of each latitude
(   57) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   58) !                   NSTA and NONL arrays
(   59) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   60) !                   NSTA and NONL arrays
(   61) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   62) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   63) !     KSTA        - Position of first grid column for the latitudes on a 
(   64) !                   processor. The information is available for all processors.
(   65) !                   The b-sets are distinguished by the last dimension of 
(   66) !                   nsta().The latitude band for each a-set is addressed by 
(   67) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   68) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   69) !                   Each split latitude has two entries in nsta(,:) which 
(   70) !                   necessitates the rather complex addressing of nsta(,:)
(   71) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   72) !     KONL        - Number of grid columns for the latitudes on a processor.
(   73) !                   Similar to nsta() in data structure.
(   74) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   75) !                   two a-sets
(   76) # 77 ".D[70]/trans_inq.h"
(   77) !                FOURIER SPACE
(   78) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   79) !                the FFT's.
(   80) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   81) !                it performs the Fourier calculations
(   82) !     KNMENG   - associated (with NLOENG) cut-off zonal wavenumber
(   83) # 84 ".D[70]/trans_inq.h"
(   84) !                 LEGENDRE
(   85) !     PMU      - sin(Gaussian latitudes)
(   86) !     PGW      - Gaussian weights
(   87) !     PRPNM    - Legendre polynomials
(   88) !     KLEI3    - First dimension of Legendre polynomials
(   89) !     KSPOLEGL - Second dimension of Legendre polynomials
(   90) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   91) !     PLAPIN   - Eigen-values of the inverse Laplace operator
(   92) !     KDGLU    - Number of active points in an hemisphere for a given wavenumber "m"
(   93) # 94 ".D[70]/trans_inq.h"
(   94) !     Method.
(   95) !     -------
(   96) # 97 ".D[70]/trans_inq.h"
(   97) !     Externals.  SET_RESOL - set resolution
(   98) !     ----------  






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 29

(   99) # 100 ".D[70]/trans_inq.h"
(  100) !     Author.
(  101) !     -------
(  102) !        Mats Hamrud *ECMWF*
(  103) # 104 ".D[70]/trans_inq.h"
(  104) !     Modifications.
(  105) !     --------------
(  106) !        Original : 00-03-03
(  107) !        M. Hortal : 2001-03-05 Dimensions of the Legendre polynomials
(  108) !        R. El Khatib 08-Aug-2012 KSMAX,PLAPIN,KNVALUE,LDLAM,KDEF_RESOL
(  109) # 110 ".D[70]/trans_inq.h"
(  110) !     ------------------------------------------------------------------
(  111) # 112 ".D[70]/trans_inq.h"
(  112) USE PARKIND1  ,ONLY : JPIM     ,JPRB, JPRD
(  113) # 115 ".D[70]/trans_inq.h"
(  115) IMPLICIT NONE
(  116) # 117 ".D[70]/trans_inq.h"
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(  118) # 119 ".D[70]/trans_inq.h"
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2
(  121) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2G
(  122) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2MX
(  123) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNUMP
(  124) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOT
(  125) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTG
(  126) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTMX
(  127) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTL(:,:)
(  128) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLOFF
(  129) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFLOFF
(  130) # 131 ".D[70]/trans_inq.h"
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYMS(:)
(  132) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KASM0(0:)
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KUMPP(:)
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPOSSP(:)
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRMS(:)
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KALLMS(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDIM0G(0:)
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLAT(:)
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLSTLAT(:)
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLAT(:)
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFRSTLAT(:)
(  142) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLSTLAT(:)
(  143) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSTA(:,:)
(  144) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KONL(:,:)
(  145) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  150) LOGICAL   ,OPTIONAL, INTENT(OUT) :: LDSPLITLAT(:)
(  151) # 152 ".D[70]/trans_inq.h"
(  152) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KULTPP(:)
(  153) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLS(:)
(  154) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNMENG(:)
(  155) # 156 ".D[70]/trans_inq.h"
(  156) REAL(KIND=JPRD)    ,OPTIONAL, INTENT(OUT) :: PMU(:)
(  157) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGW(:)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 30

(  158) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PRPNM(:,:)
(  159) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLEI3
(  160) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPOLEGL
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPMS(0:)
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDGLU(0:)
(  163) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PLAPIN(-1:)
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  165) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  166) # 167 ".D[70]/trans_inq.h"
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  168) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  169) # 170 ".D[70]/trans_inq.h"
(  170) END SUBROUTINE TRANS_INQ
(  171) # 177 ".D[70]/trans_inq.h"
(  177) END INTERFACE
(  178) # 208 "transforms4py.F90"
(  208) # 209 "transforms4py.F90"
(  209) ILOEN(:)=KLOEN(:)
(  210) ISIZEI=0
(  211) ISIZEJ=KSIZEJ
(  212) IPHYSICALSIZEI=0
(  213) IPHYSICALSIZEJ=0
(  214) ITRUNCX=KTRUNC
(  215) ITRUNCY=0
(  216) INUMMAXRESOL=KNUMMAXRESOL
(  217) INMENG(:)=KNMENG(:)
(  218) !
(  219) ! III. Setup
(  220) ZDELTAX=0.
(  221) ZDELTAY=0.
(  222) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  223)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .FALSE., SIZE(ILOEN), &
(  224)                   &ZDELTAX, ZDELTAY, IIDENTRESOL, LLSTOP)
(  225) IF (.NOT. LLSTOP) THEN
(  226)   CALL TRANS_INQ(KRESOL=IIDENTRESOL, KGPTOT=IGPTOT, KSPEC=ISPEC, KNMENG=INMENG)
(  227)   KGPTOT=IGPTOT
(  228)   KSPEC=ISPEC
(  229)   KNMENG=INMENG
(  230) ENDIF
(  231) !
(  232) END SUBROUTINE W_TRANS_INQ
(  233) # 234 "transforms4py.F90"
(  234) !___________________________________________________________________________________________
(  235) # 236 "transforms4py.F90"
(  236) SUBROUTINE W_ETRANS_INQ(KRETURNCODE, KSIZEI, KSIZEJ, KPHYSICALSIZEI, KPHYSICALSIZEJ, &
(  237)                        &KTRUNCX, KTRUNCY, KNUMMAXRESOL, PDELTAX, PDELTAY, &
(  238)                        &KGPTOT, KSPEC)
(  239) ! ** PURPOSE
(  240) !    Simplified wrapper to ETRANS_INQ
(  241) !
(  242) ! ** DUMMY ARGUMENTS
(  243) !    KSIZEI, KSIZEJ: size of grid-point field (with extension zone)
(  244) !    KPHYSICALSIZEI, KPHYSICALSIZEJ: size of physical part of grid-point field
(  245) !    KTRUNCX, KTRUNCY: troncatures
(  246) !    KNUMMAXRESOL: maximum number of troncatures handled
(  247) !    PDELTAX: x resolution
(  248) !    PDELTAY: y resolution
(  249) !    KGPTOT: number of gridpoints






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 31

(  250) !    KSPEC: number of spectral coefficients
(  251) !
(  252) ! ** AUTHOR
(  253) !    9 April 2014, S. Riette
(  254) !
(  255) ! ** MODIFICATIONS
(  256) !    6 Jan., S. Riette: PDELTAX and PDELTAY added
(  257) !
(  258) ! I. Dummy arguments declaration
(  259) IMPLICIT NONE
(  260) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  261) INTEGER(KIND=8), INTENT(IN) :: KSIZEI, KSIZEJ
(  262) INTEGER(KIND=8), INTENT(IN) :: KPHYSICALSIZEI, KPHYSICALSIZEJ
(  263) INTEGER(KIND=8), INTENT(IN) :: KTRUNCX, KTRUNCY
(  264) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  265) REAL(KIND=8), INTENT(IN) :: PDELTAX
(  266) REAL(KIND=8), INTENT(IN) :: PDELTAY
(  267) INTEGER(KIND=8), INTENT(OUT) :: KGPTOT
(  268) INTEGER(KIND=8), INTENT(OUT) :: KSPEC
(  269) !
(  270) ! II. Local variables declaration
(  271) INTEGER, DIMENSION(0:KTRUNCX) :: IESM0
(  272) INTEGER :: ISIZEI, ISIZEJ, &
(  273)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  274)          & ITRUNCX, ITRUNCY, &
(  275)          & INUMMAXRESOL
(  276) LOGICAL :: LLSTOP
(  277) INTEGER :: IIDENTRESOL
(  278) INTEGER, DIMENSION(1) :: ILOEN
(  279) INTEGER :: IGPTOT, ISPEC
(  280) # 281 "transforms4py.F90"
(  281) # 1 ".D[60]/etrans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE ETRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)  & KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)  & KMYMS,KESM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)  & KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)  & KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)  & KULTPP,KPTRLS,&
(    8)  & KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)  & LDSPLITLAT,LDLINEAR_GRID,&
(   10)  & KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,KDEF_RESOL,LDLAM,&
(   11)  & PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KCPL2M,KCPL4M,KPROCM)  
(   12) # 13 ".D[60]/etrans_inq.h"
(   13) !**** *ETRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[60]/etrans_inq.h"
(   15) !     Purpose.
(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[60]/etrans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL ETRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[60]/etrans_inq.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 32

(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[60]/etrans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KESM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation - n direction
(   50) !     KMSMAX   - spectral truncation - m direction
(   51) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   52) !     KMVALUE  - m value for each KSPEC2 spectral coeffient
(   53) !     LDLINEAR_GRID : .TRUE. if the grid is linear
(   54) # 55 ".D[60]/etrans_inq.h"
(   55) !                 GRIDPOINT SPACE                  
(   56) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   57) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   58) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   59) !     KPTRLAT     - Pointer to the start of each latitude
(   60) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   61) !                   NSTA and NONL arrays
(   62) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   63) !                   NSTA and NONL arrays
(   64) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   65) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   66) !     KSTA        - Position of first grid column for the latitudes on a 
(   67) !                   processor. The information is available for all processors.
(   68) !                   The b-sets are distinguished by the last dimension of 
(   69) !                   nsta().The latitude band for each a-set is addressed by 
(   70) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   71) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   72) !                   Each split latitude has two entries in nsta(,:) which 
(   73) !                   necessitates the rather complex addressing of nsta(,:)
(   74) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   75) !     KONL        - Number of grid columns for the latitudes on a processor.
(   76) !                   Similar to nsta() in data structure.
(   77) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   78) !                   two a-sets
(   79) # 80 ".D[60]/etrans_inq.h"
(   80) !                FOURIER SPACE
(   81) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   82) !                the FFT's.
(   83) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   84) !                it performs the Fourier calculations






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 33

(   85) # 86 ".D[60]/etrans_inq.h"
(   86) !                 LEGENDRE
(   87) !     PMU      - sin(Gaussian latitudes)
(   88) !     PGW      - Gaussian weights
(   89) !     PRPNM    - Legendre polynomials
(   90) !     KLEI3    - First dimension of Legendre polynomials
(   91) !     KSPOLEGL - Second dimension of Legendre polynomials
(   92) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   93) !     PLEPINM  - Eigen-values of the inverse Laplace operator
(   94) # 95 ".D[60]/etrans_inq.h"
(   95) !     Method.
(   96) !     -------
(   97) # 98 ".D[60]/etrans_inq.h"
(   98) !     Externals.  ESET_RESOL - set resolution
(   99) !     ----------  
(  100) # 101 ".D[60]/etrans_inq.h"
(  101) !     Author.
(  102) !     -------
(  103) !        Mats Hamrud *ECMWF*
(  104) # 105 ".D[60]/etrans_inq.h"
(  105) !     Modifications.
(  106) !     --------------
(  107) !        Original : 00-03-03
(  108) !        M.Hamrud      01-Oct-2003 CY28 Cleaning
(  109) !        A.Nmiri       15-Nov-2007 Phasing with TFL 32R3
(  110) !        A.Bogatchev   16-Sep-2010 Phasing with TFL 36R4
(  111) !        R. El Khatib 08-Aug-2012 KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,LDLAM,KDEF_RESOL,LDLINEAR_GRID
(  112) # 113 ".D[60]/etrans_inq.h"
(  113) !     ------------------------------------------------------------------
(  114) # 115 ".D[60]/etrans_inq.h"
(  115) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  116) # 117 ".D[60]/etrans_inq.h"
(  117) IMPLICIT NONE
(  118) # 119 ".D[60]/etrans_inq.h"
(  119) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KRESOL 
(  120) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC 
(  121) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2 
(  122) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2G 
(  123) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2MX 
(  124) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KNUMP 
(  125) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOT 
(  126) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTG 
(  127) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTMX 
(  128) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTL(:,:) 
(  129) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KMYMS(:) 
(  130) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KESM0(0:) 
(  131) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KUMPP(:) 
(  132) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPOSSP(:) 
(  133) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRMS(:) 
(  134) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KALLMS(:) 
(  135) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KDIM0G(0:) 
(  136) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLAT(:) 
(  137) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLSTLAT(:) 
(  138) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLOFF 
(  139) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLAT(:) 
(  140) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFRSTLAT(:) 
(  141) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLSTLAT(:) 
(  142) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFLOFF 






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 34

(  143) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSTA(:,:) 
(  144) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KONL(:,:) 
(  145) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KULTPP(:) 
(  146) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLS(:) 
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  150) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  151) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  152) LOGICAL           ,OPTIONAL,INTENT(INOUT) :: LDSPLITLAT(:) 
(  153) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PMU(:) 
(  154) REAL(KIND=JPRB)   ,OPTIONAL               :: PGW(:) ! Argument NOT used
(  155) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PRPNM(:,:) 
(  156) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLEI3 
(  157) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPOLEGL 
(  158) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPMS(0:) 
(  159) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL2M(0:) 
(  160) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL4M(0:) 
(  161) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPROCM(0:) 
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  163) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMSMAX
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  165) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMVALUE(:)
(  166) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(OUT) :: PLEPINM(:)
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  168) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  169) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLINEAR_GRID
(  170) # 171 ".D[60]/etrans_inq.h"
(  171) END SUBROUTINE ETRANS_INQ
(  172) END INTERFACE
(  173) # 282 "transforms4py.F90"
(  282) # 283 "transforms4py.F90"
(  283) ISIZEI=KSIZEI
(  284) ISIZEJ=KSIZEJ
(  285) IPHYSICALSIZEI=KPHYSICALSIZEI
(  286) IPHYSICALSIZEJ=KPHYSICALSIZEJ
(  287) ITRUNCX=KTRUNCX
(  288) ITRUNCY=KTRUNCY
(  289) INUMMAXRESOL=KNUMMAXRESOL
(  290) # 291 "transforms4py.F90"
(  291) ! III. Setup
(  292) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  293)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .TRUE., 1, &
(  294)                   &PDELTAX, PDELTAY, IIDENTRESOL, LLSTOP)
(  295) IF (.NOT. LLSTOP) THEN
(  296)   CALL ETRANS_INQ(KRESOL=IIDENTRESOL, KGPTOT=IGPTOT, KSPEC=ISPEC, KESM0=IESM0)
(  297)   KGPTOT=IGPTOT
(  298)   KSPEC=ISPEC
(  299) ENDIF
(  300) !
(  301) END SUBROUTINE W_ETRANS_INQ
(  302) # 303 "transforms4py.F90"
(  303) !______________________________________________________________________
(  304) # 305 "transforms4py.F90"
(  305) SUBROUTINE W_SPEC2GPT_LAM(KRETURNCODE, KSIZEI, KSIZEJ, KPHYSICALSIZEI, KPHYSICALSIZEJ, &
(  306)                          &KTRUNCX, KTRUNCY, KNUMMAXRESOL, KSIZE, LGRADIENT, LREORDER, PDELTAX, PDELTAY, &
(  307)                          &PSPEC, PGPT, PGPTM, PGPTL)
(  308) ! ** PURPOSE






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 35

(  309) !    Transform spectral coefficients into grid-point values
(  310) !
(  311) ! ** DUMMY ARGUMENTS
(  312) !    KRETURNCODE: error code
(  313) !    KSIZEI, KSIZEJ: size of grid-point field (with extension zone)
(  314) !    KPHYSICALSIZEI, KPHYSICALSIZEJ: size of physical part of grid-point field
(  315) !    KTRUNCX, KTRUNCY: troncatures
(  316) !    KNUMMAXRESOL: maximum number of troncatures handled
(  317) !    KSIZE: size of PSPEC
(  318) !    LREORDER: switch to reorder spectral coefficients or not
(  319) !    LGRADIENT: switch to compute or not gradient
(  320) !    PDELTAX: x resolution
(  321) !    PDELTAY: y resolution
(  322) !    PSPEC: spectral coefficient array
(  323) !    PGPT: grid-point field
(  324) !    PGPTM: N-S derivative if LGRADIENT
(  325) !    PGPTL: E-W derivative if LGRADIENT
(  326) !
(  327) ! ** AUTHOR
(  328) !    9 April 2014, S. Riette
(  329) !
(  330) ! ** MODIFICATIONS
(  331) !    5 Jan., S. Riette: PDELTAX, PDELTAY, LGRADIENT, PGPTM and PGPTL added
(  332) !    March, 2016, A.Mary: LREORDER
(  333) !
(  334) ! I. Dummy arguments declaration
(  335) USE PARKIND1, ONLY : JPRB
(  336) IMPLICIT NONE
(  337) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  338) INTEGER(KIND=8), INTENT(IN) :: KSIZEI, KSIZEJ
(  339) INTEGER(KIND=8), INTENT(IN) :: KPHYSICALSIZEI, KPHYSICALSIZEJ
(  340) INTEGER(KIND=8), INTENT(IN) :: KTRUNCX, KTRUNCY
(  341) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  342) INTEGER(KIND=8), INTENT(IN) :: KSIZE
(  343) LOGICAL, INTENT(IN) :: LGRADIENT
(  344) LOGICAL, INTENT(IN) :: LREORDER
(  345) REAL(KIND=8), INTENT(IN) :: PDELTAX
(  346) REAL(KIND=8), INTENT(IN) :: PDELTAY
(  347) REAL(KIND=8), DIMENSION(KSIZE), INTENT(IN) :: PSPEC
(  348) REAL(KIND=8), DIMENSION(KSIZEI*KSIZEJ), INTENT(OUT) :: PGPT
(  349) REAL(KIND=8), DIMENSION(KSIZEI*KSIZEJ), INTENT(OUT) :: PGPTM
(  350) REAL(KIND=8), DIMENSION(KSIZEI*KSIZEJ), INTENT(OUT) :: PGPTL
(  351) !
(  352) ! II. Local variables declaration
(  353) INTEGER, DIMENSION(0:KTRUNCX) :: IESM0
(  354) INTEGER :: IGPTOT, ISPEC
(  355) INTEGER, DIMENSION(0:KTRUNCY) :: ISPECINI, ISPECEND
(  356) REAL(KIND=8), DIMENSION(1, KSIZE) :: ZSPBUF
(  357) REAL(KIND=JPRB), DIMENSION(KSIZEI*KSIZEJ, 3, 1) :: ZGPBUF
(  358) INTEGER :: JI, JM, JN, IINDEX, IIDENTRESOL
(  359) LOGICAL :: LLSTOP
(  360) INTEGER :: ISIZEI, ISIZEJ, &
(  361)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  362)          & ITRUNCX, ITRUNCY, &
(  363)          & INUMMAXRESOL
(  364) INTEGER, DIMENSION(1) :: ILOEN
(  365) # 366 "transforms4py.F90"
(  366) # 1 ".D[60]/einv_trans.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 36

(    1) INTERFACE
(    2) SUBROUTINE EINV_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3)  & FSPGL_PROC,&
(    4)  & LDSCDERS,LDVORGP,LDDIVGP,LDUVDER,KPROMA,KVSETUV,KVSETSC,KRESOL,&
(    5)  & KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    6)  & PGP,PGPUV,PGP3A,PGP3B,PGP2,PMEANU,PMEANV)
(    7) # 8 ".D[60]/einv_trans.h"
(    8) !**** *EINV_TRANS* - Inverse spectral transform.
(    9) # 10 ".D[60]/einv_trans.h"
(   10) !     Purpose.
(   11) !     --------
(   12) !        Interface routine for the inverse spectral transform
(   13) # 14 ".D[60]/einv_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL EINV_TRANS(...)
(   17) # 18 ".D[60]/einv_trans.h"
(   18) !     Explicit arguments : All arguments are optional.
(   19) !     --------------------
(   20) !     PSPVOR(:,:) - spectral vorticity (input)
(   21) !     PSPDIV(:,:) - spectral divergence (input)
(   22) !     PSPSCALAR(:,:) - spectral scalarvalued fields (input)
(   23) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   24) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   25) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   26) !     FSPGL_PROC  - external procedure to be executed in fourier space
(   27) !                   before transposition
(   28) !     LDSCDERS    - indicating if derivatives of scalar variables are req.
(   29) !     LDVORGP     - indicating if grid-point vorticity is req.
(   30) !     LDDIVGP     - indicating if grid-point divergence is req.
(   31) !     LDUVDER     - indicating if E-W derivatives of u and v are req.
(   32) !     KPROMA      - required blocking factor for gridpoint output
(   33) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a
(   34) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   35) !                   The length of KVSETUV should be the GLOBAL number
(   36) !                   of u/v fields which is the dimension of u and v releated
(   37) !                   fields in grid-point space.
(   38) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   39) !                   scalar field. As for KVSETUV this argument is required
(   40) !                   if the total number of processors is greater than
(   41) !                   the number of processors used for distribution in
(   42) !                   spectral wave space.
(   43) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   44) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   45) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   46) !     KRESOL   - resolution tag  which is required ,default is the
(   47) !                first defined resulution (input)
(   48) !     PGP(:,:,:) - gridpoint fields (output)
(   49) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   50) !                  NPROMA is the blocking factor, IF_GP the total number
(   51) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   52) !                  The ordering of the output fields is as follows (all
(   53) !                  parts are optional depending on the input switches):
(   54) !
(   55) !       vorticity     : IF_UV_G fields (if psvor present and LDVORGP)
(   56) !       divergence    : IF_UV_G fields (if psvor present and LDDIVGP)
(   57) !       u             : IF_UV_G fields (if psvor present)
(   58) !       v             : IF_UV_G fields (if psvor present)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 37

(   59) !       scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   60) !       N-S derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   61) !                                         present and LDSCDERS)
(   62) !       E-W derivative of u : IF_UV_G fields (if psvor present and and LDUVDER)
(   63) !       E-W derivative of v : IF_UV_G fields (if psvor present and and LDUVDER)
(   64) !       E-W derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   65) !                                         present and LDSCDERS)
(   66) !
(   67) !       Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   68) !       of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   69) !       IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the
(   70) !       length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   71) !       'b-set' split
(   72) # 73 ".D[60]/einv_trans.h"
(   73) !     As an alternative to using PGP you can also use a combination of the
(   74) !     following arrays. The reason for introducing these alternative ways
(   75) !     of calling INV_TRANS is to avoid uneccessary copies where your data
(   76) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   77) !     The use of any of these precludes the use of PGP and vice versa.
(   78) # 79 ".D[60]/einv_trans.h"
(   79) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   80) !                      described for PGP. The second dimension of PGPUV should
(   81) !                      be the same as the "global" first dimension of
(   82) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   83) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   84) !                      IFLDS is the number of 'variables' (u,v,vor,div ...)
(   85) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   86) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   87) !                      IFLDS is the number of 'variables' (the same as in
(   88) !                      PSPSC3A if no derivatives, 3 times that with der.)
(   89) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   90) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   91) !                      IFLDS is the number of 'variables' (the same as in
(   92) !                      PSPSC3B if no derivatives, 3 times that with der.)
(   93) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   94) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   95) !                      IFLDS is the number of 'variables' (the same as in
(   96) !                      PSPSC2 if no derivatives, 3 times that with der.)
(   97) !     Method.
(   98) !     -------
(   99) # 100 ".D[60]/einv_trans.h"
(  100) !     Externals.  ESET_RESOL   - set resolution
(  101) !     ----------  ELTINV_CTL   - control of Legendre transform
(  102) !                 EFTINV_CTL   - control of Fourier transform
(  103) # 104 ".D[60]/einv_trans.h"
(  104) !     Author.
(  105) !     -------
(  106) !        Mats Hamrud *ECMWF*
(  107) # 108 ".D[60]/einv_trans.h"
(  108) !     Modifications.
(  109) !     --------------
(  110) !        Original : 00-03-03
(  111) !        26-02-03 Mats Hamrud & Gabor Radnoti : modified condition for scalar fields
(  112) !                                               and derivatives (IF_SCALARS_G)
(  113) # 114 ".D[60]/einv_trans.h"
(  114) !     ------------------------------------------------------------------
(  115) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  116) # 117 ".D[60]/einv_trans.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 38

(  117) IMPLICIT NONE
(  118) # 119 ".D[60]/einv_trans.h"
(  119) ! Declaration of arguments
(  120) # 121 ".D[60]/einv_trans.h"
(  121) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPVOR(:,:)
(  122) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPDIV(:,:)
(  123) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSCALAR(:,:)
(  124) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3A(:,:,:)
(  125) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3B(:,:,:)
(  126) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC2(:,:)
(  127) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDSCDERS
(  128) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDVORGP
(  129) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDDIVGP
(  130) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDUVDER
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  132) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  138) EXTERNAL  FSPGL_PROC
(  139) OPTIONAL  FSPGL_PROC
(  140) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP(:,:,:)
(  141) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGPUV(:,:,:,:)
(  142) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3A(:,:,:,:)
(  143) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3B(:,:,:,:)
(  144) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP2(:,:,:)
(  145) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN)  :: PMEANU(:)
(  146) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN)  :: PMEANV(:)
(  147) # 149 ".D[60]/einv_trans.h"
(  149) END SUBROUTINE EINV_TRANS
(  150) # 151 ".D[60]/einv_trans.h"
(  151) END INTERFACE
(  152) # 367 "transforms4py.F90"
(  367) # 367 "transforms4py.F90"
(  367) # 1 ".D[60]/etrans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE ETRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)  & KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)  & KMYMS,KESM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)  & KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)  & KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)  & KULTPP,KPTRLS,&
(    8)  & KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)  & LDSPLITLAT,LDLINEAR_GRID,&
(   10)  & KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,KDEF_RESOL,LDLAM,&
(   11)  & PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KCPL2M,KCPL4M,KPROCM)  
(   12) # 13 ".D[60]/etrans_inq.h"
(   13) !**** *ETRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[60]/etrans_inq.h"
(   15) !     Purpose.
(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[60]/etrans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL ETRANS_INQ(...)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 39

(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[60]/etrans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[60]/etrans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KESM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation - n direction
(   50) !     KMSMAX   - spectral truncation - m direction
(   51) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   52) !     KMVALUE  - m value for each KSPEC2 spectral coeffient
(   53) !     LDLINEAR_GRID : .TRUE. if the grid is linear
(   54) # 55 ".D[60]/etrans_inq.h"
(   55) !                 GRIDPOINT SPACE                  
(   56) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   57) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   58) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   59) !     KPTRLAT     - Pointer to the start of each latitude
(   60) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   61) !                   NSTA and NONL arrays
(   62) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   63) !                   NSTA and NONL arrays
(   64) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   65) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   66) !     KSTA        - Position of first grid column for the latitudes on a 
(   67) !                   processor. The information is available for all processors.
(   68) !                   The b-sets are distinguished by the last dimension of 
(   69) !                   nsta().The latitude band for each a-set is addressed by 
(   70) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   71) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   72) !                   Each split latitude has two entries in nsta(,:) which 
(   73) !                   necessitates the rather complex addressing of nsta(,:)
(   74) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   75) !     KONL        - Number of grid columns for the latitudes on a processor.
(   76) !                   Similar to nsta() in data structure.
(   77) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   78) !                   two a-sets
(   79) # 80 ".D[60]/etrans_inq.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 40

(   80) !                FOURIER SPACE
(   81) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   82) !                the FFT's.
(   83) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   84) !                it performs the Fourier calculations
(   85) # 86 ".D[60]/etrans_inq.h"
(   86) !                 LEGENDRE
(   87) !     PMU      - sin(Gaussian latitudes)
(   88) !     PGW      - Gaussian weights
(   89) !     PRPNM    - Legendre polynomials
(   90) !     KLEI3    - First dimension of Legendre polynomials
(   91) !     KSPOLEGL - Second dimension of Legendre polynomials
(   92) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   93) !     PLEPINM  - Eigen-values of the inverse Laplace operator
(   94) # 95 ".D[60]/etrans_inq.h"
(   95) !     Method.
(   96) !     -------
(   97) # 98 ".D[60]/etrans_inq.h"
(   98) !     Externals.  ESET_RESOL - set resolution
(   99) !     ----------  
(  100) # 101 ".D[60]/etrans_inq.h"
(  101) !     Author.
(  102) !     -------
(  103) !        Mats Hamrud *ECMWF*
(  104) # 105 ".D[60]/etrans_inq.h"
(  105) !     Modifications.
(  106) !     --------------
(  107) !        Original : 00-03-03
(  108) !        M.Hamrud      01-Oct-2003 CY28 Cleaning
(  109) !        A.Nmiri       15-Nov-2007 Phasing with TFL 32R3
(  110) !        A.Bogatchev   16-Sep-2010 Phasing with TFL 36R4
(  111) !        R. El Khatib 08-Aug-2012 KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,LDLAM,KDEF_RESOL,LDLINEAR_GRID
(  112) # 113 ".D[60]/etrans_inq.h"
(  113) !     ------------------------------------------------------------------
(  114) # 115 ".D[60]/etrans_inq.h"
(  115) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  116) # 117 ".D[60]/etrans_inq.h"
(  117) IMPLICIT NONE
(  118) # 119 ".D[60]/etrans_inq.h"
(  119) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KRESOL 
(  120) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC 
(  121) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2 
(  122) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2G 
(  123) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2MX 
(  124) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KNUMP 
(  125) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOT 
(  126) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTG 
(  127) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTMX 
(  128) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTL(:,:) 
(  129) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KMYMS(:) 
(  130) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KESM0(0:) 
(  131) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KUMPP(:) 
(  132) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPOSSP(:) 
(  133) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRMS(:) 
(  134) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KALLMS(:) 
(  135) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KDIM0G(0:) 
(  136) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLAT(:) 
(  137) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLSTLAT(:) 






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 41

(  138) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLOFF 
(  139) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLAT(:) 
(  140) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFRSTLAT(:) 
(  141) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLSTLAT(:) 
(  142) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFLOFF 
(  143) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSTA(:,:) 
(  144) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KONL(:,:) 
(  145) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KULTPP(:) 
(  146) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLS(:) 
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  150) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  151) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  152) LOGICAL           ,OPTIONAL,INTENT(INOUT) :: LDSPLITLAT(:) 
(  153) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PMU(:) 
(  154) REAL(KIND=JPRB)   ,OPTIONAL               :: PGW(:) ! Argument NOT used
(  155) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PRPNM(:,:) 
(  156) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLEI3 
(  157) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPOLEGL 
(  158) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPMS(0:) 
(  159) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL2M(0:) 
(  160) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL4M(0:) 
(  161) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPROCM(0:) 
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  163) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMSMAX
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  165) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMVALUE(:)
(  166) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(OUT) :: PLEPINM(:)
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  168) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  169) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLINEAR_GRID
(  170) # 171 ".D[60]/etrans_inq.h"
(  171) END SUBROUTINE ETRANS_INQ
(  172) END INTERFACE
(  173) # 368 "transforms4py.F90"
(  368) # 369 "transforms4py.F90"
(  369) KRETURNCODE=0
(  370) LLSTOP=.FALSE.
(  371) ISIZEI=KSIZEI
(  372) ISIZEJ=KSIZEJ
(  373) IPHYSICALSIZEI=KPHYSICALSIZEI
(  374) IPHYSICALSIZEJ=KPHYSICALSIZEJ
(  375) ITRUNCX=KTRUNCX
(  376) ITRUNCY=KTRUNCY
(  377) INUMMAXRESOL=KNUMMAXRESOL
(  378) ILOEN(:)=0
(  379) # 380 "transforms4py.F90"
(  380) ! III. Setup
(  381) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  382)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .TRUE., 1, &
(  383)                   &PDELTAX, PDELTAY, IIDENTRESOL, LLSTOP)
(  384) # 385 "transforms4py.F90"
(  385) ! IV. Transformation
(  386) # 387 "transforms4py.F90"
(  387) ! IV.a Shape of coefficient array
(  388) !IGPTOT is the total number of points in grid-point space
(  389) !ISPEC is the number of spectral coefficients






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 42

(  390) !IESM0(m) is the index of spectral coefficient (m,0) in model
(  391) !ISPECINI(n) is the index of the first of the 4 spectral coefficient (0,n) in FA file
(  392) !ISPECEND(n) is the index of the last of the last 4 spectral coefficients (:,n) in FA file
(  393) IF (.NOT. LLSTOP) THEN
(  394)   CALL ETRANS_INQ(KRESOL=IIDENTRESOL, KGPTOT=IGPTOT, KSPEC=ISPEC, KESM0=IESM0)
(  395)   JI=1
(  396)   DO JN=0, ITRUNCY
(  397)     ISPECINI(JN)=(JI-1)*4+1
(  398)     JI=JI+COUNT(IESM0(1:ITRUNCX)-IESM0(0:ITRUNCX-1)>JN*4)
(  399)     IF (ISPEC-IESM0(ITRUNCX)>JN*4) JI=JI+1
(  400)     ISPECEND(JN)=(JI-1)*4
(  401)   ENDDO
(  402) ENDIF
(  403) # 404 "transforms4py.F90"
(  404) ! III.b Reordering
(  405) ! reorder Aladin :  file ordering = coeffs per blocks of m, 4 reals per coeff
(  406) !           Aladin array ordering = coeffs per blocks of n, 4 reals per coeff
(  407) IF (LREORDER) THEN
(  408)   IF (.NOT. LLSTOP) THEN
(  409)     ZSPBUF(:,:)=0.
(  410)     JI=1
(  411)     DO JM=0,ITRUNCX+1
(  412)       DO JN=0,ITRUNCY
(  413)         IF (ISPECINI(JN)+JM*4+3<=ISPECEND(JN)) THEN
(  414)           DO IINDEX=ISPECINI(JN)+JM*4, ISPECINI(JN)+JM*4+3
(  415)             ZSPBUF(1,JI)=PSPEC(IINDEX)
(  416)             JI=JI+1
(  417)           ENDDO
(  418)         ENDIF
(  419)       ENDDO
(  420)     ENDDO
(  421)     IF (JI/=ISPEC+1) THEN
(  422)       PRINT*, "Internal error in W_SPEC2GPT_LAM (spectral reordering)"
(  423)       KRETURNCODE=-999
(  424)       LLSTOP=.TRUE.
(  425)     ENDIF
(  426)   ENDIF
(  427) ELSE
(  428)   ZSPBUF(1,:) = PSPEC(:)
(  429) ENDIF
(  430) # 431 "transforms4py.F90"
(  431) ! III.c Inverse transform
(  432) IF (.NOT. LLSTOP) THEN
(  433)   IF (.NOT. LGRADIENT) THEN
(  434)       CALL EINV_TRANS(PSPSCALAR=REAL(ZSPBUF(:,:),KIND=JPRB), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL)
(  435)       PGPT(:)=REAL(ZGPBUF(:,1,1),KIND=8)
(  436)   ELSE
(  437)       CALL EINV_TRANS(PSPSCALAR=REAL(ZSPBUF(:,:),KIND=JPRB), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL, LDSCDERS=.TRUE.)
(  438)       PGPT(:)=REAL(ZGPBUF(:,1,1),KIND=8)
(  439)       PGPTM(:)=REAL(ZGPBUF(:,2,1),KIND=8)
(  440)       PGPTL(:)=REAL(ZGPBUF(:,3,1),KIND=8)
(  441)   ENDIF
(  442) ENDIF
(  443) # 444 "transforms4py.F90"
(  444) END SUBROUTINE W_SPEC2GPT_LAM
(  445) # 446 "transforms4py.F90"
(  446) !____________________________________________________________________________
(  447) # 448 "transforms4py.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 43

(  448) SUBROUTINE W_SPEC2GPT_GAUSS(KRETURNCODE, KSIZEJ, KTRUNC, KNUMMAXRESOL, KGPTOT, KSLOEN, KLOEN, KSIZE, &
(  449)                           & LGRADIENT, LREORDER, PSPEC, PGPT, PGPTM, PGPTL)
(  450) ! ** PURPOSE
(  451) !    Transform spectral coefficients into grid-point values
(  452) !
(  453) ! ** DUMMY ARGUMENTS
(  454) !    KSIZEJ: Number of latitudes
(  455) !    KTRUNC: troncature
(  456) !    KNUMMAXRESOL: maximum number of troncatures handled
(  457) !    KGPTOT: number of grid-points
(  458) !    KSLOEN: Size of KLOEN
(  459) !    KLOEN:
(  460) !    KSIZE: Size of PSPEC
(  461) !    LREORDER: switch to reorder spectral coefficients or not
(  462) !    LGRADIENT: switch to compute or not gradient
(  463) !    PSPEC: spectral coefficient array
(  464) !    PGPT: grid-point field
(  465) !    PGPTM: N-S derivative if LGRADIENT
(  466) !    PGPTL: E-W derivative if LGRADIENT
(  467) !
(  468) ! ** AUTHOR
(  469) !    9 April 2014, S. Riette
(  470) !
(  471) ! ** MODIFICATIONS
(  472) !    6 Jan., S. Riette: w_spec_setup interface modified
(  473) !    March, 2016, A.Mary: LREORDER
(  474) !    Sept., 2016, A.Mary: LGRADIENT
(  475) !
(  476) ! I. Dummy arguments declaration
(  477) USE PARKIND1, ONLY : JPRB
(  478) IMPLICIT NONE
(  479) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  480) INTEGER(KIND=8), INTENT(IN) :: KSIZEJ
(  481) INTEGER(KIND=8), INTENT(IN) :: KTRUNC
(  482) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  483) INTEGER(KIND=8), INTENT(IN) :: KGPTOT
(  484) INTEGER(KIND=8), INTENT(IN) :: KSLOEN
(  485) INTEGER(KIND=8), DIMENSION(KSLOEN), INTENT(IN) :: KLOEN
(  486) INTEGER(KIND=8), INTENT(IN) :: KSIZE
(  487) LOGICAL, INTENT(IN) :: LGRADIENT
(  488) LOGICAL, INTENT(IN) :: LREORDER
(  489) REAL(KIND=8), DIMENSION(KSIZE),  INTENT(IN)  :: PSPEC
(  490) REAL(KIND=8), DIMENSION(KGPTOT), INTENT(OUT) :: PGPT
(  491) REAL(KIND=8), DIMENSION(KGPTOT), INTENT(OUT) :: PGPTM
(  492) REAL(KIND=8), DIMENSION(KGPTOT), INTENT(OUT) :: PGPTL
(  493) !
(  494) ! II. Local variables declaration
(  495) INTEGER, DIMENSION(SIZE(KLOEN)) :: ILOEN
(  496) INTEGER :: ISIZEI, ISIZEJ, &
(  497)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  498)          & ITRUNCX, ITRUNCY, &
(  499)          & INUMMAXRESOL
(  500) LOGICAL :: LLSTOP
(  501) INTEGER :: IIDENTRESOL
(  502) INTEGER :: JI, JM, JN
(  503) INTEGER, DIMENSION(0:KTRUNC) :: NASM0
(  504) REAL(KIND=8), DIMENSION(1, KSIZE) :: ZSPBUF
(  505) REAL(KIND=JPRB), DIMENSION(KGPTOT, 3, 1) :: ZGPBUF






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 44

(  506) REAL(KIND=8) :: ZDELTAX, ZDELTAY
(  507) # 507 "transforms4py.F90"
(  507) # 1 ".D[70]/trans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE TRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)                     &KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)                     &KMYMS,KASM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)                     &KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)                     &KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)                     &KULTPP,KPTRLS,KNMENG,&
(    8)                     &KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)                     &LDSPLITLAT,&
(   10)                     &KSMAX,PLAPIN,KNVALUE,KDEF_RESOL,LDLAM,&
(   11)                     &PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KDGLU)
(   12) # 13 ".D[70]/trans_inq.h"
(   13) !**** *TRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[70]/trans_inq.h"
(   15) !     Purpose.
(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[70]/trans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL TRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[70]/trans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[70]/trans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KASM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation
(   50) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   51) # 52 ".D[70]/trans_inq.h"
(   52) !                 GRIDPOINT SPACE                  
(   53) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   54) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   55) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 45

(   56) !     KPTRLAT     - Pointer to the start of each latitude
(   57) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   58) !                   NSTA and NONL arrays
(   59) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   60) !                   NSTA and NONL arrays
(   61) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   62) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   63) !     KSTA        - Position of first grid column for the latitudes on a 
(   64) !                   processor. The information is available for all processors.
(   65) !                   The b-sets are distinguished by the last dimension of 
(   66) !                   nsta().The latitude band for each a-set is addressed by 
(   67) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   68) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   69) !                   Each split latitude has two entries in nsta(,:) which 
(   70) !                   necessitates the rather complex addressing of nsta(,:)
(   71) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   72) !     KONL        - Number of grid columns for the latitudes on a processor.
(   73) !                   Similar to nsta() in data structure.
(   74) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   75) !                   two a-sets
(   76) # 77 ".D[70]/trans_inq.h"
(   77) !                FOURIER SPACE
(   78) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   79) !                the FFT's.
(   80) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   81) !                it performs the Fourier calculations
(   82) !     KNMENG   - associated (with NLOENG) cut-off zonal wavenumber
(   83) # 84 ".D[70]/trans_inq.h"
(   84) !                 LEGENDRE
(   85) !     PMU      - sin(Gaussian latitudes)
(   86) !     PGW      - Gaussian weights
(   87) !     PRPNM    - Legendre polynomials
(   88) !     KLEI3    - First dimension of Legendre polynomials
(   89) !     KSPOLEGL - Second dimension of Legendre polynomials
(   90) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   91) !     PLAPIN   - Eigen-values of the inverse Laplace operator
(   92) !     KDGLU    - Number of active points in an hemisphere for a given wavenumber "m"
(   93) # 94 ".D[70]/trans_inq.h"
(   94) !     Method.
(   95) !     -------
(   96) # 97 ".D[70]/trans_inq.h"
(   97) !     Externals.  SET_RESOL - set resolution
(   98) !     ----------  
(   99) # 100 ".D[70]/trans_inq.h"
(  100) !     Author.
(  101) !     -------
(  102) !        Mats Hamrud *ECMWF*
(  103) # 104 ".D[70]/trans_inq.h"
(  104) !     Modifications.
(  105) !     --------------
(  106) !        Original : 00-03-03
(  107) !        M. Hortal : 2001-03-05 Dimensions of the Legendre polynomials
(  108) !        R. El Khatib 08-Aug-2012 KSMAX,PLAPIN,KNVALUE,LDLAM,KDEF_RESOL
(  109) # 110 ".D[70]/trans_inq.h"
(  110) !     ------------------------------------------------------------------
(  111) # 112 ".D[70]/trans_inq.h"
(  112) USE PARKIND1  ,ONLY : JPIM     ,JPRB, JPRD
(  113) # 115 ".D[70]/trans_inq.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 46

(  115) IMPLICIT NONE
(  116) # 117 ".D[70]/trans_inq.h"
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(  118) # 119 ".D[70]/trans_inq.h"
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2
(  121) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2G
(  122) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2MX
(  123) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNUMP
(  124) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOT
(  125) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTG
(  126) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTMX
(  127) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTL(:,:)
(  128) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLOFF
(  129) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFLOFF
(  130) # 131 ".D[70]/trans_inq.h"
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYMS(:)
(  132) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KASM0(0:)
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KUMPP(:)
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPOSSP(:)
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRMS(:)
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KALLMS(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDIM0G(0:)
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLAT(:)
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLSTLAT(:)
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLAT(:)
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFRSTLAT(:)
(  142) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLSTLAT(:)
(  143) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSTA(:,:)
(  144) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KONL(:,:)
(  145) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  150) LOGICAL   ,OPTIONAL, INTENT(OUT) :: LDSPLITLAT(:)
(  151) # 152 ".D[70]/trans_inq.h"
(  152) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KULTPP(:)
(  153) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLS(:)
(  154) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNMENG(:)
(  155) # 156 ".D[70]/trans_inq.h"
(  156) REAL(KIND=JPRD)    ,OPTIONAL, INTENT(OUT) :: PMU(:)
(  157) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGW(:)
(  158) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PRPNM(:,:)
(  159) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLEI3
(  160) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPOLEGL
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPMS(0:)
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDGLU(0:)
(  163) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PLAPIN(-1:)
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  165) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  166) # 167 ".D[70]/trans_inq.h"
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  168) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  169) # 170 ".D[70]/trans_inq.h"
(  170) END SUBROUTINE TRANS_INQ
(  171) # 177 ".D[70]/trans_inq.h"
(  177) END INTERFACE






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 47

(  178) # 508 "transforms4py.F90"
(  508) # 508 "transforms4py.F90"
(  508) # 1 ".D[70]/inv_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE INV_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3)  & FSPGL_PROC,&
(    4)  & LDSCDERS,LDVORGP,LDDIVGP,LDUVDER,LDLATLON,KPROMA,KVSETUV,KVSETSC,KRESOL,&
(    5)  & KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    6)  & PGP,PGPUV,PGP3A,PGP3B,PGP2)
(    7) # 8 ".D[70]/inv_trans.h"
(    8) !**** *INV_TRANS* - Inverse spectral transform.
(    9) # 10 ".D[70]/inv_trans.h"
(   10) !     Purpose.
(   11) !     --------
(   12) !        Interface routine for the inverse spectral transform
(   13) # 14 ".D[70]/inv_trans.h"
(   14) !**   Interface.
(   15) !     ----------
(   16) !     CALL INV_TRANS(...)
(   17) # 18 ".D[70]/inv_trans.h"
(   18) !     Explicit arguments : All arguments are optional.
(   19) !     -------------------- 
(   20) !     PSPVOR(:,:) - spectral vorticity (input)
(   21) !     PSPDIV(:,:) - spectral divergence (input)
(   22) !     PSPSCALAR(:,:) - spectral scalarvalued fields (input)
(   23) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   24) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   25) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   26) !     FSPGL_PROC  - external procedure to be executed in fourier space
(   27) !                   before transposition  
(   28) !     LDSCDERS    - indicating if derivatives of scalar variables are req.
(   29) !     LDVORGP     - indicating if grid-point vorticity is req.
(   30) !     LDDIVGP     - indicating if grid-point divergence is req.
(   31) !     LDUVDER     - indicating if E-W derivatives of u and v are req.
(   32) !     LDLATLON   - indicating if regular lat-lon output requested
(   33) !     KPROMA      - required blocking factor for gridpoint output
(   34) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a 
(   35) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   36) !                   The length of KVSETUV should be the GLOBAL number
(   37) !                   of u/v fields which is the dimension of u and v releated
(   38) !                   fields in grid-point space. 
(   39) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   40) !                   scalar field. As for KVSETUV this argument is required
(   41) !                   if the total number of processors is greater than
(   42) !                   the number of processors used for distribution in
(   43) !                   spectral wave space.
(   44) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   45) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   46) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   47) !     KRESOL   - resolution tag  which is required ,default is the
(   48) !                first defined resulution (input)
(   49) !     PGP(:,:,:) - gridpoint fields (output)
(   50) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   51) !                  NPROMA is the blocking factor, IF_GP the total number
(   52) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   53) !                  The ordering of the output fields is as follows (all 
(   54) !                  parts are optional depending on the input switches):
(   55) !






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 48

(   56) !       vorticity     : IF_UV_G fields (if psvor present and LDVORGP)
(   57) !       divergence    : IF_UV_G fields (if psvor present and LDDIVGP)
(   58) !       u             : IF_UV_G fields (if psvor present)
(   59) !       v             : IF_UV_G fields (if psvor present)
(   60) !       scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   61) !       N-S derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   62) !                                         present and LDSCDERS)
(   63) !       E-W derivative of u : IF_UV_G fields (if psvor present and and LDUVDER)
(   64) !       E-W derivative of v : IF_UV_G fields (if psvor present and and LDUVDER)
(   65) !       E-W derivative of scalar fields : IF_SCALARS_G fields (if pspscalar
(   66) !                                         present and LDSCDERS)
(   67) !   
(   68) !       Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   69) !       of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   70) !       IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the 
(   71) !       length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   72) !       'b-set' split
(   73) # 74 ".D[70]/inv_trans.h"
(   74) !     As an alternative to using PGP you can also use a combination of the
(   75) !     following arrays. The reason for introducing these alternative ways
(   76) !     of calling INV_TRANS is to avoid uneccessary copies where your data
(   77) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   78) !     The use of any of these precludes the use of PGP and vice versa.
(   79) # 80 ".D[70]/inv_trans.h"
(   80) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   81) !                      described for PGP. The second dimension of PGPUV should
(   82) !                      be the same as the "global" first dimension of 
(   83) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   84) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   85) !                      IFLDS is the number of 'variables' (u,v,vor,div ...)
(   86) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   87) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   88) !                      IFLDS is the number of 'variables' (the same as in
(   89) !                      PSPSC3A if no derivatives, 3 times that with der.)
(   90) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   91) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   92) !                      IFLDS is the number of 'variables' (the same as in
(   93) !                      PSPSC3B if no derivatives, 3 times that with der.)
(   94) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   95) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   96) !                      IFLDS is the number of 'variables' (the same as in
(   97) !                      PSPSC2 if no derivatives, 3 times that with der.)
(   98) !     Method.
(   99) !     -------
(  100) # 101 ".D[70]/inv_trans.h"
(  101) !     Externals.  SET_RESOL   - set resolution
(  102) !     ----------  LTINV_CTL   - control of Legendre transform
(  103) !                 FTINV_CTL   - control of Fourier transform
(  104) # 105 ".D[70]/inv_trans.h"
(  105) !     Author.
(  106) !     -------
(  107) !        Mats Hamrud *ECMWF*
(  108) # 109 ".D[70]/inv_trans.h"
(  109) !     Modifications.
(  110) !     --------------
(  111) !        Original : 00-03-03
(  112) !        26-02-03 Mats Hamrud & Gabor Radnoti : modified condition for scalar fields
(  113) !                                               and derivatives (IF_SCALARS_G)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 49

(  114) # 115 ".D[70]/inv_trans.h"
(  115) !     ------------------------------------------------------------------
(  116) # 117 ".D[70]/inv_trans.h"
(  117) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  118) # 120 ".D[70]/inv_trans.h"
(  120) IMPLICIT NONE
(  121) # 122 ".D[70]/inv_trans.h"
(  122) ! Declaration of arguments
(  123) # 124 ".D[70]/inv_trans.h"
(  124) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPVOR(:,:)
(  125) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPDIV(:,:)
(  126) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSCALAR(:,:)
(  127) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3A(:,:,:)
(  128) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC3B(:,:,:)
(  129) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(IN) :: PSPSC2(:,:)
(  130) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDSCDERS
(  131) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDVORGP
(  132) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDDIVGP
(  133) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDUVDER
(  134) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDLATLON
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  142) EXTERNAL  FSPGL_PROC
(  143) OPTIONAL  FSPGL_PROC
(  144) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP(:,:,:)
(  145) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGPUV(:,:,:,:)
(  146) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3A(:,:,:,:)
(  147) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP3B(:,:,:,:)
(  148) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PGP2(:,:,:)
(  149) # 151 ".D[70]/inv_trans.h"
(  151) END SUBROUTINE INV_TRANS
(  152) # 153 ".D[70]/inv_trans.h"
(  153) END INTERFACE
(  154) # 509 "transforms4py.F90"
(  509) # 510 "transforms4py.F90"
(  510) ILOEN(:)=KLOEN(:)
(  511) ISIZEI=0
(  512) ISIZEJ=KSIZEJ
(  513) IPHYSICALSIZEI=0
(  514) IPHYSICALSIZEJ=0
(  515) ITRUNCX=KTRUNC
(  516) ITRUNCY=0
(  517) INUMMAXRESOL=KNUMMAXRESOL
(  518) !
(  519) ! III. Setup
(  520) ZDELTAX=0.
(  521) ZDELTAY=0.
(  522) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  523)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .FALSE., SIZE(ILOEN), &
(  524)                   &ZDELTAX, ZDELTAY, IIDENTRESOL, LLSTOP)
(  525) !
(  526) ! IV. Transformation
(  527) IF (LREORDER) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 50

(  528)   ! IV.a Shape of coefficient array
(  529)   IF (.NOT. LLSTOP) THEN
(  530)     JI=1
(  531)     DO JN=0, KTRUNC
(  532)       NASM0(JN)=JI
(  533)       JI=JI+1+JN+(JN+1)
(  534)     ENDDO
(  535)   ENDIF
(  536) # 537 "transforms4py.F90"
(  537)   ! IV.b Reordering
(  538)   IF(.NOT. LLSTOP) THEN
(  539)     ZSPBUF(1,:)=0.
(  540)     JI=1
(  541)     DO JM=0, KTRUNC
(  542)       DO JN=JM, KTRUNC
(  543)         ZSPBUF(1,JI)=PSPEC(NASM0(JN)+JM)
(  544)         JI=JI+1
(  545)         IF(JM==0) THEN
(  546)           ZSPBUF(1,JI)=0
(  547)         ELSE
(  548)           ZSPBUF(1,JI)=PSPEC(NASM0(JN)-JM)
(  549)         ENDIF
(  550)         JI=JI+1
(  551)       ENDDO
(  552)     ENDDO
(  553)   ENDIF
(  554) ELSE
(  555)   ZSPBUF(1,:) = PSPEC(:)
(  556) ENDIF
(  557) # 558 "transforms4py.F90"
(  558) ! IV.c Inverse transform
(  559) IF (.NOT. LLSTOP) THEN
(  560)   IF (.NOT. LGRADIENT) THEN
(  561)     CALL INV_TRANS(PSPSCALAR=REAL(ZSPBUF(:,:),KIND=JPRB), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL)
(  562)     PGPT(:)=REAL(ZGPBUF(:,1,1),KIND=8)
(  563)   ELSE
(  564)     CALL INV_TRANS(PSPSCALAR=REAL(ZSPBUF(:,:),KIND=JPRB), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL, LDSCDERS=.TRUE.)
(  565)     PGPT(:)=REAL(ZGPBUF(:,1,1),KIND=8)
(  566)     PGPTM(:)=REAL(ZGPBUF(:,2,1),KIND=8)
(  567)     PGPTL(:)=REAL(ZGPBUF(:,3,1),KIND=8)
(  568)   ENDIF
(  569) ENDIF
(  570) END SUBROUTINE W_SPEC2GPT_GAUSS
(  571) # 572 "transforms4py.F90"
(  572) !______________________________________________________________________
(  573) # 574 "transforms4py.F90"
(  574) SUBROUTINE W_GPT2SPEC_LAM(KRETURNCODE, KSIZE, KSIZEI, KSIZEJ, KPHYSICALSIZEI, KPHYSICALSIZEJ, &
(  575)                          &KTRUNCX, KTRUNCY, KNUMMAXRESOL, PDELTAX, PDELTAY, LREORDER, PGPT, PSPEC)
(  576) ! ** PURPOSE
(  577) !    Transform grid point values into spectral coefficients
(  578) !
(  579) ! ** DUMMY ARGUMENTS
(  580) !    KRETURNCODE: error code
(  581) !    KSIZE: size of spectral field
(  582) !    KSIZEI, KSIZEJ: size of grid-point field (with extension zone)
(  583) !    KPHYSICALSIZEI, KPHYSICALSIZEJ: size of physical part of grid-point field
(  584) !    KTRUNCX, KTRUNCY: troncatures
(  585) !    KNUMMAXRESOL: maximum number of troncatures handled






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 51

(  586) !    PDELTAX: x resolution
(  587) !    PDELTAY: y resolution
(  588) !    LREORDER: switch to reorder spectral coefficients or not
(  589) !    PGPT: grid-point field
(  590) !    PSPEC: spectral coefficient array
(  591) !
(  592) ! ** AUTHOR
(  593) !    9 April 2014, S. Riette
(  594) !
(  595) ! ** MODIFICATIONS
(  596) !    6 Jan., S. Riette: PDELTAX and PDELTAY added
(  597) !    March, 2016, A.Mary: LREORDER
(  598) !
(  599) ! I. Dummy arguments declaration
(  600) USE PARKIND1, ONLY : JPRB
(  601) IMPLICIT NONE
(  602) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  603) INTEGER(KIND=8), INTENT(IN) :: KSIZE, KSIZEI, KSIZEJ
(  604) INTEGER(KIND=8), INTENT(IN) :: KPHYSICALSIZEI, KPHYSICALSIZEJ
(  605) INTEGER(KIND=8), INTENT(IN) :: KTRUNCX, KTRUNCY
(  606) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  607) REAL(KIND=8), INTENT(IN) :: PDELTAX
(  608) REAL(KIND=8), INTENT(IN) :: PDELTAY
(  609) LOGICAL, INTENT(IN) :: LREORDER
(  610) REAL(KIND=8), DIMENSION(KSIZEI*KSIZEJ), INTENT(IN) :: PGPT
(  611) REAL(KIND=8), DIMENSION(KSIZE), INTENT(OUT) :: PSPEC
(  612) !
(  613) ! II. Local variables declaration
(  614) INTEGER, DIMENSION(0:KTRUNCX) :: IESM0
(  615) INTEGER :: IGPTOT, ISPEC
(  616) INTEGER, DIMENSION(0:KTRUNCY) :: ISPECINI, ISPECEND
(  617) REAL(KIND=JPRB), DIMENSION(1, KSIZEI*KSIZEJ) :: ZSPBUF !size over-evaluated
(  618) REAL(KIND=JPRB), DIMENSION(KSIZEI*KSIZEJ, 1, 1) :: ZGPBUF
(  619) INTEGER :: JI, JM, JN, IIDENTRESOL
(  620) LOGICAL :: LLSTOP
(  621) INTEGER :: ISIZEI, ISIZEJ, &
(  622)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  623)          & ITRUNCX, ITRUNCY, &
(  624)          & INUMMAXRESOL
(  625) INTEGER, DIMENSION(1) :: ILOEN
(  626) # 627 "transforms4py.F90"
(  627) # 1 ".D[60]/edir_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE EDIR_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3) & KPROMA,KVSETUV,KVSETSC,KRESOL,KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    4) & PGP,PGPUV,PGP3A,PGP3B,PGP2,PMEANU,PMEANV,AUX_PROC)
(    5) # 7 ".D[60]/edir_trans.h"
(    7) !**** *EDIR_TRANS* - Direct spectral transform (from grid-point to spectral).
(    8) # 9 ".D[60]/edir_trans.h"
(    9) !     Purpose.
(   10) !     --------
(   11) !        Interface routine for the direct spectral transform
(   12) # 13 ".D[60]/edir_trans.h"
(   13) !**   Interface.
(   14) !     ----------
(   15) !     CALL EDIR_TRANS(...)
(   16) # 17 ".D[60]/edir_trans.h"
(   17) !     Explicit arguments : All arguments except from PGP are optional.






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 52

(   18) !     --------------------
(   19) !     PSPVOR(:,:) - spectral vorticity (output)
(   20) !     PSPDIV(:,:) - spectral divergence (output)
(   21) !     PSPSCALAR(:,:) - spectral scalarvalued fields (output)
(   22) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   23) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   24) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   25) !     KPROMA      - required blocking factor for gridpoint output
(   26) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a
(   27) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   28) !                   The length of KVSETUV should be the GLOBAL number
(   29) !                   of u/v fields which is the dimension of u and v releated
(   30) !                   fields in grid-point space.
(   31) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   32) !                   scalar field. As for KVSETUV this argument is required
(   33) !                   if the total number of processors is greater than
(   34) !                   the number of processors used for distribution in
(   35) !                   spectral wave space.
(   36) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   37) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   38) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   39) !     KRESOL   - resolution tag  which is required ,default is the
(   40) !                first defined resulution (input)
(   41) !     PGP(:,:,:) - gridpoint fields (input)
(   42) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   43) !                  NPROMA is the blocking factor, IF_GP the total number
(   44) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   45) !                  The ordering of the output fields is as follows (all
(   46) !                  parts are optional depending on the input switches):
(   47) !
(   48) !     u             : IF_UV_G fields (if psvor present)
(   49) !     v             : IF_UV_G fields (if psvor present)
(   50) !     scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   51) !
(   52) !     Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   53) !     of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   54) !     IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the
(   55) !     length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   56) !     'b-set' split
(   57) # 58 ".D[60]/edir_trans.h"
(   58) !     As an alternative to using PGP you can also use a combination of the
(   59) !     following arrays. The reason for introducing these alternative ways
(   60) !     of calling DIR_TRANS is to avoid uneccessary copies where your data
(   61) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   62) !     The use of any of these precludes the use of PGP and vice versa.
(   63) # 64 ".D[60]/edir_trans.h"
(   64) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   65) !                      described for PGP. The second dimension of PGPUV should
(   66) !                      be the same as the "global" first dimension of
(   67) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   68) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   69) !                      IFLDS is the number of 'variables' (u,v)
(   70) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   71) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   72) !                      IFLDS is the number of 'variables' (the same as in
(   73) !                      PSPSC3A )
(   74) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   75) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 53

(   76) !                      IFLDS is the number of 'variables' (the same as in
(   77) !                      PSPSC3B)
(   78) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   79) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   80) !                      IFLDS is the number of 'variables' (the same as in
(   81) !                      PSPSC2 )
(   82) !     PMEANU(:),PMEANV(:) - mean wind
(   83) !     AUX_PROC       - optional external procedure for biperiodization of
(   84) !                      aux.fields
(   85) # 86 ".D[60]/edir_trans.h"
(   86) !     Method.
(   87) !     -------
(   88) # 89 ".D[60]/edir_trans.h"
(   89) !     Externals.  SET_RESOL   - set resolution
(   90) !     ----------  LTDIR_CTL   - control of Legendre transform
(   91) !                 FTDIR_CTL   - control of Fourier transform
(   92) # 93 ".D[60]/edir_trans.h"
(   93) !     Author.
(   94) !     -------
(   95) !        Mats Hamrud *ECMWF*
(   96) # 97 ".D[60]/edir_trans.h"
(   97) !     Modifications.
(   98) !     --------------
(   99) !        Original : 00-03-03
(  100) # 101 ".D[60]/edir_trans.h"
(  101) !     ------------------------------------------------------------------
(  102) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  103) # 104 ".D[60]/edir_trans.h"
(  104) IMPLICIT NONE
(  105) # 106 ".D[60]/edir_trans.h"
(  106) ! Declaration of arguments
(  107) # 108 ".D[60]/edir_trans.h"
(  108) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPVOR(:,:)
(  109) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPDIV(:,:)
(  110) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSCALAR(:,:)
(  111) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3A(:,:,:)
(  112) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3B(:,:,:)
(  113) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC2(:,:)
(  114) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  115) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  116) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  118) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  121) # 122 ".D[60]/edir_trans.h"
(  122) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP(:,:,:)
(  123) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGPUV(:,:,:,:)
(  124) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3A(:,:,:,:)
(  125) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3B(:,:,:,:)
(  126) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP2(:,:,:)
(  127) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PMEANU(:)
(  128) REAL(KIND=JPRB),OPTIONAL    ,INTENT(OUT) :: PMEANV(:)
(  129) EXTERNAL AUX_PROC
(  130) OPTIONAL AUX_PROC
(  131) # 133 ".D[60]/edir_trans.h"
(  133) END SUBROUTINE EDIR_TRANS
(  134) # 135 ".D[60]/edir_trans.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 54

(  135) END INTERFACE
(  136) # 628 "transforms4py.F90"
(  628) # 628 "transforms4py.F90"
(  628) # 1 ".D[60]/etrans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE ETRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)  & KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)  & KMYMS,KESM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)  & KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)  & KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)  & KULTPP,KPTRLS,&
(    8)  & KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)  & LDSPLITLAT,LDLINEAR_GRID,&
(   10)  & KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,KDEF_RESOL,LDLAM,&
(   11)  & PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KCPL2M,KCPL4M,KPROCM)  
(   12) # 13 ".D[60]/etrans_inq.h"
(   13) !**** *ETRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[60]/etrans_inq.h"
(   15) !     Purpose.
(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[60]/etrans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL ETRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[60]/etrans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[60]/etrans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KESM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs
(   49) !     KSMAX    - spectral truncation - n direction
(   50) !     KMSMAX   - spectral truncation - m direction
(   51) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   52) !     KMVALUE  - m value for each KSPEC2 spectral coeffient
(   53) !     LDLINEAR_GRID : .TRUE. if the grid is linear
(   54) # 55 ".D[60]/etrans_inq.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 55

(   55) !                 GRIDPOINT SPACE                  
(   56) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   57) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   58) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   59) !     KPTRLAT     - Pointer to the start of each latitude
(   60) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   61) !                   NSTA and NONL arrays
(   62) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   63) !                   NSTA and NONL arrays
(   64) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   65) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   66) !     KSTA        - Position of first grid column for the latitudes on a 
(   67) !                   processor. The information is available for all processors.
(   68) !                   The b-sets are distinguished by the last dimension of 
(   69) !                   nsta().The latitude band for each a-set is addressed by 
(   70) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   71) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   72) !                   Each split latitude has two entries in nsta(,:) which 
(   73) !                   necessitates the rather complex addressing of nsta(,:)
(   74) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   75) !     KONL        - Number of grid columns for the latitudes on a processor.
(   76) !                   Similar to nsta() in data structure.
(   77) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   78) !                   two a-sets
(   79) # 80 ".D[60]/etrans_inq.h"
(   80) !                FOURIER SPACE
(   81) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   82) !                the FFT's.
(   83) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   84) !                it performs the Fourier calculations
(   85) # 86 ".D[60]/etrans_inq.h"
(   86) !                 LEGENDRE
(   87) !     PMU      - sin(Gaussian latitudes)
(   88) !     PGW      - Gaussian weights
(   89) !     PRPNM    - Legendre polynomials
(   90) !     KLEI3    - First dimension of Legendre polynomials
(   91) !     KSPOLEGL - Second dimension of Legendre polynomials
(   92) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   93) !     PLEPINM  - Eigen-values of the inverse Laplace operator
(   94) # 95 ".D[60]/etrans_inq.h"
(   95) !     Method.
(   96) !     -------
(   97) # 98 ".D[60]/etrans_inq.h"
(   98) !     Externals.  ESET_RESOL - set resolution
(   99) !     ----------  
(  100) # 101 ".D[60]/etrans_inq.h"
(  101) !     Author.
(  102) !     -------
(  103) !        Mats Hamrud *ECMWF*
(  104) # 105 ".D[60]/etrans_inq.h"
(  105) !     Modifications.
(  106) !     --------------
(  107) !        Original : 00-03-03
(  108) !        M.Hamrud      01-Oct-2003 CY28 Cleaning
(  109) !        A.Nmiri       15-Nov-2007 Phasing with TFL 32R3
(  110) !        A.Bogatchev   16-Sep-2010 Phasing with TFL 36R4
(  111) !        R. El Khatib 08-Aug-2012 KSMAX,KMSMAX,KNVALUE,KMVALUE,PLEPINM,LDLAM,KDEF_RESOL,LDLINEAR_GRID
(  112) # 113 ".D[60]/etrans_inq.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 56

(  113) !     ------------------------------------------------------------------
(  114) # 115 ".D[60]/etrans_inq.h"
(  115) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  116) # 117 ".D[60]/etrans_inq.h"
(  117) IMPLICIT NONE
(  118) # 119 ".D[60]/etrans_inq.h"
(  119) INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN)    :: KRESOL 
(  120) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC 
(  121) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2 
(  122) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2G 
(  123) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPEC2MX 
(  124) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KNUMP 
(  125) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOT 
(  126) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTG 
(  127) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTMX 
(  128) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KGPTOTL(:,:) 
(  129) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KMYMS(:) 
(  130) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KESM0(0:) 
(  131) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KUMPP(:) 
(  132) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPOSSP(:) 
(  133) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRMS(:) 
(  134) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KALLMS(:) 
(  135) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KDIM0G(0:) 
(  136) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLAT(:) 
(  137) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLSTLAT(:) 
(  138) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KFRSTLOFF 
(  139) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLAT(:) 
(  140) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFRSTLAT(:) 
(  141) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLSTLAT(:) 
(  142) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRFLOFF 
(  143) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSTA(:,:) 
(  144) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KONL(:,:) 
(  145) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KULTPP(:) 
(  146) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPTRLS(:) 
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  150) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  151) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  152) LOGICAL           ,OPTIONAL,INTENT(INOUT) :: LDSPLITLAT(:) 
(  153) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PMU(:) 
(  154) REAL(KIND=JPRB)   ,OPTIONAL               :: PGW(:) ! Argument NOT used
(  155) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(INOUT) :: PRPNM(:,:) 
(  156) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KLEI3 
(  157) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KSPOLEGL 
(  158) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPMS(0:) 
(  159) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL2M(0:) 
(  160) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KCPL4M(0:) 
(  161) INTEGER(KIND=JPIM),OPTIONAL,INTENT(INOUT) :: KPROCM(0:) 
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  163) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMSMAX
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)
(  165) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMVALUE(:)
(  166) REAL(KIND=JPRB)   ,OPTIONAL,INTENT(OUT) :: PLEPINM(:)
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  168) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  169) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLINEAR_GRID
(  170) # 171 ".D[60]/etrans_inq.h"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 57

(  171) END SUBROUTINE ETRANS_INQ
(  172) END INTERFACE
(  173) # 629 "transforms4py.F90"
(  629) # 630 "transforms4py.F90"
(  630) KRETURNCODE=0
(  631) LLSTOP=.FALSE.
(  632) ISIZEI=KSIZEI
(  633) ISIZEJ=KSIZEJ
(  634) IPHYSICALSIZEI=KPHYSICALSIZEI
(  635) IPHYSICALSIZEJ=KPHYSICALSIZEJ
(  636) ITRUNCX=KTRUNCX
(  637) ITRUNCY=KTRUNCY
(  638) INUMMAXRESOL=KNUMMAXRESOL
(  639) # 640 "transforms4py.F90"
(  640) ! III. Setup
(  641) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  642)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .TRUE., 1, &
(  643)                   &PDELTAX, PDELTAY, IIDENTRESOL, LLSTOP)
(  644) # 645 "transforms4py.F90"
(  645) ! IV. Transformation
(  646) # 647 "transforms4py.F90"
(  647) ! IV.a Shape of coefficient array
(  648) !IGPTOT is the total number of points in grid-point space
(  649) !ISPEC is the number of spectral coefficients
(  650) !IESM0(m) is the index of spectral coefficient (m,0) in model
(  651) !ISPECINI(n) is the index of the first of the 4 spectral coefficient (0,n) in FA file
(  652) !ISPECEND(n) is the index of the last of the last 4 spectral coefficients (:,n) in FA file
(  653) IF (.NOT. LLSTOP) THEN
(  654)   CALL ETRANS_INQ(KRESOL=IIDENTRESOL, KGPTOT=IGPTOT, KSPEC=ISPEC, KESM0=IESM0)
(  655)   JI=1
(  656)   DO JN=0, ITRUNCY
(  657)     ISPECINI(JN)=(JI-1)*4+1
(  658)     JI=JI+COUNT(IESM0(1:ITRUNCX)-IESM0(0:ITRUNCX-1)>JN*4)
(  659)     IF (ISPEC-IESM0(ITRUNCX)>JN*4) JI=JI+1
(  660)     ISPECEND(JN)=(JI-1)*4
(  661)   ENDDO
(  662) ENDIF
(  663) # 664 "transforms4py.F90"
(  664) ! III.b transform
(  665) IF (.NOT. LLSTOP) THEN
(  666)   ZGPBUF(:,1,1)=REAL(PGPT(:),KIND=JPRB)
(  667)   CALL EDIR_TRANS(PSPSCALAR=ZSPBUF(:,:), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL)
(  668) ENDIF
(  669) # 670 "transforms4py.F90"
(  670) ! III.c Reordering
(  671) ! reorder Aladin :  file ordering = coeffs per blocks of m, 4 reals per coeff
(  672) !           Aladin array ordering = coeffs per blocks of n, 4 reals per coeff
(  673) IF (LREORDER) THEN
(  674)   IF (.NOT. LLSTOP) THEN
(  675)     JI=1
(  676)     PSPEC(:)=0.
(  677)     DO JM=0,ITRUNCX*4+4,4
(  678)       DO JN=0,ITRUNCY
(  679)         IF (ISPECINI(JN)+JM+3<=ISPECEND(JN)) THEN
(  680)           PSPEC(ISPECINI(JN)+JM:ISPECINI(JN)+JM+3) = REAL(ZSPBUF(1,JI:JI+3),KIND=8)
(  681)           JI=JI+4
(  682)         ENDIF
(  683)       ENDDO






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 58

(  684)     ENDDO
(  685)     IF(JI/=ISPEC+1) THEN
(  686)       PRINT*, "Internal error in W_GPT2SPEC_LAM (spectral reordering)"
(  687)       KRETURNCODE=-999
(  688)     ENDIF
(  689)   ENDIF
(  690) ELSE
(  691)   PSPEC(1:KSIZE) = REAL(ZSPBUF(1,1:KSIZE),KIND=8)
(  692) ENDIF
(  693) # 694 "transforms4py.F90"
(  694) END SUBROUTINE W_GPT2SPEC_LAM
(  695) # 696 "transforms4py.F90"
(  696) !____________________________________________________________________________
(  697) # 698 "transforms4py.F90"
(  698) SUBROUTINE W_GPT2SPEC_GAUSS(KRETURNCODE, KSPEC, KSIZEJ, KTRUNC, KNUMMAXRESOL, KSLOEN, KLOEN, KSIZE, LREORDER, PGPT, PSPEC)
(  699) ! ** PURPOSE
(  700) !    Transform spectral coefficients into grid-point values
(  701) !
(  702) ! ** DUMMY ARGUMENTS
(  703) !    KRETURNCODE: error code
(  704) !    KSPEC: size of spectral coefficients array
(  705) !    KSIZEJ: Number of latitudes
(  706) !    KTRUNC: troncature
(  707) !    KNUMMAXRESOL: maximum number of troncatures handled
(  708) !    KSLOEN: Size ok KLOEN
(  709) !    KLOEN
(  710) !    KSIZE: Size of PGPT
(  711) !    LREORDER: switch to reorder spectral coefficients or not
(  712) !    PGPT: grid-point field
(  713) !    PSPEC: spectral coefficient array
(  714) !
(  715) ! ** AUTHOR
(  716) !    9 April 2014, S. Riette
(  717) !
(  718) ! ** MODIFICATIONS
(  719) !    6 Jan. 2016, S. Riette: w_spec_setup interface modified
(  720) !    March, 2016, A.Mary: LREORDER
(  721) !
(  722) ! I. Dummy arguments declaration
(  723) USE PARKIND1, ONLY : JPRB
(  724) IMPLICIT NONE
(  725) INTEGER(KIND=8), INTENT(OUT) :: KRETURNCODE
(  726) INTEGER(KIND=8), INTENT(IN) :: KSPEC
(  727) INTEGER(KIND=8), INTENT(IN) :: KSIZEJ
(  728) INTEGER(KIND=8), INTENT(IN) :: KTRUNC
(  729) INTEGER(KIND=8), INTENT(IN) :: KNUMMAXRESOL
(  730) INTEGER(KIND=8), INTENT(IN) :: KSLOEN
(  731) INTEGER(KIND=8), DIMENSION(KSLOEN), INTENT(IN) :: KLOEN
(  732) INTEGER(KIND=8), INTENT(IN) :: KSIZE
(  733) LOGICAL, INTENT(IN) :: LREORDER
(  734) REAL(KIND=8), DIMENSION(KSIZE), INTENT(IN) :: PGPT
(  735) REAL(KIND=8), DIMENSION(KSPEC), INTENT(OUT) :: PSPEC
(  736) !
(  737) ! II. Local variables declaration
(  738) INTEGER, DIMENSION(SIZE(KLOEN)) :: ILOEN
(  739) INTEGER :: ISIZEI, ISIZEJ, &
(  740)          & IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  741)          & ITRUNCX, ITRUNCY, &






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 59

(  742)          & INUMMAXRESOL
(  743) LOGICAL :: LLSTOP
(  744) INTEGER :: IIDENTRESOL
(  745) INTEGER :: JI, JM, JN
(  746) INTEGER, DIMENSION(0:KTRUNC) :: NASM0
(  747) REAL(KIND=JPRB), DIMENSION(1, SIZE(PGPT)) :: ZSPBUF !size over-evaluated
(  748) REAL(KIND=JPRB), DIMENSION(SIZE(PGPT), 1, 1) :: ZGPBUF
(  749) REAL(KIND=8) :: ZDELTAX, ZDELTAY
(  750) # 751 "transforms4py.F90"
(  751) # 1 ".D[70]/trans_inq.h"
(    1) INTERFACE
(    2) SUBROUTINE TRANS_INQ(KRESOL,KSPEC,KSPEC2,KSPEC2G,KSPEC2MX,KNUMP,&
(    3)                     &KGPTOT,KGPTOTG,KGPTOTMX,KGPTOTL,&
(    4)                     &KMYMS,KASM0,KUMPP,KPOSSP,KPTRMS,KALLMS,KDIM0G,&
(    5)                     &KFRSTLAT,KLSTLAT,KFRSTLOFF,KPTRLAT,&
(    6)                     &KPTRFRSTLAT,KPTRLSTLAT,KPTRFLOFF,KSTA,KONL,&
(    7)                     &KULTPP,KPTRLS,KNMENG,&
(    8)                     &KPRTRW,KMYSETW,KMYSETV,KMY_REGION_NS,KMY_REGION_EW,&
(    9)                     &LDSPLITLAT,&
(   10)                     &KSMAX,PLAPIN,KNVALUE,KDEF_RESOL,LDLAM,&
(   11)                     &PMU,PGW,PRPNM,KLEI3,KSPOLEGL,KPMS,KDGLU)
(   12) # 13 ".D[70]/trans_inq.h"
(   13) !**** *TRANS_INQ* - Extract information from the transform package
(   14) # 15 ".D[70]/trans_inq.h"
(   15) !     Purpose.
(   16) !     --------
(   17) !     Interface routine for extracting information from the T.P.
(   18) # 19 ".D[70]/trans_inq.h"
(   19) !**   Interface.
(   20) !     ----------
(   21) !     CALL TRANS_INQ(...)
(   22) !     Explicit arguments : All arguments are optional.
(   23) !     -------------------- 
(   24) !     KRESOL   - resolution tag for which info is required ,default is the
(   25) !                first defined resulution (input)
(   26) # 27 ".D[70]/trans_inq.h"
(   27) !                   MULTI-TRANSFORMS MANAGEMENT
(   28) !     KDEF_RESOL - number or resolutions defined
(   29) !     LDLAM      - .T. if the corresponding resolution is LAM, .F. if it is global
(   30) # 31 ".D[70]/trans_inq.h"
(   31) !                   SPECTRAL SPACE
(   32) !     KSPEC    - number of complex spectral coefficients on this PE
(   33) !     KSPEC2   - 2*KSPEC 
(   34) !     KSPEC2G  - global KSPEC2
(   35) !     KSPEC2MX - maximun KSPEC2 among all PEs
(   36) !     KNUMP    - Number of spectral waves handled by this PE
(   37) !     KGPTOT   - Total number of grid columns on this PE
(   38) !     KGPTOTG  - Total number of grid columns on the Globe
(   39) !     KGPTOTMX - Maximum number of grid columns on any of the PEs
(   40) !     KGPTOTL  - Number of grid columns one each PE (dimension N_REGIONS_NS:N_REGIONS_EW)
(   41) !     KMYMS    - This PEs spectral zonal wavenumbers
(   42) !     KASM0    - Address in a spectral array of (m, n=m)
(   43) !     KUMPP    - No. of wave numbers each wave set is responsible for
(   44) !     KPOSSP   - Defines partitioning of global spectral fields among PEs
(   45) !     KPTRMS   - Pointer to the first wave number of a given a-set
(   46) !     KALLMS   - Wave numbers for all wave-set concatenated together 
(   47) !                to give all wave numbers in wave-set order
(   48) !     KDIM0G   - Defines partitioning of global spectral fields among PEs






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 60

(   49) !     KSMAX    - spectral truncation
(   50) !     KNVALUE  - n value for each KSPEC2 spectral coeffient
(   51) # 52 ".D[70]/trans_inq.h"
(   52) !                 GRIDPOINT SPACE                  
(   53) !     KFRSTLAT    - First latitude of each a-set in grid-point space
(   54) !     KLSTTLAT    - Last latitude of each a-set in grid-point space
(   55) !     KFRSTLOFF   - Offset for first lat of own a-set in grid-point space
(   56) !     KPTRLAT     - Pointer to the start of each latitude
(   57) !     KPTRFRSTLAT - Pointer to the first latitude of each a-set in 
(   58) !                   NSTA and NONL arrays
(   59) !     KPTRLSTLAT  - Pointer to the last latitude of each a-set in
(   60) !                   NSTA and NONL arrays
(   61) !     KPTRFLOFF   - Offset for pointer to the first latitude of own a-set
(   62) !                   NSTA and NONL arrays, i.e. nptrfrstlat(myseta)-1
(   63) !     KSTA        - Position of first grid column for the latitudes on a 
(   64) !                   processor. The information is available for all processors.
(   65) !                   The b-sets are distinguished by the last dimension of 
(   66) !                   nsta().The latitude band for each a-set is addressed by 
(   67) !                   nptrfrstlat(jaset),nptrlstlat(jaset), and 
(   68) !                   nptrfloff=nptrfrstlat(myseta) on this processors a-set.
(   69) !                   Each split latitude has two entries in nsta(,:) which 
(   70) !                   necessitates the rather complex addressing of nsta(,:)
(   71) !                   and the overdimensioning of nsta by N_REGIONS_NS.
(   72) !     KONL        - Number of grid columns for the latitudes on a processor.
(   73) !                   Similar to nsta() in data structure.
(   74) !     LDSPLITLAT  - TRUE if latitude is split in grid point space over 
(   75) !                   two a-sets
(   76) # 77 ".D[70]/trans_inq.h"
(   77) !                FOURIER SPACE
(   78) !     KULTPP   - number of latitudes for which each a-set is calculating 
(   79) !                the FFT's.
(   80) !     KPTRLS   - pointer to first global latitude of each a-set for which
(   81) !                it performs the Fourier calculations
(   82) !     KNMENG   - associated (with NLOENG) cut-off zonal wavenumber
(   83) # 84 ".D[70]/trans_inq.h"
(   84) !                 LEGENDRE
(   85) !     PMU      - sin(Gaussian latitudes)
(   86) !     PGW      - Gaussian weights
(   87) !     PRPNM    - Legendre polynomials
(   88) !     KLEI3    - First dimension of Legendre polynomials
(   89) !     KSPOLEGL - Second dimension of Legendre polynomials
(   90) !     KPMS     - Adress for legendre polynomial for given M (NSMAX)
(   91) !     PLAPIN   - Eigen-values of the inverse Laplace operator
(   92) !     KDGLU    - Number of active points in an hemisphere for a given wavenumber "m"
(   93) # 94 ".D[70]/trans_inq.h"
(   94) !     Method.
(   95) !     -------
(   96) # 97 ".D[70]/trans_inq.h"
(   97) !     Externals.  SET_RESOL - set resolution
(   98) !     ----------  
(   99) # 100 ".D[70]/trans_inq.h"
(  100) !     Author.
(  101) !     -------
(  102) !        Mats Hamrud *ECMWF*
(  103) # 104 ".D[70]/trans_inq.h"
(  104) !     Modifications.
(  105) !     --------------
(  106) !        Original : 00-03-03






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 61

(  107) !        M. Hortal : 2001-03-05 Dimensions of the Legendre polynomials
(  108) !        R. El Khatib 08-Aug-2012 KSMAX,PLAPIN,KNVALUE,LDLAM,KDEF_RESOL
(  109) # 110 ".D[70]/trans_inq.h"
(  110) !     ------------------------------------------------------------------
(  111) # 112 ".D[70]/trans_inq.h"
(  112) USE PARKIND1  ,ONLY : JPIM     ,JPRB, JPRD
(  113) # 115 ".D[70]/trans_inq.h"
(  115) IMPLICIT NONE
(  116) # 117 ".D[70]/trans_inq.h"
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN)  :: KRESOL
(  118) # 119 ".D[70]/trans_inq.h"
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2
(  121) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2G
(  122) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPEC2MX
(  123) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNUMP
(  124) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOT
(  125) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTG
(  126) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTMX
(  127) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KGPTOTL(:,:)
(  128) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLOFF
(  129) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFLOFF
(  130) # 131 ".D[70]/trans_inq.h"
(  131) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYMS(:)
(  132) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KASM0(0:)
(  133) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KUMPP(:)
(  134) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPOSSP(:)
(  135) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRMS(:)
(  136) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KALLMS(:)
(  137) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDIM0G(0:)
(  138) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KFRSTLAT(:)
(  139) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLSTLAT(:)
(  140) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLAT(:)
(  141) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRFRSTLAT(:)
(  142) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLSTLAT(:)
(  143) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSTA(:,:)
(  144) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KONL(:,:)
(  145) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPRTRW
(  146) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETW
(  147) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMYSETV
(  148) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_NS
(  149) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KMY_REGION_EW
(  150) LOGICAL   ,OPTIONAL, INTENT(OUT) :: LDSPLITLAT(:)
(  151) # 152 ".D[70]/trans_inq.h"
(  152) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KULTPP(:)
(  153) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPTRLS(:)
(  154) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNMENG(:)
(  155) # 156 ".D[70]/trans_inq.h"
(  156) REAL(KIND=JPRD)    ,OPTIONAL, INTENT(OUT) :: PMU(:)
(  157) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PGW(:)
(  158) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PRPNM(:,:)
(  159) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KLEI3
(  160) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSPOLEGL
(  161) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KPMS(0:)
(  162) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDGLU(0:)
(  163) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PLAPIN(-1:)
(  164) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KSMAX
(  165) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KNVALUE(:)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 62

(  166) # 167 ".D[70]/trans_inq.h"
(  167) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(OUT) :: KDEF_RESOL
(  168) LOGICAL           ,OPTIONAL,INTENT(OUT)   :: LDLAM
(  169) # 170 ".D[70]/trans_inq.h"
(  170) END SUBROUTINE TRANS_INQ
(  171) # 177 ".D[70]/trans_inq.h"
(  177) END INTERFACE
(  178) # 752 "transforms4py.F90"
(  752) # 752 "transforms4py.F90"
(  752) # 1 ".D[70]/dir_trans.h"
(    1) INTERFACE
(    2) SUBROUTINE DIR_TRANS(PSPVOR,PSPDIV,PSPSCALAR,PSPSC3A,PSPSC3B,PSPSC2,&
(    3) & LDLATLON,KPROMA,KVSETUV,KVSETSC,KRESOL,KVSETSC3A,KVSETSC3B,KVSETSC2,&
(    4) & PGP,PGPUV,PGP3A,PGP3B,PGP2)
(    5) # 7 ".D[70]/dir_trans.h"
(    7) !**** *DIR_TRANS* - Direct spectral transform (from grid-point to spectral).
(    8) # 9 ".D[70]/dir_trans.h"
(    9) !     Purpose.
(   10) !     --------
(   11) !        Interface routine for the direct spectral transform
(   12) # 13 ".D[70]/dir_trans.h"
(   13) !**   Interface.
(   14) !     ----------
(   15) !     CALL DIR_TRANS(...)
(   16) # 17 ".D[70]/dir_trans.h"
(   17) !     Explicit arguments : All arguments except from PGP are optional.
(   18) !     -------------------- 
(   19) !     PSPVOR(:,:) - spectral vorticity (output)
(   20) !     PSPDIV(:,:) - spectral divergence (output)
(   21) !     PSPSCALAR(:,:) - spectral scalarvalued fields (output)
(   22) !     PSPSC3A(:,:,:) - alternative to use of PSPSCALAR, see PGP3A below (input)
(   23) !     PSPSC3B(:,:,:) - alternative to use of PSPSCALAR, see PGP3B below (input)
(   24) !     PSPSC2(:,:)  - alternative to use of PSPSCALAR, see PGP2 below (input)
(   25) !     LDLATLON   - indicating if regular lat-lon is the input data
(   26) !     KPROMA      - required blocking factor for gridpoint output
(   27) !     KVSETUV(:)  - indicating which 'b-set' in spectral space owns a 
(   28) !                   vor/div field. Equivalant to NBSETLEV in the IFS.
(   29) !                   The length of KVSETUV should be the GLOBAL number
(   30) !                   of u/v fields which is the dimension of u and v releated
(   31) !                   fields in grid-point space. 
(   32) !     KVESETSC(:) - indicating which 'b-set' in spectral space owns a
(   33) !                   scalar field. As for KVSETUV this argument is required
(   34) !                   if the total number of processors is greater than
(   35) !                   the number of processors used for distribution in
(   36) !                   spectral wave space.  
(   37) !     KVSETSC3A(:) - as KVESETSC for PSPSC3A (distribution on first dimension)
(   38) !     KVSETSC3B(:) - as KVESETSC for PSPSC3B (distribution on first dimension)
(   39) !     KVSETSC2(:) - as KVESETSC for PSPSC2 (distribution on first dimension)
(   40) !     KRESOL   - resolution tag  which is required ,default is the
(   41) !                first defined resulution (input)
(   42) !     PGP(:,:,:) - gridpoint fields (input)
(   43) !                  PGP need to  dimensioned (NPROMA,IF_GP,NGPBLKS) where
(   44) !                  NPROMA is the blocking factor, IF_GP the total number
(   45) !                  of output fields and NGPBLKS the number of NPROMA blocks.
(   46) !                  The ordering of the output fields is as follows (all 
(   47) !                  parts are optional depending on the input switches):
(   48) !
(   49) !     u             : IF_UV_G fields (if psvor present)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 63

(   50) !     v             : IF_UV_G fields (if psvor present)
(   51) !     scalar fields : IF_SCALARS_G fields (if pspscalar present)
(   52) !   
(   53) !     Here IF_UV_G is the GLOBAL number of u/v fields as given by the length
(   54) !     of KVSETUV (or by PSPVOR if no split in spectral 'b-set' direction
(   55) !     IF_SCALARS_G is the GLOBAL number of scalar fields as giben by the 
(   56) !     length of KVESETSC (or by number of fields in PSPSCALAR if no spectral
(   57) !     'b-set' split
(   58) # 59 ".D[70]/dir_trans.h"
(   59) !     As an alternative to using PGP you can also use a combination of the
(   60) !     following arrays. The reason for introducing these alternative ways
(   61) !     of calling DIR_TRANS is to avoid uneccessary copies where your data
(   62) !     structures don't fit in to the 'PSPVOR,PSPDIV, PSPSCALAR, PGP' layout.
(   63) !     The use of any of these precludes the use of PGP and vice versa.
(   64) # 65 ".D[70]/dir_trans.h"
(   65) !     PGPUV(:,:,:,:) - the 'u-v' related grid-point variables in the order
(   66) !                      described for PGP. The second dimension of PGPUV should
(   67) !                      be the same as the "global" first dimension of 
(   68) !                      PSPVOR,PSPDIV (in the IFS this is the number of levels)
(   69) !                      PGPUV need to be dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   70) !                      IFLDS is the number of 'variables' (u,v)
(   71) !     PGP3A(:,:,:,:) - grid-point array directly connected with PSPSC3A
(   72) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   73) !                      IFLDS is the number of 'variables' (the same as in
(   74) !                      PSPSC3A )
(   75) !     PGP3B(:,:,:,:) - grid-point array directly connected with PSPSC3B
(   76) !                      dimensioned(NPROMA,ILEVS,IFLDS,NGPBLKS)
(   77) !                      IFLDS is the number of 'variables' (the same as in
(   78) !                      PSPSC3B)
(   79) !     PGP2(:,:,:)    - grid-point array directly connected with PSPSC2
(   80) !                      dimensioned(NPROMA,IFLDS,NGPBLKS)
(   81) !                      IFLDS is the number of 'variables' (the same as in
(   82) !                      PSPSC2 )
(   83) ! 
(   84) !     Method.
(   85) !     -------
(   86) # 87 ".D[70]/dir_trans.h"
(   87) !     Externals.  SET_RESOL   - set resolution
(   88) !     ----------  LTDIR_CTL   - control of Legendre transform
(   89) !                 FTDIR_CTL   - control of Fourier transform
(   90) # 91 ".D[70]/dir_trans.h"
(   91) !     Author.
(   92) !     -------
(   93) !        Mats Hamrud *ECMWF*
(   94) # 95 ".D[70]/dir_trans.h"
(   95) !     Modifications.
(   96) !     --------------
(   97) !        Original : 00-03-03
(   98) # 99 ".D[70]/dir_trans.h"
(   99) !     ------------------------------------------------------------------
(  100) # 101 ".D[70]/dir_trans.h"
(  101) USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  102) # 104 ".D[70]/dir_trans.h"
(  104) IMPLICIT NONE
(  105) # 106 ".D[70]/dir_trans.h"
(  106) ! Declaration of arguments
(  107) # 108 ".D[70]/dir_trans.h"
(  108) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPVOR(:,:)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 64

(  109) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPDIV(:,:)
(  110) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSCALAR(:,:)
(  111) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3A(:,:,:)
(  112) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC3B(:,:,:)
(  113) REAL(KIND=JPRB)    ,OPTIONAL, INTENT(OUT) :: PSPSC2(:,:)
(  114) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KPROMA
(  115) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETUV(:)
(  116) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC(:)
(  117) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3A(:)
(  118) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC3B(:)
(  119) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KVSETSC2(:)
(  120) INTEGER(KIND=JPIM) ,OPTIONAL, INTENT(IN) :: KRESOL
(  121) LOGICAL   ,OPTIONAL, INTENT(IN) :: LDLATLON
(  122) # 123 ".D[70]/dir_trans.h"
(  123) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP(:,:,:)
(  124) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGPUV(:,:,:,:)
(  125) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3A(:,:,:,:)
(  126) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP3B(:,:,:,:)
(  127) REAL(KIND=JPRB),OPTIONAL    ,INTENT(IN) :: PGP2(:,:,:)
(  128) # 130 ".D[70]/dir_trans.h"
(  130) END SUBROUTINE DIR_TRANS
(  131) # 132 ".D[70]/dir_trans.h"
(  132) END INTERFACE
(  133) # 753 "transforms4py.F90"
(  753) # 753 "transforms4py.F90"
(  753) KRETURNCODE=0
(  754) ILOEN(:)=KLOEN(:)
(  755) ISIZEI=0
(  756) ISIZEJ=KSIZEJ
(  757) IPHYSICALSIZEI=0
(  758) IPHYSICALSIZEJ=0
(  759) ITRUNCX=KTRUNC
(  760) ITRUNCY=0
(  761) INUMMAXRESOL=KNUMMAXRESOL
(  762) !
(  763) ! III. Setup
(  764) ZDELTAX=0.
(  765) ZDELTAY=0.
(  766) CALL W_SPEC_SETUP(KRETURNCODE, ISIZEI, ISIZEJ, IPHYSICALSIZEI, IPHYSICALSIZEJ, &
(  767)                   &ITRUNCX, ITRUNCY, INUMMAXRESOL, ILOEN, .FALSE., SIZE(ILOEN), &
(  768)                   &ZDELTAX, ZDELTAY, IIDENTRESOL, LLSTOP)
(  769) !
(  770) ! IV. Transformation
(  771) ! IV.a Shape of coefficient array
(  772) IF (.NOT. LLSTOP) THEN
(  773)   JI=1
(  774)   DO JN=0, KTRUNC
(  775)     NASM0(JN)=JI
(  776)     JI=JI+1+JN+(JN+1)
(  777)   ENDDO
(  778) ENDIF
(  779) # 780 "transforms4py.F90"
(  780) ! IV.b Direct transform
(  781) IF (.NOT. LLSTOP) THEN
(  782)   ZGPBUF(:,1,1)=REAL(PGPT(:),KIND=JPRB)
(  783)   CALL DIR_TRANS(PSPSCALAR=ZSPBUF(:,:), PGP=ZGPBUF(:,:,:), KRESOL=IIDENTRESOL)
(  784) ENDIF
(  785) # 786 "transforms4py.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 65

(  786) ! IV.c Reordering
(  787) IF (LREORDER) THEN
(  788)   IF(.NOT. LLSTOP) THEN
(  789)     PSPEC(:)=0.
(  790)     JI=1
(  791)     DO JM=0, KTRUNC
(  792)       DO JN=JM, KTRUNC
(  793)         PSPEC(NASM0(JN)+JM)=REAL(ZSPBUF(1,JI),KIND=8)
(  794)         JI=JI+1
(  795)         IF(JM/=0) THEN
(  796)           PSPEC(NASM0(JN)-JM)=REAL(ZSPBUF(1,JI),KIND=8)
(  797)         ENDIF
(  798)         JI=JI+1
(  799)       ENDDO
(  800)     ENDDO
(  801)     IF(JI-1/=KSPEC) THEN
(  802)       PRINT*, "Internal error in W_GPT2SPEC_GAUSS (spectral reordering)"
(  803)       KRETURNCODE=-999
(  804)     ENDIF
(  805)   ENDIF
(  806) ELSE
(  807)   PSPEC(1:KSPEC) = REAL(ZSPBUF(1,1:KSPEC),KIND=8)
(  808) ENDIF
(  809) # 810 "transforms4py.F90"
(  810) END SUBROUTINE W_GPT2SPEC_GAUSS
(  811) # 812 "transforms4py.F90"
(  812) SUBROUTINE W_SPEC2GPT_FFT1D(KSIZES, KTRUNC, PSPEC, KSIZEG, PGPT)
(  813) ! ** PURPOSE
(  814) !    Transform spectral coefficients into grid-point values,
(  815) !    for a 1D array (vertical section academic model)
(  816) !
(  817) ! ** DUMMY ARGUMENTS
(  818) !    KSIZES size of PSPEC
(  819) !    KTRUNC: troncature
(  820) !    PSPEC: spectral coefficient array
(  821) !    KSIZEG: size of grid-point field (with extension zone)
(  822) !    PGPT: grid-point field
(  823) !
(  824) ! ** AUTHOR
(  825) !    26 March 2015, A. Mary, from utilities/pinuts/module/fa_datas_mod.F90
(  826) !
(  827) ! ** MODIFICATIONS
(  828) !
(  829) ! I. Dummy arguments declaration
(  830) IMPLICIT NONE
(  831) # 832 "transforms4py.F90"
(  832) INTEGER(KIND=8), INTENT(IN) :: KSIZES
(  833) INTEGER(KIND=8), INTENT(IN) :: KTRUNC
(  834) REAL(KIND=8), DIMENSION(KSIZES), INTENT(IN) :: PSPEC
(  835) INTEGER(KIND=8), INTENT(IN) :: KSIZEG
(  836) REAL(KIND=8), DIMENSION(KSIZEG), INTENT(OUT) :: PGPT
(  837) # 838 "transforms4py.F90"
(  838) INTEGER(KIND=8) :: NSEFRE, NFTM, NDGLSUR
(  839) REAL(KIND=8), DIMENSION(:), ALLOCATABLE :: SP2, TRIGSE
(  840) INTEGER(KIND=8), DIMENSION(:), ALLOCATABLE  :: NFAXE
(  841) INTEGER(KIND=8), PARAMETER :: NZERO=0
(  842) # 843 "transforms4py.F90"
(  843) NDGLSUR = KSIZEG+MOD(KSIZEG,2)+2






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 66

(  844) NFTM    = 2*(KTRUNC+1)
(  845) ALLOCATE(SP2(NDGLSUR*NFTM))
(  846) SP2     = 0.0
(  847) SP2     = CONVRT2FFT(PSPEC,NZERO,KTRUNC,NDGLSUR)
(  848) ALLOCATE(NFAXE(1:10))
(  849) ALLOCATE(TRIGSE(1:KSIZEG)) 
(  850) CALL SET99(TRIGSE,NFAXE,KSIZEG)
(  851) CALL FFT992(SP2(1:KSIZEG), TRIGSE, NFAXE, 1, NDGLSUR, KSIZEG, 1, 1)
(  852) DEALLOCATE(TRIGSE)
(  853) DEALLOCATE(NFAXE)
(  854) PGPT(:) = SP2(1:KSIZEG)
(  855) # 856 "transforms4py.F90"
(  856) CONTAINS
(  857) # 858 "transforms4py.F90"
(  858) ! from utilities/pinuts/module/fa_datas_mod.F90
(  859) ! and utilities/pinuts/module/array_lib_mod.F90
(  860) # 861 "transforms4py.F90"
(  861) FUNCTION CONVRT2FFT(IN,X,Y,N) RESULT(OU)
(  862) REAL(KIND=8),DIMENSION(:),INTENT(IN)      :: IN
(  863) INTEGER(KIND=8),INTENT(IN)                       :: X, Y, N
(  864) REAL(KIND=8),DIMENSION(N*2*(X+1))         :: OU
(  865) # 866 "transforms4py.F90"
(  866) INTEGER(KIND=8),DIMENSION(2*(X+1),(N/2))         :: MINQ 
(  867) INTEGER(KIND=8),DIMENSION((N/2),2*(X+1))         :: TMINQ 
(  868) REAL(KIND=8),DIMENSION(2*(X+1),(N/2))     :: OMINQ, EMINQ
(  869) REAL(KIND=8),DIMENSION((N/2),2*(X+1))     :: TOMINQ, TEMINQ   
(  870) REAL(KIND=8),DIMENSION(N*(X+1))           :: OINI, EINI
(  871) REAL(KIND=8), PARAMETER                   :: ZZERO=0.0
(  872) # 873 "transforms4py.F90"
(  873) CALL SPLIT_ODEV(IN,OINI,EINI)
(  874) MINQ   = MASQ(X,Y,N)
(  875) OMINQ  = UNPACK(OINI,MINQ == 1,ZZERO)
(  876) TOMINQ = TRANSPOSE(OMINQ)
(  877) EMINQ  = UNPACK(EINI,MINQ == 1,ZZERO)
(  878) TEMINQ = TRANSPOSE(EMINQ)
(  879) TMINQ  = 1
(  880) OINI   = PACK(TOMINQ,TMINQ > 0)
(  881) EINI   = PACK(TEMINQ,TMINQ > 0)
(  882) OU     = MIX_ODEV(OINI,EINI)
(  883) END FUNCTION CONVRT2FFT
(  884) # 885 "transforms4py.F90"
(  885) FUNCTION MASQ(X,Y,N) RESULT(T)
(  886) INTEGER(KIND=8),INTENT(IN)                       :: X, Y, N
(  887) INTEGER(KIND=8),DIMENSION(1:2*(X+1),1:(N/2))     :: T
(  888) # 889 "transforms4py.F90"
(  889) INTEGER(KIND=8)                                  :: I, J
(  890) INTEGER(KIND=8),DIMENSION(0:X)                   :: KM
(  891) INTEGER(KIND=8),DIMENSION(0:Y)                   :: KN
(  892) CALL ELLIPS64(X,Y,KN,KM) 
(  893) T = 0
(  894) DO I=0,Y
(  895)   DO J=0,2*KN(I)+1
(  896)     T(J+1,I+1)=1
(  897)   END DO
(  898) END DO
(  899) END FUNCTION MASQ
(  900) # 901 "transforms4py.F90"
(  901) FUNCTION MIX_ODEV(TO,TE) RESULT(T)






NVFORTRAN (Version     23.1)          02/24/2023  13:33:57      page 67

(  902) REAL(KIND=8),DIMENSION(:),INTENT(IN)        :: TO,TE
(  903) REAL(KIND=8),DIMENSION(SIZE(TO)+SIZE(TE))   :: T
(  904) # 905 "transforms4py.F90"
(  905) INTEGER(KIND=8) :: I
(  906) # 907 "transforms4py.F90"
(  907) DO I=1,(SIZE(TO)+SIZE(TE))/2
(  908)   T((2*I)-1)=TE(I)
(  909)   T(2*I)=TO(I)
(  910) END DO
(  911) END FUNCTION MIX_ODEV
(  912) # 913 "transforms4py.F90"
(  913) SUBROUTINE SPLIT_ODEV(T,TO,TE)
(  914) REAL(KIND=8),DIMENSION(:),INTENT(IN)          :: T
(  915) REAL(KIND=8),DIMENSION(SIZE(T)/2),INTENT(OUT) :: TO,TE
(  916) # 917 "transforms4py.F90"
(  917) INTEGER(KIND=8) :: I
(  918) # 919 "transforms4py.F90"
(  919) DO I=1,SIZE(T)/2
(  920)   TO(I)=T(2*I)
(  921)   TE(I)=T((2*I)-1)
(  922) END DO
(  923) END SUBROUTINE SPLIT_ODEV
(  924) # 925 "transforms4py.F90"
(  925) END SUBROUTINE W_SPEC2GPT_FFT1D
