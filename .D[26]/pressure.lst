


NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: pressure.F90

(    1) ! Non-blocking receives before blocking sends
(    2) 
(    3) subroutine pressure
(    4) 
(    5) !************* LICENSE START *****************
(    6) !
(    7) ! Copyright 2015 Marat Khairoutdinov 
(    8) ! School of Marine & Atmospheric Sciences
(    9) ! Stony Brook University
(   10) ! This software is distributed under the terms of
(   11) ! the Apache License version 2.0.
(   12) !
(   13) !************** LICENSE END ******************
(   14) 
(   15) !       Original pressure solver based on horizontal slabs
(   16) !       (C) 1998, 2002 Marat Khairoutdinov
(   17) !       Works only when the number of slabs is equal to the number of processors.
(   18) !       Therefore, the number of processors shouldn't exceed the number of levels nzm
(   19) !       Also, used for a 2D version 
(   20) !       For more processors for the given number of levels and 3D, use pressure_big
(   21) 
(   22) use vars
(   23) use real_size
(   24) implicit none
(   25) 
(   26) 
(   27) integer, parameter :: npressureslabs = nsubdomains
(   28) integer, parameter :: nzslab = max(1,nzm / npressureslabs)
(   29) integer, parameter :: nx2=nx_gl+2, ny2=ny_gl+2*YES3D
(   30) integer, parameter :: n3i=3*nx_gl/2+1,n3j=3*ny_gl/2+1






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 3

(   31) 
(   32) real(RR) f(nx2,ny2,nzslab) ! global rhs and array for FTP coefficeients
(   33) real(RR) ff(nx+1,ny+2*YES3D,nzm)  ! local (subdomain's) version of f
(   34) real(RR) buff_slabs(nxp1,nyp2,nzslab,npressureslabs)
(   35) real(RR) buff_subs(nxp1,nyp2,nzslab,nsubdomains) 
(   36) real(RR) bufp_slabs(0:nx,1-YES3D:ny,nzslab,npressureslabs)  
(   37) real(RR) bufp_subs(0:nx,1-YES3D:ny,nzslab,nsubdomains)  
(   38) 
(   39) real(RR) work(nx2,ny2),trigxi(n3i),trigxj(n3j) ! FFT stuff
(   40) integer ifaxj(100),ifaxi(100)
(   41) 
(   42) real(8) a(nzm),b,c(nzm),e,fff(nzm)
(   43) real(8) xi,xj,xnx,xny,ddx2,ddy2,pii,factx,facty,eign
(   44) real(8) alfa(nzm-1),beta(nzm-1)
(   45) 
(   46) integer reqs_in(nsubdomains)
(   47) integer i, j, k, id, jd, m, n, it, jt, ii, jj, tag, rf
(   48) integer nyp22, n_in, count
(   49) integer iii(0:nx_gl),jjj(0:ny_gl)
(   50) logical flag(nsubdomains)
(   51) integer iwall,jwall
(   52) 
(   53) ! check if the grid size allows the computation:
(   54) 
(   55) if(nsubdomains.gt.nzm) then
(   56)   if(masterproc) print*,'pressure_orig: nzm < nsubdomains. STOP'
(   57)   call task_abort
(   58) endif
(   59) 
(   60) if(mod(nzm,npressureslabs).ne.0) then
(   61)   if(masterproc) print*,'pressure_orig: nzm/npressureslabs is not round number. STOP'
(   62)   call task_abort
(   63) endif
(   64) 
(   65) !-----------------------------------------------------------------
(   66) 
(   67) if(docolumn) return
(   68) 
(   69) if(dowallx) then
(   70)   iwall=1
(   71) else
(   72)   iwall=0
(   73) end if
(   74) if(RUN2D) then  
(   75)   nyp22=1
(   76)   jwall=0
(   77) else
(   78)   nyp22=nyp2
(   79)   if(dowally) then
(   80)     jwall=2
(   81)   else
(   82)     jwall=0
(   83)   end if
(   84) endif
(   85) 
(   86) !-----------------------------------------------------------------
(   87) !  Compute the r.h.s. of the Poisson equation for pressure
(   88) 






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 4

(   89) call press_rhs()
(   90) 
(   91) 
(   92) !----------------------------------------------------------------- 
(   93) !   Form the horizontal slabs of right-hand-sides of Poisson equation 
(   94) !   for the global domain. Request sending and receiving tasks.
(   95) 
(   96) ! iNon-blocking receive first:
(   97) 
(   98) n_in = 0
(   99) do m = 0,nsubdomains-1
(  100) 
(  101)   if(rank.lt.npressureslabs.and.m.ne.nsubdomains-1) then
(  102) 
(  103)     n_in = n_in + 1
(  104)     call task_receive_float(bufp_subs(0,1-YES3D,1,n_in), &
(  105)                            nzslab*nxp1*nyp1,reqs_in(n_in))
(  106)     flag(n_in) = .false.
(  107)  
(  108)   endif
(  109) 
(  110)   if(rank.lt.npressureslabs.and.m.eq.nsubdomains-1) then
(  111) 
(  112)     call task_rank_to_index(rank,it,jt)  
(  113)     n = rank*nzslab
(  114)     do k = 1,nzslab
(  115)      do j = 1,ny
(  116)        do i = 1,nx
(  117)          f(i+it,j+jt,k) = p(i,j,k+n)
(  118)        end do
(  119)      end do
(  120)     end do
(  121)   endif
(  122) 
(  123) end do ! m
(  124) 
(  125) 
(  126) ! Blocking send now:
(  127) 
(  128) 
(  129) do m = 0,nsubdomains-1
(  130) 
(  131)   if(m.lt.npressureslabs.and.m.ne.rank) then
(  132) 
(  133)     n = m*nzslab + 1
(  134)     call task_bsend_float(m,p(0,1-YES3D,n),nzslab*nxp1*nyp1, 33)
(  135)   endif
(  136) 
(  137) end do ! m
(  138) 
(  139) 
(  140) ! Fill slabs when receive buffers are full:
(  141) 
(  142) count = n_in
(  143) do while (count .gt. 0)
(  144)   do m = 1,n_in
(  145)    if(.not.flag(m)) then
(  146)    call task_test(reqs_in(m), flag(m), rf, tag)






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 5

(  147)         if(flag(m)) then 
(  148)           count=count-1
(  149)           call task_rank_to_index(rf,it,jt)  
(  150)           do k = 1,nzslab
(  151)             do j = 1,ny
(  152)               do i = 1,nx
(  153)                 f(i+it,j+jt,k) = bufp_subs(i,j,k,m)
(  154)               end do
(  155)             end do
(  156)           end do
(  157)         endif   
(  158)    endif
(  159)   end do
(  160) end do
(  161) 
(  162) 
(  163) !-------------------------------------------------
(  164) ! Perform Fourier transformation for a slab:
(  165) 
(  166) if(rank.lt.npressureslabs) then
(  167) 
(  168)  call fftfax_crm(nx_gl,ifaxi,trigxi)
(  169)  if(RUN3D) call fftfax_crm(ny_gl,ifaxj,trigxj)
(  170) 
(  171)  do k=1,nzslab
(  172) 
(  173)    call fft991_crm(f(1,1,k),work,trigxi,ifaxi,1,nx2,nx_gl,ny_gl,-1)
(  174) 
(  175)   if(RUN3D) then
(  176)      call fft991_crm(f(1,1,k),work,trigxj,ifaxj,nx2,1,ny_gl,nx_gl+1,-1)
(  177)   end if
(  178) 
(  179)  end do 
(  180) 
(  181) endif
(  182) 
(  183) 
(  184) 
(  185) ! Synchronize all slabs:
(  186) 
(  187) call task_barrier()
(  188) 
(  189) !-------------------------------------------------
(  190) !   Send Fourier coeffiecients back to subdomains:
(  191) 
(  192) ! Non-blocking receive first:
(  193) 
(  194) n_in = 0
(  195) do m = 0, nsubdomains-1
(  196) 
(  197)    call task_rank_to_index(m,it,jt)
(  198) 
(  199)    if(rank.lt.npressureslabs.and.m.eq.rank) then
(  200) 
(  201)      n = rank*nzslab
(  202)      do k = 1,nzslab
(  203)       do j = 1,nyp22-jwall
(  204)         do i = 1,nxp1-iwall






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 6

(  205)           ff(i,j,k+n) = f(i+it,j+jt,k) 
(  206)         end do
(  207)       end do
(  208)      end do 
(  209) 
(  210)    end if
(  211) 
(  212)    if(m.lt.npressureslabs-1.or.m.eq.npressureslabs-1 &
(  213)                             .and.rank.ge.npressureslabs) then
(  214) 
(  215)      n_in = n_in + 1
(  216)      call task_receive_float(buff_slabs(1,1,1,n_in), &
(  217)                                 nzslab*nxp1*nyp22,reqs_in(n_in))
(  218)      flag(n_in) = .false.    
(  219)    endif
(  220) 
(  221) end do ! m
(  222) 
(  223) ! Blocking send now:
(  224) 
(  225) do m = 0, nsubdomains-1
(  226) 
(  227)    call task_rank_to_index(m,it,jt)
(  228) 
(  229)    if(rank.lt.npressureslabs.and.m.ne.rank) then
(  230) 
(  231)      do k = 1,nzslab
(  232)       do j = 1,nyp22
(  233)        do i = 1,nxp1
(  234)          buff_subs(i,j,k,1) = f(i+it,j+jt,k)
(  235)        end do
(  236)       end do
(  237)      end do
(  238) 
(  239)      call task_bsend_float(m, buff_subs(1,1,1,1),nzslab*nxp1*nyp22,44)
(  240) 
(  241)    endif
(  242) 
(  243) end do ! m
(  244) 
(  245) 
(  246) 
(  247) ! Fill slabs when receive buffers are complete:
(  248) 
(  249) 
(  250) count = n_in
(  251) do while (count .gt. 0)
(  252)   do m = 1,n_in
(  253)    if(.not.flag(m)) then
(  254)      call task_test(reqs_in(m), flag(m), rf, tag)
(  255)         if(flag(m)) then 
(  256)           count=count-1
(  257)            n = rf*nzslab           
(  258)            do k = 1,nzslab
(  259)              do j=1,nyp22
(  260)                do i=1,nxp1
(  261)                  ff(i,j,k+n) = buff_slabs(i,j,k,m)
(  262)                end do






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 7

(  263)              end do
(  264)            end do
(  265)         endif   
(  266)    endif
(  267)   end do
(  268) end do
(  269) 
(  270) !-------------------------------------------------
(  271) !   Solve the tri-diagonal system for Fourier coeffiecients 
(  272) !   in the vertical for each subdomain:
(  273) 
(  274) do k=1,nzm
(  275)     a(k)=rhow(k)/(adz(k)*adzw(k)*dz*dz)
(  276)     c(k)=rhow(k+1)/(adz(k)*adzw(k+1)*dz*dz) 
(  277) end do 
(  278) 
(  279) call task_rank_to_index(rank,it,jt)
(  280) 
(  281) ddx2=1._8/(dx*dx)
(  282) ddy2=1._8/(dy*dy)
(  283) pii = acos(-1._8)
(  284) xnx=pii/nx_gl
(  285) xny=pii/ny_gl
(  286) do j=1,nyp22-jwall
(  287)    if(dowally) then
(  288)       jd=j+jt-1
(  289)       facty = 1.d0
(  290)    else
(  291)       jd=(j+jt-0.1)/2.
(  292)       facty = 2.d0
(  293)    end if
(  294)    xj=jd
(  295)    do i=1,nxp1-iwall
(  296)       if(dowallx) then
(  297)         id=i+it-1
(  298)         factx = 1.d0
(  299)       else
(  300)         id=(i+it-0.1)/2.
(  301)         factx = 2.d0
(  302)       end if
(  303)       fff(1:nzm) = ff(i,j,1:nzm)
(  304)       xi=id
(  305)       eign=(2._8*cos(factx*xnx*xi)-2._8)*ddx2+ & 
(  306)             (2._8*cos(facty*xny*xj)-2._8)*ddy2
(  307)       if(id+jd.eq.0) then               
(  308)          b=1._8/(eign*rho(1)-a(1)-c(1))
(  309)          alfa(1)=-c(1)*b
(  310)          beta(1)=fff(1)*b
(  311)       else
(  312)          b=1._8/(eign*rho(1)-c(1))
(  313)          alfa(1)=-c(1)*b
(  314)          beta(1)=fff(1)*b
(  315)       end if
(  316)       do k=2,nzm-1
(  317)         e=1._8/(eign*rho(k)-a(k)-c(k)+a(k)*alfa(k-1))
(  318)         alfa(k)=-c(k)*e
(  319)         beta(k)=(fff(k)-a(k)*beta(k-1))*e
(  320)       end do






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 8

(  321) 
(  322)       fff(nzm)=(fff(nzm)-a(nzm)*beta(nzm-1))/ &
(  323)         (eign*rho(nzm)-a(nzm)+a(nzm)*alfa(nzm-1))
(  324)   
(  325)       do k=nzm-1,1,-1
(  326)        fff(k)=alfa(k)*fff(k+1)+beta(k)
(  327)       end do
(  328)       ff(i,j,1:nzm) = fff(1:nzm)
(  329) 
(  330)    end do  
(  331) end do 
(  332) 
(  333) call task_barrier()
(  334) 
(  335) !----------------------------------------------------------------- 
(  336) !   Send the Fourier coefficient to the tasks performing
(  337) !   the inverse Fourier transformation:
(  338) 
(  339) ! Non-blocking receive first:
(  340) 
(  341) n_in = 0
(  342) do m = 0,nsubdomains-1
(  343) 
(  344)   if(rank.lt.npressureslabs.and.m.ne.nsubdomains-1) then
(  345)     n_in = n_in + 1
(  346)     call task_receive_float(buff_subs(1,1,1,n_in), &
(  347)                               nzslab*nxp1*nyp22, reqs_in(n_in))
(  348)     flag(n_in) = .false.    
(  349)   endif
(  350) 
(  351)   if(rank.lt.npressureslabs.and.m.eq.nsubdomains-1) then
(  352) 
(  353)     call task_rank_to_index(rank,it,jt)  
(  354)     n = rank*nzslab
(  355)     do k = 1,nzslab
(  356)      do j = 1,nyp22-jwall
(  357)        do i = 1,nxp1-iwall
(  358)          f(i+it,j+jt,k) = ff(i,j,k+n)
(  359)        end do
(  360)      end do
(  361)     end do
(  362) 
(  363)   endif
(  364) 
(  365) end do ! m
(  366) 
(  367) ! Blocking send now:
(  368) 
(  369) do m = 0,nsubdomains-1
(  370) 
(  371)   if(m.lt.npressureslabs.and.m.ne.rank) then
(  372)     n = m*nzslab+1
(  373)     call task_bsend_float(m,ff(1,1,n),nzslab*nxp1*nyp22, 33)
(  374)   endif
(  375) 
(  376) end do ! m
(  377) 
(  378) 






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 9

(  379) ! Fill slabs when receive buffers are full:
(  380) 
(  381) 
(  382) count = n_in
(  383) do while (count .gt. 0)
(  384)   do m = 1,n_in
(  385)    if(.not.flag(m)) then
(  386)      call task_test(reqs_in(m), flag(m), rf, tag)
(  387)         if(flag(m)) then 
(  388)           count=count-1
(  389)            call task_rank_to_index(rf,it,jt)  
(  390)            do k = 1,nzslab
(  391)             do j = 1,nyp22-jwall
(  392)              do i = 1,nxp1-iwall
(  393)                 f(i+it,j+jt,k) = buff_subs(i,j,k,m)
(  394)              end do
(  395)             end do
(  396)            end do
(  397)         endif   
(  398)    endif
(  399)   end do
(  400) end do
(  401) 
(  402) !-------------------------------------------------
(  403) !   Perform inverse Fourier transformation:
(  404) 
(  405) if(rank.lt.npressureslabs) then
(  406) 
(  407)  do k=1,nzslab
(  408) 
(  409)   if(RUN3D) then
(  410)      call fft991_crm(f(1,1,k),work,trigxj,ifaxj,nx2,1,ny_gl,nx_gl+1,+1)
(  411)   end if
(  412)  
(  413)    call fft991_crm(f(1,1,k),work,trigxi,ifaxi,1,nx2,nx_gl,ny_gl,+1)
(  414) 
(  415)  end do 
(  416) 
(  417) endif
(  418) 
(  419) call task_barrier()
(  420) 
(  421) !----------------------------------------------------------------- 
(  422) !   Fill the pressure field for each subdomain: 
(  423) 
(  424) do i=1,nx_gl
(  425)  iii(i)=i
(  426) end do
(  427) iii(0)=nx_gl
(  428) do j=1,ny_gl
(  429)  jjj(j)=j
(  430) end do
(  431) jjj(0)=ny_gl
(  432) 
(  433) ! Non-blocking receive first:
(  434) 
(  435) n_in = 0
(  436) do m = 0, nsubdomains-1






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 10

(  437) 
(  438)    call task_rank_to_index(m,it,jt)
(  439) 
(  440)    if(m.lt.npressureslabs-1.or.  &
(  441)       m.eq.npressureslabs-1.and.rank.ge.npressureslabs) then
(  442) 
(  443)      n_in = n_in + 1
(  444)      call task_receive_float(bufp_slabs(0,1-YES3D,1,n_in), &
(  445)                                 nzslab*nxp1*nyp1, reqs_in(n_in))
(  446)      flag(n_in) = .false.    
(  447) 
(  448)    endif
(  449) 
(  450)    if(rank.lt.npressureslabs.and.m.eq.rank) then
(  451) 
(  452)      n = rank*nzslab
(  453)      do k = 1,nzslab
(  454)       do j = 1-YES3D,ny
(  455)        jj=jjj(j+jt)
(  456)         do i = 0,nx
(  457)           ii=iii(i+it)
(  458)           p(i,j,k+n) = f(ii,jj,k) 
(  459)         end do
(  460)       end do
(  461)      end do 
(  462) 
(  463)    end if
(  464) 
(  465) end do ! m
(  466) 
(  467) 
(  468) ! Blocking send now:
(  469) 
(  470) do m = 0, nsubdomains-1
(  471) 
(  472)    call task_rank_to_index(m,it,jt)
(  473) 
(  474)    if(rank.lt.npressureslabs.and.m.ne.rank) then
(  475) 
(  476)      do k = 1,nzslab
(  477)       do j = 1-YES3D,ny
(  478)        jj=jjj(j+jt)
(  479)        do i = 0,nx
(  480)          ii=iii(i+it)
(  481)          bufp_subs(i,j,k,1) = f(ii,jj,k)
(  482)        end do
(  483)       end do
(  484)      end do
(  485) 
(  486)      call task_bsend_float(m, bufp_subs(0,1-YES3D,1,1), nzslab*nxp1*nyp1,44)
(  487) 
(  488)    endif
(  489) 
(  490) end do ! m
(  491) 
(  492) ! Fill the receive buffers:
(  493) 
(  494) count = n_in






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 11

(  495) do while (count .gt. 0)
(  496)   do m = 1,n_in
(  497)    if(.not.flag(m)) then
(  498)      call task_test(reqs_in(m), flag(m), rf, tag)
(  499)         if(flag(m)) then 
(  500)           count=count-1
(  501)            n = rf*nzslab           
(  502)            do k = 1,nzslab
(  503)             do j=1-YES3D,ny
(  504)              do i=0,nx
(  505)                p(i,j,k+n) = bufp_slabs(i,j,k,m)
(  506)              end do
(  507)             end do
(  508)            end do
(  509)         endif   
(  510)    endif
(  511)   end do
(  512) end do
(  513) 
(  514) 
(  515) call task_barrier()
(  516) 
(  517) !  Add pressure gradient term to the rhs of the momentum equation:
(  518) 
(  519) call press_grad()
(  520) 
(  521) end 
(  522) 
(  523) 
(  524) 


































NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 12

(    1) # 1 "pressure.F90"
(    1) ! Non-blocking receives before blocking sends
(    2) # 3 "pressure.F90"
(    3) subroutine pressure
(    4) # 5 "pressure.F90"
(    5) !************* LICENSE START *****************
(    6) !
(    7) ! Copyright 2015 Marat Khairoutdinov 
(    8) ! School of Marine & Atmospheric Sciences
(    9) ! Stony Brook University
(   10) ! This software is distributed under the terms of
(   11) ! the Apache License version 2.0.
(   12) !
(   13) !************** LICENSE END ******************
(   14) # 15 "pressure.F90"
(   15) !       Original pressure solver based on horizontal slabs
(   16) !       (C) 1998, 2002 Marat Khairoutdinov
(   17) !       Works only when the number of slabs is equal to the number of processors.
(   18) !       Therefore, the number of processors shouldn't exceed the number of levels nzm
(   19) !       Also, used for a 2D version 
(   20) !       For more processors for the given number of levels and 3D, use pressure_big
(   21) # 22 "pressure.F90"
(   22) use vars
(   23) use real_size
(   24) implicit none
(   25) # 27 "pressure.F90"
(   27) integer, parameter :: npressureslabs = nsubdomains
(   28) integer, parameter :: nzslab = max(1,nzm / npressureslabs)
(   29) integer, parameter :: nx2=nx_gl+2, ny2=ny_gl+2*YES3D
(   30) integer, parameter :: n3i=3*nx_gl/2+1,n3j=3*ny_gl/2+1
(   31) # 32 "pressure.F90"
(   32) real(RR) f(nx2,ny2,nzslab) ! global rhs and array for FTP coefficeients
(   33) real(RR) ff(nx+1,ny+2*YES3D,nzm)  ! local (subdomain's) version of f
(   34) real(RR) buff_slabs(nxp1,nyp2,nzslab,npressureslabs)
(   35) real(RR) buff_subs(nxp1,nyp2,nzslab,nsubdomains) 
(   36) real(RR) bufp_slabs(0:nx,1-YES3D:ny,nzslab,npressureslabs)  
(   37) real(RR) bufp_subs(0:nx,1-YES3D:ny,nzslab,nsubdomains)  
(   38) # 39 "pressure.F90"
(   39) real(RR) work(nx2,ny2),trigxi(n3i),trigxj(n3j) ! FFT stuff
(   40) integer ifaxj(100),ifaxi(100)
(   41) # 42 "pressure.F90"
(   42) real(8) a(nzm),b,c(nzm),e,fff(nzm)
(   43) real(8) xi,xj,xnx,xny,ddx2,ddy2,pii,factx,facty,eign
(   44) real(8) alfa(nzm-1),beta(nzm-1)
(   45) # 46 "pressure.F90"
(   46) integer reqs_in(nsubdomains)
(   47) integer i, j, k, id, jd, m, n, it, jt, ii, jj, tag, rf
(   48) integer nyp22, n_in, count
(   49) integer iii(0:nx_gl),jjj(0:ny_gl)
(   50) logical flag(nsubdomains)
(   51) integer iwall,jwall
(   52) # 53 "pressure.F90"
(   53) ! check if the grid size allows the computation:
(   54) # 55 "pressure.F90"
(   55) if(nsubdomains.gt.nzm) then
(   56)   if(masterproc) print*,'pressure_orig: nzm < nsubdomains. STOP'
(   57)   call task_abort
(   58) endif






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 13

(   59) # 60 "pressure.F90"
(   60) if(mod(nzm,npressureslabs).ne.0) then
(   61)   if(masterproc) print*,'pressure_orig: nzm/npressureslabs is not round number. STOP'
(   62)   call task_abort
(   63) endif
(   64) # 65 "pressure.F90"
(   65) !-----------------------------------------------------------------
(   66) # 67 "pressure.F90"
(   67) if(docolumn) return
(   68) # 69 "pressure.F90"
(   69) if(dowallx) then
(   70)   iwall=1
(   71) else
(   72)   iwall=0
(   73) end if
(   74) if(RUN2D) then  
(   75)   nyp22=1
(   76)   jwall=0
(   77) else
(   78)   nyp22=nyp2
(   79)   if(dowally) then
(   80)     jwall=2
(   81)   else
(   82)     jwall=0
(   83)   end if
(   84) endif
(   85) # 86 "pressure.F90"
(   86) !-----------------------------------------------------------------
(   87) !  Compute the r.h.s. of the Poisson equation for pressure
(   88) # 89 "pressure.F90"
(   89) call press_rhs()
(   90) # 92 "pressure.F90"
(   92) !----------------------------------------------------------------- 
(   93) !   Form the horizontal slabs of right-hand-sides of Poisson equation 
(   94) !   for the global domain. Request sending and receiving tasks.
(   95) # 96 "pressure.F90"
(   96) ! iNon-blocking receive first:
(   97) # 98 "pressure.F90"
(   98) n_in = 0
(   99) do m = 0,nsubdomains-1
(  100) # 101 "pressure.F90"
(  101)   if(rank.lt.npressureslabs.and.m.ne.nsubdomains-1) then
(  102) # 103 "pressure.F90"
(  103)     n_in = n_in + 1
(  104)     call task_receive_float(bufp_subs(0,1-YES3D,1,n_in), &
(  105)                            nzslab*nxp1*nyp1,reqs_in(n_in))
(  106)     flag(n_in) = .false.
(  107)  
(  108)   endif
(  109) # 110 "pressure.F90"
(  110)   if(rank.lt.npressureslabs.and.m.eq.nsubdomains-1) then
(  111) # 112 "pressure.F90"
(  112)     call task_rank_to_index(rank,it,jt)  
(  113)     n = rank*nzslab
(  114)     do k = 1,nzslab
(  115)      do j = 1,ny
(  116)        do i = 1,nx
(  117)          f(i+it,j+jt,k) = p(i,j,k+n)






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 14

(  118)        end do
(  119)      end do
(  120)     end do
(  121)   endif
(  122) # 123 "pressure.F90"
(  123) end do ! m
(  124) # 126 "pressure.F90"
(  126) ! Blocking send now:
(  127) # 129 "pressure.F90"
(  129) do m = 0,nsubdomains-1
(  130) # 131 "pressure.F90"
(  131)   if(m.lt.npressureslabs.and.m.ne.rank) then
(  132) # 133 "pressure.F90"
(  133)     n = m*nzslab + 1
(  134)     call task_bsend_float(m,p(0,1-YES3D,n),nzslab*nxp1*nyp1, 33)
(  135)   endif
(  136) # 137 "pressure.F90"
(  137) end do ! m
(  138) # 140 "pressure.F90"
(  140) ! Fill slabs when receive buffers are full:
(  141) # 142 "pressure.F90"
(  142) count = n_in
(  143) do while (count .gt. 0)
(  144)   do m = 1,n_in
(  145)    if(.not.flag(m)) then
(  146)    call task_test(reqs_in(m), flag(m), rf, tag)
(  147)         if(flag(m)) then 
(  148)           count=count-1
(  149)           call task_rank_to_index(rf,it,jt)  
(  150)           do k = 1,nzslab
(  151)             do j = 1,ny
(  152)               do i = 1,nx
(  153)                 f(i+it,j+jt,k) = bufp_subs(i,j,k,m)
(  154)               end do
(  155)             end do
(  156)           end do
(  157)         endif   
(  158)    endif
(  159)   end do
(  160) end do
(  161) # 163 "pressure.F90"
(  163) !-------------------------------------------------
(  164) ! Perform Fourier transformation for a slab:
(  165) # 166 "pressure.F90"
(  166) if(rank.lt.npressureslabs) then
(  167) # 168 "pressure.F90"
(  168)  call fftfax_crm(nx_gl,ifaxi,trigxi)
(  169)  if(RUN3D) call fftfax_crm(ny_gl,ifaxj,trigxj)
(  170) # 171 "pressure.F90"
(  171)  do k=1,nzslab
(  172) # 173 "pressure.F90"
(  173)    call fft991_crm(f(1,1,k),work,trigxi,ifaxi,1,nx2,nx_gl,ny_gl,-1)
(  174) # 175 "pressure.F90"
(  175)   if(RUN3D) then
(  176)      call fft991_crm(f(1,1,k),work,trigxj,ifaxj,nx2,1,ny_gl,nx_gl+1,-1)
(  177)   end if
(  178) # 179 "pressure.F90"
(  179)  end do 






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 15

(  180) # 181 "pressure.F90"
(  181) endif
(  182) # 185 "pressure.F90"
(  185) ! Synchronize all slabs:
(  186) # 187 "pressure.F90"
(  187) call task_barrier()
(  188) # 189 "pressure.F90"
(  189) !-------------------------------------------------
(  190) !   Send Fourier coeffiecients back to subdomains:
(  191) # 192 "pressure.F90"
(  192) ! Non-blocking receive first:
(  193) # 194 "pressure.F90"
(  194) n_in = 0
(  195) do m = 0, nsubdomains-1
(  196) # 197 "pressure.F90"
(  197)    call task_rank_to_index(m,it,jt)
(  198) # 199 "pressure.F90"
(  199)    if(rank.lt.npressureslabs.and.m.eq.rank) then
(  200) # 201 "pressure.F90"
(  201)      n = rank*nzslab
(  202)      do k = 1,nzslab
(  203)       do j = 1,nyp22-jwall
(  204)         do i = 1,nxp1-iwall
(  205)           ff(i,j,k+n) = f(i+it,j+jt,k) 
(  206)         end do
(  207)       end do
(  208)      end do 
(  209) # 210 "pressure.F90"
(  210)    end if
(  211) # 212 "pressure.F90"
(  212)    if(m.lt.npressureslabs-1.or.m.eq.npressureslabs-1 &
(  213)                             .and.rank.ge.npressureslabs) then
(  214) # 215 "pressure.F90"
(  215)      n_in = n_in + 1
(  216)      call task_receive_float(buff_slabs(1,1,1,n_in), &
(  217)                                 nzslab*nxp1*nyp22,reqs_in(n_in))
(  218)      flag(n_in) = .false.    
(  219)    endif
(  220) # 221 "pressure.F90"
(  221) end do ! m
(  222) # 223 "pressure.F90"
(  223) ! Blocking send now:
(  224) # 225 "pressure.F90"
(  225) do m = 0, nsubdomains-1
(  226) # 227 "pressure.F90"
(  227)    call task_rank_to_index(m,it,jt)
(  228) # 229 "pressure.F90"
(  229)    if(rank.lt.npressureslabs.and.m.ne.rank) then
(  230) # 231 "pressure.F90"
(  231)      do k = 1,nzslab
(  232)       do j = 1,nyp22
(  233)        do i = 1,nxp1
(  234)          buff_subs(i,j,k,1) = f(i+it,j+jt,k)
(  235)        end do
(  236)       end do
(  237)      end do
(  238) # 239 "pressure.F90"
(  239)      call task_bsend_float(m, buff_subs(1,1,1,1),nzslab*nxp1*nyp22,44)






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 16

(  240) # 241 "pressure.F90"
(  241)    endif
(  242) # 243 "pressure.F90"
(  243) end do ! m
(  244) # 247 "pressure.F90"
(  247) ! Fill slabs when receive buffers are complete:
(  248) # 250 "pressure.F90"
(  250) count = n_in
(  251) do while (count .gt. 0)
(  252)   do m = 1,n_in
(  253)    if(.not.flag(m)) then
(  254)      call task_test(reqs_in(m), flag(m), rf, tag)
(  255)         if(flag(m)) then 
(  256)           count=count-1
(  257)            n = rf*nzslab           
(  258)            do k = 1,nzslab
(  259)              do j=1,nyp22
(  260)                do i=1,nxp1
(  261)                  ff(i,j,k+n) = buff_slabs(i,j,k,m)
(  262)                end do
(  263)              end do
(  264)            end do
(  265)         endif   
(  266)    endif
(  267)   end do
(  268) end do
(  269) # 270 "pressure.F90"
(  270) !-------------------------------------------------
(  271) !   Solve the tri-diagonal system for Fourier coeffiecients 
(  272) !   in the vertical for each subdomain:
(  273) # 274 "pressure.F90"
(  274) do k=1,nzm
(  275)     a(k)=rhow(k)/(adz(k)*adzw(k)*dz*dz)
(  276)     c(k)=rhow(k+1)/(adz(k)*adzw(k+1)*dz*dz) 
(  277) end do 
(  278) # 279 "pressure.F90"
(  279) call task_rank_to_index(rank,it,jt)
(  280) # 281 "pressure.F90"
(  281) ddx2=1._8/(dx*dx)
(  282) ddy2=1._8/(dy*dy)
(  283) pii = acos(-1._8)
(  284) xnx=pii/nx_gl
(  285) xny=pii/ny_gl
(  286) do j=1,nyp22-jwall
(  287)    if(dowally) then
(  288)       jd=j+jt-1
(  289)       facty = 1.d0
(  290)    else
(  291)       jd=(j+jt-0.1)/2.
(  292)       facty = 2.d0
(  293)    end if
(  294)    xj=jd
(  295)    do i=1,nxp1-iwall
(  296)       if(dowallx) then
(  297)         id=i+it-1
(  298)         factx = 1.d0
(  299)       else
(  300)         id=(i+it-0.1)/2.






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 17

(  301)         factx = 2.d0
(  302)       end if
(  303)       fff(1:nzm) = ff(i,j,1:nzm)
(  304)       xi=id
(  305)       eign=(2._8*cos(factx*xnx*xi)-2._8)*ddx2+ & 
(  306)             (2._8*cos(facty*xny*xj)-2._8)*ddy2
(  307)       if(id+jd.eq.0) then               
(  308)          b=1._8/(eign*rho(1)-a(1)-c(1))
(  309)          alfa(1)=-c(1)*b
(  310)          beta(1)=fff(1)*b
(  311)       else
(  312)          b=1._8/(eign*rho(1)-c(1))
(  313)          alfa(1)=-c(1)*b
(  314)          beta(1)=fff(1)*b
(  315)       end if
(  316)       do k=2,nzm-1
(  317)         e=1._8/(eign*rho(k)-a(k)-c(k)+a(k)*alfa(k-1))
(  318)         alfa(k)=-c(k)*e
(  319)         beta(k)=(fff(k)-a(k)*beta(k-1))*e
(  320)       end do
(  321) # 322 "pressure.F90"
(  322)       fff(nzm)=(fff(nzm)-a(nzm)*beta(nzm-1))/ &
(  323)         (eign*rho(nzm)-a(nzm)+a(nzm)*alfa(nzm-1))
(  324)   
(  325)       do k=nzm-1,1,-1
(  326)        fff(k)=alfa(k)*fff(k+1)+beta(k)
(  327)       end do
(  328)       ff(i,j,1:nzm) = fff(1:nzm)
(  329) # 330 "pressure.F90"
(  330)    end do  
(  331) end do 
(  332) # 333 "pressure.F90"
(  333) call task_barrier()
(  334) # 335 "pressure.F90"
(  335) !----------------------------------------------------------------- 
(  336) !   Send the Fourier coefficient to the tasks performing
(  337) !   the inverse Fourier transformation:
(  338) # 339 "pressure.F90"
(  339) ! Non-blocking receive first:
(  340) # 341 "pressure.F90"
(  341) n_in = 0
(  342) do m = 0,nsubdomains-1
(  343) # 344 "pressure.F90"
(  344)   if(rank.lt.npressureslabs.and.m.ne.nsubdomains-1) then
(  345)     n_in = n_in + 1
(  346)     call task_receive_float(buff_subs(1,1,1,n_in), &
(  347)                               nzslab*nxp1*nyp22, reqs_in(n_in))
(  348)     flag(n_in) = .false.    
(  349)   endif
(  350) # 351 "pressure.F90"
(  351)   if(rank.lt.npressureslabs.and.m.eq.nsubdomains-1) then
(  352) # 353 "pressure.F90"
(  353)     call task_rank_to_index(rank,it,jt)  
(  354)     n = rank*nzslab
(  355)     do k = 1,nzslab
(  356)      do j = 1,nyp22-jwall
(  357)        do i = 1,nxp1-iwall
(  358)          f(i+it,j+jt,k) = ff(i,j,k+n)






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 18

(  359)        end do
(  360)      end do
(  361)     end do
(  362) # 363 "pressure.F90"
(  363)   endif
(  364) # 365 "pressure.F90"
(  365) end do ! m
(  366) # 367 "pressure.F90"
(  367) ! Blocking send now:
(  368) # 369 "pressure.F90"
(  369) do m = 0,nsubdomains-1
(  370) # 371 "pressure.F90"
(  371)   if(m.lt.npressureslabs.and.m.ne.rank) then
(  372)     n = m*nzslab+1
(  373)     call task_bsend_float(m,ff(1,1,n),nzslab*nxp1*nyp22, 33)
(  374)   endif
(  375) # 376 "pressure.F90"
(  376) end do ! m
(  377) # 379 "pressure.F90"
(  379) ! Fill slabs when receive buffers are full:
(  380) # 382 "pressure.F90"
(  382) count = n_in
(  383) do while (count .gt. 0)
(  384)   do m = 1,n_in
(  385)    if(.not.flag(m)) then
(  386)      call task_test(reqs_in(m), flag(m), rf, tag)
(  387)         if(flag(m)) then 
(  388)           count=count-1
(  389)            call task_rank_to_index(rf,it,jt)  
(  390)            do k = 1,nzslab
(  391)             do j = 1,nyp22-jwall
(  392)              do i = 1,nxp1-iwall
(  393)                 f(i+it,j+jt,k) = buff_subs(i,j,k,m)
(  394)              end do
(  395)             end do
(  396)            end do
(  397)         endif   
(  398)    endif
(  399)   end do
(  400) end do
(  401) # 402 "pressure.F90"
(  402) !-------------------------------------------------
(  403) !   Perform inverse Fourier transformation:
(  404) # 405 "pressure.F90"
(  405) if(rank.lt.npressureslabs) then
(  406) # 407 "pressure.F90"
(  407)  do k=1,nzslab
(  408) # 409 "pressure.F90"
(  409)   if(RUN3D) then
(  410)      call fft991_crm(f(1,1,k),work,trigxj,ifaxj,nx2,1,ny_gl,nx_gl+1,+1)
(  411)   end if
(  412)  
(  413)    call fft991_crm(f(1,1,k),work,trigxi,ifaxi,1,nx2,nx_gl,ny_gl,+1)
(  414) # 415 "pressure.F90"
(  415)  end do 
(  416) # 417 "pressure.F90"
(  417) endif
(  418) # 419 "pressure.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 19

(  419) call task_barrier()
(  420) # 421 "pressure.F90"
(  421) !----------------------------------------------------------------- 
(  422) !   Fill the pressure field for each subdomain: 
(  423) # 424 "pressure.F90"
(  424) do i=1,nx_gl
(  425)  iii(i)=i
(  426) end do
(  427) iii(0)=nx_gl
(  428) do j=1,ny_gl
(  429)  jjj(j)=j
(  430) end do
(  431) jjj(0)=ny_gl
(  432) # 433 "pressure.F90"
(  433) ! Non-blocking receive first:
(  434) # 435 "pressure.F90"
(  435) n_in = 0
(  436) do m = 0, nsubdomains-1
(  437) # 438 "pressure.F90"
(  438)    call task_rank_to_index(m,it,jt)
(  439) # 440 "pressure.F90"
(  440)    if(m.lt.npressureslabs-1.or.  &
(  441)       m.eq.npressureslabs-1.and.rank.ge.npressureslabs) then
(  442) # 443 "pressure.F90"
(  443)      n_in = n_in + 1
(  444)      call task_receive_float(bufp_slabs(0,1-YES3D,1,n_in), &
(  445)                                 nzslab*nxp1*nyp1, reqs_in(n_in))
(  446)      flag(n_in) = .false.    
(  447) # 448 "pressure.F90"
(  448)    endif
(  449) # 450 "pressure.F90"
(  450)    if(rank.lt.npressureslabs.and.m.eq.rank) then
(  451) # 452 "pressure.F90"
(  452)      n = rank*nzslab
(  453)      do k = 1,nzslab
(  454)       do j = 1-YES3D,ny
(  455)        jj=jjj(j+jt)
(  456)         do i = 0,nx
(  457)           ii=iii(i+it)
(  458)           p(i,j,k+n) = f(ii,jj,k) 
(  459)         end do
(  460)       end do
(  461)      end do 
(  462) # 463 "pressure.F90"
(  463)    end if
(  464) # 465 "pressure.F90"
(  465) end do ! m
(  466) # 468 "pressure.F90"
(  468) ! Blocking send now:
(  469) # 470 "pressure.F90"
(  470) do m = 0, nsubdomains-1
(  471) # 472 "pressure.F90"
(  472)    call task_rank_to_index(m,it,jt)
(  473) # 474 "pressure.F90"
(  474)    if(rank.lt.npressureslabs.and.m.ne.rank) then
(  475) # 476 "pressure.F90"
(  476)      do k = 1,nzslab
(  477)       do j = 1-YES3D,ny






NVFORTRAN (Version     23.1)          02/24/2023  13:57:38      page 20

(  478)        jj=jjj(j+jt)
(  479)        do i = 0,nx
(  480)          ii=iii(i+it)
(  481)          bufp_subs(i,j,k,1) = f(ii,jj,k)
(  482)        end do
(  483)       end do
(  484)      end do
(  485) # 486 "pressure.F90"
(  486)      call task_bsend_float(m, bufp_subs(0,1-YES3D,1,1), nzslab*nxp1*nyp1,44)
(  487) # 488 "pressure.F90"
(  488)    endif
(  489) # 490 "pressure.F90"
(  490) end do ! m
(  491) # 492 "pressure.F90"
(  492) ! Fill the receive buffers:
(  493) # 494 "pressure.F90"
(  494) count = n_in
(  495) do while (count .gt. 0)
(  496)   do m = 1,n_in
(  497)    if(.not.flag(m)) then
(  498)      call task_test(reqs_in(m), flag(m), rf, tag)
(  499)         if(flag(m)) then 
(  500)           count=count-1
(  501)            n = rf*nzslab           
(  502)            do k = 1,nzslab
(  503)             do j=1-YES3D,ny
(  504)              do i=0,nx
(  505)                p(i,j,k+n) = bufp_slabs(i,j,k,m)
(  506)              end do
(  507)             end do
(  508)            end do
(  509)         endif   
(  510)    endif
(  511)   end do
(  512) end do
(  513) # 515 "pressure.F90"
(  515) call task_barrier()
(  516) # 517 "pressure.F90"
(  517) !  Add pressure gradient term to the rhs of the momentum equation:
(  518) # 519 "pressure.F90"
(  519) call press_grad()
(  520) # 521 "pressure.F90"
(  521) end 
