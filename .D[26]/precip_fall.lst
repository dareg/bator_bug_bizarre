


NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: precip_fall.F90

(    1) subroutine precip_fall(qp, term_vel, hydro_type, omega, ind)
(    2) 
(    3) !************* LICENSE START *****************
(    4) !
(    5) ! Copyright 2015 Marat Khairoutdinov 
(    6) ! School of Marine & Atmospheric Sciences
(    7) ! Stony Brook University
(    8) ! This software is distributed under the terms of
(    9) ! the Apache License version 2.0.
(   10) !
(   11) !************** LICENSE END ******************
(   12) 
(   13) !     positively definite monotonic advection with non-oscillatory option
(   14) !     and gravitational sedimentation 
(   15) 
(   16) use vars
(   17) use params
(   18) use real_size
(   19) implicit none
(   20) 
(   21) 
(   22) 
(   23) real(RR) qp(dimx1_s:dimx2_s, dimy1_s:dimy2_s, nzm) ! falling hydrometeor
(   24) integer hydro_type   ! 0 - all liquid, 1 - all ice, 2 - mixed
(   25) real(RR) omega(nx,ny,nzm)   !  = 1: liquid, = 0: ice;  = 0-1: mixed : used only when hydro_type=2
(   26) integer ind
(   27) 
(   28) ! Terminal velocity fnction 
(   29) 
(   30) real(RR), external :: term_vel  ! terminal velocity function






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 3

(   31) 
(   32) 
(   33) ! Local:
(   34) 
(   35) real(RR) mx(nzm),mn(nzm), lfac(nz)
(   36) real(RR) www(nz),fz(nz)
(   37) real(RR) df(dimx1_s:dimx2_s, dimy1_s:dimy2_s, nzm)
(   38) real(RR) f0(nzm),df0(nzm)
(   39) real(RR) eps
(   40) integer i,j,k,kc,kb
(   41) logical nonos
(   42) 
(   43) real(RR) y,pp,pn
(   44) pp(y)= max(0.,y)
(   45) pn(y)=-min(0.,y)
(   46) 
(   47) real(RR) lat_heat, wmax
(   48) 
(   49) real(RR) wp(nzm), tmp_qp(nzm), irhoadz(nzm), iwmax(nzm), rhofac(nzm), prec_cfl
(   50) integer nprec, iprec
(   51) real(RR)  flagstat
(   52) 
(   53) !--------------------------------------------------------
(   54) 
(   55) ! call t_startf ('precip_fall') ! commented by Phani
(   56) 
(   57) eps = 1.e-10
(   58) nonos = .true.
(   59)   
(   60)  do k = 1,nzm
(   61)     rhofac(k) = sqrt(1.29/rho(k))
(   62)     irhoadz(k) = 1./(rho(k)*adz(k)) ! Useful factor
(   63)     kb = max(1,k-1)
(   64)     wmax       = dz*adz(kb)/dtn   ! Velocity equivalent to a cfl of 1.0.
(   65)     iwmax(k)   = 1./wmax
(   66)  end do
(   67) 
(   68) !  Add sedimentation of precipitation field to the vert. vel.
(   69) 
(   70) do j=1,ny
(   71)    do i=1,nx
(   72) 
(   73)       ! Compute precipitation velocity and flux column-by-column
(   74)       
(   75)       prec_cfl = 0.
(   76) 
(   77)       do k=1,nzm
(   78) 
(   79)          select case (hydro_type)
(   80)          case(0) 
(   81)             lfac(k) = fac_cond 
(   82)             flagstat = 1.
(   83)          case(1) 
(   84)             lfac(k) = fac_sub
(   85)             flagstat = 1.
(   86)          case(2)
(   87)             lfac(k) = fac_cond + (1-omega(i,j,k))*fac_fus
(   88)             flagstat = 1.






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 4

(   89)          case(3)
(   90)             lfac(k) = 0.
(   91)             flagstat = 0.
(   92)          case default
(   93)            if(masterproc) then
(   94)              print*, 'unknown hydro_type in precip_fall. exitting ...'
(   95)              call task_abort
(   96)            end if
(   97)          end select
(   98) 
(   99)          wp(k)=rhofac(k)*term_vel(i,j,k,ind)
(  100)          prec_cfl = max(prec_cfl,wp(k)*iwmax(k)) ! Keep column maximum CFL
(  101)          wp(k) = -wp(k)*rhow(k)*dtn/dz 
(  102) 
(  103)       end do  ! k
(  104) 
(  105)       fz(nz)=0.
(  106)       www(nz)=0.
(  107)       lfac(nz)=0
(  108) 
(  109)       ! If maximum CFL due to precipitation velocity is greater than 0.9,
(  110)       ! take more than one advection step to maintain stability.
(  111)       if (prec_cfl.gt.0.9) then
(  112)          nprec = CEILING(prec_cfl/0.9)
(  113)          do k = 1,nzm
(  114)             ! wp already includes factor of dt, so reduce it by a
(  115)             ! factor equal to the number of precipitation steps.
(  116)             wp(k) = wp(k)/float(nprec) 
(  117)          end do
(  118)       else
(  119)          nprec = 1
(  120)       end if
(  121) 
(  122)       do iprec = 1,nprec
(  123) 
(  124)          do k = 1,nzm
(  125)             tmp_qp(k) = qp(i,j,k) ! Temporary array for qp in this column
(  126)          end do
(  127) 
(  128)          !-----------------------------------------
(  129) 
(  130)          if(nonos) then
(  131) 
(  132)             do k=1,nzm
(  133)                kc=min(nzm,k+1)
(  134)                kb=max(1,k-1)
(  135)                mx(k)=max(tmp_qp(kb),tmp_qp(kc),tmp_qp(k))
(  136)                mn(k)=min(tmp_qp(kb),tmp_qp(kc),tmp_qp(k))
(  137)             end do
(  138) 
(  139)          end if  ! nonos
(  140) 
(  141)          !  loop over iterations
(  142) 
(  143)          do k=1,nzm
(  144)             ! Define upwind precipitation flux
(  145)             fz(k)=tmp_qp(k)*wp(k)
(  146)          end do






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 5

(  147) 
(  148)          do k=1,nzm
(  149)             kc=k+1
(  150)             tmp_qp(k)=tmp_qp(k)-(fz(kc)-fz(k))*irhoadz(k) !Update temporary qp
(  151)          end do
(  152) 
(  153)          do k=1,nzm
(  154)             ! Also, compute anti-diffusive correction to previous
(  155)             ! (upwind) approximation to the flux
(  156)             kb=max(1,k-1)
(  157)             ! The precipitation velocity is a cell-centered quantity,
(  158)             ! since it is computed from the cell-centered
(  159)             ! precipitation mass fraction.  Therefore, a reformulated
(  160)             ! anti-diffusive flux is used here which accounts for
(  161)             ! this and results in reduced numerical diffusion.
(  162)             www(k) = 0.5*(1.+wp(k)*irhoadz(k)) &
(  163)                  *(tmp_qp(kb)*wp(kb) - tmp_qp(k)*wp(k)) ! works for wp(k)<0
(  164)          end do
(  165) 
(  166)          !---------- non-osscilatory option ---------------
(  167) 
(  168)          if(nonos) then
(  169) 
(  170)             do k=1,nzm
(  171)                kc=min(nzm,k+1)
(  172)                kb=max(1,k-1)
(  173)                mx(k)=max(tmp_qp(kb),tmp_qp(kc),tmp_qp(k),mx(k))
(  174)                mn(k)=min(tmp_qp(kb),tmp_qp(kc),tmp_qp(k),mn(k))
(  175)             end do
(  176) 
(  177)             do k=1,nzm
(  178)                kc=min(nzm,k+1)
(  179)                mx(k)=rho(k)*adz(k)*(mx(k)-tmp_qp(k))/(pn(www(kc)) + pp(www(k))+eps)
(  180)                mn(k)=rho(k)*adz(k)*(tmp_qp(k)-mn(k))/(pp(www(kc)) + pn(www(k))+eps)
(  181)             end do
(  182) 
(  183)             do k=1,nzm
(  184)                kb=max(1,k-1)
(  185)                ! Add limited flux correction to fz(k).
(  186)                fz(k) = fz(k) &                        ! Upwind flux
(  187)                     + pp(www(k))*min(1.,mx(k), mn(kb)) &
(  188)                     - pn(www(k))*min(1.,mx(kb),mn(k)) ! Anti-diffusive flux
(  189)             end do
(  190) 
(  191)          endif ! nonos
(  192) 
(  193)          ! Update precipitation mass fraction and liquid-ice static
(  194)          ! energy using precipitation fluxes computed in this column.
(  195)          do k=1,nzm
(  196)             kc=k+1
(  197)             ! Update precipitation mass fraction.
(  198)             ! Note that fz is the total flux, including both the
(  199)             ! upwind flux and the anti-diffusive correction.
(  200)             qp(i,j,k)=qp(i,j,k)-(fz(kc)-fz(k))*irhoadz(k)
(  201)             qpfall(k)=qpfall(k)-(fz(kc)-fz(k))*irhoadz(k)*flagstat  ! For qp budget
(  202)             lat_heat = -(lfac(kc)*fz(kc)-lfac(k)*fz(k))*irhoadz(k)
(  203)             t(i,j,k)=t(i,j,k)-lat_heat
(  204)             tlat(k)=tlat(k)-lat_heat            ! For energy budget






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 6

(  205)             precflux(k) = precflux(k) - fz(k)*flagstat   ! For statistics
(  206)          end do
(  207)          precsfc(i,j) = precsfc(i,j) - fz(1)*flagstat ! For statistics
(  208)          precssfc(i,j) = precssfc(i,j) - fz(1)*(1.-omega(i,j,1))*flagstat ! For statistics
(  209)          prec_xy(i,j) = prec_xy(i,j) - fz(1)*flagstat ! For 2D output
(  210) 
(  211)          if (iprec.lt.nprec) then
(  212) 
(  213)             ! Re-compute precipitation velocity using new value of qp.
(  214)             do k=1,nzm
(  215)                   wp(k) = rhofac(k)*term_vel(i,j,k,ind)
(  216)                   ! Decrease precipitation velocity by factor of nprec
(  217)                   wp(k) = -wp(k)*rhow(k)*dtn/dz/float(nprec)
(  218)                   ! Note: Don't bother checking CFL condition at each
(  219)                   ! substep since it's unlikely that the CFL will
(  220)                   ! increase very much between substeps when using
(  221)                   ! monotonic advection schemes.
(  222)             end do
(  223) 
(  224)             fz(nz)=0.
(  225)             www(nz)=0.
(  226)             lfac(nz)=0.
(  227) 
(  228)          end if
(  229) 
(  230)       end do !iprec
(  231) 
(  232)   end do
(  233) end do
(  234) 
(  235) 
(  236) ! call t_stopf ('precip_fall') ! commented by Phani
(  237) 
(  238) end subroutine precip_fall
(  239) 
(  240) 




























NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 7

(    1) # 1 "precip_fall.F90"
(    1) subroutine precip_fall(qp, term_vel, hydro_type, omega, ind)
(    2) # 3 "precip_fall.F90"
(    3) !************* LICENSE START *****************
(    4) !
(    5) ! Copyright 2015 Marat Khairoutdinov 
(    6) ! School of Marine & Atmospheric Sciences
(    7) ! Stony Brook University
(    8) ! This software is distributed under the terms of
(    9) ! the Apache License version 2.0.
(   10) !
(   11) !************** LICENSE END ******************
(   12) # 13 "precip_fall.F90"
(   13) !     positively definite monotonic advection with non-oscillatory option
(   14) !     and gravitational sedimentation 
(   15) # 16 "precip_fall.F90"
(   16) use vars
(   17) use params
(   18) use real_size
(   19) implicit none
(   20) # 23 "precip_fall.F90"
(   23) real(RR) qp(dimx1_s:dimx2_s, dimy1_s:dimy2_s, nzm) ! falling hydrometeor
(   24) integer hydro_type   ! 0 - all liquid, 1 - all ice, 2 - mixed
(   25) real(RR) omega(nx,ny,nzm)   !  = 1: liquid, = 0: ice;  = 0-1: mixed : used only when hydro_type=2
(   26) integer ind
(   27) # 28 "precip_fall.F90"
(   28) ! Terminal velocity fnction 
(   29) # 30 "precip_fall.F90"
(   30) real(RR), external :: term_vel  ! terminal velocity function
(   31) # 33 "precip_fall.F90"
(   33) ! Local:
(   34) # 35 "precip_fall.F90"
(   35) real(RR) mx(nzm),mn(nzm), lfac(nz)
(   36) real(RR) www(nz),fz(nz)
(   37) real(RR) df(dimx1_s:dimx2_s, dimy1_s:dimy2_s, nzm)
(   38) real(RR) f0(nzm),df0(nzm)
(   39) real(RR) eps
(   40) integer i,j,k,kc,kb
(   41) logical nonos
(   42) # 43 "precip_fall.F90"
(   43) real(RR) y,pp,pn
(   44) pp(y)= max(0.,y)
(   45) pn(y)=-min(0.,y)
(   46) # 47 "precip_fall.F90"
(   47) real(RR) lat_heat, wmax
(   48) # 49 "precip_fall.F90"
(   49) real(RR) wp(nzm), tmp_qp(nzm), irhoadz(nzm), iwmax(nzm), rhofac(nzm), prec_cfl
(   50) integer nprec, iprec
(   51) real(RR)  flagstat
(   52) # 53 "precip_fall.F90"
(   53) !--------------------------------------------------------
(   54) # 55 "precip_fall.F90"
(   55) ! call t_startf ('precip_fall') ! commented by Phani
(   56) # 57 "precip_fall.F90"
(   57) eps = 1.e-10
(   58) nonos = .true.
(   59)   
(   60)  do k = 1,nzm






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 8

(   61)     rhofac(k) = sqrt(1.29/rho(k))
(   62)     irhoadz(k) = 1./(rho(k)*adz(k)) ! Useful factor
(   63)     kb = max(1,k-1)
(   64)     wmax       = dz*adz(kb)/dtn   ! Velocity equivalent to a cfl of 1.0.
(   65)     iwmax(k)   = 1./wmax
(   66)  end do
(   67) # 68 "precip_fall.F90"
(   68) !  Add sedimentation of precipitation field to the vert. vel.
(   69) # 70 "precip_fall.F90"
(   70) do j=1,ny
(   71)    do i=1,nx
(   72) # 73 "precip_fall.F90"
(   73)       ! Compute precipitation velocity and flux column-by-column
(   74)       
(   75)       prec_cfl = 0.
(   76) # 77 "precip_fall.F90"
(   77)       do k=1,nzm
(   78) # 79 "precip_fall.F90"
(   79)          select case (hydro_type)
(   80)          case(0) 
(   81)             lfac(k) = fac_cond 
(   82)             flagstat = 1.
(   83)          case(1) 
(   84)             lfac(k) = fac_sub
(   85)             flagstat = 1.
(   86)          case(2)
(   87)             lfac(k) = fac_cond + (1-omega(i,j,k))*fac_fus
(   88)             flagstat = 1.
(   89)          case(3)
(   90)             lfac(k) = 0.
(   91)             flagstat = 0.
(   92)          case default
(   93)            if(masterproc) then
(   94)              print*, 'unknown hydro_type in precip_fall. exitting ...'
(   95)              call task_abort
(   96)            end if
(   97)          end select
(   98) # 99 "precip_fall.F90"
(   99)          wp(k)=rhofac(k)*term_vel(i,j,k,ind)
(  100)          prec_cfl = max(prec_cfl,wp(k)*iwmax(k)) ! Keep column maximum CFL
(  101)          wp(k) = -wp(k)*rhow(k)*dtn/dz 
(  102) # 103 "precip_fall.F90"
(  103)       end do  ! k
(  104) # 105 "precip_fall.F90"
(  105)       fz(nz)=0.
(  106)       www(nz)=0.
(  107)       lfac(nz)=0
(  108) # 109 "precip_fall.F90"
(  109)       ! If maximum CFL due to precipitation velocity is greater than 0.9,
(  110)       ! take more than one advection step to maintain stability.
(  111)       if (prec_cfl.gt.0.9) then
(  112)          nprec = CEILING(prec_cfl/0.9)
(  113)          do k = 1,nzm
(  114)             ! wp already includes factor of dt, so reduce it by a
(  115)             ! factor equal to the number of precipitation steps.
(  116)             wp(k) = wp(k)/float(nprec) 
(  117)          end do
(  118)       else






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 9

(  119)          nprec = 1
(  120)       end if
(  121) # 122 "precip_fall.F90"
(  122)       do iprec = 1,nprec
(  123) # 124 "precip_fall.F90"
(  124)          do k = 1,nzm
(  125)             tmp_qp(k) = qp(i,j,k) ! Temporary array for qp in this column
(  126)          end do
(  127) # 128 "precip_fall.F90"
(  128)          !-----------------------------------------
(  129) # 130 "precip_fall.F90"
(  130)          if(nonos) then
(  131) # 132 "precip_fall.F90"
(  132)             do k=1,nzm
(  133)                kc=min(nzm,k+1)
(  134)                kb=max(1,k-1)
(  135)                mx(k)=max(tmp_qp(kb),tmp_qp(kc),tmp_qp(k))
(  136)                mn(k)=min(tmp_qp(kb),tmp_qp(kc),tmp_qp(k))
(  137)             end do
(  138) # 139 "precip_fall.F90"
(  139)          end if  ! nonos
(  140) # 141 "precip_fall.F90"
(  141)          !  loop over iterations
(  142) # 143 "precip_fall.F90"
(  143)          do k=1,nzm
(  144)             ! Define upwind precipitation flux
(  145)             fz(k)=tmp_qp(k)*wp(k)
(  146)          end do
(  147) # 148 "precip_fall.F90"
(  148)          do k=1,nzm
(  149)             kc=k+1
(  150)             tmp_qp(k)=tmp_qp(k)-(fz(kc)-fz(k))*irhoadz(k) !Update temporary qp
(  151)          end do
(  152) # 153 "precip_fall.F90"
(  153)          do k=1,nzm
(  154)             ! Also, compute anti-diffusive correction to previous
(  155)             ! (upwind) approximation to the flux
(  156)             kb=max(1,k-1)
(  157)             ! The precipitation velocity is a cell-centered quantity,
(  158)             ! since it is computed from the cell-centered
(  159)             ! precipitation mass fraction.  Therefore, a reformulated
(  160)             ! anti-diffusive flux is used here which accounts for
(  161)             ! this and results in reduced numerical diffusion.
(  162)             www(k) = 0.5*(1.+wp(k)*irhoadz(k)) &
(  163)                  *(tmp_qp(kb)*wp(kb) - tmp_qp(k)*wp(k)) ! works for wp(k)<0
(  164)          end do
(  165) # 166 "precip_fall.F90"
(  166)          !---------- non-osscilatory option ---------------
(  167) # 168 "precip_fall.F90"
(  168)          if(nonos) then
(  169) # 170 "precip_fall.F90"
(  170)             do k=1,nzm
(  171)                kc=min(nzm,k+1)
(  172)                kb=max(1,k-1)
(  173)                mx(k)=max(tmp_qp(kb),tmp_qp(kc),tmp_qp(k),mx(k))
(  174)                mn(k)=min(tmp_qp(kb),tmp_qp(kc),tmp_qp(k),mn(k))
(  175)             end do
(  176) # 177 "precip_fall.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 10

(  177)             do k=1,nzm
(  178)                kc=min(nzm,k+1)
(  179)                mx(k)=rho(k)*adz(k)*(mx(k)-tmp_qp(k))/(pn(www(kc)) + pp(www(k))+eps)
(  180)                mn(k)=rho(k)*adz(k)*(tmp_qp(k)-mn(k))/(pp(www(kc)) + pn(www(k))+eps)
(  181)             end do
(  182) # 183 "precip_fall.F90"
(  183)             do k=1,nzm
(  184)                kb=max(1,k-1)
(  185)                ! Add limited flux correction to fz(k).
(  186)                fz(k) = fz(k) &                        ! Upwind flux
(  187)                     + pp(www(k))*min(1.,mx(k), mn(kb)) &
(  188)                     - pn(www(k))*min(1.,mx(kb),mn(k)) ! Anti-diffusive flux
(  189)             end do
(  190) # 191 "precip_fall.F90"
(  191)          endif ! nonos
(  192) # 193 "precip_fall.F90"
(  193)          ! Update precipitation mass fraction and liquid-ice static
(  194)          ! energy using precipitation fluxes computed in this column.
(  195)          do k=1,nzm
(  196)             kc=k+1
(  197)             ! Update precipitation mass fraction.
(  198)             ! Note that fz is the total flux, including both the
(  199)             ! upwind flux and the anti-diffusive correction.
(  200)             qp(i,j,k)=qp(i,j,k)-(fz(kc)-fz(k))*irhoadz(k)
(  201)             qpfall(k)=qpfall(k)-(fz(kc)-fz(k))*irhoadz(k)*flagstat  ! For qp budget
(  202)             lat_heat = -(lfac(kc)*fz(kc)-lfac(k)*fz(k))*irhoadz(k)
(  203)             t(i,j,k)=t(i,j,k)-lat_heat
(  204)             tlat(k)=tlat(k)-lat_heat            ! For energy budget
(  205)             precflux(k) = precflux(k) - fz(k)*flagstat   ! For statistics
(  206)          end do
(  207)          precsfc(i,j) = precsfc(i,j) - fz(1)*flagstat ! For statistics
(  208)          precssfc(i,j) = precssfc(i,j) - fz(1)*(1.-omega(i,j,1))*flagstat ! For statistics
(  209)          prec_xy(i,j) = prec_xy(i,j) - fz(1)*flagstat ! For 2D output
(  210) # 211 "precip_fall.F90"
(  211)          if (iprec.lt.nprec) then
(  212) # 213 "precip_fall.F90"
(  213)             ! Re-compute precipitation velocity using new value of qp.
(  214)             do k=1,nzm
(  215)                   wp(k) = rhofac(k)*term_vel(i,j,k,ind)
(  216)                   ! Decrease precipitation velocity by factor of nprec
(  217)                   wp(k) = -wp(k)*rhow(k)*dtn/dz/float(nprec)
(  218)                   ! Note: Don't bother checking CFL condition at each
(  219)                   ! substep since it's unlikely that the CFL will
(  220)                   ! increase very much between substeps when using
(  221)                   ! monotonic advection schemes.
(  222)             end do
(  223) # 224 "precip_fall.F90"
(  224)             fz(nz)=0.
(  225)             www(nz)=0.
(  226)             lfac(nz)=0.
(  227) # 228 "precip_fall.F90"
(  228)          end if
(  229) # 230 "precip_fall.F90"
(  230)       end do !iprec
(  231) # 232 "precip_fall.F90"
(  232)   end do
(  233) end do
(  234) # 236 "precip_fall.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:57:37      page 11

(  236) ! call t_stopf ('precip_fall') ! commented by Phani
(  237) # 238 "precip_fall.F90"
(  238) end subroutine precip_fall
