


NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: Buta.F

(    1)       PROGRAM BUTAMAIN
(    2)       USE PARKIND1  ,ONLY : JPRB
(    3)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(    4) !
(    5)       IMPLICIT NONE
(    6) !
(    7)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(    8)       IF (LHOOK) CALL DR_HOOK('BUTAMAIN',0,ZHOOK_HANDLE)
(    9)       CALL BUTA
(   10)       IF (LHOOK) CALL DR_HOOK('BUTAMAIN',1,ZHOOK_HANDLE)
(   11)       ENDPROGRAM BUTAMAIN
(   12) 
(   13) ! Library:bufr $RCSfile: BUTA.f,v $, $Revision: 1.2 $
(   14) ! checked in by $Author: RayMcGrath $ at $Date: 2003/04/03 07:59:47 $
(   15) ! $State: Exp $, $Locker:  $
(   16) ! $Log: BUTA.f,v $
(   17) ! Revision 1.2  2003/04/03 07:59:47  RayMcGrath
(   18) ! (HIRLAM version 6.1.0)
(   19) ! Trap out of range indices for NTABP
(   20) !
(   21) ! Revision 1.1  1999/02/15 08:22:31  GCats
(   22) ! Created anew, HIRLAM version 4.3.5
(   23) !
(   24) !<A NAME="header">
(   25)       SUBROUTINE BUTA
(   26) !
(   27) !**** *TABLES*
(   28) !
(   29) !
(   30) !     PURPOSE.






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 3

(   31) !     --------
(   32) !       CREATES BINARY BUFR TABLES USED BY BUFR EXPANSION
(   33) !       OR BUFR ENCODING SOFTWARE.
(   34) !       THE NAMES OF THE BUFR TEXT TABLES ARE PASSED TO THE PROGRAM
(   35) !       VIA ONE OR MORE LINES OF INPUT, EACH LINE CONTAINING A LIST
(   36) !       OF FILE NAMES (WHITE SPACE SEPARATED).
(   37) !
(   38) !
(   39) !       EACH NAME IS ASSUMED TO BE IN THE STYLE "NAME.EXT"
(   40) !       WHERE "NAME" IS CODED NORMALLY AS FOLLOWS:
(   41) !
(   42) !       [TYPE][SUBCENTRE][MAINCENTRE][VER MASTER TABLE][VER LOCAL TABLE]
(   43) !       [1   ][234      ][567       ][89              ][1011 ]
(   44) !
(   45) !       TYPE='B' OR 'D' ('C' NO LONGER USED)
(   46) !
(   47) !       HOWEVER OLDER STYLE TABLES STORED ONLY 2 DIGITS FOR THE SUBCENTR
(   48) !       AND THE LAYOUT OF THE ASCII TABLES DIFFERED FROM THE CURRENT
(   49) !       CODING: THESE ARE CORRECTLY PROCESSED HERE.
(   50) !
(   51) !
(   52) !       "EXT" IS TXT OR ASC ETC (IT IS NOT USED). FILE NAMES NOT IN THIS
(   53) !        FORMAT ARE SKIPPED.
(   54) !
(   55) !       INPUT FILE EXAMPLE: B0000980201.TXT (OLD STYLE: B000980201.TXT)
(   56) !
(   57) !       FOR EACH INPUT FILE A CORRESPONDING BINARY BUFR TABLE IS WRITTEN
(   58) !       (NAME WITHOUT EXTENSION) IN THE *LOCAL* DIRECTORY (ANY
(   59) !       PATHNAME IN THE INPUT FILE NAME IS STRIPPED OUT).
(   60) !       EXAMPLE:
(   61) !       B0000980201.TXT -> B0000980201
(   62) !
(   63) !**   INTERFACE.
(   64) !     ----------
(   65) !          NONE.
(   66) !
(   67) !
(   68) !     *METHOD.
(   69) !      -------
(   70) !          NONE.
(   71) !
(   72) !
(   73) !     EXTERNALS.
(   74) !     ----------
(   75) !          NONE.
(   76) !
(   77) !
(   78) !
(   79) !
(   80) !     REFERENCE.
(   81) !     ----------
(   82) !
(   83) !          BINARY UNIVERSAL FORM FOR DATA REPRESENTATION, FM 94 BUFR.
(   84) !
(   85) !          J.K.GIBSON AND M.DRAGOSAVAC,1987: DECODING DATA
(   86) !          REPRESENTATION FM 94 BUFR,TECHNICAL MEMORANDUM NO.
(   87) !
(   88) !          J.K.GIBSON,1986:EMOS 2 - STANDARDS FOR SOFTWARE DEVELOPMENT






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 4

(   89) !          AND MAINTANANCE ,TECHICAL MEMORANDUM NO.       ECMWF.
(   90) !
(   91) !
(   92) !     AUTHOR.
(   93) !     -------
(   94) !
(   95) !     RMCGRATH DEC 1998. BASED ON SIMILAR SOFTWARE BY
(   96) !          M. DRAGOSAVAC       (ECMWF)
(   97) !
(   98) !
(   99) !
(  100)       USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  101)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  102) !      IMPLICIT LOGICAL(L,O,G), CHARACTER*8(C,H,Y)
(  103)       IMPLICIT NONE
(  104) !
(  105)       INTEGER(KIND=JPIM) :: I,IERR,N,NPATH
(  106)       LOGICAL :: LNEW
(  107) !
(  108)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  109) !
(  110)       CHARACTER(LEN=1000) :: YBIG
(  111)       CHARACTER(LEN=100)  :: YINPUT,YASC,YBIN,YPATH
(  112) !
(  113) !     ------------------------------------------------------------------
(  114) !<A NAME="s1.">
(  115) !*          1.   CREATE BINARY BUFR TABLES BY LOOPING ON INPUT FILES.
(  116) !                __________________________
(  117)       IF (LHOOK) CALL DR_HOOK('BUTA',0,ZHOOK_HANDLE)
(  118)  100  CONTINUE
(  119) !
(  120)       READ(5,FMT=1000,END=999,ERR=9999)YBIG
(  121) 1000  FORMAT(A)
(  122) 1     CONTINUE
(  123)       IF(YBIG.EQ.' ')THEN
(  124)        GO TO 100
(  125)       ELSE IF(YBIG(1:1).NE.' ')THEN
(  126)        GO TO 3
(  127)       ENDIF
(  128)       DO 2 I=1,1000
(  129)        IF(YBIG(I:I).NE.' ')THEN
(  130)        YBIG=YBIG(I:)
(  131)        GO TO 3
(  132)        ENDIF
(  133) 2     CONTINUE
(  134)       GO TO 100
(  135) 3     CONTINUE
(  136)       N=INDEX(YBIG,' ')
(  137)       IF(N.GT.0)THEN
(  138)        YINPUT=YBIG(1:N-1)
(  139)        YBIG=YBIG(N:)
(  140)       ELSE
(  141)        YINPUT=YBIG
(  142)        YBIG=' '
(  143)       ENDIF
(  144) 
(  145)       YASC=YINPUT
(  146)        write(6,*)YINPUT






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 5

(  147) !<A NAME="n10">
(  148) ! STRIP OFF ANY PATH - NOT KEPT
(  149) !
(  150)       NPATH=0
(  151)       DO 10 I=1,100
(  152)       IF(YINPUT(I:I).EQ.'/')NPATH=I
(  153) 10    CONTINUE
(  154) !
(  155)       IF(NPATH.GT.0)THEN
(  156)        YPATH=YINPUT(1:NPATH)
(  157)        YINPUT=YINPUT(NPATH+1:)
(  158)       ELSE
(  159)        YPATH=' '
(  160)       ENDIF
(  161) !
(  162)       WRITE(6,*)YINPUT,YPATH
(  163)       N=INDEX(YINPUT,'.')
(  164)       IF(N.EQ.12)THEN
(  165)          LNEW=.TRUE.
(  166)       ELSE IF(N.EQ.11)THEN
(  167)          LNEW=.FALSE.
(  168)       ELSE
(  169)        WRITE(6,*)' BAD ASCII TABLE FORMAT: ',YINPUT
(  170)        WRITE(6,*)' SKIPPED...'
(  171)        GO TO 1
(  172)       ENDIF
(  173)        YBIN=YINPUT(1:N-1)
(  174)        IF(YPATH.NE.' ')YBIN=YPATH(1:NPATH)//YINPUT(1:N-1)
(  175) !
(  176) !
(  177)        IERR=0
(  178)        IF(YINPUT(1:1).EQ.'B'.OR.YINPUT(1:1).EQ.'b')THEN
(  179)           CALL BTABLE(YASC,YBIN,LNEW,IERR)
(  180)        ELSE IF(YINPUT(1:1).EQ.'C'.OR.YINPUT(1:1).EQ.'c')THEN
(  181)           CALL CTABLE(YASC,YBIN,LNEW,IERR)
(  182)        ELSE IF(YINPUT(1:1).EQ.'D'.OR.YINPUT(1:1).EQ.'d')THEN
(  183)           CALL DTABLE(YASC,YBIN,LNEW,IERR)
(  184)        ELSE
(  185)           WRITE(6,*)' UNKNOWN TABLE (MUST BE B,C OR D): ',YINPUT(1:1)
(  186)           GO TO 100
(  187)        ENDIF
(  188)             IF(IERR.NE.0) THEN
(  189)              WRITE(6,*)' BINARY BUFR TABLE NOT CREATED: ',YBIN
(  190)              GO TO 100
(  191)             ENDIF
(  192) !<A NAME="n20">
(  193) ! GET NEXT TABLE
(  194) !
(  195)        GO TO 1
(  196) !
(  197) 9999    CONTINUE
(  198)         WRITE(6,*)' CORRUPT INPUT TO BUFR CREATION TABLES'
(  199) 999     CONTINUE
(  200)        IF (LHOOK) CALL DR_HOOK('BUTA',1,ZHOOK_HANDLE)
(  201)        RETURN
(  202) 
(  203)       IF (LHOOK) CALL DR_HOOK('BUTA',1,ZHOOK_HANDLE)
(  204)       ENDSUBROUTINE BUTA






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 6

(  205) !
(  206) !
(  207)       SUBROUTINE BTABLE(YASC,YNAME,LNEW,KERR)
(  208) !<A NAME="n30">
(  209) !**** *BTABLE*
(  210) !
(  211) !
(  212) !     PURPOSE.
(  213) !     --------
(  214) !          CREATE BUFR TABLE B IN BINARY FORM.
(  215) !
(  216) !**   INTERFACE.
(  217) !     ----------
(  218) !          NONE.
(  219) !
(  220) !
(  221) !     *METHOD.
(  222) !      -------
(  223) !          NONE.
(  224) !
(  225) !
(  226) !     EXTERNALS.
(  227) !     ----------
(  228) !          NONE.
(  229) !
(  230) !
(  231) !
(  232) !
(  233) !     REFERENCE.
(  234) !     ----------
(  235) !
(  236) !          BINARY UNIVERSAL FORM FOR DATA REPRESENTATION, FM 94 BUFR.
(  237) !
(  238) !          J.K.GIBSON AND M.DRAGOSAVAC,1987: DECODING DATA
(  239) !          REPRESENTATION FM 94 BUFR,TECHNICAL MEMORANDUM NO.
(  240) !
(  241) !          J.K.GIBSON,1986:EMOS 2 - STANDARDS FOR SOFTWARE DEVELOPMENT
(  242) !          AND MAINTANANCE ,TECHICAL MEMORANDUM NO.       ECMWF.
(  243) !
(  244) !
(  245) !     AUTHOR.
(  246) !     -------
(  247) !
(  248) !          M. DRAGOSAVAC       *ECMWF*       JANUARY 1991.
(  249) !
(  250) !
(  251) !     MODIFICATIONS.
(  252) !     --------------
(  253) !
(  254) !     RMCG000915 - TRAP OUT OF RANGE INDICES FOR NTABP
(  255) !                  (POTENTIALLY NTABP(*,256) CAN BE ACCESSED BUT
(  256) !                  FOR HIRLAM THE CORRESPONDING BUFR INDICATORS ARE
(  257) !                  NOT USED SO THE ORIGINAL ARRAY SIZE (64,255) IS
(  258) !                  RETAINED)
(  259) !
(  260) !
(  261)       USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  262)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 7

(  263) !      IMPLICIT LOGICAL(L,O,G), CHARACTER*8(C,H,Y)
(  264)       IMPLICIT NONE
(  265) !
(  266)       INTEGER(KIND=JPIM),PARAMETER :: JP=3000
(  267)       INTEGER(KIND=JPIM) :: KERR
(  268)       INTEGER(KIND=JPIM) :: I,ICLASS,ICLASS0,II,IOS,IVIND,IYYY,J
(  269)       INTEGER(KIND=JPIM) :: NTABBDW(JP)
(  270)       INTEGER(KIND=JPIM) :: NTABBRF(JP)
(  271)       INTEGER(KIND=JPIM) :: NTABBS(JP)
(  272)       INTEGER(KIND=JPIM) :: NTABBTR(JP)
(  273)       INTEGER(KIND=JPIM) :: NTABP(64,255)
(  274)       LOGICAL :: LNEW
(  275) !
(  276)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  277) !
(  278) !
(  279) !      PARAMETER(JP=1000)
(  280) !RJ       PARAMETER(JP=3000)
(  281) !
(  282)       CHARACTER(LEN=64)  :: CTABBEN(JP)
(  283)       CHARACTER(LEN=24)  :: CTABBU(JP)
(  284)       CHARACTER(LEN=120) :: YENTRY
(  285)       CHARACTER(LEN=*)   :: YNAME
(  286)       CHARACTER(LEN=*)   :: YASC
(  287) !
(  288)       DATA CTABBEN/JP*' '/,CTABBU/JP*' '/
(  289) !
(  290) !     ------------------------------------------------------------------
(  291) !<A NAME="s1.">
(  292) !*          1.   INITIALIZE CONSTANTS AND VARIABLES.
(  293) !                -----------------------------------
(  294)       IF (LHOOK) CALL DR_HOOK('BTABLE',0,ZHOOK_HANDLE)
(  295)  100  CONTINUE
(  296) !
(  297)       J=0
(  298)       ICLASS0=0
(  299)       IVIND=2147483647
(  300) !
(  301)       DO 101 I=1,64
(  302)       do 101 ii=1,255
(  303)       NTABP(I,ii)=0
(  304)  101  CONTINUE
(  305) !
(  306)       DO 102 i=1,JP
(  307)       NTABBTR(I)=IVIND
(  308)       NTABBS (I)=IVIND
(  309)       NTABBRF(I)=IVIND
(  310)       NTABBDW(I)=IVIND
(  311)       CTABBEN(I)=' '
(  312)       CTABBU (I)=' '
(  313)  102  CONTINUE
(  314) !
(  315)       OPEN(UNIT=21,FILE=YASC,                                           &
(  316)      &            ERR=401,                                              &
(  317)      &            IOSTAT=IOS,                                           &
(  318)      &            STATUS='OLD')
(  319) !     ------------------------------------------------------------------
(  320) !<A NAME="s2.">






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 8

(  321) !*          2.   READ IN TABLE B ELEMENT.
(  322) !                ------------------------
(  323) !
(  324)  200  CONTINUE
(  325) !
(  326)       YENTRY=' '
(  327)       READ(21,'(A)',ERR=402,END=300) YENTRY
(  328) !
(  329)       IF(.NOT.LNEW)THEN
(  330)       IF(YENTRY(1:7).EQ.' ') THEN
(  331)          CTABBEN(J)(33:64)=YENTRY( 9:40)
(  332)          GO TO 200
(  333)       END IF
(  334)       ENDIF
(  335)       J=J+1
(  336)       IF(J.GT.JP) THEN
(  337)          PRINT*,' DIMENSION TOO SMALL J=',J
(  338)          CALL ABORT
(  339)       END IF
(  340) !
(  341) !     ------------------------------------------------------------------
(  342) !<A NAME="s2.1">
(  343) !*          2.1  SET ARRAYS FOR TABLE REFERENCE, ELEMENT NAME, UNITS,
(  344) !*               REFERENCE VALUE AND DATA WIDTH.
(  345) !
(  346)  210  CONTINUE
(  347) !
(  348) !
(  349)       IF(.NOT.LNEW)THEN
(  350)       READ(YENTRY,'(1X,I6,33X,21X,I3,I12,I4)') NTABBTR(J),NTABBS (J),   &
(  351)      &                                         NTABBRF(J),NTABBDW(J)
(  352) !
(  353)       CTABBEN(J)(1:32)=YENTRY( 9:40)
(  354)       CTABBU (J)=YENTRY(42:61)
(  355)       ELSE
(  356)       READ(YENTRY,'(1X,I6,1x,64x,1x,24x,1x,I3,1x,I12,1x,I3)')           &
(  357)      &                                         NTABBTR(J),NTABBS (J),   &
(  358)      &                                         NTABBRF(J),NTABBDW(J)
(  359) !
(  360)       CTABBEN(J)=YENTRY( 9:72)
(  361)       CTABBU (J)=YENTRY(74:97)
(  362)       ENDIF
(  363) !
(  364)       ICLASS=NTABBTR(J)/1000
(  365)       iyyy  =ntabbtr(j)-iclass*1000+1
(  366) !
(  367) !RM
(  368)             IF(iyyy.gt.255)THEN
(  369)               write(6,*)'BUTA: ****  ntabp going out of range:'
(  370)               iyyy=255
(  371)             ENDIF
(  372) 
(  373)       iclass=iclass+1
(  374)       ntabp(iclass,iyyy)=j
(  375) !<A NAME="n40">
(  376) !      WRITE(*,1000) NTABBTR(J),CTABBEN(J),CTABBU(J),NTABBS(J),
(  377) !     1              NTABBRF(J),NTABBDW(J)
(  378) ! 1000 FORMAT(1X ,1X,I6,1x,64x,1x,24x,1x,,I3,1x,I12,1x,I3)






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 9

(  379) !
(  380)       GO TO 200
(  381) !
(  382) !     ------------------------------------------------------------------
(  383) !*          3.   WRITE WORKING TABLE B INTO FILE.
(  384) !                --------------------------------
(  385)  300  CONTINUE
(  386) !
(  387)       OPEN(UNIT=10,FILE=YNAME,ERR=403,                                  &
(  388)      &             FORM='UNFORMATTED',                                  &
(  389)      &             ACCESS='SEQUENTIAL',                                 &
(  390)      &             STATUS='unknown')
(  391) !
(  392) !
(  393)       WRITE(10,IOSTAT=IOS,ERR=404)  NTABBTR,CTABBEN,CTABBU,             &
(  394)      &                              NTABBS ,NTABBRF,NTABBDW,            &
(  395)      &                              NTABP
(  396) !
(  397)       CLOSE(10)
(  398) !     -----------------------------------------------------------------
(  399)  400  CONTINUE
(  400) !
(  401)       write(*,'(1X )')
(  402)       write(*,'(1X ,a,i4)') 'Total number of entries in the Table B is',&
(  403)      &                       j
(  404) !
(  405)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  406)       RETURN
(  407) !
(  408) 404   CONTINUE
(  409)       KERR=1
(  410)       WRITE(*,4404) IOS,yname
(  411)  4404 FORMAT(1X ,'Write error',i4,' on ',a)
(  412)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  413)       RETURN
(  414) !
(  415) 403   CONTINUE
(  416)       KERR=1
(  417)       WRITE(*,4403) IOS,yname
(  418) 4403  FORMAT(1X ,'Open error',i4,' on ',a)
(  419)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  420)       RETURN
(  421) !
(  422) !
(  423) 402   CONTINUE
(  424)       KERR=1
(  425)       WRITE(*,4402) IOS,YASC
(  426)  4402 FORMAT(1X ,'Read error',i4,' on ',a)
(  427)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  428)       RETURN
(  429) !
(  430) !
(  431)  401  CONTINUE
(  432) !
(  433)       KERR=1
(  434)       WRITE(*,4401) IOS,YASC
(  435)  4401 FORMAT(1X ,'Open error',i4,' on ',a)
(  436) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 10

(  437)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  438)       RETURN
(  439)       ENDSUBROUTINE BTABLE
(  440) !
(  441) !
(  442)       SUBROUTINE DTABLE(YASC,YNAME,LNEW,KERR)
(  443) !<A NAME="n50">
(  444) !**** *DTABLE*
(  445) !
(  446) !
(  447) !     PURPOSE.
(  448) !     --------
(  449) !          THE MAIN PURPOSE OF THIS PROGRAMME IS TO CREATE WORKING
(  450) !          TABLE OF SEQUENCE DESCRIPTORS FOR *BUFR* DECODING.
(  451) !
(  452) !**   INTERFACE.
(  453) !     ----------
(  454) !          NONE.
(  455) !
(  456) !
(  457) !
(  458) !
(  459) !     *METHOD.
(  460) !      -------
(  461) !          NONE.
(  462) !
(  463) !
(  464) !
(  465) !     EXTERNALS.
(  466) !     ----------
(  467) !          NONE.
(  468) !
(  469) !
(  470) !
(  471) !
(  472) !     REFERENCE.
(  473) !     ----------
(  474) !
(  475) !          BINARY UNIVERSAL FORM FOR DATA REPRESENTATION, *FM 94 BUFR*.
(  476) !
(  477) !          J.K.GIBSON AND *M.DRAGOSAVAC,1987:* DECODING *DATA *REPRESENT
(  478) !                          *FM 94 BUFR*,*TECHNICAL *MEMORANDUM *NO.
(  479) !
(  480) !          J.K.GIBSON,1986:*EMOS 2 - *STANDARDS FOR SOFTWARE DEVELOPMENT
(  481) !                           AND MAINTANANCE *,*TECHICAL MEMORANDUM *NO.
(  482) !                           *ECMWF*.
(  483) !
(  484) !
(  485) !     AUTHOR.
(  486) !     -------
(  487) !
(  488) !          M. DRAGOSAVAC       *ECMWF*       JANUARY 1991.
(  489) !
(  490) !
(  491) !     MODIFICATIONS.
(  492) !     --------------
(  493) !
(  494) !          NONE.






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 11

(  495) !
(  496) !
(  497)       USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  498)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  499) !      IMPLICIT LOGICAL(L,O,G), CHARACTER*8(C,H,Y)
(  500)       IMPLICIT NONE
(  501) !
(  502)       INTEGER(KIND=JPIM),PARAMETER :: JL=20
(  503)       INTEGER(KIND=JPIM),PARAMETER :: JP=3000
(  504)       INTEGER(KIND=JPIM) :: KERR
(  505)       INTEGER(KIND=JPIM) :: I,IIST,IOS,IST,J,JA
(  506)       INTEGER(KIND=JPIM) :: NLIST(JL)
(  507)       INTEGER(KIND=JPIM) :: NTABDL(JP)
(  508)       INTEGER(KIND=JPIM) :: NTABDSQ(JP*20)
(  509)       INTEGER(KIND=JPIM) :: NTABDST(JP)
(  510)       INTEGER(KIND=JPIM) :: NTABDTR(JP)
(  511)       LOGICAL :: LNEW
(  512) !
(  513)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  514) !
(  515) !
(  516) !      PARAMETER(JP=1000,JL=20)
(  517) !RJ       PARAMETER(JP=3000,JL=20)
(  518) !
(  519)       CHARACTER(LEN=120) :: YENTRY
(  520)       CHARACTER(LEN=*)   :: YNAME
(  521)       CHARACTER(LEN=*)   :: YASC
(  522) !
(  523) !
(  524) !     ------------------------------------------------------------------
(  525) !<A NAME="s1.">
(  526) !*          1.   SET INITIAL CONSTANTS.
(  527) !                ----------------------
(  528)       IF (LHOOK) CALL DR_HOOK('DTABLE',0,ZHOOK_HANDLE)
(  529)  100  CONTINUE
(  530) !
(  531)       KERR=0
(  532)       J  =0
(  533)       IST=1
(  534) !
(  535)       DO 101 I=1,JP
(  536)       NTABDTR(I)=999999
(  537)       NTABDL (I)=0
(  538)       NTABDST(I)=0
(  539)  101  CONTINUE
(  540) !
(  541)       DO 102 I=1,JP*20
(  542)       NTABDSQ(I)=0
(  543)  102  CONTINUE
(  544) !
(  545)       DO 103 I=1,JL
(  546)       NLIST(I)=0
(  547)  103  CONTINUE
(  548) !
(  549)       OPEN(UNIT=21,ERR=401,FILE=YASC,STATUS='OLD')
(  550) !
(  551) !     ------------------------------------------------------------------
(  552) !<A NAME="s2.">






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 12

(  553) !*          2.   READ IN TABLE D
(  554) !                ---------------
(  555) !
(  556)  200  CONTINUE
(  557) !
(  558)       READ(21,'(A)',ERR=402,END=300) YENTRY
(  559) !
(  560)       J=J+1
(  561) !
(  562)       IF(J.GT.JP) THEN
(  563)          PRINT*,' DIMENSION TOO SMALL J=',J
(  564)          kerr=1
(  565)          CALL ABORT
(  566)       END IF
(  567) !
(  568) !     ------------------------------------------------------------------
(  569) !<A NAME="s2.1">
(  570) !*          2.1  SET ARRAYS FOR TABLE REFERENCE, DATA LENGTH,
(  571) !*               STARTING POINTER AND SEQUENCE DESCRIPTORS.
(  572) !
(  573)  210  CONTINUE
(  574) !
(  575) !
(  576)       READ(YENTRY,'(1X,I6,1X,I2)') NTABDTR(J),NTABDL (J)
(  577) !
(  578)       IF(J.EQ.1) THEN
(  579)          IST=1
(  580)          NTABDST(J)=IST
(  581)       ELSE
(  582)          IST=IST + NTABDL(J-1)
(  583)          NTABDST(J)=IST
(  584)       END IF
(  585) !
(  586)       IF(NTABDL(J).GT.1) THEN
(  587)          READ(YENTRY,'(11X,I6)') NTABDSQ(IST)
(  588)          IIST=IST
(  589) !
(  590)          DO 220 JA=1,NTABDL(J)-1
(  591)          IIST=IIST+1
(  592)          READ(21,'(A)',END=300) YENTRY
(  593)          READ(YENTRY,'(11X,I6)') NTABDSQ(IIST)
(  594)  220     CONTINUE
(  595) !
(  596)       ELSE
(  597)          READ(YENTRY,'(11X,I6)') NTABDSQ(IST)
(  598)       END IF
(  599) !
(  600) !<A NAME="n60">
(  601) !      WRITE(*,1000) NTABDTR(J),NTABDL(J),NTABDST(J),
(  602) !     1              (NTABDSQ(I),I=NTABDST(J),NTABDL(J)+NTABDST(J)-1)
(  603) !
(  604) ! 1000 FORMAT(1X ,I6,1X,I2,1X,I6,1X,I6/ (18X,I6))
(  605) !
(  606)       GO TO 200
(  607) !
(  608) !     ------------------------------------------------------------------
(  609) !*          3.   WRITE WORKING TABLE D INTO FILE
(  610) !                --------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 13

(  611)  300  CONTINUE
(  612) !
(  613) !
(  614)       OPEN(UNIT=22,FILE=YNAME,ERR=403,                                  &
(  615)      &             FORM='UNFORMATTED',                                  &
(  616)      &             ACCESS='SEQUENTIAL',                                 &
(  617)      &             STATUS='unknown')
(  618) !
(  619)       WRITE(22,IOSTAT=IOS,ERR=404) NTABDTR,NTABDL,NTABDST,NTABDSQ
(  620) !
(  621)       write(*,'(1X )')
(  622)       WRITE(*,'(1X ,a,i4)') 'Total number of entries in the Table D is',&
(  623)      &                       j
(  624) !
(  625)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  626)       RETURN
(  627) !     -----------------------------------------------------------------
(  628)  400  CONTINUE
(  629) !
(  630)  401  CONTINUE
(  631) !
(  632)       KERR=1
(  633)       WRITE(*,4401) IOS,YASC
(  634)  4401 FORMAT(1X ,'Open error ',i4,' on ',a)
(  635)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  636)       RETURN
(  637) !
(  638)  402  CONTINUE
(  639) !
(  640)       KERR=1
(  641)       WRITE(*,4402) IOS,YASC
(  642)  4402 FORMAT(1X ,'Read error ',i4,' on ',a)
(  643)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  644)       RETURN
(  645) !
(  646)  403  CONTINUE
(  647) !
(  648)       KERR=1
(  649)       WRITE(*,4403) IOS,yname
(  650)  4403 FORMAT(1X ,'Open error ',i4,' on ',a)
(  651)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  652)       RETURN
(  653) !
(  654) 404   CONTINUE
(  655) !
(  656)       KERR=1
(  657)       WRITE(*,4404) IOS,yname
(  658)  4404 FORMAT(1X ,'Write error ',i4,' on ',a)
(  659)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  660)       RETURN
(  661) !
(  662)       ENDSUBROUTINE DTABLE
(  663) !
(  664) !
(  665)       SUBROUTINE CTABLE(YASC,YNAME,LNEW,KERR)
(  666) !<A NAME="n70">
(  667) !**** *CTABLE*
(  668) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 14

(  669) !
(  670) !     PURPOSE.
(  671) !     --------
(  672) !          THE MAIN PURPOSE OF THIS PROGRAMME IS TO CREATE WORKING
(  673) !          CODE TABLES FOR *BUFR* DECODING.
(  674) !
(  675) !**   INTERFACE.
(  676) !     ----------
(  677) !          NONE.
(  678) !
(  679) !
(  680) !
(  681) !
(  682) !     *METHOD.
(  683) !      -------
(  684) !          NONE.
(  685) !
(  686) !
(  687) !
(  688) !     EXTERNALS.
(  689) !     ----------
(  690) !          NONE.
(  691) !
(  692) !
(  693) !
(  694) !
(  695) !     REFERENCE.
(  696) !     ----------
(  697) !
(  698) !          BINARY UNIVERSAL FORM FOR DATA REPRESENTATION, *FM 94 BUFR*.
(  699) !
(  700) !          J.K.GIBSON AND *M.DRAGOSAVAC,1987:* DECODING *DATA *REPRESENT
(  701) !                          *FM 94 BUFR*,*TECHNICAL *MEMORANDUM *NO. 134
(  702) !
(  703) !          J.K.GIBSON,1986:*EMOS 2 - *STANDARDS FOR SOFTWARE DEVELOPMENT
(  704) !                           AND MAINTANANCE *,*TECHICAL MEMORANDUM *NO.
(  705) !                           *ECMWF*.
(  706) !
(  707) !
(  708) !     AUTHOR.
(  709) !     -------
(  710) !
(  711) !          M. DRAGOSAVAC       *ECMWF*       JANUARY 1991.
(  712) !
(  713) !
(  714) !     MODIFICATIONS.
(  715) !     --------------
(  716) !
(  717) !          NONE.
(  718) !
(  719) !
(  720)       USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  721)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  722) !      IMPLICIT LOGICAL(L,O,G), CHARACTER*8(C,H,Y)
(  723)       IMPLICIT NONE
(  724) !
(  725)       INTEGER(KIND=JPIM),PARAMETER :: JP=120
(  726)       INTEGER(KIND=JPIM),PARAMETER :: JPN=15






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 15

(  727)       INTEGER(KIND=JPIM) :: KERR
(  728)       INTEGER(KIND=JPIM) :: I,IIPT,IOS,IPT,J,JA,JB,JPN4
(  729)       INTEGER(KIND=JPIM) :: NCODE
(  730)       INTEGER(KIND=JPIM) :: NCODNUM(JP*JPN)
(  731)       INTEGER(KIND=JPIM) :: NLEN(JP)
(  732)       INTEGER(KIND=JPIM) :: NLENC(JP*JPN)
(  733)       INTEGER(KIND=JPIM) :: NLINE
(  734)       INTEGER(KIND=JPIM) :: NREF(JP)
(  735)       INTEGER(KIND=JPIM) :: NSTART(JP)
(  736)       INTEGER(KIND=JPIM) :: NSTARTC(JP*JPN)
(  737)       LOGICAL :: LNEW
(  738) !
(  739)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  740) !
(  741) !
(  742)       CHARACTER(LEN=64)  :: CTEXT(JP*JPN*4)
(  743)       CHARACTER(LEN=120) :: YENTRY
(  744)       CHARACTER(LEN=*)   :: YNAME
(  745)       CHARACTER(LEN=*)   :: YASC
(  746) !
(  747) !
(  748) !     ------------------------------------------------------------------
(  749) !<A NAME="s1.">
(  750) !*          1.   SET INITIAL CONSTANTS AND POINTERS
(  751) !                ----------------------------------
(  752)       IF (LHOOK) CALL DR_HOOK('CTABLE',0,ZHOOK_HANDLE)
(  753)  100  CONTINUE
(  754) !
(  755)       J=0
(  756)       JPN4=JP*JPN*4
(  757) !
(  758)       DO 101 I=1,JPN4
(  759)       CTEXT(I)=' '
(  760)  101  CONTINUE
(  761) !
(  762)       DO 102 I=1,JP
(  763)       NREF(I)=0
(  764)       NSTART(I)=0
(  765)       NLEN(I)=0
(  766)  102  CONTINUE
(  767) !
(  768)       DO 103 I=1,JP*JPN
(  769)       NCODNUM(I)=0
(  770)       NSTARTC(I)=0
(  771)       NLENC  (I)=0
(  772)  103  CONTINUE
(  773) !
(  774)       OPEN(UNIT=21,FILE=YASC,ERR=401,STATUS='OLD')
(  775) !
(  776) !     ------------------------------------------------------------------
(  777) !<A NAME="s2.">
(  778) !*          2.   READ IN CODE TABLE ENTRY
(  779) !                ------------------------
(  780)  200  CONTINUE
(  781) !
(  782) !
(  783)       READ(21,'(A)',ERR=402,END=300) YENTRY
(  784) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 16

(  785)       J = J+1
(  786) !
(  787)       IF(J.GT.JP) THEN
(  788)          PRINT*,' DIMENSION TOO SMALL J=',J
(  789)          CALL ABORT
(  790)       END IF
(  791) !
(  792) !     ------------------------------------------------------------------
(  793) !<A NAME="s2.1">
(  794) !*          2.1  SET ARRAYS FOR CODE TABLE TABLE REFERENCE, STARTING POI
(  795) !                FOR LIST OF CODE NUMBERS, LENGTH , LIST OF CODE NUMBERS
(  796) !                STARTING POINTERS AND LENGTH OF TEXT INFORMATION.
(  797)  210  CONTINUE
(  798) !
(  799)       READ(YENTRY,'(I6,1X,I4,1X,I4,1X,I2)') NREF(J),NLEN(J),NCODE,NLINE
(  800) !
(  801)       IF(J.EQ.1) THEN
(  802)          NSTART (J)  = 1
(  803)          NSTARTC(J)  = 1
(  804)          IPT = 1
(  805)          IIPT= 1
(  806)       ELSE
(  807)          NSTART(J)   = NSTART(J-1) + NLEN(J-1)
(  808)          IPT         = NSTART(J)
(  809)          IIPT        = IIPT + 1
(  810)          NSTARTC(IPT)= IIPT
(  811)       END IF
(  812) !
(  813) !
(  814)       NCODNUM(IPT)=NCODE
(  815)       NLENC ( IPT)=NLINE
(  816) !
(  817)       CTEXT (IIPT)=YENTRY(21:80)
(  818) !     ------------------------------------------------------------------
(  819)       IF(NLENC(IPT).GT.1) THEN
(  820)          DO 220 JA=1,NLENC(IPT)-1
(  821)          READ(21,'(A)',END=300) YENTRY
(  822)          IIPT=IIPT+1
(  823)          CTEXT(IIPT)=YENTRY(21:80)
(  824)  220     CONTINUE
(  825)       END IF
(  826) !
(  827)       IF(NLEN(J).GT.1) THEN
(  828)          DO 230 JA=1,NLEN(J)-1
(  829)          READ(21,'(A)',END=300) YENTRY
(  830)          READ(YENTRY,'(12X,I4,1X,I2)') NCODE,NLINE
(  831)          IPT   = IPT + 1
(  832)          IIPT  =IIPT + 1
(  833)          NCODNUM(IPT)= NCODE
(  834)          NSTARTC(IPT)=  IIPT
(  835)          NLENC  (IPT)=NLINE
(  836)          CTEXT(IIPT) = YENTRY(21:80)
(  837)          IF(NLENC(IPT).GT.1) THEN
(  838)             DO 240 JB=1,NLENC(IPT)-1
(  839)             READ(21,'(A)',END=300) YENTRY
(  840)             IIPT=IIPT+1
(  841)             CTEXT(IIPT)=YENTRY(21:80)
(  842)  240        CONTINUE






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 17

(  843)          END IF
(  844)  230     CONTINUE
(  845)       END IF
(  846) !
(  847)       GO TO 200
(  848) !
(  849) !     ------------------------------------------------------------------
(  850) !<A NAME="s3.">
(  851) !*          3.   WRITE WORKING CODE TABLE INTO FILE.
(  852) !                -----------------------------------
(  853)  300  CONTINUE
(  854) !
(  855)       OPEN(UNIT=22,FILE=YNAME,ERR=403,                                  &
(  856)      &             FORM='UNFORMATTED',                                  &
(  857)      &             STATUS='unknown')
(  858) !
(  859)       WRITE(22,IOSTAT=IOS,ERR=404) NREF,NSTART,NLEN,NCODNUM,            &
(  860)      &                             NSTARTC,NLENC,CTEXT
(  861) !
(  862)       CLOSE(21)
(  863)       CLOSE(22)
(  864) !     -----------------------------------------------------------------
(  865) !<A NAME="s3.1">
(  866) !*          3.1  WRITE TABLES ON OUTPUT FILE
(  867) !                ---------------------------
(  868)  310  CONTINUE
(  869) !
(  870) !      JEND=J
(  871) !      DO 311 J=1,JEND
(  872) !
(  873) !      IPT=NSTART(J)
(  874) !      IIPT=NSTARTC(IPT)
(  875) !      WRITE(*,999) NREF(J),NLEN(J),NCODNUM(IPT),NLENC(IPT),CTEXT(IIPT)
(  876) !
(  877) !      IF(NLENC(IPT).GT.1) THEN
(  878) !         DO 312 JA=1,NLENC(IPT)-1
(  879) !         IIPT = IIPT + 1
(  880) !         WRITE(*,998) CTEXT(IIPT)
(  881) ! 312     CONTINUE
(  882) !      END IF
(  883) !
(  884) !      IF(NLEN(J).GT.1) THEN
(  885) !         DO 313 JB=1,NLEN(J)-1
(  886) !         IPT = IPT + 1
(  887) !         IIPT= NSTARTC(IPT)
(  888) !         WRITE(*,997) NCODNUM(IPT),NLENC(IPT),CTEXT(IIPT)
(  889) !         IF(NLENC(IPT).GT.1) THEN
(  890) !            DO 314 JC=1,NLENC(IPT)-1
(  891) !            IIPT= IIPT + 1
(  892) !            WRITE(*,998) CTEXT(IIPT)
(  893) ! 314        CONTINUE
(  894) !         END IF
(  895) ! 313     CONTINUE
(  896) !      END IF
(  897) !
(  898) ! 311  CONTINUE
(  899) !
(  900)       write(*,'(1X )')






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 18

(  901)       write(*,'(1X ,a,i4)') 'Total number of entries in the Table C is',&
(  902)      &                       j
(  903) !
(  904)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  905)       RETURN
(  906) !     -----------------------------------------------------------------
(  907)  400  CONTINUE
(  908) !
(  909)  401  CONTINUE
(  910) !
(  911)       KERR=1
(  912)       WRITE(*,4401) IOS,YASC
(  913)  4401 FORMAT(1X ,'Open error ',i4,' on ',a)
(  914)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  915)       RETURN
(  916) !
(  917)  402  CONTINUE
(  918)       KERR=1
(  919)       WRITE(*,4402) IOS,YASC
(  920)  4402 FORMAT(1X ,'Read error ',i4,' on ',a)
(  921)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  922)       RETURN
(  923) !
(  924)  403  CONTINUE
(  925) !
(  926)       KERR=1
(  927)       WRITE(*,4403) IOS,yname
(  928)  4403 FORMAT(1X ,'Open error ',i4,' on ',a)
(  929)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  930)       RETURN
(  931)  404  CONTINUE
(  932) !
(  933)       KERR=1
(  934)       WRITE(*,4404) IOS,yname
(  935)  4404 FORMAT(1X ,'Write error ',i4,' on ',a)
(  936)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  937)       RETURN
(  938) !
(  939)   997 FORMAT(1X ,14X,I4,1X,I2,1X,A)
(  940)   998 FORMAT(1X ,22X,A)
(  941)   999 FORMAT(1X ,2X,I6,1X,I4,1X,I4,1X,I2,1X,A)
(  942) !
(  943)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  944)       ENDSUBROUTINE CTABLE




















NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 19

(    1) # 1 "Buta.F"
(    1)       PROGRAM BUTAMAIN
(    2)       USE PARKIND1  ,ONLY : JPRB
(    3)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(    4) !
(    5)       IMPLICIT NONE
(    6) !
(    7)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(    8)       IF (LHOOK) CALL DR_HOOK('BUTAMAIN',0,ZHOOK_HANDLE)
(    9)       CALL BUTA
(   10)       IF (LHOOK) CALL DR_HOOK('BUTAMAIN',1,ZHOOK_HANDLE)
(   11)       ENDPROGRAM BUTAMAIN
(   12) # 13 "Buta.F"
(   13) ! Library:bufr $RCSfile: BUTA.f,v $, $Revision: 1.2 $
(   14) ! checked in by $Author: RayMcGrath $ at $Date: 2003/04/03 07:59:47 $
(   15) ! $State: Exp $, $Locker:  $
(   16) ! $Log: BUTA.f,v $
(   17) ! Revision 1.2  2003/04/03 07:59:47  RayMcGrath
(   18) ! (HIRLAM version 6.1.0)
(   19) ! Trap out of range indices for NTABP
(   20) !
(   21) ! Revision 1.1  1999/02/15 08:22:31  GCats
(   22) ! Created anew, HIRLAM version 4.3.5
(   23) !
(   24) !<A NAME="header">
(   25)       SUBROUTINE BUTA
(   26) !
(   27) !**** *TABLES*
(   28) !
(   29) !
(   30) !     PURPOSE.
(   31) !     --------
(   32) !       CREATES BINARY BUFR TABLES USED BY BUFR EXPANSION
(   33) !       OR BUFR ENCODING SOFTWARE.
(   34) !       THE NAMES OF THE BUFR TEXT TABLES ARE PASSED TO THE PROGRAM
(   35) !       VIA ONE OR MORE LINES OF INPUT, EACH LINE CONTAINING A LIST
(   36) !       OF FILE NAMES (WHITE SPACE SEPARATED).
(   37) !
(   38) !
(   39) !       EACH NAME IS ASSUMED TO BE IN THE STYLE "NAME.EXT"
(   40) !       WHERE "NAME" IS CODED NORMALLY AS FOLLOWS:
(   41) !
(   42) !       [TYPE][SUBCENTRE][MAINCENTRE][VER MASTER TABLE][VER LOCAL TABLE]
(   43) !       [1   ][234      ][567       ][89              ][1011 ]
(   44) !
(   45) !       TYPE='B' OR 'D' ('C' NO LONGER USED)
(   46) !
(   47) !       HOWEVER OLDER STYLE TABLES STORED ONLY 2 DIGITS FOR THE SUBCENTR
(   48) !       AND THE LAYOUT OF THE ASCII TABLES DIFFERED FROM THE CURRENT
(   49) !       CODING: THESE ARE CORRECTLY PROCESSED HERE.
(   50) !
(   51) !
(   52) !       "EXT" IS TXT OR ASC ETC (IT IS NOT USED). FILE NAMES NOT IN THIS
(   53) !        FORMAT ARE SKIPPED.
(   54) !
(   55) !       INPUT FILE EXAMPLE: B0000980201.TXT (OLD STYLE: B000980201.TXT)
(   56) !
(   57) !       FOR EACH INPUT FILE A CORRESPONDING BINARY BUFR TABLE IS WRITTEN






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 20

(   58) !       (NAME WITHOUT EXTENSION) IN THE *LOCAL* DIRECTORY (ANY
(   59) !       PATHNAME IN THE INPUT FILE NAME IS STRIPPED OUT).
(   60) !       EXAMPLE:
(   61) !       B0000980201.TXT -> B0000980201
(   62) !
(   63) !**   INTERFACE.
(   64) !     ----------
(   65) !          NONE.
(   66) !
(   67) !
(   68) !     *METHOD.
(   69) !      -------
(   70) !          NONE.
(   71) !
(   72) !
(   73) !     EXTERNALS.
(   74) !     ----------
(   75) !          NONE.
(   76) !
(   77) !
(   78) !
(   79) !
(   80) !     REFERENCE.
(   81) !     ----------
(   82) !
(   83) !          BINARY UNIVERSAL FORM FOR DATA REPRESENTATION, FM 94 BUFR.
(   84) !
(   85) !          J.K.GIBSON AND M.DRAGOSAVAC,1987: DECODING DATA
(   86) !          REPRESENTATION FM 94 BUFR,TECHNICAL MEMORANDUM NO.
(   87) !
(   88) !          J.K.GIBSON,1986:EMOS 2 - STANDARDS FOR SOFTWARE DEVELOPMENT
(   89) !          AND MAINTANANCE ,TECHICAL MEMORANDUM NO.       ECMWF.
(   90) !
(   91) !
(   92) !     AUTHOR.
(   93) !     -------
(   94) !
(   95) !     RMCGRATH DEC 1998. BASED ON SIMILAR SOFTWARE BY
(   96) !          M. DRAGOSAVAC       (ECMWF)
(   97) !
(   98) !
(   99) !
(  100)       USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  101)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  102) !      IMPLICIT LOGICAL(L,O,G), CHARACTER*8(C,H,Y)
(  103)       IMPLICIT NONE
(  104) !
(  105)       INTEGER(KIND=JPIM) :: I,IERR,N,NPATH
(  106)       LOGICAL :: LNEW
(  107) !
(  108)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  109) !
(  110)       CHARACTER(LEN=1000) :: YBIG
(  111)       CHARACTER(LEN=100)  :: YINPUT,YASC,YBIN,YPATH
(  112) !
(  113) !     ------------------------------------------------------------------
(  114) !<A NAME="s1.">
(  115) !*          1.   CREATE BINARY BUFR TABLES BY LOOPING ON INPUT FILES.






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 21

(  116) !                __________________________
(  117)       IF (LHOOK) CALL DR_HOOK('BUTA',0,ZHOOK_HANDLE)
(  118)  100  CONTINUE
(  119) !
(  120)       READ(5,FMT=1000,END=999,ERR=9999)YBIG
(  121) 1000  FORMAT(A)
(  122) 1     CONTINUE
(  123)       IF(YBIG.EQ.' ')THEN
(  124)        GO TO 100
(  125)       ELSE IF(YBIG(1:1).NE.' ')THEN
(  126)        GO TO 3
(  127)       ENDIF
(  128)       DO 2 I=1,1000
(  129)        IF(YBIG(I:I).NE.' ')THEN
(  130)        YBIG=YBIG(I:)
(  131)        GO TO 3
(  132)        ENDIF
(  133) 2     CONTINUE
(  134)       GO TO 100
(  135) 3     CONTINUE
(  136)       N=INDEX(YBIG,' ')
(  137)       IF(N.GT.0)THEN
(  138)        YINPUT=YBIG(1:N-1)
(  139)        YBIG=YBIG(N:)
(  140)       ELSE
(  141)        YINPUT=YBIG
(  142)        YBIG=' '
(  143)       ENDIF
(  144) # 145 "Buta.F"
(  145)       YASC=YINPUT
(  146)        write(6,*)YINPUT
(  147) !<A NAME="n10">
(  148) ! STRIP OFF ANY PATH - NOT KEPT
(  149) !
(  150)       NPATH=0
(  151)       DO 10 I=1,100
(  152)       IF(YINPUT(I:I).EQ.'/')NPATH=I
(  153) 10    CONTINUE
(  154) !
(  155)       IF(NPATH.GT.0)THEN
(  156)        YPATH=YINPUT(1:NPATH)
(  157)        YINPUT=YINPUT(NPATH+1:)
(  158)       ELSE
(  159)        YPATH=' '
(  160)       ENDIF
(  161) !
(  162)       WRITE(6,*)YINPUT,YPATH
(  163)       N=INDEX(YINPUT,'.')
(  164)       IF(N.EQ.12)THEN
(  165)          LNEW=.TRUE.
(  166)       ELSE IF(N.EQ.11)THEN
(  167)          LNEW=.FALSE.
(  168)       ELSE
(  169)        WRITE(6,*)' BAD ASCII TABLE FORMAT: ',YINPUT
(  170)        WRITE(6,*)' SKIPPED...'
(  171)        GO TO 1
(  172)       ENDIF
(  173)        YBIN=YINPUT(1:N-1)






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 22

(  174)        IF(YPATH.NE.' ')YBIN=YPATH(1:NPATH)//YINPUT(1:N-1)
(  175) !
(  176) !
(  177)        IERR=0
(  178)        IF(YINPUT(1:1).EQ.'B'.OR.YINPUT(1:1).EQ.'b')THEN
(  179)           CALL BTABLE(YASC,YBIN,LNEW,IERR)
(  180)        ELSE IF(YINPUT(1:1).EQ.'C'.OR.YINPUT(1:1).EQ.'c')THEN
(  181)           CALL CTABLE(YASC,YBIN,LNEW,IERR)
(  182)        ELSE IF(YINPUT(1:1).EQ.'D'.OR.YINPUT(1:1).EQ.'d')THEN
(  183)           CALL DTABLE(YASC,YBIN,LNEW,IERR)
(  184)        ELSE
(  185)           WRITE(6,*)' UNKNOWN TABLE (MUST BE B,C OR D): ',YINPUT(1:1)
(  186)           GO TO 100
(  187)        ENDIF
(  188)             IF(IERR.NE.0) THEN
(  189)              WRITE(6,*)' BINARY BUFR TABLE NOT CREATED: ',YBIN
(  190)              GO TO 100
(  191)             ENDIF
(  192) !<A NAME="n20">
(  193) ! GET NEXT TABLE
(  194) !
(  195)        GO TO 1
(  196) !
(  197) 9999    CONTINUE
(  198)         WRITE(6,*)' CORRUPT INPUT TO BUFR CREATION TABLES'
(  199) 999     CONTINUE
(  200)        IF (LHOOK) CALL DR_HOOK('BUTA',1,ZHOOK_HANDLE)
(  201)        RETURN
(  202) # 203 "Buta.F"
(  203)       IF (LHOOK) CALL DR_HOOK('BUTA',1,ZHOOK_HANDLE)
(  204)       ENDSUBROUTINE BUTA
(  205) !
(  206) !
(  207)       SUBROUTINE BTABLE(YASC,YNAME,LNEW,KERR)
(  208) !<A NAME="n30">
(  209) !**** *BTABLE*
(  210) !
(  211) !
(  212) !     PURPOSE.
(  213) !     --------
(  214) !          CREATE BUFR TABLE B IN BINARY FORM.
(  215) !
(  216) !**   INTERFACE.
(  217) !     ----------
(  218) !          NONE.
(  219) !
(  220) !
(  221) !     *METHOD.
(  222) !      -------
(  223) !          NONE.
(  224) !
(  225) !
(  226) !     EXTERNALS.
(  227) !     ----------
(  228) !          NONE.
(  229) !
(  230) !
(  231) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 23

(  232) !
(  233) !     REFERENCE.
(  234) !     ----------
(  235) !
(  236) !          BINARY UNIVERSAL FORM FOR DATA REPRESENTATION, FM 94 BUFR.
(  237) !
(  238) !          J.K.GIBSON AND M.DRAGOSAVAC,1987: DECODING DATA
(  239) !          REPRESENTATION FM 94 BUFR,TECHNICAL MEMORANDUM NO.
(  240) !
(  241) !          J.K.GIBSON,1986:EMOS 2 - STANDARDS FOR SOFTWARE DEVELOPMENT
(  242) !          AND MAINTANANCE ,TECHICAL MEMORANDUM NO.       ECMWF.
(  243) !
(  244) !
(  245) !     AUTHOR.
(  246) !     -------
(  247) !
(  248) !          M. DRAGOSAVAC       *ECMWF*       JANUARY 1991.
(  249) !
(  250) !
(  251) !     MODIFICATIONS.
(  252) !     --------------
(  253) !
(  254) !     RMCG000915 - TRAP OUT OF RANGE INDICES FOR NTABP
(  255) !                  (POTENTIALLY NTABP(*,256) CAN BE ACCESSED BUT
(  256) !                  FOR HIRLAM THE CORRESPONDING BUFR INDICATORS ARE
(  257) !                  NOT USED SO THE ORIGINAL ARRAY SIZE (64,255) IS
(  258) !                  RETAINED)
(  259) !
(  260) !
(  261)       USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  262)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  263) !      IMPLICIT LOGICAL(L,O,G), CHARACTER*8(C,H,Y)
(  264)       IMPLICIT NONE
(  265) !
(  266)       INTEGER(KIND=JPIM),PARAMETER :: JP=3000
(  267)       INTEGER(KIND=JPIM) :: KERR
(  268)       INTEGER(KIND=JPIM) :: I,ICLASS,ICLASS0,II,IOS,IVIND,IYYY,J
(  269)       INTEGER(KIND=JPIM) :: NTABBDW(JP)
(  270)       INTEGER(KIND=JPIM) :: NTABBRF(JP)
(  271)       INTEGER(KIND=JPIM) :: NTABBS(JP)
(  272)       INTEGER(KIND=JPIM) :: NTABBTR(JP)
(  273)       INTEGER(KIND=JPIM) :: NTABP(64,255)
(  274)       LOGICAL :: LNEW
(  275) !
(  276)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  277) !
(  278) !
(  279) !      PARAMETER(JP=1000)
(  280) !RJ       PARAMETER(JP=3000)
(  281) !
(  282)       CHARACTER(LEN=64)  :: CTABBEN(JP)
(  283)       CHARACTER(LEN=24)  :: CTABBU(JP)
(  284)       CHARACTER(LEN=120) :: YENTRY
(  285)       CHARACTER(LEN=*)   :: YNAME
(  286)       CHARACTER(LEN=*)   :: YASC
(  287) !
(  288)       DATA CTABBEN/JP*' '/,CTABBU/JP*' '/
(  289) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 24

(  290) !     ------------------------------------------------------------------
(  291) !<A NAME="s1.">
(  292) !*          1.   INITIALIZE CONSTANTS AND VARIABLES.
(  293) !                -----------------------------------
(  294)       IF (LHOOK) CALL DR_HOOK('BTABLE',0,ZHOOK_HANDLE)
(  295)  100  CONTINUE
(  296) !
(  297)       J=0
(  298)       ICLASS0=0
(  299)       IVIND=2147483647
(  300) !
(  301)       DO 101 I=1,64
(  302)       do 101 ii=1,255
(  303)       NTABP(I,ii)=0
(  304)  101  CONTINUE
(  305) !
(  306)       DO 102 i=1,JP
(  307)       NTABBTR(I)=IVIND
(  308)       NTABBS (I)=IVIND
(  309)       NTABBRF(I)=IVIND
(  310)       NTABBDW(I)=IVIND
(  311)       CTABBEN(I)=' '
(  312)       CTABBU (I)=' '
(  313)  102  CONTINUE
(  314) !
(  315)       OPEN(UNIT=21,FILE=YASC,                                           
(  316)      &            ERR=401,                                              
(  317)      &            IOSTAT=IOS,                                           
(  318)      &            STATUS='OLD')
(  319) !     ------------------------------------------------------------------
(  320) !<A NAME="s2.">
(  321) !*          2.   READ IN TABLE B ELEMENT.
(  322) !                ------------------------
(  323) !
(  324)  200  CONTINUE
(  325) !
(  326)       YENTRY=' '
(  327)       READ(21,'(A)',ERR=402,END=300) YENTRY
(  328) !
(  329)       IF(.NOT.LNEW)THEN
(  330)       IF(YENTRY(1:7).EQ.' ') THEN
(  331)          CTABBEN(J)(33:64)=YENTRY( 9:40)
(  332)          GO TO 200
(  333)       END IF
(  334)       ENDIF
(  335)       J=J+1
(  336)       IF(J.GT.JP) THEN
(  337)          PRINT*,' DIMENSION TOO SMALL J=',J
(  338)          CALL ABORT
(  339)       END IF
(  340) !
(  341) !     ------------------------------------------------------------------
(  342) !<A NAME="s2.1">
(  343) !*          2.1  SET ARRAYS FOR TABLE REFERENCE, ELEMENT NAME, UNITS,
(  344) !*               REFERENCE VALUE AND DATA WIDTH.
(  345) !
(  346)  210  CONTINUE
(  347) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 25

(  348) !
(  349)       IF(.NOT.LNEW)THEN
(  350)       READ(YENTRY,'(1X,I6,33X,21X,I3,I12,I4)') NTABBTR(J),NTABBS (J),   
(  351)      &                                         NTABBRF(J),NTABBDW(J)
(  352) !
(  353)       CTABBEN(J)(1:32)=YENTRY( 9:40)
(  354)       CTABBU (J)=YENTRY(42:61)
(  355)       ELSE
(  356)       READ(YENTRY,'(1X,I6,1x,64x,1x,24x,1x,I3,1x,I12,1x,I3)')           
(  357)      &                                         NTABBTR(J),NTABBS (J),   
(  358)      &                                         NTABBRF(J),NTABBDW(J)
(  359) !
(  360)       CTABBEN(J)=YENTRY( 9:72)
(  361)       CTABBU (J)=YENTRY(74:97)
(  362)       ENDIF
(  363) !
(  364)       ICLASS=NTABBTR(J)/1000
(  365)       iyyy  =ntabbtr(j)-iclass*1000+1
(  366) !
(  367) !RM
(  368)             IF(iyyy.gt.255)THEN
(  369)               write(6,*)'BUTA: ****  ntabp going out of range:'
(  370)               iyyy=255
(  371)             ENDIF
(  372) # 373 "Buta.F"
(  373)       iclass=iclass+1
(  374)       ntabp(iclass,iyyy)=j
(  375) !<A NAME="n40">
(  376) !      WRITE(*,1000) NTABBTR(J),CTABBEN(J),CTABBU(J),NTABBS(J),
(  377) !     1              NTABBRF(J),NTABBDW(J)
(  378) ! 1000 FORMAT(1X ,1X,I6,1x,64x,1x,24x,1x,,I3,1x,I12,1x,I3)
(  379) !
(  380)       GO TO 200
(  381) !
(  382) !     ------------------------------------------------------------------
(  383) !*          3.   WRITE WORKING TABLE B INTO FILE.
(  384) !                --------------------------------
(  385)  300  CONTINUE
(  386) !
(  387)       OPEN(UNIT=10,FILE=YNAME,ERR=403,                                  
(  388)      &             FORM='UNFORMATTED',                                  
(  389)      &             ACCESS='SEQUENTIAL',                                 
(  390)      &             STATUS='unknown')
(  391) !
(  392) !
(  393)       WRITE(10,IOSTAT=IOS,ERR=404)  NTABBTR,CTABBEN,CTABBU,             
(  394)      &                              NTABBS ,NTABBRF,NTABBDW,            
(  395)      &                              NTABP
(  396) !
(  397)       CLOSE(10)
(  398) !     -----------------------------------------------------------------
(  399)  400  CONTINUE
(  400) !
(  401)       write(*,'(1X )')
(  402)       write(*,'(1X ,a,i4)') 'Total number of entries in the Table B is',
(  403)      &                       j
(  404) !
(  405)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 26

(  406)       RETURN
(  407) !
(  408) 404   CONTINUE
(  409)       KERR=1
(  410)       WRITE(*,4404) IOS,yname
(  411)  4404 FORMAT(1X ,'Write error',i4,' on ',a)
(  412)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  413)       RETURN
(  414) !
(  415) 403   CONTINUE
(  416)       KERR=1
(  417)       WRITE(*,4403) IOS,yname
(  418) 4403  FORMAT(1X ,'Open error',i4,' on ',a)
(  419)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  420)       RETURN
(  421) !
(  422) !
(  423) 402   CONTINUE
(  424)       KERR=1
(  425)       WRITE(*,4402) IOS,YASC
(  426)  4402 FORMAT(1X ,'Read error',i4,' on ',a)
(  427)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  428)       RETURN
(  429) !
(  430) !
(  431)  401  CONTINUE
(  432) !
(  433)       KERR=1
(  434)       WRITE(*,4401) IOS,YASC
(  435)  4401 FORMAT(1X ,'Open error',i4,' on ',a)
(  436) !
(  437)       IF (LHOOK) CALL DR_HOOK('BTABLE',1,ZHOOK_HANDLE)
(  438)       RETURN
(  439)       ENDSUBROUTINE BTABLE
(  440) !
(  441) !
(  442)       SUBROUTINE DTABLE(YASC,YNAME,LNEW,KERR)
(  443) !<A NAME="n50">
(  444) !**** *DTABLE*
(  445) !
(  446) !
(  447) !     PURPOSE.
(  448) !     --------
(  449) !          THE MAIN PURPOSE OF THIS PROGRAMME IS TO CREATE WORKING
(  450) !          TABLE OF SEQUENCE DESCRIPTORS FOR *BUFR* DECODING.
(  451) !
(  452) !**   INTERFACE.
(  453) !     ----------
(  454) !          NONE.
(  455) !
(  456) !
(  457) !
(  458) !
(  459) !     *METHOD.
(  460) !      -------
(  461) !          NONE.
(  462) !
(  463) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 27

(  464) !
(  465) !     EXTERNALS.
(  466) !     ----------
(  467) !          NONE.
(  468) !
(  469) !
(  470) !
(  471) !
(  472) !     REFERENCE.
(  473) !     ----------
(  474) !
(  475) !          BINARY UNIVERSAL FORM FOR DATA REPRESENTATION, *FM 94 BUFR*.
(  476) !
(  477) !          J.K.GIBSON AND *M.DRAGOSAVAC,1987:* DECODING *DATA *REPRESENT
(  478) !                          *FM 94 BUFR*,*TECHNICAL *MEMORANDUM *NO.
(  479) !
(  480) !          J.K.GIBSON,1986:*EMOS 2 - *STANDARDS FOR SOFTWARE DEVELOPMENT
(  481) !                           AND MAINTANANCE *,*TECHICAL MEMORANDUM *NO.
(  482) !                           *ECMWF*.
(  483) !
(  484) !
(  485) !     AUTHOR.
(  486) !     -------
(  487) !
(  488) !          M. DRAGOSAVAC       *ECMWF*       JANUARY 1991.
(  489) !
(  490) !
(  491) !     MODIFICATIONS.
(  492) !     --------------
(  493) !
(  494) !          NONE.
(  495) !
(  496) !
(  497)       USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  498)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  499) !      IMPLICIT LOGICAL(L,O,G), CHARACTER*8(C,H,Y)
(  500)       IMPLICIT NONE
(  501) !
(  502)       INTEGER(KIND=JPIM),PARAMETER :: JL=20
(  503)       INTEGER(KIND=JPIM),PARAMETER :: JP=3000
(  504)       INTEGER(KIND=JPIM) :: KERR
(  505)       INTEGER(KIND=JPIM) :: I,IIST,IOS,IST,J,JA
(  506)       INTEGER(KIND=JPIM) :: NLIST(JL)
(  507)       INTEGER(KIND=JPIM) :: NTABDL(JP)
(  508)       INTEGER(KIND=JPIM) :: NTABDSQ(JP*20)
(  509)       INTEGER(KIND=JPIM) :: NTABDST(JP)
(  510)       INTEGER(KIND=JPIM) :: NTABDTR(JP)
(  511)       LOGICAL :: LNEW
(  512) !
(  513)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  514) !
(  515) !
(  516) !      PARAMETER(JP=1000,JL=20)
(  517) !RJ       PARAMETER(JP=3000,JL=20)
(  518) !
(  519)       CHARACTER(LEN=120) :: YENTRY
(  520)       CHARACTER(LEN=*)   :: YNAME
(  521)       CHARACTER(LEN=*)   :: YASC






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 28

(  522) !
(  523) !
(  524) !     ------------------------------------------------------------------
(  525) !<A NAME="s1.">
(  526) !*          1.   SET INITIAL CONSTANTS.
(  527) !                ----------------------
(  528)       IF (LHOOK) CALL DR_HOOK('DTABLE',0,ZHOOK_HANDLE)
(  529)  100  CONTINUE
(  530) !
(  531)       KERR=0
(  532)       J  =0
(  533)       IST=1
(  534) !
(  535)       DO 101 I=1,JP
(  536)       NTABDTR(I)=999999
(  537)       NTABDL (I)=0
(  538)       NTABDST(I)=0
(  539)  101  CONTINUE
(  540) !
(  541)       DO 102 I=1,JP*20
(  542)       NTABDSQ(I)=0
(  543)  102  CONTINUE
(  544) !
(  545)       DO 103 I=1,JL
(  546)       NLIST(I)=0
(  547)  103  CONTINUE
(  548) !
(  549)       OPEN(UNIT=21,ERR=401,FILE=YASC,STATUS='OLD')
(  550) !
(  551) !     ------------------------------------------------------------------
(  552) !<A NAME="s2.">
(  553) !*          2.   READ IN TABLE D
(  554) !                ---------------
(  555) !
(  556)  200  CONTINUE
(  557) !
(  558)       READ(21,'(A)',ERR=402,END=300) YENTRY
(  559) !
(  560)       J=J+1
(  561) !
(  562)       IF(J.GT.JP) THEN
(  563)          PRINT*,' DIMENSION TOO SMALL J=',J
(  564)          kerr=1
(  565)          CALL ABORT
(  566)       END IF
(  567) !
(  568) !     ------------------------------------------------------------------
(  569) !<A NAME="s2.1">
(  570) !*          2.1  SET ARRAYS FOR TABLE REFERENCE, DATA LENGTH,
(  571) !*               STARTING POINTER AND SEQUENCE DESCRIPTORS.
(  572) !
(  573)  210  CONTINUE
(  574) !
(  575) !
(  576)       READ(YENTRY,'(1X,I6,1X,I2)') NTABDTR(J),NTABDL (J)
(  577) !
(  578)       IF(J.EQ.1) THEN
(  579)          IST=1






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 29

(  580)          NTABDST(J)=IST
(  581)       ELSE
(  582)          IST=IST + NTABDL(J-1)
(  583)          NTABDST(J)=IST
(  584)       END IF
(  585) !
(  586)       IF(NTABDL(J).GT.1) THEN
(  587)          READ(YENTRY,'(11X,I6)') NTABDSQ(IST)
(  588)          IIST=IST
(  589) !
(  590)          DO 220 JA=1,NTABDL(J)-1
(  591)          IIST=IIST+1
(  592)          READ(21,'(A)',END=300) YENTRY
(  593)          READ(YENTRY,'(11X,I6)') NTABDSQ(IIST)
(  594)  220     CONTINUE
(  595) !
(  596)       ELSE
(  597)          READ(YENTRY,'(11X,I6)') NTABDSQ(IST)
(  598)       END IF
(  599) !
(  600) !<A NAME="n60">
(  601) !      WRITE(*,1000) NTABDTR(J),NTABDL(J),NTABDST(J),
(  602) !     1              (NTABDSQ(I),I=NTABDST(J),NTABDL(J)+NTABDST(J)-1)
(  603) !
(  604) ! 1000 FORMAT(1X ,I6,1X,I2,1X,I6,1X,I6/ (18X,I6))
(  605) !
(  606)       GO TO 200
(  607) !
(  608) !     ------------------------------------------------------------------
(  609) !*          3.   WRITE WORKING TABLE D INTO FILE
(  610) !                --------------------------------
(  611)  300  CONTINUE
(  612) !
(  613) !
(  614)       OPEN(UNIT=22,FILE=YNAME,ERR=403,                                  
(  615)      &             FORM='UNFORMATTED',                                  
(  616)      &             ACCESS='SEQUENTIAL',                                 
(  617)      &             STATUS='unknown')
(  618) !
(  619)       WRITE(22,IOSTAT=IOS,ERR=404) NTABDTR,NTABDL,NTABDST,NTABDSQ
(  620) !
(  621)       write(*,'(1X )')
(  622)       WRITE(*,'(1X ,a,i4)') 'Total number of entries in the Table D is',
(  623)      &                       j
(  624) !
(  625)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  626)       RETURN
(  627) !     -----------------------------------------------------------------
(  628)  400  CONTINUE
(  629) !
(  630)  401  CONTINUE
(  631) !
(  632)       KERR=1
(  633)       WRITE(*,4401) IOS,YASC
(  634)  4401 FORMAT(1X ,'Open error ',i4,' on ',a)
(  635)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  636)       RETURN
(  637) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 30

(  638)  402  CONTINUE
(  639) !
(  640)       KERR=1
(  641)       WRITE(*,4402) IOS,YASC
(  642)  4402 FORMAT(1X ,'Read error ',i4,' on ',a)
(  643)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  644)       RETURN
(  645) !
(  646)  403  CONTINUE
(  647) !
(  648)       KERR=1
(  649)       WRITE(*,4403) IOS,yname
(  650)  4403 FORMAT(1X ,'Open error ',i4,' on ',a)
(  651)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  652)       RETURN
(  653) !
(  654) 404   CONTINUE
(  655) !
(  656)       KERR=1
(  657)       WRITE(*,4404) IOS,yname
(  658)  4404 FORMAT(1X ,'Write error ',i4,' on ',a)
(  659)       IF (LHOOK) CALL DR_HOOK('DTABLE',1,ZHOOK_HANDLE)
(  660)       RETURN
(  661) !
(  662)       ENDSUBROUTINE DTABLE
(  663) !
(  664) !
(  665)       SUBROUTINE CTABLE(YASC,YNAME,LNEW,KERR)
(  666) !<A NAME="n70">
(  667) !**** *CTABLE*
(  668) !
(  669) !
(  670) !     PURPOSE.
(  671) !     --------
(  672) !          THE MAIN PURPOSE OF THIS PROGRAMME IS TO CREATE WORKING
(  673) !          CODE TABLES FOR *BUFR* DECODING.
(  674) !
(  675) !**   INTERFACE.
(  676) !     ----------
(  677) !          NONE.
(  678) !
(  679) !
(  680) !
(  681) !
(  682) !     *METHOD.
(  683) !      -------
(  684) !          NONE.
(  685) !
(  686) !
(  687) !
(  688) !     EXTERNALS.
(  689) !     ----------
(  690) !          NONE.
(  691) !
(  692) !
(  693) !
(  694) !
(  695) !     REFERENCE.






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 31

(  696) !     ----------
(  697) !
(  698) !          BINARY UNIVERSAL FORM FOR DATA REPRESENTATION, *FM 94 BUFR*.
(  699) !
(  700) !          J.K.GIBSON AND *M.DRAGOSAVAC,1987:* DECODING *DATA *REPRESENT
(  701) !                          *FM 94 BUFR*,*TECHNICAL *MEMORANDUM *NO. 134
(  702) !
(  703) !          J.K.GIBSON,1986:*EMOS 2 - *STANDARDS FOR SOFTWARE DEVELOPMENT
(  704) !                           AND MAINTANANCE *,*TECHICAL MEMORANDUM *NO.
(  705) !                           *ECMWF*.
(  706) !
(  707) !
(  708) !     AUTHOR.
(  709) !     -------
(  710) !
(  711) !          M. DRAGOSAVAC       *ECMWF*       JANUARY 1991.
(  712) !
(  713) !
(  714) !     MODIFICATIONS.
(  715) !     --------------
(  716) !
(  717) !          NONE.
(  718) !
(  719) !
(  720)       USE PARKIND1  ,ONLY : JPIM     ,JPRB
(  721)       USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
(  722) !      IMPLICIT LOGICAL(L,O,G), CHARACTER*8(C,H,Y)
(  723)       IMPLICIT NONE
(  724) !
(  725)       INTEGER(KIND=JPIM),PARAMETER :: JP=120
(  726)       INTEGER(KIND=JPIM),PARAMETER :: JPN=15
(  727)       INTEGER(KIND=JPIM) :: KERR
(  728)       INTEGER(KIND=JPIM) :: I,IIPT,IOS,IPT,J,JA,JB,JPN4
(  729)       INTEGER(KIND=JPIM) :: NCODE
(  730)       INTEGER(KIND=JPIM) :: NCODNUM(JP*JPN)
(  731)       INTEGER(KIND=JPIM) :: NLEN(JP)
(  732)       INTEGER(KIND=JPIM) :: NLENC(JP*JPN)
(  733)       INTEGER(KIND=JPIM) :: NLINE
(  734)       INTEGER(KIND=JPIM) :: NREF(JP)
(  735)       INTEGER(KIND=JPIM) :: NSTART(JP)
(  736)       INTEGER(KIND=JPIM) :: NSTARTC(JP*JPN)
(  737)       LOGICAL :: LNEW
(  738) !
(  739)       REAL(KIND=JPRB) :: ZHOOK_HANDLE
(  740) !
(  741) !
(  742)       CHARACTER(LEN=64)  :: CTEXT(JP*JPN*4)
(  743)       CHARACTER(LEN=120) :: YENTRY
(  744)       CHARACTER(LEN=*)   :: YNAME
(  745)       CHARACTER(LEN=*)   :: YASC
(  746) !
(  747) !
(  748) !     ------------------------------------------------------------------
(  749) !<A NAME="s1.">
(  750) !*          1.   SET INITIAL CONSTANTS AND POINTERS
(  751) !                ----------------------------------
(  752)       IF (LHOOK) CALL DR_HOOK('CTABLE',0,ZHOOK_HANDLE)
(  753)  100  CONTINUE






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 32

(  754) !
(  755)       J=0
(  756)       JPN4=JP*JPN*4
(  757) !
(  758)       DO 101 I=1,JPN4
(  759)       CTEXT(I)=' '
(  760)  101  CONTINUE
(  761) !
(  762)       DO 102 I=1,JP
(  763)       NREF(I)=0
(  764)       NSTART(I)=0
(  765)       NLEN(I)=0
(  766)  102  CONTINUE
(  767) !
(  768)       DO 103 I=1,JP*JPN
(  769)       NCODNUM(I)=0
(  770)       NSTARTC(I)=0
(  771)       NLENC  (I)=0
(  772)  103  CONTINUE
(  773) !
(  774)       OPEN(UNIT=21,FILE=YASC,ERR=401,STATUS='OLD')
(  775) !
(  776) !     ------------------------------------------------------------------
(  777) !<A NAME="s2.">
(  778) !*          2.   READ IN CODE TABLE ENTRY
(  779) !                ------------------------
(  780)  200  CONTINUE
(  781) !
(  782) !
(  783)       READ(21,'(A)',ERR=402,END=300) YENTRY
(  784) !
(  785)       J = J+1
(  786) !
(  787)       IF(J.GT.JP) THEN
(  788)          PRINT*,' DIMENSION TOO SMALL J=',J
(  789)          CALL ABORT
(  790)       END IF
(  791) !
(  792) !     ------------------------------------------------------------------
(  793) !<A NAME="s2.1">
(  794) !*          2.1  SET ARRAYS FOR CODE TABLE TABLE REFERENCE, STARTING POI
(  795) !                FOR LIST OF CODE NUMBERS, LENGTH , LIST OF CODE NUMBERS
(  796) !                STARTING POINTERS AND LENGTH OF TEXT INFORMATION.
(  797)  210  CONTINUE
(  798) !
(  799)       READ(YENTRY,'(I6,1X,I4,1X,I4,1X,I2)') NREF(J),NLEN(J),NCODE,NLINE
(  800) !
(  801)       IF(J.EQ.1) THEN
(  802)          NSTART (J)  = 1
(  803)          NSTARTC(J)  = 1
(  804)          IPT = 1
(  805)          IIPT= 1
(  806)       ELSE
(  807)          NSTART(J)   = NSTART(J-1) + NLEN(J-1)
(  808)          IPT         = NSTART(J)
(  809)          IIPT        = IIPT + 1
(  810)          NSTARTC(IPT)= IIPT
(  811)       END IF






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 33

(  812) !
(  813) !
(  814)       NCODNUM(IPT)=NCODE
(  815)       NLENC ( IPT)=NLINE
(  816) !
(  817)       CTEXT (IIPT)=YENTRY(21:80)
(  818) !     ------------------------------------------------------------------
(  819)       IF(NLENC(IPT).GT.1) THEN
(  820)          DO 220 JA=1,NLENC(IPT)-1
(  821)          READ(21,'(A)',END=300) YENTRY
(  822)          IIPT=IIPT+1
(  823)          CTEXT(IIPT)=YENTRY(21:80)
(  824)  220     CONTINUE
(  825)       END IF
(  826) !
(  827)       IF(NLEN(J).GT.1) THEN
(  828)          DO 230 JA=1,NLEN(J)-1
(  829)          READ(21,'(A)',END=300) YENTRY
(  830)          READ(YENTRY,'(12X,I4,1X,I2)') NCODE,NLINE
(  831)          IPT   = IPT + 1
(  832)          IIPT  =IIPT + 1
(  833)          NCODNUM(IPT)= NCODE
(  834)          NSTARTC(IPT)=  IIPT
(  835)          NLENC  (IPT)=NLINE
(  836)          CTEXT(IIPT) = YENTRY(21:80)
(  837)          IF(NLENC(IPT).GT.1) THEN
(  838)             DO 240 JB=1,NLENC(IPT)-1
(  839)             READ(21,'(A)',END=300) YENTRY
(  840)             IIPT=IIPT+1
(  841)             CTEXT(IIPT)=YENTRY(21:80)
(  842)  240        CONTINUE
(  843)          END IF
(  844)  230     CONTINUE
(  845)       END IF
(  846) !
(  847)       GO TO 200
(  848) !
(  849) !     ------------------------------------------------------------------
(  850) !<A NAME="s3.">
(  851) !*          3.   WRITE WORKING CODE TABLE INTO FILE.
(  852) !                -----------------------------------
(  853)  300  CONTINUE
(  854) !
(  855)       OPEN(UNIT=22,FILE=YNAME,ERR=403,                                  
(  856)      &             FORM='UNFORMATTED',                                  
(  857)      &             STATUS='unknown')
(  858) !
(  859)       WRITE(22,IOSTAT=IOS,ERR=404) NREF,NSTART,NLEN,NCODNUM,            
(  860)      &                             NSTARTC,NLENC,CTEXT
(  861) !
(  862)       CLOSE(21)
(  863)       CLOSE(22)
(  864) !     -----------------------------------------------------------------
(  865) !<A NAME="s3.1">
(  866) !*          3.1  WRITE TABLES ON OUTPUT FILE
(  867) !                ---------------------------
(  868)  310  CONTINUE
(  869) !






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 34

(  870) !      JEND=J
(  871) !      DO 311 J=1,JEND
(  872) !
(  873) !      IPT=NSTART(J)
(  874) !      IIPT=NSTARTC(IPT)
(  875) !      WRITE(*,999) NREF(J),NLEN(J),NCODNUM(IPT),NLENC(IPT),CTEXT(IIPT)
(  876) !
(  877) !      IF(NLENC(IPT).GT.1) THEN
(  878) !         DO 312 JA=1,NLENC(IPT)-1
(  879) !         IIPT = IIPT + 1
(  880) !         WRITE(*,998) CTEXT(IIPT)
(  881) ! 312     CONTINUE
(  882) !      END IF
(  883) !
(  884) !      IF(NLEN(J).GT.1) THEN
(  885) !         DO 313 JB=1,NLEN(J)-1
(  886) !         IPT = IPT + 1
(  887) !         IIPT= NSTARTC(IPT)
(  888) !         WRITE(*,997) NCODNUM(IPT),NLENC(IPT),CTEXT(IIPT)
(  889) !         IF(NLENC(IPT).GT.1) THEN
(  890) !            DO 314 JC=1,NLENC(IPT)-1
(  891) !            IIPT= IIPT + 1
(  892) !            WRITE(*,998) CTEXT(IIPT)
(  893) ! 314        CONTINUE
(  894) !         END IF
(  895) ! 313     CONTINUE
(  896) !      END IF
(  897) !
(  898) ! 311  CONTINUE
(  899) !
(  900)       write(*,'(1X )')
(  901)       write(*,'(1X ,a,i4)') 'Total number of entries in the Table C is',
(  902)      &                       j
(  903) !
(  904)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  905)       RETURN
(  906) !     -----------------------------------------------------------------
(  907)  400  CONTINUE
(  908) !
(  909)  401  CONTINUE
(  910) !
(  911)       KERR=1
(  912)       WRITE(*,4401) IOS,YASC
(  913)  4401 FORMAT(1X ,'Open error ',i4,' on ',a)
(  914)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  915)       RETURN
(  916) !
(  917)  402  CONTINUE
(  918)       KERR=1
(  919)       WRITE(*,4402) IOS,YASC
(  920)  4402 FORMAT(1X ,'Read error ',i4,' on ',a)
(  921)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  922)       RETURN
(  923) !
(  924)  403  CONTINUE
(  925) !
(  926)       KERR=1
(  927)       WRITE(*,4403) IOS,yname






NVFORTRAN (Version     23.1)          02/24/2023  13:39:49      page 35

(  928)  4403 FORMAT(1X ,'Open error ',i4,' on ',a)
(  929)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  930)       RETURN
(  931)  404  CONTINUE
(  932) !
(  933)       KERR=1
(  934)       WRITE(*,4404) IOS,yname
(  935)  4404 FORMAT(1X ,'Write error ',i4,' on ',a)
(  936)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  937)       RETURN
(  938) !
(  939)   997 FORMAT(1X ,14X,I4,1X,I2,1X,A)
(  940)   998 FORMAT(1X ,22X,A)
(  941)   999 FORMAT(1X ,2X,I6,1X,I4,1X,I4,1X,I2,1X,A)
(  942) !
(  943)       IF (LHOOK) CALL DR_HOOK('CTABLE',1,ZHOOK_HANDLE)
(  944)       ENDSUBROUTINE CTABLE
