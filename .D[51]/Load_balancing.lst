


NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: Load_balancing.F90

(    1)        PROGRAM Load_balancing
(    2) !
(    3) !
(    4) !**** *Load_balancing*
(    5) !
(    6) !
(    7) !     Purpose.
(    8) !     --------
(    9) !          Create load balanced input observation files for ODB loading.
(   10) !          The data are organised by subtypes, time slots, number of pools
(   11) !          and number of processors.
(   12) !
(   13) !
(   14) !**   Interface.
(   15) !     ----------
(   16) !
(   17) !
(   18) !     Method.
(   19) !     -------
(   20) !
(   21) !
(   22) !
(   23) !     Externals.
(   24) !     ----------
(   25) !
(   26) !          NONE.
(   27) !
(   28) !     Reference.
(   29) !     ----------
(   30) !






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 3

(   31) !
(   32) !     Author.
(   33) !     -------
(   34) !
(   35) !          M. Dragosavac    *ECMWF*       15/01/1010
(   36) !
(   37) !
(   38) !     Modifications.
(   39) !     --------------
(   40) !
(   41) !      B.Krzeminski      31-08-2010  Increased jbufl,jbyte,kelem for Aeolus
(   42) !      J. Munoz Sabater  Mars -2011  Changed value of jbufl,jbyte,kelem
(   43) !                                    jbufl set the max limit (in bytes) for a single bulletin sent via GTS
(   44) 
(   45) 
(   46)        implicit none
(   47) 
(   48) 
(   49) 
(   50)        integer, parameter :: jsup =   9
(   51)        integer, parameter :: jsec0=   3
(   52)        integer, parameter :: jsec1=  40
(   53)        integer, parameter :: jsec2=  4096
(   54)        integer, parameter :: jsec3=   4
(   55)        integer, parameter :: jsec4=   2 
(   56)        integer, parameter :: jbufl=  512000
(   57)        integer, parameter :: jbpw =  32
(   58)        integer, parameter :: jkey=  46
(   59)        integer, parameter :: jbyte= 2048000 
(   60) !       integer, parameter :: kelem=160000
(   61)        integer, parameter :: kvals=4096000
(   62)        integer, parameter :: nkey=13
(   63)        integer, parameter :: nvind=2147483647
(   64)        
(   65)        integer, dimension(jbufl) :: kbuff
(   66)        integer, dimension(jsup)  :: ksup
(   67)        integer, dimension(jsec0) :: ksec0
(   68)        integer, dimension(jsec1) :: ksec1
(   69)        integer, dimension(jsec2) :: ksec2
(   70)        integer, dimension(jsec3) :: ksec3
(   71)        integer, dimension(jsec4) :: ksec4
(   72)        integer, dimension(jkey)  :: key
(   73)        integer, dimension(6)     :: datetime1,datetime2,iymdhms
(   74)         
(   75)        real*8, dimension(kvals)    :: values
(   76) 
(   77)        integer, parameter :: nnn=4096000    ! size of list
(   78)        integer, parameter :: maxtsl = 1000
(   79)        integer, parameter :: nmax_stype=255
(   80)        INTEGER, DIMENSION(maxtsl)          :: timeslotno
(   81)        INTEGER, DIMENSION(maxtsl)          :: date1
(   82)        INTEGER, DIMENSION(maxtsl)          :: date2
(   83)        INTEGER, DIMENSION(maxtsl)          :: time1
(   84)        INTEGER, DIMENSION(maxtsl)          :: time2
(   85)        INTEGER, DIMENSION(maxtsl)          :: tperiod
(   86)        INTEGER, DIMENSION(maxtsl)          :: seconds1, seconds2
(   87)        INTEGER, allocatable                :: icnt(:,:)
(   88)        integer, allocatable                :: isubsets_perpool(:), isubsets(:)






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 4

(   89)        integer, allocatable                :: proc_unit(:)
(   90)        integer, allocatable                :: subsets_pertimeslot(:)
(   91)        integer, allocatable                :: subtypes(:,:)
(   92)        integer, allocatable                :: timeslot_subtype(:,:)
(   93)        integer, allocatable                :: nomsg_pertimeslot(:)
(   94)        INTEGER, DIMENSION(nmax_stype)      :: subtype_list
(   95)        integer, dimension(25)              :: i2
(   96)        integer                             :: idiff
(   97)        integer                             :: number_of_timeslots
(   98)        integer, dimension(maxtsl)          :: start_of_timeslots
(   99)        integer                             :: total_numsubsets
(  100)        integer                             :: nomsgs
(  101)        integer                             :: no_pools, pool_number
(  102)        integer                             :: number_of_pools, icomm,itmp
(  103)        integer                             :: new_numsubsets
(  104)        real*8                                :: perpool_numsubsets
(  105)        integer                             :: nummsgs
(  106)        integer                             :: pool_numsubsets
(  107)        integer                             :: nomsgs_pertimeslot
(  108)        integer                             :: i,j,n,is,iln,iz,ios,l,k
(  109)        integer                             :: ipos, kval,ij,ii,jj,ival
(  110)        integer                             :: isubtype
(  111)        real                                ::  r                          ! random number
(  112)        integer, dimension(20)              :: subtypes_list
(  113)        integer                             :: number_of_subtypes, ex_subsets
(  114)        integer                             :: iunit,iunit1,iret,ierr,iikbufl
(  115)        integer                             :: nbytpw,kbufl,ioff,istart,is_big_little,iend
(  116)        integer                             :: NPES,no_subtypes,narg,iargc
(  117)        logical                             :: in_list, found
(  118)        integer                             :: operation
(  119)      
(  120) 
(  121)        character(len=256) cfin, cfout, cfts, cexc
(  122)        character(len=256) field, commfile,outputfile
(  123)        character(len=256) , dimension(20) :: carg
(  124)        character(len=14) :: ytime
(  125)        character(len=20)  :: cdigit
(  126)        character(len=1)   :: write_mode
(  127) 
(  128)        type list_def
(  129)          integer      :: subtype
(  130)          integer      :: date
(  131)          integer      :: time
(  132)          integer      :: offset
(  133)          integer      :: data_size
(  134)          integer      :: seconds
(  135)          integer      :: timeslot_no
(  136)          integer      :: pool_number
(  137)          integer      :: processor_number
(  138)          integer      :: no_subsets
(  139)           
(  140)        end type list_def
(  141) 
(  142)        type (list_def), allocatable :: list(:)
(  143) 
(  144)        NAMELIST/INC/ operation,number_of_subtypes,subtypes_list
(  145) 
(  146) !-------------------------------------------------------------------------------------------






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 5

(  147)        cfin=' '
(  148)        cfout=' '
(  149)        narg=min(iargc(),size(carg))
(  150) 
(  151)        if(narg < 2) then
(  152)        print*,'Usage -- Load_balancing -i inputfile -p number_of_pools'// &
(  153)          & '  -o outputfile -c number_of_processers  -t timeslot_file -e exclude_subtype'
(  154)        print*,'      inputfile       -- input file name'
(  155)        print*,'      number_of_pools -- number of pools to be created '
(  156)        print*,'      outputfile      -- output file name'
(  157)        print*,'      number_of_processers -- number of processors i.e.  number of files created on output'
(  158)        print*,'      time slot file'
(  159)        print*,'      exclude_subtype -- namelist of subtypes to exclude'
(  160)        stop 'Invalid input args' 
(  161)        end if
(  162) 
(  163)        do  j=1,narg
(  164)         call getarg(j,carg(j))
(  165)        end do
(  166) 
(  167)        do j=1,narg
(  168)          if (carg(j) == '-i' .and. j<narg) then
(  169)             cfin=carg(j+1)
(  170)          elseif (carg(j) == '-o' .and. j<narg) then
(  171)             cfout=carg(j+1)
(  172)          elseif (carg(j) == '-p' .and. j<narg) then
(  173)             read(carg(j+1),*) number_of_pools
(  174)          elseif (carg(j) == '-c' .and. j<narg) then
(  175)             read(carg(j+1),*) NPES
(  176)          elseif (carg(j) == '-t' .and. j<narg) then
(  177)             cfts=carg(j+1)
(  178)          elseif (carg(j) == '-e' .and. j<narg) then
(  179)             cexc=carg(j+1)
(  180)          else
(  181)             cycle
(  182)          end if
(  183)        end do
(  184) 
(  185)        
(  186) !      initialise subtypes to exclude
(  187) 
(  188)        operation=0
(  189)        number_of_subtypes=0
(  190)        subtypes_list=-999
(  191) 
(  192) !      allocate( proc_unit(NPES))
(  193)        allocate( proc_unit(number_of_pools))
(  194) 
(  195)        nbytpw=jbpw/8
(  196)        n=0
(  197) 
(  198) 
(  199) !      Open input file, Output file, and timeslot file
(  200) 
(  201)       iret=0
(  202)       call pbopen(iunit,trim(cfin),'R',iret)
(  203)       if(iret.eq.-1) STOP 'Open failed'
(  204)       if(iret.eq.-2) STOP 'Invalid input file name'






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 6

(  205)       if(iret.EQ.-3) STOP 'Invalid open mode specified'
(  206) 
(  207) !     call pbopen(iunit1,trim(cfout),'w',iret)
(  208) 
(  209) !     if(iret.eq.-1) STOP 'Open failed'
(  210) !     if(iret.eq.-2) STOP 'Invalid output file name'
(  211) !     if(iret.EQ.-3) STOP 'Invalid open mode specified'
(  212) 
(  213)       ios=0
(  214)       print*,'Time slot file =',trim(cfts)
(  215)       open (unit=33,FILE=trim(cfts),STATUS='old',FORM='formatted',IOSTAT=ios)
(  216)       if(ios /= 0) then
(  217)        write(*,'(a,a)')  'Error opening time slot file: ',trim(cfts)
(  218)        call exit(2)
(  219)       end if
(  220) 
(  221)       open(47,file=trim(cexc),iostat=ios,status='OLD')
(  222)       if(ios /= 0) then
(  223)          print*,'open error ',ios,' on file ',cexc
(  224)          call exit(2)
(  225)       end if
(  226) 
(  227) !     Read subtypes to exclude
(  228) 
(  229) !
(  230)       READ (47,NML=INC)
(  231)       WRITE(*,NML=INC)
(  232) 
(  233) !     Read in time slot ranges
(  234) 
(  235)       i=0
(  236)       do while ( ios == 0 .and. i<maxtsl)
(  237)        i=i+1
(  238)        read(unit=33,fmt=*,iostat=ios) timeslotno(i), date1(i), time1(i), date2(i), time2(i)
(  239)        if(ios /= 0) then
(  240)           i=i-1
(  241)           exit
(  242)        endif
(  243)       datetime1(1)=date1(i)/10000           ! year
(  244)       idiff=date1(i)-datetime1(1)*10000
(  245)       datetime1(2)=idiff/100                ! month
(  246)       datetime1(3)=idiff-datetime1(2)*100   ! day
(  247) 
(  248)       datetime1(4)=time1(i)/10000           ! hour
(  249)       idiff=time1(i)-datetime1(4)*10000
(  250)       datetime1(5)=idiff/100                ! min
(  251)       datetime1(6)=idiff-datetime1(5)*100   ! sec
(  252) !
(  253)       datetime2(1)=date2(i)/10000           ! year
(  254)       idiff=date2(i)-datetime2(1)*10000
(  255)       datetime2(2)=idiff/100                ! month
(  256)       datetime2(3)=idiff-datetime2(2)*100   ! day
(  257) 
(  258)       datetime2(4)=time2(i)/10000           ! hour
(  259)       idiff=time2(i)-datetime2(4)*10000
(  260)       datetime2(5)=idiff/100                ! min
(  261)       datetime2(6)=idiff-datetime2(5)*100   ! sec
(  262) !






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 7

(  263) 
(  264) 
(  265) 
(  266)       call ymdhms2s(seconds1(i),datetime1)
(  267)       call ymdhms2s(seconds2(i),datetime2)
(  268) 
(  269)       tperiod(i)=seconds2(i) - seconds1(i)
(  270)       write(*,'(" t=",i5," : ",2x,i8.8,1x,i6.6," -- ",i8.8,1x,i6.6," : period =",i6," sec","soconds1=",I10," seconds2=",I10)
(  271)             timeslotno(i), date1(i), time1(i), date2(i), time2(i), tperiod(i), seconds1(i), seconds2(i)
(  272)       if (timeslotno(i) < 1 .or. timeslotno(i) > maxtsl) then
(  273)         write(0,*)'***Warning: Timeslot number ',timeslotno(i),' out of range: ',1,' -- ',maxtsl
(  274)         i=i-1
(  275)         cycle
(  276)       endif
(  277) 
(  278)       end do
(  279) 
(  280)       number_of_timeslots=i
(  281) 
(  282) !     close time slot input file
(  283) 
(  284)       close( 33)
(  285) 
(  286) !     Allocate memory for some arrays
(  287) !     -------------------------------
(  288)       allocate( icnt(number_of_timeslots+1,0:nmax_stype))
(  289)       icnt(:,:) = 0    
(  290)       allocate(subsets_pertimeslot(number_of_timeslots))
(  291)       subsets_pertimeslot(:)=0
(  292)       allocate(nomsg_pertimeslot(number_of_timeslots))
(  293)       nomsg_pertimeslot(:)=0
(  294) 
(  295) !      Create a list of record information
(  296) !      -----------------------------------
(  297)       no_subtypes=0
(  298)       subtype_list(:)=0
(  299) 
(  300)       do while(iret.ge.0)
(  301) 
(  302)          call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  303)          if(iret.eq.-1) exit
(  304)          n=n+1
(  305)          ierr=0
(  306)          ksec1(7)=0
(  307)          iikbufl=kbufl/nbytpw+1
(  308)          call bus012(iikbufl,kbuff,ksup,ksec0,ksec1,ksec2,ierr)
(  309)          if(ierr.ne.0) then
(  310)             print*,'Error in bus012'
(  311)             call exit(2)
(  312)          end if
(  313) 
(  314) !        Find number of different subtypes
(  315)          in_list=.false.
(  316)          do j=1,255
(  317)            if(subtype_list(j) == ksec1(7)) then
(  318)               in_list=.true.
(  319)            end if
(  320)          end do






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 8

(  321)          if(.not.in_list) then
(  322)            no_subtypes=no_subtypes+1
(  323)            subtype_list(no_subtypes)=ksec1(7)
(  324)          end if
(  325) 
(  326)       end do
(  327) 
(  328) !     call pbclose(iunit,iret)
(  329) 
(  330)       allocate ( list(n) )
(  331)       allocate ( subtypes(no_subtypes,n))
(  332)       allocate (timeslot_subtype(number_of_timeslots,n))
(  333)     
(  334) 
(  335) 
(  336)       call pbseek(iunit,0,0,iret)
(  337)       if(iret.eq.-1) then
(  338)          print*,'End of file hit'
(  339)          call exit(2)
(  340)       elseif(iret == -2) then
(  341)          print*,'Error in handling the file'
(  342)          call exit(2)
(  343)      end if
(  344) 
(  345)       iret=0
(  346) 
(  347)       n=0
(  348)       
(  349)       iret=0
(  350)       icnt(:,:)=0
(  351) 
(  352)       ex_subsets=0
(  353)       do while(iret.ge.0)
(  354) 
(  355)          call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  356)          if(iret.eq.-1) exit  
(  357) 
(  358)          call pbseek(iunit,0,1,iln)
(  359)          if(iln.lt.0) then
(  360)              print*,'pbseek error :',ierr
(  361)              call exit(2)
(  362)          end if
(  363) 
(  364)          ierr=0
(  365)          ksec1(7)=0
(  366)          iikbufl=kbufl/nbytpw+1
(  367)          call bus0123(iikbufl,kbuff,ksup,ksec0,ksec1,ksec2,ksec3,ierr)
(  368)          if(ierr.ne.0) then
(  369)             print*,'Error in bus0123'
(  370)             call exit(2)
(  371)          end if
(  372)  
(  373)          if(operation == 1 ) then
(  374) !           exclude subtypes
(  375)             found=.false.
(  376)             do iz=1,number_of_subtypes
(  377)               if(ksec1(7) == subtypes_list(iz) ) then
(  378)                  ex_subsets=ex_subsets+ksec3(3)






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 9

(  379)                  found=.true.
(  380)                  exit
(  381)               end if
(  382)             end do
(  383)             if(found) cycle
(  384)          elseif(operation == 2) then
(  385) !           include subtypes
(  386)             found=.false.
(  387)             do iz=1,number_of_subtypes
(  388)               if(ksec1(7) == subtypes_list(iz) ) then
(  389)                  found=.true.
(  390)               end if
(  391)             end do
(  392)             if(.not.found)then
(  393)                 ex_subsets=ex_subsets+ksec3(3)
(  394)                 cycle
(  395)             end if
(  396)          end if
(  397) 
(  398)          n=n+1
(  399)          
(  400) 
(  401)          list(n)%offset=iln-kbufl
(  402)          list(n)%data_size=kbufl
(  403)          list(n)%subtype=ksec1(7)
(  404)          list(n)%no_subsets=ksup(6)
(  405)        
(  406)          if(ksec0(3) <= 3 ) then
(  407)           if(ksec1(9) >=20 .and. ksec1(9) <= 100) then
(  408)              ksec1(9)=ksec1(9)+1900
(  409)           else
(  410)              ksec1(9)=ksec1(9)+2000
(  411)           end if
(  412)          end if
(  413) 
(  414) 
(  415)          list(n)%date=ksec1(9)*10000+ksec1(10)*100+ksec1(11)
(  416)      
(  417)          list(n)%time=ksec1(12)*10000+ksec1(13)*100
(  418)         
(  419) 
(  420)          iymdhms(1)=ksec1(9)
(  421)          iymdhms(2)=ksec1(10)
(  422)          iymdhms(3)=ksec1(11)
(  423)          iymdhms(4)=ksec1(12)
(  424)          iymdhms(5)=ksec1(13)
(  425)          iymdhms(6)=0
(  426)          call ymdhms2s(list(n)%seconds,iymdhms(1:6))
(  427) !        print*,list(n)%seconds
(  428) 
(  429) !        Determine timeslot number for record
(  430) !        ------------------------------------
(  431) 
(  432)          list(n)%timeslot_no=0
(  433)          do iz=1,number_of_timeslots
(  434)            if( list(n)%seconds >= seconds1(iz) .and. list(n)%seconds <= seconds2(iz) ) then
(  435)                list(n)%timeslot_no=iz
(  436)                icnt(iz,list(n)%subtype)= icnt(iz,list(n)%subtype)+1






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 10

(  437)                exit
(  438)            end if
(  439)          end do
(  440)          if(list(n)%timeslot_no == 0 ) then
(  441)             i = number_of_timeslots + 1
(  442)             icnt(i,list(n)%subtype) = icnt(i,list(n)%subtype) + 1
(  443)             write(*,'(a,I10,a,I10)') 'message ',n,' out of specified timeslots. Subtype ',list(n)%subtype
(  444)             write(*,'(I10,a,I10)') list(n)%date,'--', list(n)%time
(  445)          end if
(  446) 
(  447) 
(  448) 
(  449) 
(  450)       end do
(  451) 
(  452) 
(  453)       print*,'Number of subtypes=',no_subtypes
(  454)       print*,subtype_list(1:no_subtypes)
(  455)       if(operation == 1) then
(  456)          print*,'Subtypes excluded=',subtypes_list
(  457)       elseif(operation == 2) then
(  458)          print*,'Subtypes included=',subtypes_list
(  459)       else
(  460)          print*,'All subtypes used'
(  461)       end if
(  462)       print*,'Number of subsets not used', ex_subsets
(  463) 
(  464)       
(  465)       do i=1,number_of_timeslots
(  466)       do j=1,n
(  467)         if(list(j)%timeslot_no == i) then
(  468)            subsets_pertimeslot(i)=subsets_pertimeslot(i)+list(j)%no_subsets
(  469)            nomsg_pertimeslot(i)=nomsg_pertimeslot(i)+1
(  470)         end if
(  471)       end do
(  472)       end do
(  473) 
(  474) !     Print statistics about timeslots
(  475) 
(  476)       do i=1, number_of_timeslots
(  477)         itmp = sum(icnt(i,:))
(  478)         write(0,'(" t=",i5," : ",2x,i8.8,1x,i6.6," -- ",&
(  479)                  & i8.8,1x,i6.6," : total count=",i12," : number of subsets",i12)',advance='no') &
(  480)               timeslotno(i), date1(i), time1(i), date2(i), time2(i), itmp, subsets_pertimeslot(i)
(  481)         if (itmp > 0) then
(  482)           write(0,'(a)')', per subtype follow'
(  483)           do j=1,nmax_stype
(  484)             if (icnt(i,j) > 0) write(0,'(15x,a,i3,a,i12)') 'subtype=',j,' : ',icnt(i,j)
(  485)           enddo
(  486)         else
(  487)           write(0,'(1x)')
(  488)         endif
(  489)       enddo
(  490)       i = number_of_timeslots + 1
(  491)       itmp = sum(icnt(i,:))
(  492)       if (itmp > 0) then
(  493) 
(  494)         write(0,'(1x,a,i12,a)') '***Warning: ',itmp,' out of specified timeslots; counts per subtype follow:'






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 11

(  495)         do j=0,nmax_stype
(  496)           if (icnt(i,j) > 0) write(0,'(15x,a,i3,a,i12)') 'subtype=',j,' : ',icnt(i,j)
(  497)         enddo
(  498)       else
(  499)         write(0,*)'No BUFR-messages out of specified timeslots'
(  500)       endif
(  501) 
(  502)       itmp = sum(icnt(:,:))
(  503)       write(0,*)'Summary: ',number_of_timeslots,' timeslots ',&
(  504)                                                     itmp,' BUFR-messages'
(  505) 
(  506) 
(  507) !     end if statistics
(  508) 
(  509)        
(  510)        nomsgs=n
(  511) 
(  512) !      rewind(iunit)
(  513) 
(  514)        print*,nomsgs,' records to be used'
(  515) 
(  516) 
(  517) !      Make a list of records ordered by subtype within timeslot
(  518) !      ---------------------------------------------------------
(  519) 
(  520) 
(  521)        timeslot_subtype=-999
(  522)        do i=1,number_of_timeslots
(  523)        l=0
(  524)        do j=1,no_subtypes
(  525)        isubtype=subtype_list(j)
(  526)        do k=1,n
(  527)           if(list(k)%subtype == isubtype .and. list(k)%timeslot_no == i ) then
(  528)              l=l+1
(  529)              timeslot_subtype(i,l)= k
(  530)           end if
(  531)        end do
(  532)        end do
(  533)        print*,'number of records per timeslot=',l
(  534)        end do
(  535) 
(  536) 
(  537) !      Split data per timeslot over number of pools
(  538) !      --------------------------------------------
(  539) 
(  540)        if (number_of_pools < 1) then
(  541)           print*,'number_of_pools < 1'
(  542)           call exit(2)
(  543)        end if
(  544) 
(  545)        allocate(isubsets_perpool(number_of_pools))
(  546) 
(  547)        isubsets_perpool(:) = 0
(  548) 
(  549) !      Number of subsets in each message
(  550)        allocate(isubsets(nomsgs))
(  551)        isubsets(:) = 0
(  552) 






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 12

(  553)        
(  554)        ii=0
(  555)        do i=1,number_of_timeslots
(  556) 
(  557)        print*,'Timeslot --- ',i
(  558) 
(  559) !       new_numsubsets = subsets_pertimeslot(i)
(  560) !       ii=sum(isubsets_perpool(:))
(  561) !       total_numsubsets = ii + new_numsubsets
(  562)         new_numsubsets = subsets_pertimeslot(i)
(  563)         total_numsubsets=sum(subsets_pertimeslot(1:i))
(  564)         perpool_numsubsets = dble(total_numsubsets)/dble(number_of_pools)
(  565) 
(  566) !       Number of messages per timeslot
(  567)         nomsgs_pertimeslot=nomsg_pertimeslot(i)
(  568)         if(nomsgs_pertimeslot < 0) nomsgs_pertimeslot=0
(  569) 
(  570)         write(0,*)'nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets=',&
(  571)                 nomsgs_pertimeslot, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets
(  572)  
(  573)         call open_next_pool()
(  574) !       print*,'Pool number ---', pool_number
(  575) 
(  576) 
(  577)         iret = 0
(  578)         n=0
(  579) 
(  580) !       iz is message number in the list of messages
(  581) 
(  582)         print*,'Number of records for timeslot=',nomsg_pertimeslot(i)
(  583) 
(  584)         do iz=1,nomsgs
(  585)           if(list(iz)%timeslot_no == i) then
(  586)             list(iz)%pool_number=pool_number
(  587)             list(iz)%processor_number=mod(pool_number,NPES)
(  588)             if(list(iz)%processor_number == 0) list(iz)%processor_number=NPES
(  589) 
(  590)             n = n + 1
(  591)             pool_numsubsets = pool_numsubsets + list(iz)%no_subsets
(  592) !           print*,'iz=',iz,' subsets=',list(iz)%no_subsets
(  593) 
(  594)             iret=0
(  595)             if (pool_numsubsets > perpool_numsubsets) then
(  596)                 isubsets_perpool(pool_number)=pool_numsubsets
(  597)                 call open_next_pool()
(  598)                 iret=0
(  599)              end if
(  600)            end if
(  601)          end do 
(  602) 
(  603)          write(0,'((10i12))') isubsets_perpool(:)
(  604)          
(  605)          isubsets_perpool(pool_number)=pool_numsubsets
(  606)          ii=ii+subsets_pertimeslot(i)
(  607)        end do
(  608)        print*,'timeslot subsets =',sum(isubsets_perpool(:)),ii
(  609)       
(  610) 






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 13

(  611) 
(  612) 
(  613) !--    Update communication file
(  614) 
(  615) !      write(icomm,*) number_of_pools
(  616) !      write(icomm,'((10i12))') isubsets_perpool(:)
(  617) !      close(icomm)
(  618) 
(  619) !--------------------------------------------------------------------------
(  620) 
(  621) !      Group data from pool range into files per NPES
(  622) !      ----------------------------------------------
(  623) 
(  624) !      Write sorted file
(  625) !      -------------------------------
(  626) 
(  627) !        do j=1,NPES
(  628)          do j=1,number_of_pools    
(  629)           write(cdigit,'(i20)') j
(  630)           write(outputfile,'(a,".",a)') trim(cfout),trim(adjustl(cdigit))
(  631)           call pbopen(proc_unit(j),trim(outputfile),'W',iret)
(  632)           if(iret == -1) stop 'Open failed'
(  633)           if(iret == -2) stop 'Invalid input file name' 
(  634)           if(iret == -3) stop 'Invalid open mode specified' 
(  635)          end do
(  636) 
(  637)        do i=1,nomsgs
(  638) 
(  639)          if(list(i)%timeslot_no == 0) cycle
(  640)          ioff=list(i)%offset
(  641) !
(  642)          istart=0
(  643)          call pbseek(iunit,ioff,istart,iret)
(  644)          if(iret.lt.0) then
(  645)             print*,'pbseek: error ',iret
(  646)          end if
(  647) !
(  648)          IRET=0
(  649)          CALL PBBUFR(IUNIT,KBUFF,JBYTE,KBUFL,IRET)
(  650)          IF(IRET.EQ.-1) then
(  651)            print*,'offset=',ioff
(  652)            print*,'pbbufr : error ',iret
(  653)            STOP 'EOF'
(  654)          end if
(  655)          IF(IRET.EQ.-2) STOP 'File handling problem'
(  656)          IF(IRET.EQ.-3) STOP 'Array too small for product'
(  657)          ierr=0
(  658) 
(  659) 
(  660) !        CALL PBWRITE(proc_unit(list(i)%processor_number),KBUFF,KBUFL,IERR)
(  661)          CALL PBWRITE(proc_unit(list(i)%pool_number),KBUFF,KBUFL,IERR)
(  662)          if(ierr.lt.0) then
(  663)             print*,'Error writing into target file.'
(  664)             call exit(2)
(  665)          END IF
(  666) 
(  667)       end do
(  668) 






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 14

(  669)       contains
(  670) 
(  671)       SUBROUTINE OPEN_NEXT_POOL()
(  672)       implicit none
(  673)       INTEGER           :: istart_pool
(  674) 
(  675)       itmp = isubsets_perpool(1)
(  676)       istart_pool = 1
(  677)       do j=2,number_of_pools
(  678)         if (isubsets_perpool(j) < itmp) then
(  679)           itmp = isubsets_perpool(j)
(  680)           istart_pool = j
(  681)         endif
(  682)       enddo
(  683)       pool_number = istart_pool
(  684)       pool_numsubsets=isubsets_perpool(pool_number)
(  685) 
(  686)       END SUBROUTINE OPEN_NEXT_POOL
(  687) 
(  688) 
(  689) 
(  690)       END PROGRAM Load_balancing
(  691) 
(  692)       SUBROUTINE YMDHMS2S(ksec,ktime)
(  693) !
(  694) !**** *ymdhm2m*
(  695) !
(  696) !
(  697) !     purpose.
(  698) !     --------
(  699) !         calculate time in minutes since 1/1/1978,
(  700) !         given input as ktime(1)  year (1992)
(  701) !                        ktime(2)  month
(  702) !                        ktime(3)  day
(  703) !                        ktime(4)  hour
(  704) !                        ktime(5)  minute
(  705) !                        ktime(6)  second
(  706) !
(  707) !**   interface.
(  708) !     ----------
(  709) !
(  710) !         *iymdhm2m(ktime)*
(  711) !
(  712) !          input :  ktime(6)
(  713) !
(  714) !
(  715) !     method.
(  716) !     -------
(  717) !
(  718) !          none.
(  719) !
(  720) !
(  721) !     externals.
(  722) !     ----------
(  723) !
(  724) !         none.
(  725) !
(  726) !     reference.






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 15

(  727) !     ----------
(  728) !
(  729) !          none.
(  730) !
(  731) !     author.
(  732) !     -------
(  733) !
(  734) !          M. Dragosavac    *ecmwf*       21/01/2010
(  735) !
(  736) !
(  737) !     modifications.
(  738) !     --------------
(  739) !
(  740)       IMPLICIT NONE
(  741) !
(  742)       integer,dimension(6)  :: ktime
(  743) !
(  744)       integer, dimension(13)  :: idm
(  745)       integer :: idays,iy,i,ksec
(  746)       INTEGER :: ITM
(  747) !
(  748)       data idm/0,31,28,31,30,31,30,31,31,30,31,30,31/
(  749) !
(  750) !     ------------------------------------------------------------------
(  751) !*          1.  set minutes.
(  752) !               ------------
(  753) 100   continue
(  754) !
(  755)       idays=0
(  756) !
(  757)       do 101 i=1978,ktime(1)-1
(  758)        idays=idays+365
(  759)        if(mod(i,4).eq.0) idays=idays+1
(  760)  101  continue
(  761) !
(  762)       do 102 i=1,ktime(2)
(  763)        idays=idays+idm(i)
(  764)        if(i.eq.3) then
(  765)           iy=ktime(1)
(  766)           if(mod(iy,4).eq.0) idays=idays+1
(  767)        end if
(  768)  102  continue
(  769) !
(  770)       idays=idays+ktime(3)-1
(  771) !
(  772)       itm=idays*1440+ktime(4)*60+ktime(5)
(  773) !
(  774)       ksec=itm*60+ktime(6)
(  775) !
(  776)       return
(  777)       ENDSUBROUTINE YMDHMS2S
(  778) !
(  779) !
(  780)       SUBROUTINE S2YMDHMS(kseconds,ktime)
(  781) !
(  782) !**** *s2ymdhms*
(  783) !
(  784) !






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 16

(  785) !     purposeec
(  786) !     --------
(  787) !         calculate date/time  from seconds  since 1/1/1978,
(  788) !         given input as ktime(1)  year (1992)
(  789) !                        ktime(2)  month
(  790) !                        ktime(3)  day
(  791) !                        ktime(4)  hour
(  792) !                        ktime(5)  minute
(  793) !                        ktime(6)  second
(  794) !
(  795) !**   interface.
(  796) !     ----------
(  797) !
(  798) !         *s2ymdhms(kseconds,ktime)*
(  799) !
(  800) !          input :  ktime(6)
(  801) !
(  802) !
(  803) !     method.
(  804) !     -------
(  805) !
(  806) !          none.
(  807) !
(  808) !
(  809) !     externals.
(  810) !     ----------
(  811) !
(  812) !         none.
(  813) !
(  814) !     reference.
(  815) !     ----------
(  816) !
(  817) !          none.
(  818) !
(  819) !     author.
(  820) !     -------
(  821) !
(  822) !          M. Dragosavac    *ecmwf*       21/01/2010
(  823) !
(  824) !
(  825) !     modifications.
(  826) !     --------------
(  827) !
(  828) !          none.
(  829) !
(  830) !
(  831)       IMPLICIT NONE
(  832) !
(  833)       integer,dimension(6) ::  ktime
(  834) !
(  835)       integer, dimension(12) ::  idm
(  836)       integer  :: itm,kseconds,ihours,idays,i
(  837) !
(  838)       data idm/31,28,31,30,31,30,31,31,30,31,30,31/
(  839)   
(  840) !
(  841) !     ------------------------------------------------------------------
(  842) !*          1.  set minutes.






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 17

(  843) !               ------------
(  844) 100   continue
(  845) !
(  846) !     seconds
(  847)       itm=kseconds/60
(  848)       ktime(6)=kseconds-itm*60
(  849) !
(  850) !     minutes
(  851)       ihours=itm/60
(  852)       ktime(5)=itm-ihours*60
(  853) !
(  854) !     hour
(  855)       idays=ihours/24
(  856)       ktime(4)=ihours-idays*24
(  857)       print*,'idays=',idays
(  858) !
(  859)       do 101 i=1,100
(  860)        if(idays.le.365) go to 102
(  861)        idays=idays-365
(  862)        if(mod(i,4).eq.0) idays=idays-1
(  863)  101  continue
(  864) 
(  865)  102  continue
(  866) !     year
(  867)       ktime(1)=i+1978-1
(  868) !
(  869)       print*,'idays=',idays
(  870)       do 104 i=1,12
(  871)        if(idays.lt.idm(i)) go to 103
(  872)        idays=idays-idm(i)
(  873)        if(i.eq.2) then
(  874)           if(mod(ktime(1),4).eq.0) idays=idays-1
(  875)        end if
(  876)  104  continue
(  877) 
(  878)  103  continue
(  879) !     month
(  880)       ktime(2)=i
(  881) 
(  882)       ktime(3)=idays+1
(  883) !
(  884)       return
(  885)       ENDSUBROUTINE S2YMDHMS





















NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 18

(    1) # 1 "Load_balancing.F90"
(    1)        PROGRAM Load_balancing
(    2) !
(    3) !
(    4) !**** *Load_balancing*
(    5) !
(    6) !
(    7) !     Purpose.
(    8) !     --------
(    9) !          Create load balanced input observation files for ODB loading.
(   10) !          The data are organised by subtypes, time slots, number of pools
(   11) !          and number of processors.
(   12) !
(   13) !
(   14) !**   Interface.
(   15) !     ----------
(   16) !
(   17) !
(   18) !     Method.
(   19) !     -------
(   20) !
(   21) !
(   22) !
(   23) !     Externals.
(   24) !     ----------
(   25) !
(   26) !          NONE.
(   27) !
(   28) !     Reference.
(   29) !     ----------
(   30) !
(   31) !
(   32) !     Author.
(   33) !     -------
(   34) !
(   35) !          M. Dragosavac    *ECMWF*       15/01/1010
(   36) !
(   37) !
(   38) !     Modifications.
(   39) !     --------------
(   40) !
(   41) !      B.Krzeminski      31-08-2010  Increased jbufl,jbyte,kelem for Aeolus
(   42) !      J. Munoz Sabater  Mars -2011  Changed value of jbufl,jbyte,kelem
(   43) !                                    jbufl set the max limit (in bytes) for a single bulletin sent via GTS
(   44) # 46 "Load_balancing.F90"
(   46)        implicit none
(   47) # 50 "Load_balancing.F90"
(   50)        integer, parameter :: jsup =   9
(   51)        integer, parameter :: jsec0=   3
(   52)        integer, parameter :: jsec1=  40
(   53)        integer, parameter :: jsec2=  4096
(   54)        integer, parameter :: jsec3=   4
(   55)        integer, parameter :: jsec4=   2 
(   56)        integer, parameter :: jbufl=  512000
(   57)        integer, parameter :: jbpw =  32
(   58)        integer, parameter :: jkey=  46
(   59)        integer, parameter :: jbyte= 2048000 
(   60) !       integer, parameter :: kelem=160000






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 19

(   61)        integer, parameter :: kvals=4096000
(   62)        integer, parameter :: nkey=13
(   63)        integer, parameter :: nvind=2147483647
(   64)        
(   65)        integer, dimension(jbufl) :: kbuff
(   66)        integer, dimension(jsup)  :: ksup
(   67)        integer, dimension(jsec0) :: ksec0
(   68)        integer, dimension(jsec1) :: ksec1
(   69)        integer, dimension(jsec2) :: ksec2
(   70)        integer, dimension(jsec3) :: ksec3
(   71)        integer, dimension(jsec4) :: ksec4
(   72)        integer, dimension(jkey)  :: key
(   73)        integer, dimension(6)     :: datetime1,datetime2,iymdhms
(   74)         
(   75)        real*8, dimension(kvals)    :: values
(   76) # 77 "Load_balancing.F90"
(   77)        integer, parameter :: nnn=4096000    ! size of list
(   78)        integer, parameter :: maxtsl = 1000
(   79)        integer, parameter :: nmax_stype=255
(   80)        INTEGER, DIMENSION(maxtsl)          :: timeslotno
(   81)        INTEGER, DIMENSION(maxtsl)          :: date1
(   82)        INTEGER, DIMENSION(maxtsl)          :: date2
(   83)        INTEGER, DIMENSION(maxtsl)          :: time1
(   84)        INTEGER, DIMENSION(maxtsl)          :: time2
(   85)        INTEGER, DIMENSION(maxtsl)          :: tperiod
(   86)        INTEGER, DIMENSION(maxtsl)          :: seconds1, seconds2
(   87)        INTEGER, allocatable                :: icnt(:,:)
(   88)        integer, allocatable                :: isubsets_perpool(:), isubsets(:)
(   89)        integer, allocatable                :: proc_unit(:)
(   90)        integer, allocatable                :: subsets_pertimeslot(:)
(   91)        integer, allocatable                :: subtypes(:,:)
(   92)        integer, allocatable                :: timeslot_subtype(:,:)
(   93)        integer, allocatable                :: nomsg_pertimeslot(:)
(   94)        INTEGER, DIMENSION(nmax_stype)      :: subtype_list
(   95)        integer, dimension(25)              :: i2
(   96)        integer                             :: idiff
(   97)        integer                             :: number_of_timeslots
(   98)        integer, dimension(maxtsl)          :: start_of_timeslots
(   99)        integer                             :: total_numsubsets
(  100)        integer                             :: nomsgs
(  101)        integer                             :: no_pools, pool_number
(  102)        integer                             :: number_of_pools, icomm,itmp
(  103)        integer                             :: new_numsubsets
(  104)        real*8                                :: perpool_numsubsets
(  105)        integer                             :: nummsgs
(  106)        integer                             :: pool_numsubsets
(  107)        integer                             :: nomsgs_pertimeslot
(  108)        integer                             :: i,j,n,is,iln,iz,ios,l,k
(  109)        integer                             :: ipos, kval,ij,ii,jj,ival
(  110)        integer                             :: isubtype
(  111)        real                                ::  r                          ! random number
(  112)        integer, dimension(20)              :: subtypes_list
(  113)        integer                             :: number_of_subtypes, ex_subsets
(  114)        integer                             :: iunit,iunit1,iret,ierr,iikbufl
(  115)        integer                             :: nbytpw,kbufl,ioff,istart,is_big_little,iend
(  116)        integer                             :: NPES,no_subtypes,narg,iargc
(  117)        logical                             :: in_list, found
(  118)        integer                             :: operation






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 20

(  119)      
(  120) # 121 "Load_balancing.F90"
(  121)        character(len=256) cfin, cfout, cfts, cexc
(  122)        character(len=256) field, commfile,outputfile
(  123)        character(len=256) , dimension(20) :: carg
(  124)        character(len=14) :: ytime
(  125)        character(len=20)  :: cdigit
(  126)        character(len=1)   :: write_mode
(  127) # 128 "Load_balancing.F90"
(  128)        type list_def
(  129)          integer      :: subtype
(  130)          integer      :: date
(  131)          integer      :: time
(  132)          integer      :: offset
(  133)          integer      :: data_size
(  134)          integer      :: seconds
(  135)          integer      :: timeslot_no
(  136)          integer      :: pool_number
(  137)          integer      :: processor_number
(  138)          integer      :: no_subsets
(  139)           
(  140)        end type list_def
(  141) # 142 "Load_balancing.F90"
(  142)        type (list_def), allocatable :: list(:)
(  143) # 144 "Load_balancing.F90"
(  144)        NAMELIST/INC/ operation,number_of_subtypes,subtypes_list
(  145) # 146 "Load_balancing.F90"
(  146) !-------------------------------------------------------------------------------------------
(  147)        cfin=' '
(  148)        cfout=' '
(  149)        narg=min(iargc(),size(carg))
(  150) # 151 "Load_balancing.F90"
(  151)        if(narg < 2) then
(  152)        print*,'Usage -- Load_balancing -i inputfile -p number_of_pools'// &
(  153)          & '  -o outputfile -c number_of_processers  -t timeslot_file -e exclude_subtype'
(  154)        print*,'      inputfile       -- input file name'
(  155)        print*,'      number_of_pools -- number of pools to be created '
(  156)        print*,'      outputfile      -- output file name'
(  157)        print*,'      number_of_processers -- number of processors i.e.  number of files created on output'
(  158)        print*,'      time slot file'
(  159)        print*,'      exclude_subtype -- namelist of subtypes to exclude'
(  160)        stop 'Invalid input args' 
(  161)        end if
(  162) # 163 "Load_balancing.F90"
(  163)        do  j=1,narg
(  164)         call getarg(j,carg(j))
(  165)        end do
(  166) # 167 "Load_balancing.F90"
(  167)        do j=1,narg
(  168)          if (carg(j) == '-i' .and. j<narg) then
(  169)             cfin=carg(j+1)
(  170)          elseif (carg(j) == '-o' .and. j<narg) then
(  171)             cfout=carg(j+1)
(  172)          elseif (carg(j) == '-p' .and. j<narg) then
(  173)             read(carg(j+1),*) number_of_pools
(  174)          elseif (carg(j) == '-c' .and. j<narg) then
(  175)             read(carg(j+1),*) NPES
(  176)          elseif (carg(j) == '-t' .and. j<narg) then






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 21

(  177)             cfts=carg(j+1)
(  178)          elseif (carg(j) == '-e' .and. j<narg) then
(  179)             cexc=carg(j+1)
(  180)          else
(  181)             cycle
(  182)          end if
(  183)        end do
(  184) # 185 "Load_balancing.F90"
(  185)        
(  186) !      initialise subtypes to exclude
(  187) # 188 "Load_balancing.F90"
(  188)        operation=0
(  189)        number_of_subtypes=0
(  190)        subtypes_list=-999
(  191) # 192 "Load_balancing.F90"
(  192) !      allocate( proc_unit(NPES))
(  193)        allocate( proc_unit(number_of_pools))
(  194) # 195 "Load_balancing.F90"
(  195)        nbytpw=jbpw/8
(  196)        n=0
(  197) # 199 "Load_balancing.F90"
(  199) !      Open input file, Output file, and timeslot file
(  200) # 201 "Load_balancing.F90"
(  201)       iret=0
(  202)       call pbopen(iunit,trim(cfin),'R',iret)
(  203)       if(iret.eq.-1) STOP 'Open failed'
(  204)       if(iret.eq.-2) STOP 'Invalid input file name'
(  205)       if(iret.EQ.-3) STOP 'Invalid open mode specified'
(  206) # 207 "Load_balancing.F90"
(  207) !     call pbopen(iunit1,trim(cfout),'w',iret)
(  208) # 209 "Load_balancing.F90"
(  209) !     if(iret.eq.-1) STOP 'Open failed'
(  210) !     if(iret.eq.-2) STOP 'Invalid output file name'
(  211) !     if(iret.EQ.-3) STOP 'Invalid open mode specified'
(  212) # 213 "Load_balancing.F90"
(  213)       ios=0
(  214)       print*,'Time slot file =',trim(cfts)
(  215)       open (unit=33,FILE=trim(cfts),STATUS='old',FORM='formatted',IOSTAT=ios)
(  216)       if(ios /= 0) then
(  217)        write(*,'(a,a)')  'Error opening time slot file: ',trim(cfts)
(  218)        call exit(2)
(  219)       end if
(  220) # 221 "Load_balancing.F90"
(  221)       open(47,file=trim(cexc),iostat=ios,status='OLD')
(  222)       if(ios /= 0) then
(  223)          print*,'open error ',ios,' on file ',cexc
(  224)          call exit(2)
(  225)       end if
(  226) # 227 "Load_balancing.F90"
(  227) !     Read subtypes to exclude
(  228) # 229 "Load_balancing.F90"
(  229) !
(  230)       READ (47,NML=INC)
(  231)       WRITE(*,NML=INC)
(  232) # 233 "Load_balancing.F90"
(  233) !     Read in time slot ranges
(  234) # 235 "Load_balancing.F90"
(  235)       i=0






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 22

(  236)       do while ( ios == 0 .and. i<maxtsl)
(  237)        i=i+1
(  238)        read(unit=33,fmt=*,iostat=ios) timeslotno(i), date1(i), time1(i), date2(i), time2(i)
(  239)        if(ios /= 0) then
(  240)           i=i-1
(  241)           exit
(  242)        endif
(  243)       datetime1(1)=date1(i)/10000           ! year
(  244)       idiff=date1(i)-datetime1(1)*10000
(  245)       datetime1(2)=idiff/100                ! month
(  246)       datetime1(3)=idiff-datetime1(2)*100   ! day
(  247) # 248 "Load_balancing.F90"
(  248)       datetime1(4)=time1(i)/10000           ! hour
(  249)       idiff=time1(i)-datetime1(4)*10000
(  250)       datetime1(5)=idiff/100                ! min
(  251)       datetime1(6)=idiff-datetime1(5)*100   ! sec
(  252) !
(  253)       datetime2(1)=date2(i)/10000           ! year
(  254)       idiff=date2(i)-datetime2(1)*10000
(  255)       datetime2(2)=idiff/100                ! month
(  256)       datetime2(3)=idiff-datetime2(2)*100   ! day
(  257) # 258 "Load_balancing.F90"
(  258)       datetime2(4)=time2(i)/10000           ! hour
(  259)       idiff=time2(i)-datetime2(4)*10000
(  260)       datetime2(5)=idiff/100                ! min
(  261)       datetime2(6)=idiff-datetime2(5)*100   ! sec
(  262) !
(  263) # 266 "Load_balancing.F90"
(  266)       call ymdhms2s(seconds1(i),datetime1)
(  267)       call ymdhms2s(seconds2(i),datetime2)
(  268) # 269 "Load_balancing.F90"
(  269)       tperiod(i)=seconds2(i) - seconds1(i)
(  270)       write(*,'(" t=",i5," : ",2x,i8.8,1x,i6.6," -- ",i8.8,1x,i6.6," : period =",i6," sec","soconds1=",I10," seconds2=",I10)') &
(  271)             timeslotno(i), date1(i), time1(i), date2(i), time2(i), tperiod(i), seconds1(i), seconds2(i)
(  272)       if (timeslotno(i) < 1 .or. timeslotno(i) > maxtsl) then
(  273)         write(0,*)'***Warning: Timeslot number ',timeslotno(i),' out of range: ',1,' -- ',maxtsl
(  274)         i=i-1
(  275)         cycle
(  276)       endif
(  277) # 278 "Load_balancing.F90"
(  278)       end do
(  279) # 280 "Load_balancing.F90"
(  280)       number_of_timeslots=i
(  281) # 282 "Load_balancing.F90"
(  282) !     close time slot input file
(  283) # 284 "Load_balancing.F90"
(  284)       close( 33)
(  285) # 286 "Load_balancing.F90"
(  286) !     Allocate memory for some arrays
(  287) !     -------------------------------
(  288)       allocate( icnt(number_of_timeslots+1,0:nmax_stype))
(  289)       icnt(:,:) = 0    
(  290)       allocate(subsets_pertimeslot(number_of_timeslots))
(  291)       subsets_pertimeslot(:)=0
(  292)       allocate(nomsg_pertimeslot(number_of_timeslots))
(  293)       nomsg_pertimeslot(:)=0
(  294) # 295 "Load_balancing.F90"
(  295) !      Create a list of record information






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 23

(  296) !      -----------------------------------
(  297)       no_subtypes=0
(  298)       subtype_list(:)=0
(  299) # 300 "Load_balancing.F90"
(  300)       do while(iret.ge.0)
(  301) # 302 "Load_balancing.F90"
(  302)          call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  303)          if(iret.eq.-1) exit
(  304)          n=n+1
(  305)          ierr=0
(  306)          ksec1(7)=0
(  307)          iikbufl=kbufl/nbytpw+1
(  308)          call bus012(iikbufl,kbuff,ksup,ksec0,ksec1,ksec2,ierr)
(  309)          if(ierr.ne.0) then
(  310)             print*,'Error in bus012'
(  311)             call exit(2)
(  312)          end if
(  313) # 314 "Load_balancing.F90"
(  314) !        Find number of different subtypes
(  315)          in_list=.false.
(  316)          do j=1,255
(  317)            if(subtype_list(j) == ksec1(7)) then
(  318)               in_list=.true.
(  319)            end if
(  320)          end do
(  321)          if(.not.in_list) then
(  322)            no_subtypes=no_subtypes+1
(  323)            subtype_list(no_subtypes)=ksec1(7)
(  324)          end if
(  325) # 326 "Load_balancing.F90"
(  326)       end do
(  327) # 328 "Load_balancing.F90"
(  328) !     call pbclose(iunit,iret)
(  329) # 330 "Load_balancing.F90"
(  330)       allocate ( list(n) )
(  331)       allocate ( subtypes(no_subtypes,n))
(  332)       allocate (timeslot_subtype(number_of_timeslots,n))
(  333)     
(  334) # 336 "Load_balancing.F90"
(  336)       call pbseek(iunit,0,0,iret)
(  337)       if(iret.eq.-1) then
(  338)          print*,'End of file hit'
(  339)          call exit(2)
(  340)       elseif(iret == -2) then
(  341)          print*,'Error in handling the file'
(  342)          call exit(2)
(  343)      end if
(  344) # 345 "Load_balancing.F90"
(  345)       iret=0
(  346) # 347 "Load_balancing.F90"
(  347)       n=0
(  348)       
(  349)       iret=0
(  350)       icnt(:,:)=0
(  351) # 352 "Load_balancing.F90"
(  352)       ex_subsets=0
(  353)       do while(iret.ge.0)
(  354) # 355 "Load_balancing.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 24

(  355)          call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  356)          if(iret.eq.-1) exit  
(  357) # 358 "Load_balancing.F90"
(  358)          call pbseek(iunit,0,1,iln)
(  359)          if(iln.lt.0) then
(  360)              print*,'pbseek error :',ierr
(  361)              call exit(2)
(  362)          end if
(  363) # 364 "Load_balancing.F90"
(  364)          ierr=0
(  365)          ksec1(7)=0
(  366)          iikbufl=kbufl/nbytpw+1
(  367)          call bus0123(iikbufl,kbuff,ksup,ksec0,ksec1,ksec2,ksec3,ierr)
(  368)          if(ierr.ne.0) then
(  369)             print*,'Error in bus0123'
(  370)             call exit(2)
(  371)          end if
(  372)  
(  373)          if(operation == 1 ) then
(  374) !           exclude subtypes
(  375)             found=.false.
(  376)             do iz=1,number_of_subtypes
(  377)               if(ksec1(7) == subtypes_list(iz) ) then
(  378)                  ex_subsets=ex_subsets+ksec3(3)
(  379)                  found=.true.
(  380)                  exit
(  381)               end if
(  382)             end do
(  383)             if(found) cycle
(  384)          elseif(operation == 2) then
(  385) !           include subtypes
(  386)             found=.false.
(  387)             do iz=1,number_of_subtypes
(  388)               if(ksec1(7) == subtypes_list(iz) ) then
(  389)                  found=.true.
(  390)               end if
(  391)             end do
(  392)             if(.not.found)then
(  393)                 ex_subsets=ex_subsets+ksec3(3)
(  394)                 cycle
(  395)             end if
(  396)          end if
(  397) # 398 "Load_balancing.F90"
(  398)          n=n+1
(  399)          
(  400) # 401 "Load_balancing.F90"
(  401)          list(n)%offset=iln-kbufl
(  402)          list(n)%data_size=kbufl
(  403)          list(n)%subtype=ksec1(7)
(  404)          list(n)%no_subsets=ksup(6)
(  405)        
(  406)          if(ksec0(3) <= 3 ) then
(  407)           if(ksec1(9) >=20 .and. ksec1(9) <= 100) then
(  408)              ksec1(9)=ksec1(9)+1900
(  409)           else
(  410)              ksec1(9)=ksec1(9)+2000
(  411)           end if
(  412)          end if






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 25

(  413) # 415 "Load_balancing.F90"
(  415)          list(n)%date=ksec1(9)*10000+ksec1(10)*100+ksec1(11)
(  416)      
(  417)          list(n)%time=ksec1(12)*10000+ksec1(13)*100
(  418)         
(  419) # 420 "Load_balancing.F90"
(  420)          iymdhms(1)=ksec1(9)
(  421)          iymdhms(2)=ksec1(10)
(  422)          iymdhms(3)=ksec1(11)
(  423)          iymdhms(4)=ksec1(12)
(  424)          iymdhms(5)=ksec1(13)
(  425)          iymdhms(6)=0
(  426)          call ymdhms2s(list(n)%seconds,iymdhms(1:6))
(  427) !        print*,list(n)%seconds
(  428) # 429 "Load_balancing.F90"
(  429) !        Determine timeslot number for record
(  430) !        ------------------------------------
(  431) # 432 "Load_balancing.F90"
(  432)          list(n)%timeslot_no=0
(  433)          do iz=1,number_of_timeslots
(  434)            if( list(n)%seconds >= seconds1(iz) .and. list(n)%seconds <= seconds2(iz) ) then
(  435)                list(n)%timeslot_no=iz
(  436)                icnt(iz,list(n)%subtype)= icnt(iz,list(n)%subtype)+1
(  437)                exit
(  438)            end if
(  439)          end do
(  440)          if(list(n)%timeslot_no == 0 ) then
(  441)             i = number_of_timeslots + 1
(  442)             icnt(i,list(n)%subtype) = icnt(i,list(n)%subtype) + 1
(  443)             write(*,'(a,I10,a,I10)') 'message ',n,' out of specified timeslots. Subtype ',list(n)%subtype
(  444)             write(*,'(I10,a,I10)') list(n)%date,'--', list(n)%time
(  445)          end if
(  446) # 450 "Load_balancing.F90"
(  450)       end do
(  451) # 453 "Load_balancing.F90"
(  453)       print*,'Number of subtypes=',no_subtypes
(  454)       print*,subtype_list(1:no_subtypes)
(  455)       if(operation == 1) then
(  456)          print*,'Subtypes excluded=',subtypes_list
(  457)       elseif(operation == 2) then
(  458)          print*,'Subtypes included=',subtypes_list
(  459)       else
(  460)          print*,'All subtypes used'
(  461)       end if
(  462)       print*,'Number of subsets not used', ex_subsets
(  463) # 464 "Load_balancing.F90"
(  464)       
(  465)       do i=1,number_of_timeslots
(  466)       do j=1,n
(  467)         if(list(j)%timeslot_no == i) then
(  468)            subsets_pertimeslot(i)=subsets_pertimeslot(i)+list(j)%no_subsets
(  469)            nomsg_pertimeslot(i)=nomsg_pertimeslot(i)+1
(  470)         end if
(  471)       end do
(  472)       end do
(  473) # 474 "Load_balancing.F90"
(  474) !     Print statistics about timeslots
(  475) # 476 "Load_balancing.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 26

(  476)       do i=1, number_of_timeslots
(  477)         itmp = sum(icnt(i,:))
(  478)         write(0,'(" t=",i5," : ",2x,i8.8,1x,i6.6," -- ",&
(  479)                  & i8.8,1x,i6.6," : total count=",i12," : number of subsets",i12)',advance='no') &
(  480)               timeslotno(i), date1(i), time1(i), date2(i), time2(i), itmp, subsets_pertimeslot(i)
(  481)         if (itmp > 0) then
(  482)           write(0,'(a)')', per subtype follow'
(  483)           do j=1,nmax_stype
(  484)             if (icnt(i,j) > 0) write(0,'(15x,a,i3,a,i12)') 'subtype=',j,' : ',icnt(i,j)
(  485)           enddo
(  486)         else
(  487)           write(0,'(1x)')
(  488)         endif
(  489)       enddo
(  490)       i = number_of_timeslots + 1
(  491)       itmp = sum(icnt(i,:))
(  492)       if (itmp > 0) then
(  493) # 494 "Load_balancing.F90"
(  494)         write(0,'(1x,a,i12,a)') '***Warning: ',itmp,' out of specified timeslots; counts per subtype follow:'
(  495)         do j=0,nmax_stype
(  496)           if (icnt(i,j) > 0) write(0,'(15x,a,i3,a,i12)') 'subtype=',j,' : ',icnt(i,j)
(  497)         enddo
(  498)       else
(  499)         write(0,*)'No BUFR-messages out of specified timeslots'
(  500)       endif
(  501) # 502 "Load_balancing.F90"
(  502)       itmp = sum(icnt(:,:))
(  503)       write(0,*)'Summary: ',number_of_timeslots,' timeslots ',&
(  504)                                                     itmp,' BUFR-messages'
(  505) # 507 "Load_balancing.F90"
(  507) !     end if statistics
(  508) # 509 "Load_balancing.F90"
(  509)        
(  510)        nomsgs=n
(  511) # 512 "Load_balancing.F90"
(  512) !      rewind(iunit)
(  513) # 514 "Load_balancing.F90"
(  514)        print*,nomsgs,' records to be used'
(  515) # 517 "Load_balancing.F90"
(  517) !      Make a list of records ordered by subtype within timeslot
(  518) !      ---------------------------------------------------------
(  519) # 521 "Load_balancing.F90"
(  521)        timeslot_subtype=-999
(  522)        do i=1,number_of_timeslots
(  523)        l=0
(  524)        do j=1,no_subtypes
(  525)        isubtype=subtype_list(j)
(  526)        do k=1,n
(  527)           if(list(k)%subtype == isubtype .and. list(k)%timeslot_no == i ) then
(  528)              l=l+1
(  529)              timeslot_subtype(i,l)= k
(  530)           end if
(  531)        end do
(  532)        end do
(  533)        print*,'number of records per timeslot=',l
(  534)        end do
(  535) # 537 "Load_balancing.F90"
(  537) !      Split data per timeslot over number of pools






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 27

(  538) !      --------------------------------------------
(  539) # 540 "Load_balancing.F90"
(  540)        if (number_of_pools < 1) then
(  541)           print*,'number_of_pools < 1'
(  542)           call exit(2)
(  543)        end if
(  544) # 545 "Load_balancing.F90"
(  545)        allocate(isubsets_perpool(number_of_pools))
(  546) # 547 "Load_balancing.F90"
(  547)        isubsets_perpool(:) = 0
(  548) # 549 "Load_balancing.F90"
(  549) !      Number of subsets in each message
(  550)        allocate(isubsets(nomsgs))
(  551)        isubsets(:) = 0
(  552) # 553 "Load_balancing.F90"
(  553)        
(  554)        ii=0
(  555)        do i=1,number_of_timeslots
(  556) # 557 "Load_balancing.F90"
(  557)        print*,'Timeslot --- ',i
(  558) # 559 "Load_balancing.F90"
(  559) !       new_numsubsets = subsets_pertimeslot(i)
(  560) !       ii=sum(isubsets_perpool(:))
(  561) !       total_numsubsets = ii + new_numsubsets
(  562)         new_numsubsets = subsets_pertimeslot(i)
(  563)         total_numsubsets=sum(subsets_pertimeslot(1:i))
(  564)         perpool_numsubsets = dble(total_numsubsets)/dble(number_of_pools)
(  565) # 566 "Load_balancing.F90"
(  566) !       Number of messages per timeslot
(  567)         nomsgs_pertimeslot=nomsg_pertimeslot(i)
(  568)         if(nomsgs_pertimeslot < 0) nomsgs_pertimeslot=0
(  569) # 570 "Load_balancing.F90"
(  570)         write(0,*)'nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets=',&
(  571)                 nomsgs_pertimeslot, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets
(  572)  
(  573)         call open_next_pool()
(  574) !       print*,'Pool number ---', pool_number
(  575) # 577 "Load_balancing.F90"
(  577)         iret = 0
(  578)         n=0
(  579) # 580 "Load_balancing.F90"
(  580) !       iz is message number in the list of messages
(  581) # 582 "Load_balancing.F90"
(  582)         print*,'Number of records for timeslot=',nomsg_pertimeslot(i)
(  583) # 584 "Load_balancing.F90"
(  584)         do iz=1,nomsgs
(  585)           if(list(iz)%timeslot_no == i) then
(  586)             list(iz)%pool_number=pool_number
(  587)             list(iz)%processor_number=mod(pool_number,NPES)
(  588)             if(list(iz)%processor_number == 0) list(iz)%processor_number=NPES
(  589) # 590 "Load_balancing.F90"
(  590)             n = n + 1
(  591)             pool_numsubsets = pool_numsubsets + list(iz)%no_subsets
(  592) !           print*,'iz=',iz,' subsets=',list(iz)%no_subsets
(  593) # 594 "Load_balancing.F90"
(  594)             iret=0
(  595)             if (pool_numsubsets > perpool_numsubsets) then
(  596)                 isubsets_perpool(pool_number)=pool_numsubsets






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 28

(  597)                 call open_next_pool()
(  598)                 iret=0
(  599)              end if
(  600)            end if
(  601)          end do 
(  602) # 603 "Load_balancing.F90"
(  603)          write(0,'((10i12))') isubsets_perpool(:)
(  604)          
(  605)          isubsets_perpool(pool_number)=pool_numsubsets
(  606)          ii=ii+subsets_pertimeslot(i)
(  607)        end do
(  608)        print*,'timeslot subsets =',sum(isubsets_perpool(:)),ii
(  609)       
(  610) # 613 "Load_balancing.F90"
(  613) !--    Update communication file
(  614) # 615 "Load_balancing.F90"
(  615) !      write(icomm,*) number_of_pools
(  616) !      write(icomm,'((10i12))') isubsets_perpool(:)
(  617) !      close(icomm)
(  618) # 619 "Load_balancing.F90"
(  619) !--------------------------------------------------------------------------
(  620) # 621 "Load_balancing.F90"
(  621) !      Group data from pool range into files per NPES
(  622) !      ----------------------------------------------
(  623) # 624 "Load_balancing.F90"
(  624) !      Write sorted file
(  625) !      -------------------------------
(  626) # 627 "Load_balancing.F90"
(  627) !        do j=1,NPES
(  628)          do j=1,number_of_pools    
(  629)           write(cdigit,'(i20)') j
(  630)           write(outputfile,'(a,".",a)') trim(cfout),trim(adjustl(cdigit))
(  631)           call pbopen(proc_unit(j),trim(outputfile),'W',iret)
(  632)           if(iret == -1) stop 'Open failed'
(  633)           if(iret == -2) stop 'Invalid input file name' 
(  634)           if(iret == -3) stop 'Invalid open mode specified' 
(  635)          end do
(  636) # 637 "Load_balancing.F90"
(  637)        do i=1,nomsgs
(  638) # 639 "Load_balancing.F90"
(  639)          if(list(i)%timeslot_no == 0) cycle
(  640)          ioff=list(i)%offset
(  641) !
(  642)          istart=0
(  643)          call pbseek(iunit,ioff,istart,iret)
(  644)          if(iret.lt.0) then
(  645)             print*,'pbseek: error ',iret
(  646)          end if
(  647) !
(  648)          IRET=0
(  649)          CALL PBBUFR(IUNIT,KBUFF,JBYTE,KBUFL,IRET)
(  650)          IF(IRET.EQ.-1) then
(  651)            print*,'offset=',ioff
(  652)            print*,'pbbufr : error ',iret
(  653)            STOP 'EOF'
(  654)          end if
(  655)          IF(IRET.EQ.-2) STOP 'File handling problem'
(  656)          IF(IRET.EQ.-3) STOP 'Array too small for product'






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 29

(  657)          ierr=0
(  658) # 660 "Load_balancing.F90"
(  660) !        CALL PBWRITE(proc_unit(list(i)%processor_number),KBUFF,KBUFL,IERR)
(  661)          CALL PBWRITE(proc_unit(list(i)%pool_number),KBUFF,KBUFL,IERR)
(  662)          if(ierr.lt.0) then
(  663)             print*,'Error writing into target file.'
(  664)             call exit(2)
(  665)          END IF
(  666) # 667 "Load_balancing.F90"
(  667)       end do
(  668) # 669 "Load_balancing.F90"
(  669)       contains
(  670) # 671 "Load_balancing.F90"
(  671)       SUBROUTINE OPEN_NEXT_POOL()
(  672)       implicit none
(  673)       INTEGER           :: istart_pool
(  674) # 675 "Load_balancing.F90"
(  675)       itmp = isubsets_perpool(1)
(  676)       istart_pool = 1
(  677)       do j=2,number_of_pools
(  678)         if (isubsets_perpool(j) < itmp) then
(  679)           itmp = isubsets_perpool(j)
(  680)           istart_pool = j
(  681)         endif
(  682)       enddo
(  683)       pool_number = istart_pool
(  684)       pool_numsubsets=isubsets_perpool(pool_number)
(  685) # 686 "Load_balancing.F90"
(  686)       END SUBROUTINE OPEN_NEXT_POOL
(  687) # 690 "Load_balancing.F90"
(  690)       END PROGRAM Load_balancing
(  691) # 692 "Load_balancing.F90"
(  692)       SUBROUTINE YMDHMS2S(ksec,ktime)
(  693) !
(  694) !**** *ymdhm2m*
(  695) !
(  696) !
(  697) !     purpose.
(  698) !     --------
(  699) !         calculate time in minutes since 1/1/1978,
(  700) !         given input as ktime(1)  year (1992)
(  701) !                        ktime(2)  month
(  702) !                        ktime(3)  day
(  703) !                        ktime(4)  hour
(  704) !                        ktime(5)  minute
(  705) !                        ktime(6)  second
(  706) !
(  707) !**   interface.
(  708) !     ----------
(  709) !
(  710) !         *iymdhm2m(ktime)*
(  711) !
(  712) !          input :  ktime(6)
(  713) !
(  714) !
(  715) !     method.
(  716) !     -------
(  717) !






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 30

(  718) !          none.
(  719) !
(  720) !
(  721) !     externals.
(  722) !     ----------
(  723) !
(  724) !         none.
(  725) !
(  726) !     reference.
(  727) !     ----------
(  728) !
(  729) !          none.
(  730) !
(  731) !     author.
(  732) !     -------
(  733) !
(  734) !          M. Dragosavac    *ecmwf*       21/01/2010
(  735) !
(  736) !
(  737) !     modifications.
(  738) !     --------------
(  739) !
(  740)       IMPLICIT NONE
(  741) !
(  742)       integer,dimension(6)  :: ktime
(  743) !
(  744)       integer, dimension(13)  :: idm
(  745)       integer :: idays,iy,i,ksec
(  746)       INTEGER :: ITM
(  747) !
(  748)       data idm/0,31,28,31,30,31,30,31,31,30,31,30,31/
(  749) !
(  750) !     ------------------------------------------------------------------
(  751) !*          1.  set minutes.
(  752) !               ------------
(  753) 100   continue
(  754) !
(  755)       idays=0
(  756) !
(  757)       do 101 i=1978,ktime(1)-1
(  758)        idays=idays+365
(  759)        if(mod(i,4).eq.0) idays=idays+1
(  760)  101  continue
(  761) !
(  762)       do 102 i=1,ktime(2)
(  763)        idays=idays+idm(i)
(  764)        if(i.eq.3) then
(  765)           iy=ktime(1)
(  766)           if(mod(iy,4).eq.0) idays=idays+1
(  767)        end if
(  768)  102  continue
(  769) !
(  770)       idays=idays+ktime(3)-1
(  771) !
(  772)       itm=idays*1440+ktime(4)*60+ktime(5)
(  773) !
(  774)       ksec=itm*60+ktime(6)
(  775) !






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 31

(  776)       return
(  777)       ENDSUBROUTINE YMDHMS2S
(  778) !
(  779) !
(  780)       SUBROUTINE S2YMDHMS(kseconds,ktime)
(  781) !
(  782) !**** *s2ymdhms*
(  783) !
(  784) !
(  785) !     purposeec
(  786) !     --------
(  787) !         calculate date/time  from seconds  since 1/1/1978,
(  788) !         given input as ktime(1)  year (1992)
(  789) !                        ktime(2)  month
(  790) !                        ktime(3)  day
(  791) !                        ktime(4)  hour
(  792) !                        ktime(5)  minute
(  793) !                        ktime(6)  second
(  794) !
(  795) !**   interface.
(  796) !     ----------
(  797) !
(  798) !         *s2ymdhms(kseconds,ktime)*
(  799) !
(  800) !          input :  ktime(6)
(  801) !
(  802) !
(  803) !     method.
(  804) !     -------
(  805) !
(  806) !          none.
(  807) !
(  808) !
(  809) !     externals.
(  810) !     ----------
(  811) !
(  812) !         none.
(  813) !
(  814) !     reference.
(  815) !     ----------
(  816) !
(  817) !          none.
(  818) !
(  819) !     author.
(  820) !     -------
(  821) !
(  822) !          M. Dragosavac    *ecmwf*       21/01/2010
(  823) !
(  824) !
(  825) !     modifications.
(  826) !     --------------
(  827) !
(  828) !          none.
(  829) !
(  830) !
(  831)       IMPLICIT NONE
(  832) !
(  833)       integer,dimension(6) ::  ktime






NVFORTRAN (Version     23.1)          02/24/2023  13:31:51      page 32

(  834) !
(  835)       integer, dimension(12) ::  idm
(  836)       integer  :: itm,kseconds,ihours,idays,i
(  837) !
(  838)       data idm/31,28,31,30,31,30,31,31,30,31,30,31/
(  839)   
(  840) !
(  841) !     ------------------------------------------------------------------
(  842) !*          1.  set minutes.
(  843) !               ------------
(  844) 100   continue
(  845) !
(  846) !     seconds
(  847)       itm=kseconds/60
(  848)       ktime(6)=kseconds-itm*60
(  849) !
(  850) !     minutes
(  851)       ihours=itm/60
(  852)       ktime(5)=itm-ihours*60
(  853) !
(  854) !     hour
(  855)       idays=ihours/24
(  856)       ktime(4)=ihours-idays*24
(  857)       print*,'idays=',idays
(  858) !
(  859)       do 101 i=1,100
(  860)        if(idays.le.365) go to 102
(  861)        idays=idays-365
(  862)        if(mod(i,4).eq.0) idays=idays-1
(  863)  101  continue
(  864) # 865 "Load_balancing.F90"
(  865)  102  continue
(  866) !     year
(  867)       ktime(1)=i+1978-1
(  868) !
(  869)       print*,'idays=',idays
(  870)       do 104 i=1,12
(  871)        if(idays.lt.idm(i)) go to 103
(  872)        idays=idays-idm(i)
(  873)        if(i.eq.2) then
(  874)           if(mod(ktime(1),4).eq.0) idays=idays-1
(  875)        end if
(  876)  104  continue
(  877) # 878 "Load_balancing.F90"
(  878)  103  continue
(  879) !     month
(  880)       ktime(2)=i
(  881) # 882 "Load_balancing.F90"
(  882)       ktime(3)=idays+1
(  883) !
(  884)       return
(  885)       ENDSUBROUTINE S2YMDHMS
