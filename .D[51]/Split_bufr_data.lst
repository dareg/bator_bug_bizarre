


NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: Split_bufr_data.F90

(    1)        PROGRAM Split_bufr_data
(    2) USE PARKIND1  ,ONLY : JPIM     ,JPRD
(    3) !
(    4) !
(    5) !**** *Split_bufr_data*
(    6) !
(    7) !
(    8) !     Purpose.
(    9) !     --------
(   10) !
(   11) ! 
(   12) !
(   13) !
(   14) !**   Interface.
(   15) !     ----------
(   16) !
(   17) !
(   18) !     Method.
(   19) !     -------
(   20) !
(   21) !
(   22) !
(   23) !
(   24) !
(   25) !     Externals.
(   26) !     ----------
(   27) !
(   28) !
(   29) !
(   30) !     Reference.






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 3

(   31) !     ----------
(   32) !
(   33) !
(   34) !
(   35) !     Author.
(   36) !     -------
(   37) !
(   38) !          M. Dragosavac    *ECMWF*       
(   39) !
(   40) !
(   41) !     Modifications.
(   42) !     --------------
(   43) !
(   44) !          NONE.
(   45) !          (at last one) R. El Khatib 17-Apr-2010 : dynamic allocations for Bufr arrays
(   46) !---------------------------------------------------------------------------
(   47) 
(   48) #ifdef NAG
(   49) use f90_unix_env,  only: iargc, getarg
(   50) use f90_unix_proc, only: exit
(   51) #endif
(   52) 
(   53)  use bufr_mod
(   54) 
(   55)       implicit none
(   56) 
(   57) integer, parameter                :: nmax_stype=20
(   58) 
(   59) character(len=256)                :: inputfile
(   60) character(len=256)                :: outputfile
(   61) character(len=256)                :: commfile
(   62) character(len=256)                :: outfile_prefix
(   63) character(len=256), dimension(20) :: carg
(   64) character(len=20)                 :: cdigit
(   65) 
(   66) 
(   67) INTEGER(KIND=JPIM)                           :: n, jj
(   68) INTEGER(KIND=JPIM)                           :: narg
(   69) #ifndef NAG
(   70) INTEGER(KIND=JPIM)                           :: iargc
(   71) #endif
(   72) INTEGER(KIND=JPIM)                           :: iunit,iunitout
(   73) INTEGER(KIND=JPIM)                           :: j
(   74) INTEGER(KIND=JPIM)                           :: iret
(   75) INTEGER(KIND=JPIM)                           :: icomm, itmp, ios
(   76) 
(   77) 
(   78) INTEGER(KIND=JPIM)                           :: pool_number
(   79) INTEGER(KIND=JPIM)                           :: pool_numsubsets
(   80) INTEGER(KIND=JPIM)                           :: number_of_pools
(   81) INTEGER(KIND=JPIM)                           :: new_numsubsets, total_numsubsets
(   82) INTEGER, DIMENSION(nmax_stype)               :: subtypes_list
(   83) REAL(KIND=JPRD)                              :: perpool_numsubsets
(   84) character(len=1)                             :: write_mode
(   85) 
(   86) INTEGER(KIND=JPIM)                           :: nummsgs, kbufl1
(   87) INTEGER(KIND=JPIM), allocatable              :: isubsets(:)
(   88) INTEGER(KIND=JPIM), allocatable              :: isubsets_perpool(:)






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 4

(   89) logical, allocatable                         :: LLopened(:)
(   90) INTEGER(KIND=JPIM)                           :: number_of_subtypes
(   91) character(len=256)                           :: namelist_file
(   92) integer(kind=JPIM)                           :: operation
(   93) logical                                      :: in_list
(   94) 
(   95) 
(   96) NAMELIST/INC/ operation, number_of_subtypes,subtypes_list
(   97) !---------------------------------------------------------------------------
(   98) 
(   99)     call bufr_alloc
(  100) 
(  101)     inputfile=' '
(  102)     outputfile=' '
(  103)     commfile='/dev/null'
(  104)     outfile_prefix=' '
(  105)     iret=0
(  106)     write_mode='w'
(  107)     namelist_file=' '
(  108)     number_of_subtypes=0
(  109)     subtypes_list=-999
(  110)     operation=0
(  111)     narg=min(iargc(),size(carg))
(  112) 
(  113)     if(narg < 2) then
(  114)        print*,'Usage -- split_bufr_data -i inputfile -p number_of_pools '
(  115)        print*,'                         [-c commfile]'
(  116)        print*,'                         [-a -o outfile_prefix]'
(  117)        print*,'                         [-l subtypes_list]'
(  118)        print*,'      inputfile       -- input file name'
(  119)        print*,'      number_of_pools -- number of files to be created i.e. one per pool'
(  120)        print*,'      commfile        -- communic. file to pass no. of subsets between sweeps'
(  121)        print*,'      outfile_prefix  -- prefix for output file (default=inputfile)'
(  122)        print*,'      -a              -- open output file in append mode'
(  123)        print*,'      subtypes_list    -- namelist of subtypes to exclude or include'
(  124)        call estop('Invalid input args')
(  125)     end if
(  126) 
(  127)     do  j=1,narg
(  128)       call getarg(j,carg(j))
(  129)     end do
(  130) 
(  131)     number_of_pools = 1
(  132) 
(  133)     do j=1,narg
(  134)       if (carg(j) == '-i' .and. j<narg) then
(  135)          inputfile=carg(j+1)
(  136)       elseif (carg(j) == '-c' .and. j<narg) then
(  137)          commfile=carg(j+1)
(  138)       elseif (carg(j) == '-o' .and. j<narg) then
(  139)          outfile_prefix=carg(j+1)
(  140)       elseif (carg(j) == '-p' .and. j<narg) then
(  141)          read(carg(j+1),*) number_of_pools
(  142)       elseif (carg(j) == '-l' .and. j<narg) then
(  143)          namelist_file=carg(j+1)
(  144)       elseif (carg(j) == '-a') then
(  145)          write_mode='a'
(  146)       else






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 5

(  147)          cycle
(  148)       end if
(  149)     end do
(  150) 
(  151)     if (namelist_file /= ' ') then
(  152)       open(47,file=trim(namelist_file),iostat=ios,status='OLD')
(  153)       if(ios /= 0) then
(  154)         print*,'open error ',ios,' on namelist file ',trim(namelist_file)
(  155)         call estop('Invalid namelist file')
(  156)       end if
(  157)       READ (47,NML=INC)
(  158)       WRITE(*,NML=INC)
(  159)       close(47)
(  160)     end if
(  161) 
(  162)     if (number_of_pools < 1) call estop('number_of_pools < 1')
(  163)     allocate(LLopened(number_of_pools))
(  164)     LLopened(:) = .FALSE.
(  165) 
(  166)     if (outfile_prefix == ' ') outfile_prefix = inputfile
(  167) 
(  168)     
(  169) 
(  170) !   Open communication file
(  171) 
(  172)     allocate(isubsets_perpool(number_of_pools))
(  173) 
(  174)     icomm = 33
(  175)     open(icomm, file=trim(commfile), status='unknown', iostat=ios)
(  176)     if (ios == 0) then
(  177)       read(icomm,*,err=99,end=99) itmp ! no. of pools
(  178)       if (itmp /= number_of_pools) goto 99
(  179)       read(icomm,*,err=99,end=99) isubsets_perpool(:)
(  180)       goto 98 ! all ok
(  181)     endif
(  182)  99 continue
(  183) !-- error or first time and/or file wasn't there/supplied
(  184)     isubsets_perpool(:) = 0
(  185)  98 continue
(  186)     if (commfile /= '/dev/null' .and. ios == 0) rewind(icomm)
(  187) 
(  188) !   Open input file
(  189) 
(  190)     iret=0
(  191)     call pbopen(iunit,trim(inputfile),'r',iret)
(  192)     if(iret == -1) call estop('Open failed')
(  193)     if(iret == -2) call estop('Invalid input file name')
(  194)     if(iret == -3) call estop('Invalid open mode specified')
(  195) 
(  196) !   Count number of bufr messages in input file
(  197)     !CALL util_numprod(iunit, "BUFR", nummsgs)  ! Runs slow on Cray so use alternate method
(  198)     iret = 0
(  199)     nummsgs = 0
(  200)     do while(iret == 0)
(  201)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  202)       if(iret == -1) exit
(  203)       nummsgs = nummsgs + 1
(  204)     end do






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 6

(  205)     call pbseek(iunit, 0, 0, iret)
(  206) 
(  207)     allocate(isubsets(nummsgs))
(  208)     isubsets(:) = 0
(  209) 
(  210)     iret = 0
(  211)     n = 0
(  212)     do while(iret == 0)
(  213)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  214)       if(iret == -1) exit
(  215)       if(iret == -2) call estop('File handling problem')
(  216)       kbufl1=kbufl/4+1
(  217)       ksec1(7)=0
(  218)       call bus012(kbufl1,kbuff,ksup,ksec0,ksec1,ksec2,iret)
(  219)       if(iret /= 0) call estop('bus012 error')
(  220)       if (operation == 2) then
(  221) ! check if subtype is in the list of subtypes to include
(  222)         do jj=1,  nmax_stype
(  223)           if (subtypes_list(jj) == ksec1(7)) then
(  224)             n = n + 1
(  225)             if(n > nummsgs) call estop('n > nummsgs')
(  226)             isubsets(n) = ksup(6)
(  227)             exit
(  228)           endif
(  229)         enddo
(  230)       else if (operation == 1) then
(  231) ! check if subtype is excluded
(  232)         in_list=.true.
(  233)         do jj=1,  nmax_stype
(  234)           if (subtypes_list(jj) == ksec1(7)) then
(  235)             in_list=.false.
(  236)           endif
(  237)         enddo
(  238)         if (in_list) then
(  239)           n = n + 1
(  240)           if(n > nummsgs) call estop('n > nummsgs')
(  241)           isubsets(n) = ksup(6)
(  242)         endif
(  243)       else
(  244)         n = n + 1
(  245)         if(n > nummsgs) call estop('n > nummsgs')
(  246)         isubsets(n) = ksup(6)
(  247)       endif
(  248)     end do
(  249) 
(  250) !*AF    if(n /= nummsgs) call estop('n /= nummsgs')
(  251)     n = nummsgs
(  252)     new_numsubsets = sum(isubsets(:))
(  253)     total_numsubsets = sum(isubsets_perpool(:)) + new_numsubsets
(  254)     perpool_numsubsets = dble(total_numsubsets)/dble(number_of_pools)
(  255) 
(  256)     write(0,*)'nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets=',&
(  257)                nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets
(  258) !!    write(0,'(a/(10i12))') '*isubsets=',isubsets(:)
(  259) !!    write(0,'(a/(10i12))') '>isubsets_perpool=',isubsets_perpool(:)
(  260) 
(  261)     call pbseek(iunit, 0, 0, iret)
(  262)     if(iret == -1) call estop('End-of-file is hit whilst positioning to the given byte offset')






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 7

(  263)     if(iret == -2) call estop('Error in positioning the file')
(  264) 
(  265)     call open_next_pool()
(  266) 
(  267)     n = 0
(  268)     iret = 0
(  269)     do while (iret == 0)
(  270)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  271)       if(iret == -1) exit
(  272)       if(iret == -2) call estop('File handling problem')
(  273)       if(iret == -3) call estop('The size of kbuff is not sufficient for a product')
(  274) !***********************
(  275)       kbufl1=kbufl/4+1
(  276)       ksec1(7)=0
(  277)       call bus012(kbufl1,kbuff,ksup,ksec0,ksec1,ksec2,iret)
(  278)       if(iret /= 0) call estop('bus012 error')
(  279)       if (operation == 2) then
(  280)         in_list=.false.
(  281) ! check if subtype is in the list of subtypes to include
(  282)         do jj=1,  nmax_stype
(  283)           if (subtypes_list(jj) == ksec1(7)) then
(  284)             in_list=.true.
(  285)             exit
(  286)           endif
(  287)         enddo
(  288)       else if (operation == 1) then
(  289) ! check if subtype is excluded
(  290)         in_list=.true.
(  291)         do jj=1,  nmax_stype
(  292)           if (subtypes_list(jj) == ksec1(7)) then
(  293)             in_list=.false. ! exclude subtype
(  294)           endif
(  295)         enddo
(  296)       else
(  297)         in_list=.true.
(  298)       endif
(  299) !*************
(  300)       if (in_list) then
(  301)         call pbwrite(iunitout,kbuff,kbufl,iret)
(  302)         if(iret >= 0) then
(  303)            iret=0
(  304)         else
(  305)            print*,'pbwrite error :',iret
(  306)            call exit(2)
(  307)         end if
(  308) 
(  309)         n = n + 1
(  310)         pool_numsubsets = pool_numsubsets + isubsets(n)
(  311)       endif
(  312)       iret=0
(  313)       if (pool_numsubsets > perpool_numsubsets) then
(  314)          isubsets_perpool(pool_number)=pool_numsubsets
(  315)          call pbclose(iunitout,iret)
(  316)          call open_next_pool()
(  317)          iret=0
(  318)       end if
(  319)     end do ! do while (iret == 0)
(  320) 






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 8

(  321)     isubsets_perpool(pool_number)=pool_numsubsets
(  322)     call pbclose(iunitout,iret)
(  323) 
(  324)     do j=1,number_of_pools
(  325)       if (.not.LLopened(j)) then
(  326) !!        write(0,*)'---> remaining pool#',j
(  327)         write(cdigit,'(i20)') j
(  328)         write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  329)         call pbopen(iunitout,trim(outputfile),write_mode,iret)
(  330)         if(iret == -1) call estop('Open failed')
(  331)         if(iret == -2) call estop('Invalid input file name')
(  332)         if(iret == -3) call estop('Invalid open mode specified')
(  333)         call pbclose(iunitout,iret)
(  334)       endif
(  335)     end do
(  336) 
(  337)     call pbclose(iunit,iret)
(  338) 
(  339) !-- Update communication file
(  340) if (commfile /= '/dev/null')then
(  341)   write(icomm,*) number_of_pools
(  342)   write(icomm,'((10i12))') isubsets_perpool(:)
(  343)   close(icomm)
(  344) endif
(  345) 
(  346) !!    write(0,'(a/(10i12))') '<isubsets_perpool=',isubsets_perpool(:)
(  347) 
(  348) CONTAINS
(  349) 
(  350) subroutine open_next_pool()
(  351) implicit none
(  352) INTEGER(KIND=JPIM) istart_pool
(  353) character(len=1) open_mode
(  354) itmp = isubsets_perpool(1)
(  355) istart_pool = 1
(  356) do j=2,number_of_pools
(  357)   if (isubsets_perpool(j) < itmp) then
(  358)     itmp = isubsets_perpool(j)
(  359)     istart_pool = j
(  360)   endif
(  361) enddo
(  362) pool_number = istart_pool
(  363) pool_numsubsets=isubsets_perpool(pool_number)
(  364) write(cdigit,'(i20)') pool_number
(  365) write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  366) open_mode = write_mode
(  367) if (LLopened(pool_number)) open_mode = 'a'
(  368) call pbopen(iunitout,trim(outputfile),open_mode,iret)
(  369) if(iret == -1) call estop('Open failed')
(  370) if(iret == -2) call estop('Invalid input file name')
(  371) if(iret == -3) call estop('Invalid open mode specified')
(  372) LLopened(pool_number) = .TRUE.
(  373) end subroutine open_next_pool
(  374) 
(  375) 
(  376) subroutine estop(cmsg, rc)
(  377) 
(  378) implicit none






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 9

(  379) character(len=*), intent(in) :: cmsg
(  380) INTEGER(KIND=JPIM), intent(in), optional :: rc
(  381) INTEGER(KIND=JPIM) iretcode
(  382) write(0,*) '***Error: '//cmsg
(  383) iretcode = 1
(  384) if (present(rc)) iretcode = rc
(  385) call exit(iretcode)
(  386) end subroutine estop
(  387) 
(  388) END PROGRAM Split_bufr_data






















































NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 10

(    1) # 1 "Split_bufr_data.F90"
(    1)        PROGRAM Split_bufr_data
(    2) USE PARKIND1  ,ONLY : JPIM     ,JPRD
(    3) !
(    4) !
(    5) !**** *Split_bufr_data*
(    6) !
(    7) !
(    8) !     Purpose.
(    9) !     --------
(   10) !
(   11) ! 
(   12) !
(   13) !
(   14) !**   Interface.
(   15) !     ----------
(   16) !
(   17) !
(   18) !     Method.
(   19) !     -------
(   20) !
(   21) !
(   22) !
(   23) !
(   24) !
(   25) !     Externals.
(   26) !     ----------
(   27) !
(   28) !
(   29) !
(   30) !     Reference.
(   31) !     ----------
(   32) !
(   33) !
(   34) !
(   35) !     Author.
(   36) !     -------
(   37) !
(   38) !          M. Dragosavac    *ECMWF*       
(   39) !
(   40) !
(   41) !     Modifications.
(   42) !     --------------
(   43) !
(   44) !          NONE.
(   45) !          (at last one) R. El Khatib 17-Apr-2010 : dynamic allocations for Bufr arrays
(   46) !---------------------------------------------------------------------------
(   47) # 53 "Split_bufr_data.F90"
(   53)  use bufr_mod
(   54) # 55 "Split_bufr_data.F90"
(   55)       implicit none
(   56) # 57 "Split_bufr_data.F90"
(   57) integer, parameter                :: nmax_stype=20
(   58) # 59 "Split_bufr_data.F90"
(   59) character(len=256)                :: inputfile
(   60) character(len=256)                :: outputfile
(   61) character(len=256)                :: commfile
(   62) character(len=256)                :: outfile_prefix






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 11

(   63) character(len=256), dimension(20) :: carg
(   64) character(len=20)                 :: cdigit
(   65) # 67 "Split_bufr_data.F90"
(   67) INTEGER(KIND=JPIM)                           :: n, jj
(   68) INTEGER(KIND=JPIM)                           :: narg
(   69) # 70 "Split_bufr_data.F90"
(   70) INTEGER(KIND=JPIM)                           :: iargc
(   71) # 72 "Split_bufr_data.F90"
(   72) INTEGER(KIND=JPIM)                           :: iunit,iunitout
(   73) INTEGER(KIND=JPIM)                           :: j
(   74) INTEGER(KIND=JPIM)                           :: iret
(   75) INTEGER(KIND=JPIM)                           :: icomm, itmp, ios
(   76) # 78 "Split_bufr_data.F90"
(   78) INTEGER(KIND=JPIM)                           :: pool_number
(   79) INTEGER(KIND=JPIM)                           :: pool_numsubsets
(   80) INTEGER(KIND=JPIM)                           :: number_of_pools
(   81) INTEGER(KIND=JPIM)                           :: new_numsubsets, total_numsubsets
(   82) INTEGER, DIMENSION(nmax_stype)               :: subtypes_list
(   83) REAL(KIND=JPRD)                              :: perpool_numsubsets
(   84) character(len=1)                             :: write_mode
(   85) # 86 "Split_bufr_data.F90"
(   86) INTEGER(KIND=JPIM)                           :: nummsgs, kbufl1
(   87) INTEGER(KIND=JPIM), allocatable              :: isubsets(:)
(   88) INTEGER(KIND=JPIM), allocatable              :: isubsets_perpool(:)
(   89) logical, allocatable                         :: LLopened(:)
(   90) INTEGER(KIND=JPIM)                           :: number_of_subtypes
(   91) character(len=256)                           :: namelist_file
(   92) integer(kind=JPIM)                           :: operation
(   93) logical                                      :: in_list
(   94) # 96 "Split_bufr_data.F90"
(   96) NAMELIST/INC/ operation, number_of_subtypes,subtypes_list
(   97) !---------------------------------------------------------------------------
(   98) # 99 "Split_bufr_data.F90"
(   99)     call bufr_alloc
(  100) # 101 "Split_bufr_data.F90"
(  101)     inputfile=' '
(  102)     outputfile=' '
(  103)     commfile='/dev/null'
(  104)     outfile_prefix=' '
(  105)     iret=0
(  106)     write_mode='w'
(  107)     namelist_file=' '
(  108)     number_of_subtypes=0
(  109)     subtypes_list=-999
(  110)     operation=0
(  111)     narg=min(iargc(),size(carg))
(  112) # 113 "Split_bufr_data.F90"
(  113)     if(narg < 2) then
(  114)        print*,'Usage -- split_bufr_data -i inputfile -p number_of_pools '
(  115)        print*,'                         [-c commfile]'
(  116)        print*,'                         [-a -o outfile_prefix]'
(  117)        print*,'                         [-l subtypes_list]'
(  118)        print*,'      inputfile       -- input file name'
(  119)        print*,'      number_of_pools -- number of files to be created i.e. one per pool'
(  120)        print*,'      commfile        -- communic. file to pass no. of subsets between sweeps'
(  121)        print*,'      outfile_prefix  -- prefix for output file (default=inputfile)'
(  122)        print*,'      -a              -- open output file in append mode'
(  123)        print*,'      subtypes_list    -- namelist of subtypes to exclude or include'






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 12

(  124)        call estop('Invalid input args')
(  125)     end if
(  126) # 127 "Split_bufr_data.F90"
(  127)     do  j=1,narg
(  128)       call getarg(j,carg(j))
(  129)     end do
(  130) # 131 "Split_bufr_data.F90"
(  131)     number_of_pools = 1
(  132) # 133 "Split_bufr_data.F90"
(  133)     do j=1,narg
(  134)       if (carg(j) == '-i' .and. j<narg) then
(  135)          inputfile=carg(j+1)
(  136)       elseif (carg(j) == '-c' .and. j<narg) then
(  137)          commfile=carg(j+1)
(  138)       elseif (carg(j) == '-o' .and. j<narg) then
(  139)          outfile_prefix=carg(j+1)
(  140)       elseif (carg(j) == '-p' .and. j<narg) then
(  141)          read(carg(j+1),*) number_of_pools
(  142)       elseif (carg(j) == '-l' .and. j<narg) then
(  143)          namelist_file=carg(j+1)
(  144)       elseif (carg(j) == '-a') then
(  145)          write_mode='a'
(  146)       else
(  147)          cycle
(  148)       end if
(  149)     end do
(  150) # 151 "Split_bufr_data.F90"
(  151)     if (namelist_file /= ' ') then
(  152)       open(47,file=trim(namelist_file),iostat=ios,status='OLD')
(  153)       if(ios /= 0) then
(  154)         print*,'open error ',ios,' on namelist file ',trim(namelist_file)
(  155)         call estop('Invalid namelist file')
(  156)       end if
(  157)       READ (47,NML=INC)
(  158)       WRITE(*,NML=INC)
(  159)       close(47)
(  160)     end if
(  161) # 162 "Split_bufr_data.F90"
(  162)     if (number_of_pools < 1) call estop('number_of_pools < 1')
(  163)     allocate(LLopened(number_of_pools))
(  164)     LLopened(:) = .FALSE.
(  165) # 166 "Split_bufr_data.F90"
(  166)     if (outfile_prefix == ' ') outfile_prefix = inputfile
(  167) # 168 "Split_bufr_data.F90"
(  168)     
(  169) # 170 "Split_bufr_data.F90"
(  170) !   Open communication file
(  171) # 172 "Split_bufr_data.F90"
(  172)     allocate(isubsets_perpool(number_of_pools))
(  173) # 174 "Split_bufr_data.F90"
(  174)     icomm = 33
(  175)     open(icomm, file=trim(commfile), status='unknown', iostat=ios)
(  176)     if (ios == 0) then
(  177)       read(icomm,*,err=99,end=99) itmp ! no. of pools
(  178)       if (itmp /= number_of_pools) goto 99
(  179)       read(icomm,*,err=99,end=99) isubsets_perpool(:)
(  180)       goto 98 ! all ok
(  181)     endif






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 13

(  182)  99 continue
(  183) !-- error or first time and/or file wasn't there/supplied
(  184)     isubsets_perpool(:) = 0
(  185)  98 continue
(  186)     if (commfile /= '/dev/null' .and. ios == 0) rewind(icomm)
(  187) # 188 "Split_bufr_data.F90"
(  188) !   Open input file
(  189) # 190 "Split_bufr_data.F90"
(  190)     iret=0
(  191)     call pbopen(iunit,trim(inputfile),'r',iret)
(  192)     if(iret == -1) call estop('Open failed')
(  193)     if(iret == -2) call estop('Invalid input file name')
(  194)     if(iret == -3) call estop('Invalid open mode specified')
(  195) # 196 "Split_bufr_data.F90"
(  196) !   Count number of bufr messages in input file
(  197)     !CALL util_numprod(iunit, "BUFR", nummsgs)  ! Runs slow on Cray so use alternate method
(  198)     iret = 0
(  199)     nummsgs = 0
(  200)     do while(iret == 0)
(  201)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  202)       if(iret == -1) exit
(  203)       nummsgs = nummsgs + 1
(  204)     end do
(  205)     call pbseek(iunit, 0, 0, iret)
(  206) # 207 "Split_bufr_data.F90"
(  207)     allocate(isubsets(nummsgs))
(  208)     isubsets(:) = 0
(  209) # 210 "Split_bufr_data.F90"
(  210)     iret = 0
(  211)     n = 0
(  212)     do while(iret == 0)
(  213)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  214)       if(iret == -1) exit
(  215)       if(iret == -2) call estop('File handling problem')
(  216)       kbufl1=kbufl/4+1
(  217)       ksec1(7)=0
(  218)       call bus012(kbufl1,kbuff,ksup,ksec0,ksec1,ksec2,iret)
(  219)       if(iret /= 0) call estop('bus012 error')
(  220)       if (operation == 2) then
(  221) ! check if subtype is in the list of subtypes to include
(  222)         do jj=1,  nmax_stype
(  223)           if (subtypes_list(jj) == ksec1(7)) then
(  224)             n = n + 1
(  225)             if(n > nummsgs) call estop('n > nummsgs')
(  226)             isubsets(n) = ksup(6)
(  227)             exit
(  228)           endif
(  229)         enddo
(  230)       else if (operation == 1) then
(  231) ! check if subtype is excluded
(  232)         in_list=.true.
(  233)         do jj=1,  nmax_stype
(  234)           if (subtypes_list(jj) == ksec1(7)) then
(  235)             in_list=.false.
(  236)           endif
(  237)         enddo
(  238)         if (in_list) then
(  239)           n = n + 1






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 14

(  240)           if(n > nummsgs) call estop('n > nummsgs')
(  241)           isubsets(n) = ksup(6)
(  242)         endif
(  243)       else
(  244)         n = n + 1
(  245)         if(n > nummsgs) call estop('n > nummsgs')
(  246)         isubsets(n) = ksup(6)
(  247)       endif
(  248)     end do
(  249) # 250 "Split_bufr_data.F90"
(  250) !*AF    if(n /= nummsgs) call estop('n /= nummsgs')
(  251)     n = nummsgs
(  252)     new_numsubsets = sum(isubsets(:))
(  253)     total_numsubsets = sum(isubsets_perpool(:)) + new_numsubsets
(  254)     perpool_numsubsets = dble(total_numsubsets)/dble(number_of_pools)
(  255) # 256 "Split_bufr_data.F90"
(  256)     write(0,*)'nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets=',&
(  257)                nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets
(  258) !!    write(0,'(a/(10i12))') '*isubsets=',isubsets(:)
(  259) !!    write(0,'(a/(10i12))') '>isubsets_perpool=',isubsets_perpool(:)
(  260) # 261 "Split_bufr_data.F90"
(  261)     call pbseek(iunit, 0, 0, iret)
(  262)     if(iret == -1) call estop('End-of-file is hit whilst positioning to the given byte offset')
(  263)     if(iret == -2) call estop('Error in positioning the file')
(  264) # 265 "Split_bufr_data.F90"
(  265)     call open_next_pool()
(  266) # 267 "Split_bufr_data.F90"
(  267)     n = 0
(  268)     iret = 0
(  269)     do while (iret == 0)
(  270)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  271)       if(iret == -1) exit
(  272)       if(iret == -2) call estop('File handling problem')
(  273)       if(iret == -3) call estop('The size of kbuff is not sufficient for a product')
(  274) !***********************
(  275)       kbufl1=kbufl/4+1
(  276)       ksec1(7)=0
(  277)       call bus012(kbufl1,kbuff,ksup,ksec0,ksec1,ksec2,iret)
(  278)       if(iret /= 0) call estop('bus012 error')
(  279)       if (operation == 2) then
(  280)         in_list=.false.
(  281) ! check if subtype is in the list of subtypes to include
(  282)         do jj=1,  nmax_stype
(  283)           if (subtypes_list(jj) == ksec1(7)) then
(  284)             in_list=.true.
(  285)             exit
(  286)           endif
(  287)         enddo
(  288)       else if (operation == 1) then
(  289) ! check if subtype is excluded
(  290)         in_list=.true.
(  291)         do jj=1,  nmax_stype
(  292)           if (subtypes_list(jj) == ksec1(7)) then
(  293)             in_list=.false. ! exclude subtype
(  294)           endif
(  295)         enddo
(  296)       else
(  297)         in_list=.true.






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 15

(  298)       endif
(  299) !*************
(  300)       if (in_list) then
(  301)         call pbwrite(iunitout,kbuff,kbufl,iret)
(  302)         if(iret >= 0) then
(  303)            iret=0
(  304)         else
(  305)            print*,'pbwrite error :',iret
(  306)            call exit(2)
(  307)         end if
(  308) # 309 "Split_bufr_data.F90"
(  309)         n = n + 1
(  310)         pool_numsubsets = pool_numsubsets + isubsets(n)
(  311)       endif
(  312)       iret=0
(  313)       if (pool_numsubsets > perpool_numsubsets) then
(  314)          isubsets_perpool(pool_number)=pool_numsubsets
(  315)          call pbclose(iunitout,iret)
(  316)          call open_next_pool()
(  317)          iret=0
(  318)       end if
(  319)     end do ! do while (iret == 0)
(  320) # 321 "Split_bufr_data.F90"
(  321)     isubsets_perpool(pool_number)=pool_numsubsets
(  322)     call pbclose(iunitout,iret)
(  323) # 324 "Split_bufr_data.F90"
(  324)     do j=1,number_of_pools
(  325)       if (.not.LLopened(j)) then
(  326) !!        write(0,*)'---> remaining pool#',j
(  327)         write(cdigit,'(i20)') j
(  328)         write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  329)         call pbopen(iunitout,trim(outputfile),write_mode,iret)
(  330)         if(iret == -1) call estop('Open failed')
(  331)         if(iret == -2) call estop('Invalid input file name')
(  332)         if(iret == -3) call estop('Invalid open mode specified')
(  333)         call pbclose(iunitout,iret)
(  334)       endif
(  335)     end do
(  336) # 337 "Split_bufr_data.F90"
(  337)     call pbclose(iunit,iret)
(  338) # 339 "Split_bufr_data.F90"
(  339) !-- Update communication file
(  340) if (commfile /= '/dev/null')then
(  341)   write(icomm,*) number_of_pools
(  342)   write(icomm,'((10i12))') isubsets_perpool(:)
(  343)   close(icomm)
(  344) endif
(  345) # 346 "Split_bufr_data.F90"
(  346) !!    write(0,'(a/(10i12))') '<isubsets_perpool=',isubsets_perpool(:)
(  347) # 348 "Split_bufr_data.F90"
(  348) CONTAINS
(  349) # 350 "Split_bufr_data.F90"
(  350) subroutine open_next_pool()
(  351) implicit none
(  352) INTEGER(KIND=JPIM) istart_pool
(  353) character(len=1) open_mode
(  354) itmp = isubsets_perpool(1)
(  355) istart_pool = 1






NVFORTRAN (Version     23.1)          02/24/2023  13:50:11      page 16

(  356) do j=2,number_of_pools
(  357)   if (isubsets_perpool(j) < itmp) then
(  358)     itmp = isubsets_perpool(j)
(  359)     istart_pool = j
(  360)   endif
(  361) enddo
(  362) pool_number = istart_pool
(  363) pool_numsubsets=isubsets_perpool(pool_number)
(  364) write(cdigit,'(i20)') pool_number
(  365) write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  366) open_mode = write_mode
(  367) if (LLopened(pool_number)) open_mode = 'a'
(  368) call pbopen(iunitout,trim(outputfile),open_mode,iret)
(  369) if(iret == -1) call estop('Open failed')
(  370) if(iret == -2) call estop('Invalid input file name')
(  371) if(iret == -3) call estop('Invalid open mode specified')
(  372) LLopened(pool_number) = .TRUE.
(  373) end subroutine open_next_pool
(  374) # 376 "Split_bufr_data.F90"
(  376) subroutine estop(cmsg, rc)
(  377) # 378 "Split_bufr_data.F90"
(  378) implicit none
(  379) character(len=*), intent(in) :: cmsg
(  380) INTEGER(KIND=JPIM), intent(in), optional :: rc
(  381) INTEGER(KIND=JPIM) iretcode
(  382) write(0,*) '***Error: '//cmsg
(  383) iretcode = 1
(  384) if (present(rc)) iretcode = rc
(  385) call exit(iretcode)
(  386) end subroutine estop
(  387) # 388 "Split_bufr_data.F90"
(  388) END PROGRAM Split_bufr_data
