


NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: Split_bufr_per_subtype.F90

(    1)        PROGRAM Split_bufr_data
(    2) USE PARKIND1  ,ONLY : JPIM     ,JPRD
(    3) !
(    4) !
(    5) !**** *Split_bufr_data*
(    6) !
(    7) !
(    8) !     Purpose.
(    9) !     --------
(   10) !
(   11) ! 
(   12) !
(   13) !
(   14) !**   Interface.
(   15) !     ----------
(   16) !
(   17) !
(   18) !     Method.
(   19) !     -------
(   20) !
(   21) !
(   22) !
(   23) !
(   24) !
(   25) !     Externals.
(   26) !     ----------
(   27) !
(   28) !
(   29) !
(   30) !     Reference.






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 3

(   31) !     ----------
(   32) !
(   33) !
(   34) !
(   35) !     Author.
(   36) !     -------
(   37) !
(   38) !          M. Dragosavac    *ECMWF*       
(   39) !
(   40) !
(   41) !     Modifications.
(   42) !     --------------
(   43) !
(   44) !          NONE.
(   45) !          (at last one) R. El Khatib 17-Apr-2010 : dynamic allocations for Bufr arrays
(   46) !---------------------------------------------------------------------------
(   47) 
(   48) #ifdef NAG
(   49) use f90_unix_env,  only: iargc, getarg
(   50) use f90_unix_proc, only: exit
(   51) #endif
(   52) 
(   53)  use bufr_mod
(   54) 
(   55)       implicit none
(   56) 
(   57) integer, parameter                :: nmax_stype=50
(   58) 
(   59) character(len=256)                :: inputfile
(   60) character(len=256)                :: outputfile
(   61) character(len=256)                :: commfile
(   62) character(len=256)                :: outfile_prefix
(   63) character(len=256), dimension(20) :: carg
(   64) character(len=20)                 :: cdigit
(   65) 
(   66) 
(   67) INTEGER(KIND=JPIM)                           :: n, jj
(   68) INTEGER(KIND=JPIM)                           :: narg
(   69) #ifndef NAG
(   70) INTEGER(KIND=JPIM)                           :: iargc
(   71) #endif
(   72) INTEGER(KIND=JPIM)                           :: iunit,iunitout
(   73) INTEGER(KIND=JPIM)                           :: j
(   74) INTEGER(KIND=JPIM)                           :: iret
(   75) INTEGER(KIND=JPIM)                           :: icomm, itmp, ios
(   76) 
(   77) 
(   78) INTEGER(KIND=JPIM)                           :: pool_number
(   79) INTEGER(KIND=JPIM)                           :: pool_numsubsets
(   80) INTEGER(KIND=JPIM)                           :: number_of_pools
(   81) INTEGER(KIND=JPIM)                           :: new_numsubsets, total_numsubsets
(   82) INTEGER, DIMENSION(nmax_stype)               :: subtypes_list
(   83) INTEGER, DIMENSION(nmax_stype)               :: subtypes_found
(   84) REAL(KIND=JPRD), DIMENSION(nmax_stype)       :: subtypes_count
(   85) REAL(KIND=JPRD), DIMENSION(nmax_stype)       :: subtypes_current_count
(   86) INTEGER(KIND=JPIM), DIMENSION(nmax_stype)    :: subtypes_current_poolno
(   87) REAL(KIND=JPRD)                              :: perpool_numsubsets
(   88) character(len=1)                             :: write_mode






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 4

(   89) 
(   90) INTEGER(KIND=JPIM)                           :: nummsgs, kbufl1
(   91) INTEGER(KIND=JPIM)                           :: nb_subtypes, current_subtype
(   92) INTEGER(KIND=JPIM), allocatable              :: isubsets(:)
(   93) INTEGER(KIND=JPIM), allocatable              :: isubsets_perpool(:)
(   94) logical, allocatable                         :: LLopened(:)
(   95) INTEGER(KIND=JPIM)                           :: number_of_subtypes
(   96) character(len=256)                           :: namelist_file
(   97) integer(kind=JPIM)                           :: operation
(   98) logical                                      :: in_list
(   99) 
(  100) 
(  101) NAMELIST/INC/ operation, number_of_subtypes,subtypes_list
(  102) !---------------------------------------------------------------------------
(  103) 
(  104) 
(  105)     call bufr_alloc
(  106) 
(  107)     inputfile=' '
(  108)     outputfile=' '
(  109)     commfile='/dev/null'
(  110)     outfile_prefix=' '
(  111)     iret=0
(  112)     write_mode='w'
(  113)     namelist_file=' '
(  114)     number_of_subtypes=0
(  115)     subtypes_list=-999
(  116)     operation=0
(  117)     narg=min(iargc(),size(carg))
(  118) 
(  119)     if(narg < 2) then
(  120)        print*,'Usage -- split_bufr_data -i inputfile -p number_of_pools '
(  121)        print*,'                         [-c commfile]'
(  122)        print*,'                         [-a -o outfile_prefix]'
(  123)        print*,'                         [-l subtypes_list]'
(  124)        print*,'      inputfile       -- input file name'
(  125)        print*,'      number_of_pools -- number of files to be created i.e. one per pool'
(  126)        print*,'      commfile        -- communic. file to pass no. of subsets between sweeps'
(  127)        print*,'      outfile_prefix  -- prefix for output file (default=inputfile)'
(  128)        print*,'      -a              -- open output file in append mode'
(  129)        print*,'      subtypes_list    -- namelist of subtypes to exclude or include'
(  130)        call estop('Invalid input args')
(  131)     end if
(  132) 
(  133)     do  j=1,narg
(  134)       call getarg(j,carg(j))
(  135)     end do
(  136) 
(  137)     number_of_pools = 1
(  138) 
(  139)     do j=1,narg
(  140)       if (carg(j) == '-i' .and. j<narg) then
(  141)          inputfile=carg(j+1)
(  142)       elseif (carg(j) == '-c' .and. j<narg) then
(  143)          commfile=carg(j+1)
(  144)       elseif (carg(j) == '-o' .and. j<narg) then
(  145)          outfile_prefix=carg(j+1)
(  146)       elseif (carg(j) == '-p' .and. j<narg) then






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 5

(  147)          read(carg(j+1),*) number_of_pools
(  148)       elseif (carg(j) == '-l' .and. j<narg) then
(  149)          namelist_file=carg(j+1)
(  150)       elseif (carg(j) == '-a') then
(  151)          write_mode='a'
(  152)       else
(  153)          cycle
(  154)       end if
(  155)     end do
(  156) 
(  157)     if (namelist_file /= ' ') then
(  158)       open(47,file=trim(namelist_file),iostat=ios,status='OLD')
(  159)       if(ios /= 0) then
(  160)         print*,'open error ',ios,' on namelist file ',trim(namelist_file)
(  161)         call estop('Invalid namelist file')
(  162)       end if
(  163)       READ (47,NML=INC)
(  164)       WRITE(*,NML=INC)
(  165)       close(47)
(  166)     end if
(  167) 
(  168)     if (number_of_pools < 1) call estop('number_of_pools < 1')
(  169)     allocate(LLopened(number_of_pools))
(  170)     LLopened(:) = .FALSE.
(  171) 
(  172)     if (outfile_prefix == ' ') outfile_prefix = inputfile
(  173) 
(  174)     
(  175) 
(  176) !   Open communication file
(  177) 
(  178)     allocate(isubsets_perpool(number_of_pools))
(  179) 
(  180)     icomm = 33
(  181)     open(icomm, file=trim(commfile), status='unknown', iostat=ios)
(  182)     if (ios == 0) then
(  183)       read(icomm,*,err=99,end=99) itmp ! no. of pools
(  184)       if (itmp /= number_of_pools) goto 99
(  185)       read(icomm,*,err=99,end=99) isubsets_perpool(:)
(  186)       goto 98 ! all ok
(  187)     endif
(  188)  99 continue
(  189) !-- error or first time and/or file wasn't there/supplied
(  190)     isubsets_perpool(:) = 0
(  191)  98 continue
(  192)     if (commfile /= '/dev/null' .and. ios == 0)rewind(icomm)
(  193) 
(  194) !   Open input file
(  195) 
(  196)     iret=0
(  197)     call pbopen(iunit,trim(inputfile),'r',iret)
(  198)     if(iret == -1) call estop('Open failed')
(  199)     if(iret == -2) call estop('Invalid input file name')
(  200)     if(iret == -3) call estop('Invalid open mode specified')
(  201) 
(  202)     CALL util_numprod(iunit, "BUFR", nummsgs)
(  203)     allocate(isubsets(nummsgs))
(  204)     isubsets(:) = 0






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 6

(  205) 
(  206)     iret = 0
(  207)     n = 0
(  208)     subtypes_found(:)= -1
(  209)     subtypes_count(:)= 0
(  210)     nb_subtypes=0
(  211)     do while(iret == 0)
(  212)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  213)       if(iret == -1) exit
(  214)       if(iret == -2) call estop('File handling problem')
(  215)       kbufl1=kbufl/4+1
(  216)       ksec1(7)=0
(  217)       call bus012(kbufl1,kbuff,ksup,ksec0,ksec1,ksec2,iret)
(  218)       if(iret /= 0) call estop('bus012 error')
(  219)       in_list=.false.
(  220)       do jj=1,  nmax_stype
(  221)         if (subtypes_found(jj) == ksec1(7)) then
(  222)           in_list=.true.
(  223)       subtypes_count(jj) = subtypes_count(jj) + 1
(  224)           exit
(  225)         endif 
(  226)       enddo
(  227)       if (.not. in_list) then ! the current subtype is new
(  228)         nb_subtypes=nb_subtypes+1
(  229)         subtypes_found(nb_subtypes) = ksec1(7)
(  230)         subtypes_count(nb_subtypes) = 1
(  231)       endif
(  232)       if (operation == 2) then
(  233) ! check if subtype is in the list of subtypes to include
(  234)         do jj=1,  nmax_stype
(  235)           if (subtypes_list(jj) == ksec1(7)) then
(  236)             n = n + 1
(  237)             if(n > nummsgs) call estop('n > nummsgs')
(  238)             isubsets(n) = ksup(6)
(  239)             exit
(  240)           endif
(  241)         enddo
(  242)       else if (operation == 1) then
(  243) ! check if subtype is excluded
(  244)         in_list=.true.
(  245)         do jj=1,  nmax_stype
(  246)           if (subtypes_list(jj) == ksec1(7)) then
(  247)             in_list=.false.
(  248)           endif
(  249)         enddo
(  250)         if (in_list) then
(  251)           n = n + 1
(  252)           if(n > nummsgs) call estop('n > nummsgs')
(  253)           isubsets(n) = ksup(6)
(  254)         endif
(  255)       else
(  256)         n = n + 1
(  257)         if(n > nummsgs) call estop('n > nummsgs')
(  258)         isubsets(n) = ksup(6)
(  259)       endif
(  260)     end do
(  261) 
(  262)    do jj=1, nmax_stype






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 7

(  263)        write(0,*) 'BEFORE division subtype ', subtypes_found(jj), ' nb nessages par pools = ', subtypes_count(jj)
(  264)    enddo
(  265) 
(  266)    do jj=1, nmax_stype
(  267)      if (subtypes_found(jj) > 0) then
(  268)        subtypes_count(jj) = subtypes_count(jj)/dble(number_of_pools) 
(  269)        if (subtypes_count(jj) < 1) subtypes_count(jj)=1
(  270)        write(0,*) 'subtype ', subtypes_found(jj), ' nb nessages par pools = ', subtypes_count(jj)
(  271)      endif
(  272)    enddo
(  273) !*AF    if(n /= nummsgs) call estop('n /= nummsgs')
(  274)     n = nummsgs
(  275)     new_numsubsets = sum(isubsets(:))
(  276)     total_numsubsets = sum(isubsets_perpool(:)) + new_numsubsets
(  277)     perpool_numsubsets = dble(total_numsubsets)/dble(number_of_pools)
(  278) 
(  279)     write(0,*)'nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets=',&
(  280)                nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets
(  281) !!    write(0,'(a/(10i12))') '*isubsets=',isubsets(:)
(  282) !!    write(0,'(a/(10i12))') '>isubsets_perpool=',isubsets_perpool(:)
(  283) 
(  284)     call pbseek(iunit, 0, 0, iret)
(  285)     if(iret == -1) call estop('End-of-file is hit whilst positioning to the given byte offset')
(  286)     if(iret == -2) call estop('Error in positioning the file')
(  287) 
(  288)     call open_pool(1)
(  289) 
(  290)     n = 0
(  291)     iret = 0
(  292)     subtypes_current_count(:)=0
(  293)     subtypes_current_poolno(:)=1
(  294)     do while (iret == 0)
(  295)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  296)       if(iret == -1) exit
(  297)       if(iret == -2) call estop('File handling problem')
(  298)       if(iret == -3) call estop('The size of kbuff is not sufficient for a product')
(  299) !***********************
(  300)       kbufl1=kbufl/4+1
(  301)       ksec1(7)=0
(  302)       call bus012(kbufl1,kbuff,ksup,ksec0,ksec1,ksec2,iret)
(  303)       if(iret /= 0) call estop('bus012 error')
(  304)       in_list=.false.
(  305)       do current_subtype=1,  nmax_stype
(  306)         if (subtypes_found(current_subtype) == ksec1(7)) then
(  307)           in_list=.true.
(  308)           exit
(  309)         endif 
(  310)       enddo
(  311)       if (subtypes_found(current_subtype) > 0) then
(  312)         subtypes_current_count(current_subtype) = subtypes_current_count(current_subtype) + 1
(  313)       endif
(  314)       if (operation == 2) then
(  315)         in_list=.false.
(  316) ! check if subtype is in the list of subtypes to include
(  317)         do jj=1,  nmax_stype
(  318)           if (subtypes_list(jj) == ksec1(7)) then
(  319)             in_list=.true.
(  320)             exit






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 8

(  321)           endif
(  322)         enddo
(  323)       else if (operation == 1) then
(  324) ! check if subtype is excluded
(  325)         in_list=.true.
(  326)         do jj=1,  nmax_stype
(  327)           if (subtypes_list(jj) == ksec1(7)) then
(  328)             in_list=.false. ! exclude subtype
(  329)           endif
(  330)         enddo
(  331)       else
(  332)         in_list=.true.
(  333)       endif
(  334) !*************
(  335)       if (in_list) then
(  336)         call pbwrite(iunitout,kbuff,kbufl,iret)
(  337)         if(iret >= 0) then
(  338)            iret=0
(  339)         else
(  340)            print*,'pbwrite error :',iret
(  341)            call exit(2)
(  342)         end if
(  343) 
(  344)         n = n + 1
(  345)         pool_numsubsets = pool_numsubsets + isubsets(n)
(  346)       endif
(  347)       iret=0
(  348)       if (subtypes_current_count(current_subtype) >= subtypes_count(current_subtype)) then
(  349)          subtypes_current_poolno(current_subtype) = subtypes_current_poolno(current_subtype) + 1
(  350)          subtypes_current_count(current_subtype) = 1
(  351)          if (subtypes_current_poolno(current_subtype) > number_of_pools) subtypes_current_poolno(current_subtype) =1
(  352)          isubsets_perpool(pool_number)=pool_numsubsets
(  353)          call pbclose(iunitout,iret)
(  354)          call open_pool(subtypes_current_poolno(current_subtype))
(  355)          iret=0
(  356)       end if
(  357)     end do ! do while (iret == 0)
(  358) 
(  359)     isubsets_perpool(pool_number)=pool_numsubsets
(  360)     call pbclose(iunitout,iret)
(  361) 
(  362)     do j=1,number_of_pools
(  363)       if (.not.LLopened(j)) then
(  364) !!        write(0,*)'---> remaining pool#',j
(  365)         write(cdigit,'(i20)') j
(  366)         write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  367)         call pbopen(iunitout,trim(outputfile),write_mode,iret)
(  368)         if(iret == -1) call estop('Open failed')
(  369)         if(iret == -2) call estop('Invalid input file name')
(  370)         if(iret == -3) call estop('Invalid open mode specified')
(  371)         call pbclose(iunitout,iret)
(  372)       endif
(  373)     end do
(  374) 
(  375)     call pbclose(iunit,iret)
(  376) 
(  377) !-- Update communication file
(  378) if (commfile /= '/dev/null')then






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 9

(  379)   write(icomm,*) number_of_pools
(  380)   write(icomm,'((10i12))') isubsets_perpool(:)
(  381)   close(icomm)
(  382) endif
(  383) 
(  384) !!    write(0,'(a/(10i12))') '<isubsets_perpool=',isubsets_perpool(:)
(  385) 
(  386) CONTAINS
(  387) 
(  388) subroutine open_pool(poolno)
(  389) implicit none
(  390) INTEGER(KIND=JPIM), intent(in) :: poolno
(  391) character(len=1)               :: open_mode
(  392) pool_number = poolno
(  393) pool_numsubsets=isubsets_perpool(pool_number)
(  394) write(cdigit,'(i20)') pool_number
(  395) write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  396) open_mode = write_mode
(  397) if (LLopened(pool_number)) open_mode = 'a'
(  398) call pbopen(iunitout,trim(outputfile),open_mode,iret)
(  399) if(iret == -1) call estop('Open failed')
(  400) if(iret == -2) call estop('Invalid input file name')
(  401) if(iret == -3) call estop('Invalid open mode specified')
(  402) LLopened(pool_number) = .TRUE.
(  403) end subroutine open_pool
(  404) 
(  405) subroutine open_next_pool()
(  406) implicit none
(  407) INTEGER(KIND=JPIM) istart_pool
(  408) character(len=1) open_mode
(  409) itmp = isubsets_perpool(1)
(  410) istart_pool = 1
(  411) do j=2,number_of_pools
(  412)   if (isubsets_perpool(j) < itmp) then
(  413)     itmp = isubsets_perpool(j)
(  414)     istart_pool = j
(  415)   endif
(  416) enddo
(  417) pool_number = istart_pool
(  418) pool_numsubsets=isubsets_perpool(pool_number)
(  419) write(cdigit,'(i20)') pool_number
(  420) write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  421) open_mode = write_mode
(  422) if (LLopened(pool_number)) open_mode = 'a'
(  423) call pbopen(iunitout,trim(outputfile),open_mode,iret)
(  424) if(iret == -1) call estop('Open failed')
(  425) if(iret == -2) call estop('Invalid input file name')
(  426) if(iret == -3) call estop('Invalid open mode specified')
(  427) LLopened(pool_number) = .TRUE.
(  428) end subroutine open_next_pool
(  429) 
(  430) 
(  431) subroutine estop(cmsg, rc)
(  432) 
(  433) implicit none
(  434) character(len=*), intent(in) :: cmsg
(  435) INTEGER(KIND=JPIM), intent(in), optional :: rc
(  436) INTEGER(KIND=JPIM) iretcode






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 10

(  437) write(0,*) '***Error: '//cmsg
(  438) iretcode = 1
(  439) if (present(rc)) iretcode = rc
(  440) call exit(iretcode)
(  441) end subroutine estop
(  442) 
(  443) END PROGRAM Split_bufr_data

























































NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 11

(    1) # 1 "Split_bufr_per_subtype.F90"
(    1)        PROGRAM Split_bufr_data
(    2) USE PARKIND1  ,ONLY : JPIM     ,JPRD
(    3) !
(    4) !
(    5) !**** *Split_bufr_data*
(    6) !
(    7) !
(    8) !     Purpose.
(    9) !     --------
(   10) !
(   11) ! 
(   12) !
(   13) !
(   14) !**   Interface.
(   15) !     ----------
(   16) !
(   17) !
(   18) !     Method.
(   19) !     -------
(   20) !
(   21) !
(   22) !
(   23) !
(   24) !
(   25) !     Externals.
(   26) !     ----------
(   27) !
(   28) !
(   29) !
(   30) !     Reference.
(   31) !     ----------
(   32) !
(   33) !
(   34) !
(   35) !     Author.
(   36) !     -------
(   37) !
(   38) !          M. Dragosavac    *ECMWF*       
(   39) !
(   40) !
(   41) !     Modifications.
(   42) !     --------------
(   43) !
(   44) !          NONE.
(   45) !          (at last one) R. El Khatib 17-Apr-2010 : dynamic allocations for Bufr arrays
(   46) !---------------------------------------------------------------------------
(   47) # 53 "Split_bufr_per_subtype.F90"
(   53)  use bufr_mod
(   54) # 55 "Split_bufr_per_subtype.F90"
(   55)       implicit none
(   56) # 57 "Split_bufr_per_subtype.F90"
(   57) integer, parameter                :: nmax_stype=50
(   58) # 59 "Split_bufr_per_subtype.F90"
(   59) character(len=256)                :: inputfile
(   60) character(len=256)                :: outputfile
(   61) character(len=256)                :: commfile
(   62) character(len=256)                :: outfile_prefix






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 12

(   63) character(len=256), dimension(20) :: carg
(   64) character(len=20)                 :: cdigit
(   65) # 67 "Split_bufr_per_subtype.F90"
(   67) INTEGER(KIND=JPIM)                           :: n, jj
(   68) INTEGER(KIND=JPIM)                           :: narg
(   69) # 70 "Split_bufr_per_subtype.F90"
(   70) INTEGER(KIND=JPIM)                           :: iargc
(   71) # 72 "Split_bufr_per_subtype.F90"
(   72) INTEGER(KIND=JPIM)                           :: iunit,iunitout
(   73) INTEGER(KIND=JPIM)                           :: j
(   74) INTEGER(KIND=JPIM)                           :: iret
(   75) INTEGER(KIND=JPIM)                           :: icomm, itmp, ios
(   76) # 78 "Split_bufr_per_subtype.F90"
(   78) INTEGER(KIND=JPIM)                           :: pool_number
(   79) INTEGER(KIND=JPIM)                           :: pool_numsubsets
(   80) INTEGER(KIND=JPIM)                           :: number_of_pools
(   81) INTEGER(KIND=JPIM)                           :: new_numsubsets, total_numsubsets
(   82) INTEGER, DIMENSION(nmax_stype)               :: subtypes_list
(   83) INTEGER, DIMENSION(nmax_stype)               :: subtypes_found
(   84) REAL(KIND=JPRD), DIMENSION(nmax_stype)       :: subtypes_count
(   85) REAL(KIND=JPRD), DIMENSION(nmax_stype)       :: subtypes_current_count
(   86) INTEGER(KIND=JPIM), DIMENSION(nmax_stype)    :: subtypes_current_poolno
(   87) REAL(KIND=JPRD)                              :: perpool_numsubsets
(   88) character(len=1)                             :: write_mode
(   89) # 90 "Split_bufr_per_subtype.F90"
(   90) INTEGER(KIND=JPIM)                           :: nummsgs, kbufl1
(   91) INTEGER(KIND=JPIM)                           :: nb_subtypes, current_subtype
(   92) INTEGER(KIND=JPIM), allocatable              :: isubsets(:)
(   93) INTEGER(KIND=JPIM), allocatable              :: isubsets_perpool(:)
(   94) logical, allocatable                         :: LLopened(:)
(   95) INTEGER(KIND=JPIM)                           :: number_of_subtypes
(   96) character(len=256)                           :: namelist_file
(   97) integer(kind=JPIM)                           :: operation
(   98) logical                                      :: in_list
(   99) # 101 "Split_bufr_per_subtype.F90"
(  101) NAMELIST/INC/ operation, number_of_subtypes,subtypes_list
(  102) !---------------------------------------------------------------------------
(  103) # 105 "Split_bufr_per_subtype.F90"
(  105)     call bufr_alloc
(  106) # 107 "Split_bufr_per_subtype.F90"
(  107)     inputfile=' '
(  108)     outputfile=' '
(  109)     commfile='/dev/null'
(  110)     outfile_prefix=' '
(  111)     iret=0
(  112)     write_mode='w'
(  113)     namelist_file=' '
(  114)     number_of_subtypes=0
(  115)     subtypes_list=-999
(  116)     operation=0
(  117)     narg=min(iargc(),size(carg))
(  118) # 119 "Split_bufr_per_subtype.F90"
(  119)     if(narg < 2) then
(  120)        print*,'Usage -- split_bufr_data -i inputfile -p number_of_pools '
(  121)        print*,'                         [-c commfile]'
(  122)        print*,'                         [-a -o outfile_prefix]'
(  123)        print*,'                         [-l subtypes_list]'
(  124)        print*,'      inputfile       -- input file name'






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 13

(  125)        print*,'      number_of_pools -- number of files to be created i.e. one per pool'
(  126)        print*,'      commfile        -- communic. file to pass no. of subsets between sweeps'
(  127)        print*,'      outfile_prefix  -- prefix for output file (default=inputfile)'
(  128)        print*,'      -a              -- open output file in append mode'
(  129)        print*,'      subtypes_list    -- namelist of subtypes to exclude or include'
(  130)        call estop('Invalid input args')
(  131)     end if
(  132) # 133 "Split_bufr_per_subtype.F90"
(  133)     do  j=1,narg
(  134)       call getarg(j,carg(j))
(  135)     end do
(  136) # 137 "Split_bufr_per_subtype.F90"
(  137)     number_of_pools = 1
(  138) # 139 "Split_bufr_per_subtype.F90"
(  139)     do j=1,narg
(  140)       if (carg(j) == '-i' .and. j<narg) then
(  141)          inputfile=carg(j+1)
(  142)       elseif (carg(j) == '-c' .and. j<narg) then
(  143)          commfile=carg(j+1)
(  144)       elseif (carg(j) == '-o' .and. j<narg) then
(  145)          outfile_prefix=carg(j+1)
(  146)       elseif (carg(j) == '-p' .and. j<narg) then
(  147)          read(carg(j+1),*) number_of_pools
(  148)       elseif (carg(j) == '-l' .and. j<narg) then
(  149)          namelist_file=carg(j+1)
(  150)       elseif (carg(j) == '-a') then
(  151)          write_mode='a'
(  152)       else
(  153)          cycle
(  154)       end if
(  155)     end do
(  156) # 157 "Split_bufr_per_subtype.F90"
(  157)     if (namelist_file /= ' ') then
(  158)       open(47,file=trim(namelist_file),iostat=ios,status='OLD')
(  159)       if(ios /= 0) then
(  160)         print*,'open error ',ios,' on namelist file ',trim(namelist_file)
(  161)         call estop('Invalid namelist file')
(  162)       end if
(  163)       READ (47,NML=INC)
(  164)       WRITE(*,NML=INC)
(  165)       close(47)
(  166)     end if
(  167) # 168 "Split_bufr_per_subtype.F90"
(  168)     if (number_of_pools < 1) call estop('number_of_pools < 1')
(  169)     allocate(LLopened(number_of_pools))
(  170)     LLopened(:) = .FALSE.
(  171) # 172 "Split_bufr_per_subtype.F90"
(  172)     if (outfile_prefix == ' ') outfile_prefix = inputfile
(  173) # 174 "Split_bufr_per_subtype.F90"
(  174)     
(  175) # 176 "Split_bufr_per_subtype.F90"
(  176) !   Open communication file
(  177) # 178 "Split_bufr_per_subtype.F90"
(  178)     allocate(isubsets_perpool(number_of_pools))
(  179) # 180 "Split_bufr_per_subtype.F90"
(  180)     icomm = 33
(  181)     open(icomm, file=trim(commfile), status='unknown', iostat=ios)
(  182)     if (ios == 0) then






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 14

(  183)       read(icomm,*,err=99,end=99) itmp ! no. of pools
(  184)       if (itmp /= number_of_pools) goto 99
(  185)       read(icomm,*,err=99,end=99) isubsets_perpool(:)
(  186)       goto 98 ! all ok
(  187)     endif
(  188)  99 continue
(  189) !-- error or first time and/or file wasn't there/supplied
(  190)     isubsets_perpool(:) = 0
(  191)  98 continue
(  192)     if (commfile /= '/dev/null' .and. ios == 0)rewind(icomm)
(  193) # 194 "Split_bufr_per_subtype.F90"
(  194) !   Open input file
(  195) # 196 "Split_bufr_per_subtype.F90"
(  196)     iret=0
(  197)     call pbopen(iunit,trim(inputfile),'r',iret)
(  198)     if(iret == -1) call estop('Open failed')
(  199)     if(iret == -2) call estop('Invalid input file name')
(  200)     if(iret == -3) call estop('Invalid open mode specified')
(  201) # 202 "Split_bufr_per_subtype.F90"
(  202)     CALL util_numprod(iunit, "BUFR", nummsgs)
(  203)     allocate(isubsets(nummsgs))
(  204)     isubsets(:) = 0
(  205) # 206 "Split_bufr_per_subtype.F90"
(  206)     iret = 0
(  207)     n = 0
(  208)     subtypes_found(:)= -1
(  209)     subtypes_count(:)= 0
(  210)     nb_subtypes=0
(  211)     do while(iret == 0)
(  212)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  213)       if(iret == -1) exit
(  214)       if(iret == -2) call estop('File handling problem')
(  215)       kbufl1=kbufl/4+1
(  216)       ksec1(7)=0
(  217)       call bus012(kbufl1,kbuff,ksup,ksec0,ksec1,ksec2,iret)
(  218)       if(iret /= 0) call estop('bus012 error')
(  219)       in_list=.false.
(  220)       do jj=1,  nmax_stype
(  221)         if (subtypes_found(jj) == ksec1(7)) then
(  222)           in_list=.true.
(  223)       subtypes_count(jj) = subtypes_count(jj) + 1
(  224)           exit
(  225)         endif 
(  226)       enddo
(  227)       if (.not. in_list) then ! the current subtype is new
(  228)         nb_subtypes=nb_subtypes+1
(  229)         subtypes_found(nb_subtypes) = ksec1(7)
(  230)         subtypes_count(nb_subtypes) = 1
(  231)       endif
(  232)       if (operation == 2) then
(  233) ! check if subtype is in the list of subtypes to include
(  234)         do jj=1,  nmax_stype
(  235)           if (subtypes_list(jj) == ksec1(7)) then
(  236)             n = n + 1
(  237)             if(n > nummsgs) call estop('n > nummsgs')
(  238)             isubsets(n) = ksup(6)
(  239)             exit
(  240)           endif






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 15

(  241)         enddo
(  242)       else if (operation == 1) then
(  243) ! check if subtype is excluded
(  244)         in_list=.true.
(  245)         do jj=1,  nmax_stype
(  246)           if (subtypes_list(jj) == ksec1(7)) then
(  247)             in_list=.false.
(  248)           endif
(  249)         enddo
(  250)         if (in_list) then
(  251)           n = n + 1
(  252)           if(n > nummsgs) call estop('n > nummsgs')
(  253)           isubsets(n) = ksup(6)
(  254)         endif
(  255)       else
(  256)         n = n + 1
(  257)         if(n > nummsgs) call estop('n > nummsgs')
(  258)         isubsets(n) = ksup(6)
(  259)       endif
(  260)     end do
(  261) # 262 "Split_bufr_per_subtype.F90"
(  262)    do jj=1, nmax_stype
(  263)        write(0,*) 'BEFORE division subtype ', subtypes_found(jj), ' nb nessages par pools = ', subtypes_count(jj)
(  264)    enddo
(  265) # 266 "Split_bufr_per_subtype.F90"
(  266)    do jj=1, nmax_stype
(  267)      if (subtypes_found(jj) > 0) then
(  268)        subtypes_count(jj) = subtypes_count(jj)/dble(number_of_pools) 
(  269)        if (subtypes_count(jj) < 1) subtypes_count(jj)=1
(  270)        write(0,*) 'subtype ', subtypes_found(jj), ' nb nessages par pools = ', subtypes_count(jj)
(  271)      endif
(  272)    enddo
(  273) !*AF    if(n /= nummsgs) call estop('n /= nummsgs')
(  274)     n = nummsgs
(  275)     new_numsubsets = sum(isubsets(:))
(  276)     total_numsubsets = sum(isubsets_perpool(:)) + new_numsubsets
(  277)     perpool_numsubsets = dble(total_numsubsets)/dble(number_of_pools)
(  278) # 279 "Split_bufr_per_subtype.F90"
(  279)     write(0,*)'nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets=',&
(  280)                nummsgs, new_numsubsets, total_numsubsets, number_of_pools, perpool_numsubsets
(  281) !!    write(0,'(a/(10i12))') '*isubsets=',isubsets(:)
(  282) !!    write(0,'(a/(10i12))') '>isubsets_perpool=',isubsets_perpool(:)
(  283) # 284 "Split_bufr_per_subtype.F90"
(  284)     call pbseek(iunit, 0, 0, iret)
(  285)     if(iret == -1) call estop('End-of-file is hit whilst positioning to the given byte offset')
(  286)     if(iret == -2) call estop('Error in positioning the file')
(  287) # 288 "Split_bufr_per_subtype.F90"
(  288)     call open_pool(1)
(  289) # 290 "Split_bufr_per_subtype.F90"
(  290)     n = 0
(  291)     iret = 0
(  292)     subtypes_current_count(:)=0
(  293)     subtypes_current_poolno(:)=1
(  294)     do while (iret == 0)
(  295)       call pbbufr(iunit,kbuff,jbyte,kbufl,iret)
(  296)       if(iret == -1) exit
(  297)       if(iret == -2) call estop('File handling problem')
(  298)       if(iret == -3) call estop('The size of kbuff is not sufficient for a product')






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 16

(  299) !***********************
(  300)       kbufl1=kbufl/4+1
(  301)       ksec1(7)=0
(  302)       call bus012(kbufl1,kbuff,ksup,ksec0,ksec1,ksec2,iret)
(  303)       if(iret /= 0) call estop('bus012 error')
(  304)       in_list=.false.
(  305)       do current_subtype=1,  nmax_stype
(  306)         if (subtypes_found(current_subtype) == ksec1(7)) then
(  307)           in_list=.true.
(  308)           exit
(  309)         endif 
(  310)       enddo
(  311)       if (subtypes_found(current_subtype) > 0) then
(  312)         subtypes_current_count(current_subtype) = subtypes_current_count(current_subtype) + 1
(  313)       endif
(  314)       if (operation == 2) then
(  315)         in_list=.false.
(  316) ! check if subtype is in the list of subtypes to include
(  317)         do jj=1,  nmax_stype
(  318)           if (subtypes_list(jj) == ksec1(7)) then
(  319)             in_list=.true.
(  320)             exit
(  321)           endif
(  322)         enddo
(  323)       else if (operation == 1) then
(  324) ! check if subtype is excluded
(  325)         in_list=.true.
(  326)         do jj=1,  nmax_stype
(  327)           if (subtypes_list(jj) == ksec1(7)) then
(  328)             in_list=.false. ! exclude subtype
(  329)           endif
(  330)         enddo
(  331)       else
(  332)         in_list=.true.
(  333)       endif
(  334) !*************
(  335)       if (in_list) then
(  336)         call pbwrite(iunitout,kbuff,kbufl,iret)
(  337)         if(iret >= 0) then
(  338)            iret=0
(  339)         else
(  340)            print*,'pbwrite error :',iret
(  341)            call exit(2)
(  342)         end if
(  343) # 344 "Split_bufr_per_subtype.F90"
(  344)         n = n + 1
(  345)         pool_numsubsets = pool_numsubsets + isubsets(n)
(  346)       endif
(  347)       iret=0
(  348)       if (subtypes_current_count(current_subtype) >= subtypes_count(current_subtype)) then
(  349)          subtypes_current_poolno(current_subtype) = subtypes_current_poolno(current_subtype) + 1
(  350)          subtypes_current_count(current_subtype) = 1
(  351)          if (subtypes_current_poolno(current_subtype) > number_of_pools) subtypes_current_poolno(current_subtype) =1
(  352)          isubsets_perpool(pool_number)=pool_numsubsets
(  353)          call pbclose(iunitout,iret)
(  354)          call open_pool(subtypes_current_poolno(current_subtype))
(  355)          iret=0
(  356)       end if






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 17

(  357)     end do ! do while (iret == 0)
(  358) # 359 "Split_bufr_per_subtype.F90"
(  359)     isubsets_perpool(pool_number)=pool_numsubsets
(  360)     call pbclose(iunitout,iret)
(  361) # 362 "Split_bufr_per_subtype.F90"
(  362)     do j=1,number_of_pools
(  363)       if (.not.LLopened(j)) then
(  364) !!        write(0,*)'---> remaining pool#',j
(  365)         write(cdigit,'(i20)') j
(  366)         write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  367)         call pbopen(iunitout,trim(outputfile),write_mode,iret)
(  368)         if(iret == -1) call estop('Open failed')
(  369)         if(iret == -2) call estop('Invalid input file name')
(  370)         if(iret == -3) call estop('Invalid open mode specified')
(  371)         call pbclose(iunitout,iret)
(  372)       endif
(  373)     end do
(  374) # 375 "Split_bufr_per_subtype.F90"
(  375)     call pbclose(iunit,iret)
(  376) # 377 "Split_bufr_per_subtype.F90"
(  377) !-- Update communication file
(  378) if (commfile /= '/dev/null')then
(  379)   write(icomm,*) number_of_pools
(  380)   write(icomm,'((10i12))') isubsets_perpool(:)
(  381)   close(icomm)
(  382) endif
(  383) # 384 "Split_bufr_per_subtype.F90"
(  384) !!    write(0,'(a/(10i12))') '<isubsets_perpool=',isubsets_perpool(:)
(  385) # 386 "Split_bufr_per_subtype.F90"
(  386) CONTAINS
(  387) # 388 "Split_bufr_per_subtype.F90"
(  388) subroutine open_pool(poolno)
(  389) implicit none
(  390) INTEGER(KIND=JPIM), intent(in) :: poolno
(  391) character(len=1)               :: open_mode
(  392) pool_number = poolno
(  393) pool_numsubsets=isubsets_perpool(pool_number)
(  394) write(cdigit,'(i20)') pool_number
(  395) write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  396) open_mode = write_mode
(  397) if (LLopened(pool_number)) open_mode = 'a'
(  398) call pbopen(iunitout,trim(outputfile),open_mode,iret)
(  399) if(iret == -1) call estop('Open failed')
(  400) if(iret == -2) call estop('Invalid input file name')
(  401) if(iret == -3) call estop('Invalid open mode specified')
(  402) LLopened(pool_number) = .TRUE.
(  403) end subroutine open_pool
(  404) # 405 "Split_bufr_per_subtype.F90"
(  405) subroutine open_next_pool()
(  406) implicit none
(  407) INTEGER(KIND=JPIM) istart_pool
(  408) character(len=1) open_mode
(  409) itmp = isubsets_perpool(1)
(  410) istart_pool = 1
(  411) do j=2,number_of_pools
(  412)   if (isubsets_perpool(j) < itmp) then
(  413)     itmp = isubsets_perpool(j)
(  414)     istart_pool = j






NVFORTRAN (Version     23.1)          02/24/2023  13:48:30      page 18

(  415)   endif
(  416) enddo
(  417) pool_number = istart_pool
(  418) pool_numsubsets=isubsets_perpool(pool_number)
(  419) write(cdigit,'(i20)') pool_number
(  420) write(outputfile,'(a,".",a)') trim(outfile_prefix),trim(adjustl(cdigit))
(  421) open_mode = write_mode
(  422) if (LLopened(pool_number)) open_mode = 'a'
(  423) call pbopen(iunitout,trim(outputfile),open_mode,iret)
(  424) if(iret == -1) call estop('Open failed')
(  425) if(iret == -2) call estop('Invalid input file name')
(  426) if(iret == -3) call estop('Invalid open mode specified')
(  427) LLopened(pool_number) = .TRUE.
(  428) end subroutine open_next_pool
(  429) # 431 "Split_bufr_per_subtype.F90"
(  431) subroutine estop(cmsg, rc)
(  432) # 433 "Split_bufr_per_subtype.F90"
(  433) implicit none
(  434) character(len=*), intent(in) :: cmsg
(  435) INTEGER(KIND=JPIM), intent(in), optional :: rc
(  436) INTEGER(KIND=JPIM) iretcode
(  437) write(0,*) '***Error: '//cmsg
(  438) iretcode = 1
(  439) if (present(rc)) iretcode = rc
(  440) call exit(iretcode)
(  441) end subroutine estop
(  442) # 443 "Split_bufr_per_subtype.F90"
(  443) END PROGRAM Split_bufr_data
