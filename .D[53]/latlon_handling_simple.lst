


NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: latlon_handling_simple.F90

(    1) module LatLon_Handling
(    2)   !  #[ Description
(    3) 
(    4)   !---------------------------------------------------
(    5)   ! a library to manage the latlon handling in fortran90 programs
(    6)   !---------------------------------------------------
(    7)   !    Written by:  J. de Kloe, KNMI
(    8)   !    created:     25-Oct-2006
(    9)   !
(   10)   ! Modifications:
(   11)   ! 25-Oct-2006 J. de Kloe   Initial version
(   12)   ! 01-Nov-2006 J. de Kloe   added proper missing handling
(   13)   ! 16-Jan-2008 J. de Kloe   phase out integer kind i_ 
(   14)   ! 11-Jun-2009 J. de Kloe   bugfix in get_angle_distance_grcircle
(   15)   !                          (prevent reporting of neg. values)
(   16)   ! 10-Aug-2009 J. de Kloe   added ensure_lon_range_180_180
(   17)   ! 19-Jul-2011 J. de Kloe   made interface identical to latlon_handling_eecfi
(   18)   ! 11-Nov-2011 J. de Kloe   added error_flag to InitLatLonhandlingModule
(   19)   ! 25-Feb-2014 J. de Kloe   add eps tests to prevent some gfortran warnings
(   20)   !
(   21)   !---------------------------------------------------
(   22) 
(   23)   !  #]
(   24)   !  #[ Modules used
(   25)   USE Numerics, only: r8_,missing_indicator_real_r8, missing_real
(   26)   USE ErrorHandler, only: no_error,error_programming
(   27)   !  #]
(   28)   !  #[ Variables and parameters
(   29)   IMPLICIT NONE
(   30) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 3

(   31)   ! to be moved into the constants module
(   32)   real(r8_),  parameter :: R_earth_equatorial = 6378.1_r8_ ! [km]
(   33)   !real(r8_),  parameter :: R_earth_polar      = 6356.8_r8_ ! [km]
(   34)   ! source: http://wwwflag.wr.usgs.gov/USGSFlag/Space/wall/earth.html
(   35) 
(   36)   ! size of the earth: 12756.3 * !dpi = 40075.098 km (omtrek)
(   37)   ! so 1 degree corresponds to 40075.098/360.=111.3 km
(   38)   ! see http://nl.wikipedia.org/wiki/Aarde
(   39) 
(   40)   real(r8_), parameter :: pi =  3.14159265358979323846_r8_ ! = pi
(   41)   real(r8_), parameter :: deg2rad = pi/180._r8_
(   42)   real(r8_), parameter :: rad2deg = 180._r8_/pi
(   43) 
(   44)   logical, save :: show_warnings
(   45)   !  #]
(   46)   !  #[ interface definition
(   47)   ! choose which of the routines will be exported to the user
(   48)   interface get_midpoint
(   49)      ! a very simple approximation, valid for short distance only
(   50)      !module procedure get_midpoint_simple
(   51)      ! a proper calculation
(   52)      module procedure get_midpoint_vector
(   53)   end interface
(   54)   interface get_distance
(   55)      ! a very simple approximation, valid for short distance only
(   56)      !module procedure get_distance_flat
(   57)      ! a proper calculation
(   58)      module procedure get_distance_grcircle
(   59)   end interface
(   60) 
(   61)   private :: get_angle_distance_grcircle !, get_distance_flat
(   62)   ! these are basically internal as well, but I wish to test them in
(   63)   ! the Test program, so they cannot be made private here
(   64)   ! latlon2xyz_radius1, xyz2latlon_radius1
(   65)   !  #]
(   66) contains ! routines to handle the data in this module
(   67)   !--------------------------------
(   68)   subroutine InitLatLonhandlingModule(error_flag,show_warnings_in)
(   69)     !  #[
(   70)     ! REMARK: this is a dummy routine for now
(   71)     !         only added to make the interface identical
(   72)     !         to the one in latlon_handling_eecfi
(   73) 
(   74)     ! This routine retrieves some some global constants 
(   75)     ! from the ee_cfi header files
(   76) 
(   77)     integer, intent(out)          :: error_flag
(   78)     logical, intent(in), optional :: show_warnings_in
(   79)     
(   80)     ! error_flag is not used here, but needed for compatibility
(   81)     ! with the latlon_handling_eecfi.F90 version of this module
(   82)     error_flag = no_error
(   83) 
(   84)     show_warnings = .true.
(   85)     if (present(show_warnings_in)) show_warnings = show_warnings_in
(   86) 
(   87)   end subroutine InitLatLonhandlingModule
(   88)     !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 4

(   89)   !--------------------------------
(   90)   subroutine get_midpoint_vector(lat1,lon1,lat2,lon2,& ! inputs
(   91)                                  lat_mid,lon_mid)      ! outputs
(   92)     !  #[
(   93)     ! determine the lat-lon of the midpoint in [deg]
(   94)     ! from 2 lat-lon pairs given in [deg]
(   95) 
(   96)     ! method: 
(   97)     ! ==>convert both lat-lon pairs to (x,y,z) vectors
(   98)     ! ==>do a vector average
(   99)     ! ==>renormalise to 1
(  100)     ! ==>convert xyz back to lat,lon
(  101) 
(  102)     real(r8_), intent(in)  :: lat1,lon1,lat2,lon2 ! inputs
(  103)     real(r8_), intent(out) :: lat_mid,lon_mid     ! outputs
(  104) 
(  105)     ! local variables
(  106)     real(r8_) :: x1,y1,z1
(  107)     real(r8_) :: x2,y2,z2
(  108)     real(r8_) :: x_mid,y_mid,z_mid
(  109)     real(r8_) :: norm_factor
(  110)     real(r8_) :: length_sq_mid_vector
(  111)     real(r8_), parameter :: eps = 1.e-12_r8_
(  112) 
(  113)     ! if any of the inputs is missing, return with missing
(  114)     if ( missing_real(lat1) .or. missing_real(lon1) .or. &
(  115)          missing_real(lat2) .or. missing_real(lon2) ) then
(  116)        lat_mid = missing_indicator_real_r8
(  117)        lon_mid = missing_indicator_real_r8
(  118)        return
(  119)     end if
(  120) 
(  121)     ! ==>convert both lat-lon pairs to (x,y,z) vectors
(  122)     call latlon2xyz_radius1(lat1,lon1,x1,y1,z1)
(  123)     call latlon2xyz_radius1(lat2,lon2,x2,y2,z2)
(  124) 
(  125)     ! ==>do a vector average
(  126)     x_mid = 0.5_r8_*(x1+x2)
(  127)     y_mid = 0.5_r8_*(y1+y2)
(  128)     z_mid = 0.5_r8_*(z1+z2)
(  129) 
(  130)     length_sq_mid_vector = x_mid*x_mid + y_mid*y_mid + z_mid*z_mid
(  131) 
(  132)     IF (abs(length_sq_mid_vector) .lt. eps) THEN
(  133)        ! this exception might happen if you ask for the midpoint of 
(  134)        ! 2 locations that are exactly opposite on the globe.
(  135)        ! Since no proper midpoint can be defined on this case
(  136)        ! return with missing values
(  137)        lat_mid = missing_indicator_real_r8
(  138)        lon_mid = missing_indicator_real_r8
(  139)        return
(  140)     END IF
(  141) 
(  142)     ! ==>renormalise to 1
(  143)     norm_factor = 1._r8_/sqrt(length_sq_mid_vector)
(  144)     x_mid = x_mid * norm_factor
(  145)     y_mid = y_mid * norm_factor
(  146)     z_mid = z_mid * norm_factor






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 5

(  147) 
(  148)     ! ==>convert xyz back to lat,lon
(  149)     call xyz2latlon_radius1(x_mid,y_mid,z_mid,lat_mid,lon_mid)
(  150) 
(  151)   end subroutine get_midpoint_vector
(  152)     !  #]
(  153)   subroutine get_midpoint_simple(lat1,lon1,lat2,lon2,& ! inputs
(  154)                                  lat_mid,lon_mid)      ! outputs
(  155)     !  #[
(  156)     ! determine the lat-lon of the midpoint in [deg]
(  157)     ! from 2 lat-lon pairs given in [deg]
(  158) 
(  159)     ! method: use a very simple average
(  160)     ! (known to fail around the poles, and not very accurate, since
(  161)     !  you don't follow the great-circle, so only valid for small distances)
(  162) 
(  163)     real(r8_), intent(in)  :: lat1,lon1,lat2,lon2 ! inputs
(  164)     real(r8_), intent(out) :: lat_mid,lon_mid     ! outputs
(  165) 
(  166)     ! local variables
(  167)     real(r8_) :: lat_diff_deg, lon_diff_deg
(  168) 
(  169)     ! if any of the inputs is missing, return with missing
(  170)     if ( missing_real(lat1) .or. missing_real(lon1) .or. &
(  171)          missing_real(lat2) .or. missing_real(lon2) ) then
(  172)        lat_mid = missing_indicator_real_r8
(  173)        lon_mid = missing_indicator_real_r8
(  174)        return
(  175)     end if
(  176) 
(  177)     ! get the differences
(  178)     lat_diff_deg = lat2 - lat1
(  179)     lon_diff_deg = lon2 - lon1
(  180) 
(  181)     ! account for the fact that lon=-179.9 and lon=179.9 are neighbouring
(  182)     IF (lon_diff_deg .gt.  180._r8_) lon_diff_deg = lon_diff_deg - 360._r8_ 
(  183)     IF (lon_diff_deg .lt. -180._r8_) lon_diff_deg = lon_diff_deg + 360._r8_ 
(  184) 
(  185)     lat_mid = lat1+0.5*lat_diff_deg
(  186)     lon_mid = lon1+0.5*lon_diff_deg
(  187) 
(  188)     ! enforcethe range -180 .. +180
(  189)     if (lon_mid .gt.  180._r8_) lon_mid = lon_mid - 360._r8_ 
(  190)     if (lon_mid .lt. -180._r8_) lon_mid = lon_mid + 360._r8_ 
(  191) 
(  192)   end subroutine get_midpoint_simple
(  193)     !  #]
(  194)   !--------------------------------
(  195)   function get_distance_grcircle(lat1,lon1,lat2,lon2) result(distance)
(  196)     !  #[
(  197)     ! this function converts the angle-distance between 
(  198)     ! 2 latlon pairs to a km distance
(  199) 
(  200)     real(r8_) :: lat1,lon1,lat2,lon2 ! input
(  201)     real(r8_) :: distance            ! result [km]
(  202) 
(  203)     ! local variables
(  204)     real(r8_) :: angle_distance






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 6

(  205) 
(  206)     ! if any of the inputs is missing, return with missing
(  207)     if ( missing_real(lat1) .or. missing_real(lon1) .or. &
(  208)          missing_real(lat2) .or. missing_real(lon2) ) then
(  209)        distance = missing_indicator_real_r8
(  210)        return
(  211)     end if
(  212) 
(  213)     ! since angle_distance will always yield a non-negative
(  214)     ! number, distance will always be non-negative as well
(  215)     angle_distance = get_angle_distance_grcircle(lat1,lon1,lat2,lon2) 
(  216)     distance = 2._r8_*pi*R_earth_equatorial*angle_distance/360._r8_
(  217) 
(  218)   end function Get_distance_grcircle
(  219)     !  #]
(  220)   !function get_distance_flat(lat1,lon1,lat2,lon2) result(distance)
(  221)     !  #[
(  222)     ! this function converts the angle-distance between 
(  223)     ! 2 latlon pairs to a km distance
(  224) 
(  225) !    real(r8_) :: lat1,lon1,lat2,lon2 ! input
(  226) !    real(r8_) :: distance            ! result [km]
(  227) 
(  228)     ! local variables
(  229) !    real(r8_) :: angle_distance
(  230) 
(  231)     ! if any of the inputs is missing, return with missing
(  232) !    if ( missing_real(lat1) .or. missing_real(lon1) .or. &
(  233) !         missing_real(lat2) .or. missing_real(lon2) ) then
(  234) !       distance = missing_indicator_real_r8
(  235) !       return
(  236) !    end if
(  237) 
(  238)     ! since angle_distance will always yield a non-negative
(  239)     ! number, distance will always be non-negative as well
(  240) !    angle_distance = get_angle_distance_flat(lat1,lon1,lat2,lon2) 
(  241) !    distance = 2._r8_*pi*R_earth_equatorial*angle_distance/360._r8_
(  242)     
(  243) !  end function get_distance_flat
(  244)     !  #]
(  245)   !--------------------------------
(  246)   function ensure_lon_range_180_180(lon) result(norm_lon)
(  247)     !  #[
(  248)     real(r8_), intent(in) :: lon      ! input  in [deg]
(  249)     real(r8_)             :: norm_lon ! result in [deg]
(  250) 
(  251)     norm_lon =  modulo(lon+180._r8_, 360._r8_)-180._r8_
(  252) 
(  253)   end function ensure_lon_range_180_180
(  254)     !  #]
(  255)   !--------------------------------
(  256)   ! functions private to this module
(  257)   function get_angle_distance_grcircle(lat1,lon1,lat2,lon2) result(angle_dist)
(  258)     !  #[
(  259)     ! determine the angle (in degrees) on the earths surface
(  260)     ! between 2 sets of lat-lon coordinates
(  261)     ! along a great-circle 
(  262)     ! (assuming that the shape of the earth is a perfect globe)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 7

(  263)     
(  264)     ! equations taken from:
(  265)     ! http://mathworld.wolfram.com/GreatCircle.html
(  266) 
(  267)     ! use the property that the angle alpha between 2 vectors in
(  268)     ! cartesian coordinates is given by the inner product of the 2 vectors:
(  269)     !              _    _
(  270)     ! cos(alpha) = v1 . v2
(  271) 
(  272)     ! note that the error for using a sperical earth in stead of the proper
(  273)     ! spheroid must always be between the result using R_earth_equatorial
(  274)     ! and the result using R_earth_polar. Therefore the maximum error
(  275)     ! is estimated at: 
(  276)     ! 100.*(R_earth_equatorial - R_earth_polar)/R_earth_polar = 0.34 percent
(  277)     ! which is an acceptable accuracy for our use
(  278) 
(  279)     real(r8_), intent(in) :: lat1,lon1,lat2,lon2
(  280)     real(r8_) :: angle_dist
(  281) 
(  282)     ! loal variables
(  283)     real(r8_) :: x1,y1,z1
(  284)     real(r8_) :: x2,y2,z2
(  285)     real(r8_) :: inner_prod
(  286) 
(  287)     call latlon2xyz_radius1(lat1,lon1,x1,y1,z1)
(  288)     call latlon2xyz_radius1(lat2,lon2,x2,y2,z2)
(  289)     inner_prod = (x1*x2+y1*y2+z1*z2)
(  290) 
(  291)     ! extra check, abs(inner_prod) should never be larger than 1 !
(  292)     ! however, due to rounding errors it might happen anyway
(  293)     if (abs(inner_prod) .gt. 1._r8_) inner_prod = 1._r8_
(  294) 
(  295)     ! extra check, abs(inner_prod) should never be smaller than -1 !
(  296)     ! however, due to rounding errors it might happen anyway
(  297)     if (abs(inner_prod) .lt. -1._r8_) inner_prod = -1._r8_
(  298) 
(  299)     ! note that an inner product may be negative
(  300)     ! so apply abs() to ensure the distance is always positive or zero
(  301)     angle_dist = abs(acos(inner_prod)*rad2deg)
(  302)     
(  303)   end function get_angle_distance_grcircle
(  304)   !  #] ----------------------------------------------------------
(  305)   function get_angle_distance_flat(lat1,lon1,lat2,lon2) result(angle_dist)
(  306)     !  #[
(  307)     ! determine the angle (in degrees) between 2 sets of lat-lon coordinates
(  308)     ! (assuming that the local shape of the earth is flat)
(  309) 
(  310)     ! this function is borrowed from KNMI's genscat package
(  311)     ! it calculates the angle-distance between 2 latlon pairs
(  312) 
(  313)     ! compare with the old PRESCAT code in NODEQC.F, lines 210/214
(  314)     ! calculation of zDlat, zDlon
(  315) 
(  316)     real(r8_), intent(in) :: lat1,lon1,lat2,lon2
(  317)     real(r8_) :: angle_dist
(  318) 
(  319)     ! loal variables
(  320)     real(r8_) :: lat_diff_deg, lon_diff_deg






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 8

(  321)     real(r8_) :: lat_min_deg, lat_min_rad
(  322)     real(r8_) :: distance_sq
(  323) 
(  324)     ! get the differences
(  325)     lat_diff_deg = lat2 - lat1
(  326)     lon_diff_deg = lon2 - lon1
(  327)     
(  328)     ! determine lowest latitude of both positions
(  329)     lat_min_deg = min( abs(lat1),abs(lat2) )
(  330)              
(  331)     ! convert lowest latitude to radians
(  332)     lat_min_rad = lat_min_deg*deg2rad
(  333)              
(  334)     ! account for the fact that lon=-179.9 and lon=179.9 are neighbouring
(  335)     IF (lon_diff_deg .gt.  180._r8_) lon_diff_deg = lon_diff_deg - 360._r8_ 
(  336)     IF (lon_diff_deg .lt. -180._r8_) lon_diff_deg = lon_diff_deg + 360._r8_ 
(  337) 
(  338)     ! the triangle in lat-lon grid defining the distance between the 
(  339)     ! two nodes, has sides of length (R=radius of the earth):
(  340)     !     R*lat_difference_rad                      (in north-south direction)
(  341)     ! and R*cos(lat_minimum_rad)*lon_difference_rad (in east-west direction)
(  342)     !
(  343)     ! so the square of the third side (and the distance) is:
(  344)     !     R^2*lat_difference_rad^2 + 
(  345)     !     R^2*cos(lat_minimum_rad)^2*lon_difference_rad^2
(  346)              
(  347)     ! for simplicity, we remove the factors R and deg2rad
(  348)     ! from this calculation, and the following remains:
(  349)     
(  350)     distance_sq = lon_diff_deg**2 * cos(lat_min_rad)**2 + lat_diff_deg**2
(  351)     angle_dist = sqrt(distance_sq)
(  352) 
(  353)   end function get_angle_distance_flat
(  354)   !  #] ----------------------------------------------------------
(  355)   subroutine latlon2xyz_radius1(lat,lon,x,y,z)
(  356)     !  #[
(  357)     ! convert spherical to cartesian coordinates, i.e.
(  358)     ! calculate x,y,z coordinates for a given lat,lon pair on a sphere
(  359)     ! of radius 1
(  360) 
(  361)     ! equations taken from:
(  362)     ! http://mathworld.wolfram.com/GreatCircle.html
(  363) 
(  364)     real(r8_), intent(in)  :: lat,lon
(  365)     real(r8_), intent(out) :: x,y,z
(  366) 
(  367)     ! local variables
(  368)     real(r8_) :: lon_rad,lat_rad
(  369)     real(r8_) :: coslat
(  370) 
(  371)     lon_rad   = lon*deg2rad
(  372)     lat_rad   = lat*deg2rad
(  373)     coslat = cos(lat_rad)
(  374)     x      = cos(lon_rad)*coslat
(  375)     y      = sin(lon_rad)*coslat
(  376)     z      = sin(lat_rad)
(  377) 
(  378)   end subroutine latlon2xyz_radius1






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 9

(  379)   !  #]                                      
(  380)   subroutine xyz2latlon_radius1(x,y,z,lat,lon)
(  381)     !  #[ 
(  382)     ! convert cartesian coordinates to spherical, i.e.
(  383)     ! calculate a lat,lon pair on a sphere of radius 1
(  384)     ! given the x,y,z coordinates 
(  385) 
(  386)     real(r8_), intent(in)  :: x,y,z
(  387)     real(r8_), intent(out) :: lat,lon
(  388) 
(  389)     ! local variable
(  390)     real(r8_) :: cos_lat
(  391)     real(r8_), parameter :: eps = 1.e-12_r8_
(  392) 
(  393)     ! calculate the latitude
(  394)     cos_lat   = sqrt(x*x+y*y)
(  395)     if (z .ge. 0._r8_) then
(  396)        lat =           acos(cos_lat)*rad2deg
(  397)     else
(  398)        lat = -1._r8_ * acos(cos_lat)*rad2deg
(  399)     end if
(  400) 
(  401)     ! calculate the longitude
(  402)     if ((abs(y) .lt. eps) .and. (abs(x) .lt. eps)) then
(  403)        ! on the pole longitude has no meaning, so set it to 0
(  404)        lon = 0._r8_
(  405)     else
(  406)        lon = atan2(y,x)*rad2deg
(  407)        ! result is in the range -180 .. +180
(  408)     endif
(  409) 
(  410)   end subroutine xyz2latlon_radius1
(  411)   !  #]
(  412)   !--------------------------------
(  413) end module LatLon_Handling





























NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 10

(    1) # 1 "latlon_handling_simple.F90"
(    1) module LatLon_Handling
(    2)   !  #[ Description
(    3) # 4 "latlon_handling_simple.F90"
(    4)   !---------------------------------------------------
(    5)   ! a library to manage the latlon handling in fortran90 programs
(    6)   !---------------------------------------------------
(    7)   !    Written by:  J. de Kloe, KNMI
(    8)   !    created:     25-Oct-2006
(    9)   !
(   10)   ! Modifications:
(   11)   ! 25-Oct-2006 J. de Kloe   Initial version
(   12)   ! 01-Nov-2006 J. de Kloe   added proper missing handling
(   13)   ! 16-Jan-2008 J. de Kloe   phase out integer kind i_ 
(   14)   ! 11-Jun-2009 J. de Kloe   bugfix in get_angle_distance_grcircle
(   15)   !                          (prevent reporting of neg. values)
(   16)   ! 10-Aug-2009 J. de Kloe   added ensure_lon_range_180_180
(   17)   ! 19-Jul-2011 J. de Kloe   made interface identical to latlon_handling_eecfi
(   18)   ! 11-Nov-2011 J. de Kloe   added error_flag to InitLatLonhandlingModule
(   19)   ! 25-Feb-2014 J. de Kloe   add eps tests to prevent some gfortran warnings
(   20)   !
(   21)   !---------------------------------------------------
(   22) # 23 "latlon_handling_simple.F90"
(   23)   !  #]
(   24)   !  #[ Modules used
(   25)   USE Numerics, only: r8_,missing_indicator_real_r8, missing_real
(   26)   USE ErrorHandler, only: no_error,error_programming
(   27)   !  #]
(   28)   !  #[ Variables and parameters
(   29)   IMPLICIT NONE
(   30) # 31 "latlon_handling_simple.F90"
(   31)   ! to be moved into the constants module
(   32)   real(r8_),  parameter :: R_earth_equatorial = 6378.1_r8_ ! [km]
(   33)   !real(r8_),  parameter :: R_earth_polar      = 6356.8_r8_ ! [km]
(   34)   ! source: http://wwwflag.wr.usgs.gov/USGSFlag/Space/wall/earth.html
(   35) # 36 "latlon_handling_simple.F90"
(   36)   ! size of the earth: 12756.3 * !dpi = 40075.098 km (omtrek)
(   37)   ! so 1 degree corresponds to 40075.098/360.=111.3 km
(   38)   ! see http://nl.wikipedia.org/wiki/Aarde
(   39) # 40 "latlon_handling_simple.F90"
(   40)   real(r8_), parameter :: pi =  3.14159265358979323846_r8_ ! = pi
(   41)   real(r8_), parameter :: deg2rad = pi/180._r8_
(   42)   real(r8_), parameter :: rad2deg = 180._r8_/pi
(   43) # 44 "latlon_handling_simple.F90"
(   44)   logical, save :: show_warnings
(   45)   !  #]
(   46)   !  #[ interface definition
(   47)   ! choose which of the routines will be exported to the user
(   48)   interface get_midpoint
(   49)      ! a very simple approximation, valid for short distance only
(   50)      !module procedure get_midpoint_simple
(   51)      ! a proper calculation
(   52)      module procedure get_midpoint_vector
(   53)   end interface
(   54)   interface get_distance
(   55)      ! a very simple approximation, valid for short distance only
(   56)      !module procedure get_distance_flat
(   57)      ! a proper calculation






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 11

(   58)      module procedure get_distance_grcircle
(   59)   end interface
(   60) # 61 "latlon_handling_simple.F90"
(   61)   private :: get_angle_distance_grcircle !, get_distance_flat
(   62)   ! these are basically internal as well, but I wish to test them in
(   63)   ! the Test program, so they cannot be made private here
(   64)   ! latlon2xyz_radius1, xyz2latlon_radius1
(   65)   !  #]
(   66) contains ! routines to handle the data in this module
(   67)   !--------------------------------
(   68)   subroutine InitLatLonhandlingModule(error_flag,show_warnings_in)
(   69)     !  #[
(   70)     ! REMARK: this is a dummy routine for now
(   71)     !         only added to make the interface identical
(   72)     !         to the one in latlon_handling_eecfi
(   73) # 74 "latlon_handling_simple.F90"
(   74)     ! This routine retrieves some some global constants 
(   75)     ! from the ee_cfi header files
(   76) # 77 "latlon_handling_simple.F90"
(   77)     integer, intent(out)          :: error_flag
(   78)     logical, intent(in), optional :: show_warnings_in
(   79)     
(   80)     ! error_flag is not used here, but needed for compatibility
(   81)     ! with the latlon_handling_eecfi.F90 version of this module
(   82)     error_flag = no_error
(   83) # 84 "latlon_handling_simple.F90"
(   84)     show_warnings = .true.
(   85)     if (present(show_warnings_in)) show_warnings = show_warnings_in
(   86) # 87 "latlon_handling_simple.F90"
(   87)   end subroutine InitLatLonhandlingModule
(   88)     !  #]
(   89)   !--------------------------------
(   90)   subroutine get_midpoint_vector(lat1,lon1,lat2,lon2,& ! inputs
(   91)                                  lat_mid,lon_mid)      ! outputs
(   92)     !  #[
(   93)     ! determine the lat-lon of the midpoint in [deg]
(   94)     ! from 2 lat-lon pairs given in [deg]
(   95) # 96 "latlon_handling_simple.F90"
(   96)     ! method: 
(   97)     ! ==>convert both lat-lon pairs to (x,y,z) vectors
(   98)     ! ==>do a vector average
(   99)     ! ==>renormalise to 1
(  100)     ! ==>convert xyz back to lat,lon
(  101) # 102 "latlon_handling_simple.F90"
(  102)     real(r8_), intent(in)  :: lat1,lon1,lat2,lon2 ! inputs
(  103)     real(r8_), intent(out) :: lat_mid,lon_mid     ! outputs
(  104) # 105 "latlon_handling_simple.F90"
(  105)     ! local variables
(  106)     real(r8_) :: x1,y1,z1
(  107)     real(r8_) :: x2,y2,z2
(  108)     real(r8_) :: x_mid,y_mid,z_mid
(  109)     real(r8_) :: norm_factor
(  110)     real(r8_) :: length_sq_mid_vector
(  111)     real(r8_), parameter :: eps = 1.e-12_r8_
(  112) # 113 "latlon_handling_simple.F90"
(  113)     ! if any of the inputs is missing, return with missing
(  114)     if ( missing_real(lat1) .or. missing_real(lon1) .or. &
(  115)          missing_real(lat2) .or. missing_real(lon2) ) then






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 12

(  116)        lat_mid = missing_indicator_real_r8
(  117)        lon_mid = missing_indicator_real_r8
(  118)        return
(  119)     end if
(  120) # 121 "latlon_handling_simple.F90"
(  121)     ! ==>convert both lat-lon pairs to (x,y,z) vectors
(  122)     call latlon2xyz_radius1(lat1,lon1,x1,y1,z1)
(  123)     call latlon2xyz_radius1(lat2,lon2,x2,y2,z2)
(  124) # 125 "latlon_handling_simple.F90"
(  125)     ! ==>do a vector average
(  126)     x_mid = 0.5_r8_*(x1+x2)
(  127)     y_mid = 0.5_r8_*(y1+y2)
(  128)     z_mid = 0.5_r8_*(z1+z2)
(  129) # 130 "latlon_handling_simple.F90"
(  130)     length_sq_mid_vector = x_mid*x_mid + y_mid*y_mid + z_mid*z_mid
(  131) # 132 "latlon_handling_simple.F90"
(  132)     IF (abs(length_sq_mid_vector) .lt. eps) THEN
(  133)        ! this exception might happen if you ask for the midpoint of 
(  134)        ! 2 locations that are exactly opposite on the globe.
(  135)        ! Since no proper midpoint can be defined on this case
(  136)        ! return with missing values
(  137)        lat_mid = missing_indicator_real_r8
(  138)        lon_mid = missing_indicator_real_r8
(  139)        return
(  140)     END IF
(  141) # 142 "latlon_handling_simple.F90"
(  142)     ! ==>renormalise to 1
(  143)     norm_factor = 1._r8_/sqrt(length_sq_mid_vector)
(  144)     x_mid = x_mid * norm_factor
(  145)     y_mid = y_mid * norm_factor
(  146)     z_mid = z_mid * norm_factor
(  147) # 148 "latlon_handling_simple.F90"
(  148)     ! ==>convert xyz back to lat,lon
(  149)     call xyz2latlon_radius1(x_mid,y_mid,z_mid,lat_mid,lon_mid)
(  150) # 151 "latlon_handling_simple.F90"
(  151)   end subroutine get_midpoint_vector
(  152)     !  #]
(  153)   subroutine get_midpoint_simple(lat1,lon1,lat2,lon2,& ! inputs
(  154)                                  lat_mid,lon_mid)      ! outputs
(  155)     !  #[
(  156)     ! determine the lat-lon of the midpoint in [deg]
(  157)     ! from 2 lat-lon pairs given in [deg]
(  158) # 159 "latlon_handling_simple.F90"
(  159)     ! method: use a very simple average
(  160)     ! (known to fail around the poles, and not very accurate, since
(  161)     !  you don't follow the great-circle, so only valid for small distances)
(  162) # 163 "latlon_handling_simple.F90"
(  163)     real(r8_), intent(in)  :: lat1,lon1,lat2,lon2 ! inputs
(  164)     real(r8_), intent(out) :: lat_mid,lon_mid     ! outputs
(  165) # 166 "latlon_handling_simple.F90"
(  166)     ! local variables
(  167)     real(r8_) :: lat_diff_deg, lon_diff_deg
(  168) # 169 "latlon_handling_simple.F90"
(  169)     ! if any of the inputs is missing, return with missing
(  170)     if ( missing_real(lat1) .or. missing_real(lon1) .or. &
(  171)          missing_real(lat2) .or. missing_real(lon2) ) then
(  172)        lat_mid = missing_indicator_real_r8
(  173)        lon_mid = missing_indicator_real_r8






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 13

(  174)        return
(  175)     end if
(  176) # 177 "latlon_handling_simple.F90"
(  177)     ! get the differences
(  178)     lat_diff_deg = lat2 - lat1
(  179)     lon_diff_deg = lon2 - lon1
(  180) # 181 "latlon_handling_simple.F90"
(  181)     ! account for the fact that lon=-179.9 and lon=179.9 are neighbouring
(  182)     IF (lon_diff_deg .gt.  180._r8_) lon_diff_deg = lon_diff_deg - 360._r8_ 
(  183)     IF (lon_diff_deg .lt. -180._r8_) lon_diff_deg = lon_diff_deg + 360._r8_ 
(  184) # 185 "latlon_handling_simple.F90"
(  185)     lat_mid = lat1+0.5*lat_diff_deg
(  186)     lon_mid = lon1+0.5*lon_diff_deg
(  187) # 188 "latlon_handling_simple.F90"
(  188)     ! enforcethe range -180 .. +180
(  189)     if (lon_mid .gt.  180._r8_) lon_mid = lon_mid - 360._r8_ 
(  190)     if (lon_mid .lt. -180._r8_) lon_mid = lon_mid + 360._r8_ 
(  191) # 192 "latlon_handling_simple.F90"
(  192)   end subroutine get_midpoint_simple
(  193)     !  #]
(  194)   !--------------------------------
(  195)   function get_distance_grcircle(lat1,lon1,lat2,lon2) result(distance)
(  196)     !  #[
(  197)     ! this function converts the angle-distance between 
(  198)     ! 2 latlon pairs to a km distance
(  199) # 200 "latlon_handling_simple.F90"
(  200)     real(r8_) :: lat1,lon1,lat2,lon2 ! input
(  201)     real(r8_) :: distance            ! result [km]
(  202) # 203 "latlon_handling_simple.F90"
(  203)     ! local variables
(  204)     real(r8_) :: angle_distance
(  205) # 206 "latlon_handling_simple.F90"
(  206)     ! if any of the inputs is missing, return with missing
(  207)     if ( missing_real(lat1) .or. missing_real(lon1) .or. &
(  208)          missing_real(lat2) .or. missing_real(lon2) ) then
(  209)        distance = missing_indicator_real_r8
(  210)        return
(  211)     end if
(  212) # 213 "latlon_handling_simple.F90"
(  213)     ! since angle_distance will always yield a non-negative
(  214)     ! number, distance will always be non-negative as well
(  215)     angle_distance = get_angle_distance_grcircle(lat1,lon1,lat2,lon2) 
(  216)     distance = 2._r8_*pi*R_earth_equatorial*angle_distance/360._r8_
(  217) # 218 "latlon_handling_simple.F90"
(  218)   end function Get_distance_grcircle
(  219)     !  #]
(  220)   !function get_distance_flat(lat1,lon1,lat2,lon2) result(distance)
(  221)     !  #[
(  222)     ! this function converts the angle-distance between 
(  223)     ! 2 latlon pairs to a km distance
(  224) # 225 "latlon_handling_simple.F90"
(  225) !    real(r8_) :: lat1,lon1,lat2,lon2 ! input
(  226) !    real(r8_) :: distance            ! result [km]
(  227) # 228 "latlon_handling_simple.F90"
(  228)     ! local variables
(  229) !    real(r8_) :: angle_distance
(  230) # 231 "latlon_handling_simple.F90"
(  231)     ! if any of the inputs is missing, return with missing






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 14

(  232) !    if ( missing_real(lat1) .or. missing_real(lon1) .or. &
(  233) !         missing_real(lat2) .or. missing_real(lon2) ) then
(  234) !       distance = missing_indicator_real_r8
(  235) !       return
(  236) !    end if
(  237) # 238 "latlon_handling_simple.F90"
(  238)     ! since angle_distance will always yield a non-negative
(  239)     ! number, distance will always be non-negative as well
(  240) !    angle_distance = get_angle_distance_flat(lat1,lon1,lat2,lon2) 
(  241) !    distance = 2._r8_*pi*R_earth_equatorial*angle_distance/360._r8_
(  242)     
(  243) !  end function get_distance_flat
(  244)     !  #]
(  245)   !--------------------------------
(  246)   function ensure_lon_range_180_180(lon) result(norm_lon)
(  247)     !  #[
(  248)     real(r8_), intent(in) :: lon      ! input  in [deg]
(  249)     real(r8_)             :: norm_lon ! result in [deg]
(  250) # 251 "latlon_handling_simple.F90"
(  251)     norm_lon =  modulo(lon+180._r8_, 360._r8_)-180._r8_
(  252) # 253 "latlon_handling_simple.F90"
(  253)   end function ensure_lon_range_180_180
(  254)     !  #]
(  255)   !--------------------------------
(  256)   ! functions private to this module
(  257)   function get_angle_distance_grcircle(lat1,lon1,lat2,lon2) result(angle_dist)
(  258)     !  #[
(  259)     ! determine the angle (in degrees) on the earths surface
(  260)     ! between 2 sets of lat-lon coordinates
(  261)     ! along a great-circle 
(  262)     ! (assuming that the shape of the earth is a perfect globe)
(  263)     
(  264)     ! equations taken from:
(  265)     ! http://mathworld.wolfram.com/GreatCircle.html
(  266) # 267 "latlon_handling_simple.F90"
(  267)     ! use the property that the angle alpha between 2 vectors in
(  268)     ! cartesian coordinates is given by the inner product of the 2 vectors:
(  269)     !              _    _
(  270)     ! cos(alpha) = v1 . v2
(  271) # 272 "latlon_handling_simple.F90"
(  272)     ! note that the error for using a sperical earth in stead of the proper
(  273)     ! spheroid must always be between the result using R_earth_equatorial
(  274)     ! and the result using R_earth_polar. Therefore the maximum error
(  275)     ! is estimated at: 
(  276)     ! 100.*(R_earth_equatorial - R_earth_polar)/R_earth_polar = 0.34 percent
(  277)     ! which is an acceptable accuracy for our use
(  278) # 279 "latlon_handling_simple.F90"
(  279)     real(r8_), intent(in) :: lat1,lon1,lat2,lon2
(  280)     real(r8_) :: angle_dist
(  281) # 282 "latlon_handling_simple.F90"
(  282)     ! loal variables
(  283)     real(r8_) :: x1,y1,z1
(  284)     real(r8_) :: x2,y2,z2
(  285)     real(r8_) :: inner_prod
(  286) # 287 "latlon_handling_simple.F90"
(  287)     call latlon2xyz_radius1(lat1,lon1,x1,y1,z1)
(  288)     call latlon2xyz_radius1(lat2,lon2,x2,y2,z2)
(  289)     inner_prod = (x1*x2+y1*y2+z1*z2)






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 15

(  290) # 291 "latlon_handling_simple.F90"
(  291)     ! extra check, abs(inner_prod) should never be larger than 1 !
(  292)     ! however, due to rounding errors it might happen anyway
(  293)     if (abs(inner_prod) .gt. 1._r8_) inner_prod = 1._r8_
(  294) # 295 "latlon_handling_simple.F90"
(  295)     ! extra check, abs(inner_prod) should never be smaller than -1 !
(  296)     ! however, due to rounding errors it might happen anyway
(  297)     if (abs(inner_prod) .lt. -1._r8_) inner_prod = -1._r8_
(  298) # 299 "latlon_handling_simple.F90"
(  299)     ! note that an inner product may be negative
(  300)     ! so apply abs() to ensure the distance is always positive or zero
(  301)     angle_dist = abs(acos(inner_prod)*rad2deg)
(  302)     
(  303)   end function get_angle_distance_grcircle
(  304)   !  #] ----------------------------------------------------------
(  305)   function get_angle_distance_flat(lat1,lon1,lat2,lon2) result(angle_dist)
(  306)     !  #[
(  307)     ! determine the angle (in degrees) between 2 sets of lat-lon coordinates
(  308)     ! (assuming that the local shape of the earth is flat)
(  309) # 310 "latlon_handling_simple.F90"
(  310)     ! this function is borrowed from KNMI's genscat package
(  311)     ! it calculates the angle-distance between 2 latlon pairs
(  312) # 313 "latlon_handling_simple.F90"
(  313)     ! compare with the old PRESCAT code in NODEQC.F, lines 210/214
(  314)     ! calculation of zDlat, zDlon
(  315) # 316 "latlon_handling_simple.F90"
(  316)     real(r8_), intent(in) :: lat1,lon1,lat2,lon2
(  317)     real(r8_) :: angle_dist
(  318) # 319 "latlon_handling_simple.F90"
(  319)     ! loal variables
(  320)     real(r8_) :: lat_diff_deg, lon_diff_deg
(  321)     real(r8_) :: lat_min_deg, lat_min_rad
(  322)     real(r8_) :: distance_sq
(  323) # 324 "latlon_handling_simple.F90"
(  324)     ! get the differences
(  325)     lat_diff_deg = lat2 - lat1
(  326)     lon_diff_deg = lon2 - lon1
(  327)     
(  328)     ! determine lowest latitude of both positions
(  329)     lat_min_deg = min( abs(lat1),abs(lat2) )
(  330)              
(  331)     ! convert lowest latitude to radians
(  332)     lat_min_rad = lat_min_deg*deg2rad
(  333)              
(  334)     ! account for the fact that lon=-179.9 and lon=179.9 are neighbouring
(  335)     IF (lon_diff_deg .gt.  180._r8_) lon_diff_deg = lon_diff_deg - 360._r8_ 
(  336)     IF (lon_diff_deg .lt. -180._r8_) lon_diff_deg = lon_diff_deg + 360._r8_ 
(  337) # 338 "latlon_handling_simple.F90"
(  338)     ! the triangle in lat-lon grid defining the distance between the 
(  339)     ! two nodes, has sides of length (R=radius of the earth):
(  340)     !     R*lat_difference_rad                      (in north-south direction)
(  341)     ! and R*cos(lat_minimum_rad)*lon_difference_rad (in east-west direction)
(  342)     !
(  343)     ! so the square of the third side (and the distance) is:
(  344)     !     R^2*lat_difference_rad^2 + 
(  345)     !     R^2*cos(lat_minimum_rad)^2*lon_difference_rad^2
(  346)              
(  347)     ! for simplicity, we remove the factors R and deg2rad






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 16

(  348)     ! from this calculation, and the following remains:
(  349)     
(  350)     distance_sq = lon_diff_deg**2 * cos(lat_min_rad)**2 + lat_diff_deg**2
(  351)     angle_dist = sqrt(distance_sq)
(  352) # 353 "latlon_handling_simple.F90"
(  353)   end function get_angle_distance_flat
(  354)   !  #] ----------------------------------------------------------
(  355)   subroutine latlon2xyz_radius1(lat,lon,x,y,z)
(  356)     !  #[
(  357)     ! convert spherical to cartesian coordinates, i.e.
(  358)     ! calculate x,y,z coordinates for a given lat,lon pair on a sphere
(  359)     ! of radius 1
(  360) # 361 "latlon_handling_simple.F90"
(  361)     ! equations taken from:
(  362)     ! http://mathworld.wolfram.com/GreatCircle.html
(  363) # 364 "latlon_handling_simple.F90"
(  364)     real(r8_), intent(in)  :: lat,lon
(  365)     real(r8_), intent(out) :: x,y,z
(  366) # 367 "latlon_handling_simple.F90"
(  367)     ! local variables
(  368)     real(r8_) :: lon_rad,lat_rad
(  369)     real(r8_) :: coslat
(  370) # 371 "latlon_handling_simple.F90"
(  371)     lon_rad   = lon*deg2rad
(  372)     lat_rad   = lat*deg2rad
(  373)     coslat = cos(lat_rad)
(  374)     x      = cos(lon_rad)*coslat
(  375)     y      = sin(lon_rad)*coslat
(  376)     z      = sin(lat_rad)
(  377) # 378 "latlon_handling_simple.F90"
(  378)   end subroutine latlon2xyz_radius1
(  379)   !  #]                                      
(  380)   subroutine xyz2latlon_radius1(x,y,z,lat,lon)
(  381)     !  #[ 
(  382)     ! convert cartesian coordinates to spherical, i.e.
(  383)     ! calculate a lat,lon pair on a sphere of radius 1
(  384)     ! given the x,y,z coordinates 
(  385) # 386 "latlon_handling_simple.F90"
(  386)     real(r8_), intent(in)  :: x,y,z
(  387)     real(r8_), intent(out) :: lat,lon
(  388) # 389 "latlon_handling_simple.F90"
(  389)     ! local variable
(  390)     real(r8_) :: cos_lat
(  391)     real(r8_), parameter :: eps = 1.e-12_r8_
(  392) # 393 "latlon_handling_simple.F90"
(  393)     ! calculate the latitude
(  394)     cos_lat   = sqrt(x*x+y*y)
(  395)     if (z .ge. 0._r8_) then
(  396)        lat =           acos(cos_lat)*rad2deg
(  397)     else
(  398)        lat = -1._r8_ * acos(cos_lat)*rad2deg
(  399)     end if
(  400) # 401 "latlon_handling_simple.F90"
(  401)     ! calculate the longitude
(  402)     if ((abs(y) .lt. eps) .and. (abs(x) .lt. eps)) then
(  403)        ! on the pole longitude has no meaning, so set it to 0
(  404)        lon = 0._r8_
(  405)     else






NVFORTRAN (Version     23.1)          02/24/2023  13:47:26      page 17

(  406)        lon = atan2(y,x)*rad2deg
(  407)        ! result is in the range -180 .. +180
(  408)     endif
(  409) # 410 "latlon_handling_simple.F90"
(  410)   end subroutine xyz2latlon_radius1
(  411)   !  #]
(  412)   !--------------------------------
(  413) end module LatLon_Handling
