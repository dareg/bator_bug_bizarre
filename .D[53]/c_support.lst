


NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: c_support.F90

(    1) module c_support
(    2)   !  #[ documentation
(    3)   !-------------------------------------------
(    4)   ! some routines for easier access to routines
(    5)   ! from the standard clib library, that are not
(    6)   ! easily available for fortran90
(    7)   !
(    8)   ! Modifications:
(    9)   !   27-Oct-2005 J. de Kloe added this module to the L2BP (copy from genscat)
(   10)   !   03-Apr-2006 J. de Kloe added wrappers for gethostname and get_process_id
(   11)   !   27-Jul-2006 J. de Kloe added wrappers for the remove() function
(   12)   !   22-Nov-2006 J. de Kloe added function convert_string_c_to_fortran
(   13)   !   10-Oct-2007 J. de Kloe added a few missing intents
(   14)   !   16-Jan-2008 J. de Kloe phase out integer kind i_ 
(   15)   !   08-Jan-2009 J. de Kloe added is_dir() function
(   16)   !   23-Jan-2009 J. de Kloe added system_cmd() subroutine
(   17)   !   20-Mar-2009 J. de Kloe adapted to changed get_size_of_long function
(   18)   !   11-Apr-2014 J. de Kloe implement dirlisting, glob and regexp support
(   19)   !   24-Apr-2014 J. de Kloe implement open_dir_for_listing_sorted
(   20)   !   30-Apr-2014 J. de Kloe fix sorting in open_dir_for_listing
(   21)   !                          which crashed for the pgf90 compiler
(   22)   !
(   23)   !-------------------------------------------
(   24)   !  #]
(   25)   !  #[ use statements
(   26)   USE StringTools, only: string2chararray, chararray2string
(   27)   USE numerics, only: i2_, i4_, i8_, nbytes_i4_, nbytes_i8_
(   28)   USE ErrorHandler, only: error_programming, error_c_interface, &
(   29)        error_allocate, no_error
(   30)   !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 3

(   31)   !  #[ variables and parameters 
(   32) 
(   33)   implicit none
(   34) 
(   35)   ! the next 4 saved global variables are used by open_dir_for_listing_sorted,
(   36)   ! get_next_direntry_sorted, and close_dir_for_listing_sorted
(   37)   integer, save :: count, max_len, last_reported_direntry
(   38)   character(len=1), dimension(:,:), pointer, save :: stored_names
(   39) 
(   40) 
(   41)   ! see the manpage of stat for a description of these elements 
(   42)   integer, parameter :: stat_dev     = 1  ! device
(   43)   integer, parameter :: stat_ino     = 2  ! inode
(   44)   integer, parameter :: stat_mode    = 3  ! protection
(   45)   integer, parameter :: stat_nlink   = 4  ! number of hard links
(   46)   integer, parameter :: stat_uid     = 5  ! user ID of owner
(   47)   integer, parameter :: stat_gid     = 6  ! group ID of owner
(   48)   integer, parameter :: stat_rdev    = 7  ! device type (if inode device)
(   49)   integer, parameter :: stat_size    = 8  ! total size, in bytes
(   50)   integer, parameter :: stat_blksize = 9  ! blocksize for filesystem I/O
(   51)   integer, parameter :: stat_blocks  = 10 ! number of blocks allocated
(   52)   integer, parameter :: stat_atime   = 11 ! time of last access
(   53)   integer, parameter :: stat_mtime   = 12 ! time of last modification
(   54)   integer, parameter :: stat_ctime   = 13 ! time of last change
(   55)   !  #]
(   56)   !  #[ interface statements to external c functions
(   57)   ! this replaces the old "external" statement
(   58)   ! and provides the compiler a way of checking the interface !!
(   59)   interface 
(   60)      ! a version that is used when sizeof(long)=4
(   61)      function get_stat_result_c4(filename, stat_result) result(err)
(   62)        USE numerics, only: i4_
(   63)        character(len=*),            intent(in)  :: filename
(   64)        integer(i4_), dimension(13), intent(out) :: stat_result
(   65)        integer(i4_)                             :: err
(   66)      end function get_stat_result_c4
(   67)      ! a version that is used when sizeof(long)=8
(   68)      function get_stat_result_c8(filename, stat_result) result(err)
(   69)        USE numerics, only: i8_
(   70)        character(len=*),            intent(in)  :: filename
(   71)        integer(i8_), dimension(13), intent(out) :: stat_result
(   72)        integer(i8_)                             :: err
(   73)      end function get_stat_result_c8
(   74)      ! a function to request sizeof(long)
(   75)      function get_size_of_long() result(size)
(   76)        USE numerics, only:i2_
(   77)        integer(i2_) :: size
(   78)      end function get_size_of_long
(   79)      function gethostname_c4(hostname) result(err)
(   80)        USE numerics, only: i4_
(   81)        character(len=*), intent(out) :: hostname
(   82)        integer(i4_)                  :: err
(   83)      end function gethostname_c4
(   84)      function gethostname_c8(hostname) result(err)
(   85)        USE numerics, only: i8_
(   86)        character(len=*), intent(out) :: hostname
(   87)        integer(i8_)                  :: err
(   88)      end function gethostname_c8






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 4

(   89)      function get_pid_c4() result(pid)
(   90)        USE numerics, only: i4_
(   91)        integer(i4_) :: pid
(   92)      end function get_pid_c4
(   93)      function get_pid_c8() result(pid)
(   94)        USE numerics, only: i8_
(   95)        integer(i8_) :: pid
(   96)      end function get_pid_c8
(   97)      function remove_file_c4(filename) result(err)
(   98)        USE numerics, only: i4_
(   99)        character(len=*), intent(in) :: filename
(  100)        integer(i4_)                 :: err
(  101)      end function remove_file_c4
(  102)      function remove_file_c8(filename) result(err)
(  103)        USE numerics, only: i8_
(  104)        character(len=*), intent(in) :: filename
(  105)        integer(i8_)                 :: err
(  106)      end function remove_file_c8
(  107)      function is_dir_c4(dirname) result(isdir)
(  108)        USE numerics, only: i4_
(  109)        character(len=*), intent(in) :: dirname
(  110)        integer(i4_)                 :: isdir       
(  111)      end function is_dir_c4
(  112)      function is_dir_c8(dirname) result(isdir)
(  113)        USE numerics, only: i8_
(  114)        character(len=*), intent(in) :: dirname
(  115)        integer(i8_)                 :: isdir       
(  116)      end function is_dir_c8
(  117)      function system_c4(command) result(err)
(  118)        USE numerics, only: i4_
(  119)        character(len=*), intent(in) :: command
(  120)        integer(i4_)                 :: err
(  121)      end function system_c4
(  122)      function system_c8(command) result(err)
(  123)        USE numerics, only: i8_
(  124)        character(len=*), intent(in) :: command
(  125)        integer(i8_)                 :: err
(  126)      end function system_c8
(  127)      function opendir_c4(dirname) result(err)
(  128)        USE numerics, only: i4_
(  129)        character(len=*), intent(in) :: dirname
(  130)        integer(i4_)                 :: err
(  131)      end function opendir_c4
(  132)      function opendir_c8(dirname) result(err)
(  133)        USE numerics, only: i8_
(  134)        character(len=*), intent(in) :: dirname
(  135)        integer(i8_)                 :: err
(  136)      end function opendir_c8
(  137)      function get_next_direntry_c4(direntry257) result(err)
(  138)        USE numerics, only: i4_
(  139)        character(len=*), intent(in) :: direntry257
(  140)        integer(i4_)                 :: err
(  141)      end function get_next_direntry_c4
(  142)      function get_next_direntry_c8(direntry257) result(err)
(  143)        USE numerics, only: i8_
(  144)        character(len=*), intent(in) :: direntry257
(  145)        integer(i8_)                 :: err
(  146)      end function get_next_direntry_c8






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 5

(  147)      function closedir() result(err)
(  148)        USE numerics, only: i4_
(  149)        integer(i4_)                 :: err
(  150)      end function closedir
(  151)      function openglob_c4(pattern) result(err)
(  152)        USE numerics, only: i4_
(  153)        character(len=*), intent(in) :: pattern
(  154)        integer(i4_)                 :: err
(  155)      end function openglob_c4
(  156)      function openglob_c8(pattern) result(err)
(  157)        USE numerics, only: i8_
(  158)        character(len=*), intent(in) :: pattern
(  159)        integer(i8_)                 :: err
(  160)      end function openglob_c8
(  161)      function getnextglobentry_c4(match257) result(err)
(  162)        USE numerics, only: i4_
(  163)        character(len=*), intent(in) :: match257
(  164)        integer(i4_)                 :: err
(  165)      end function getnextglobentry_c4
(  166)      function getnextglobentry_c8(match257) result(err)
(  167)        USE numerics, only: i8_
(  168)        character(len=*), intent(in) :: match257
(  169)        integer(i8_)                 :: err
(  170)      end function getnextglobentry_c8
(  171)      function closeglob() result(err)
(  172)        USE numerics, only: i4_
(  173)        integer(i4_)                 :: err
(  174)      end function closeglob
(  175)      function regexp_compile_c4(pattern) result(err)
(  176)        USE numerics, only: i4_
(  177)        character(len=*), intent(in) :: pattern
(  178)        integer(i4_)                 :: err
(  179)      end function regexp_compile_c4
(  180)      function regexp_compile_c8(pattern) result(err)
(  181)        USE numerics, only: i8_
(  182)        character(len=*), intent(in) :: pattern
(  183)        integer(i8_)                 :: err
(  184)      end function regexp_compile_c8
(  185)      function regexp_search_c4(text) result(err)
(  186)        USE numerics, only: i4_
(  187)        character(len=*), intent(in) :: text
(  188)        integer(i4_)                 :: err
(  189)      end function regexp_search_c4
(  190)      function regexp_search_c8(text) result(err)
(  191)        USE numerics, only: i8_
(  192)        character(len=*), intent(in) :: text
(  193)        integer(i8_)                 :: err
(  194)      end function regexp_search_c8
(  195)      function regexp_close() result(err)
(  196)        USE numerics, only: i4_
(  197)        integer(i4_)                 :: err
(  198)      end function regexp_close
(  199)   end interface
(  200)   !  #]
(  201)   !  #[ overload some functions with multiple input interfaces
(  202)   ! overload the get_filesize function
(  203)   interface get_filesize
(  204)      module procedure get_filesize_u, get_filesize_f






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 6

(  205)   end interface
(  206)   !  #]
(  207) contains
(  208)   !------------------------------------------
(  209)   function get_filesize_u(fileunit) result(size)
(  210)     !  #[ get the filesize
(  211)     integer, intent(in) :: fileunit ! input
(  212)     integer             :: size     ! result
(  213) 
(  214)     ! local variables
(  215)     logical            :: nmd
(  216)     character(len=256) :: fname
(  217) 
(  218)     ! this trick with inquire to find out the filename is necessary
(  219)     ! because the c-fileunits differ from the fortran-fileunits,
(  220)     ! so the c-function fstat() cannot directly handle fortran
(  221)     ! fileunits as input.
(  222) 
(  223)     inquire(unit=fileunit,named=nmd)
(  224)     if (nmd) then
(  225)        ! init the remainder of the string with spaces
(  226)        fname(:) = ' '
(  227) 
(  228)        inquire(unit=fileunit,name=fname)
(  229) 
(  230)        size = get_filesize_f(fname)
(  231)        !print *,"inside c_support.F90[get_filesize_u]: "
(  232)        !print *,"the size of this file is ",size," in bytes"
(  233)        !print *,"the name of this file is ",trim(fname)
(  234)     else
(  235)        print *,"Error in get_filesize_u():"
(  236)        print *,"The fileunit: ",fileunit," seems not to belong to a"
(  237)        print *,"named file. Therefore the wrapper to the stat() function"
(  238)        print *,"can not be called...."
(  239)        print *,"If this is needed please implement it yourself."
(  240)        size = -1 ! report -1 to indicate the error
(  241)        return
(  242)     end if
(  243) 
(  244)     return
(  245) 
(  246)   end function get_filesize_u
(  247)     !  #]
(  248)   function get_filesize_f(filename) result(size)
(  249)     !  #[ get the filesize 
(  250)     character(len=*), intent(in) :: filename ! input
(  251)     integer                      :: size     ! result
(  252) 
(  253)     ! local variables
(  254)     integer(i2_)                :: longsize
(  255)     integer(i4_)                :: err
(  256)     integer(i4_)                :: err4
(  257)     integer(i8_)                :: err8
(  258)     integer(i4_), dimension(13) :: stat_result
(  259)     integer(i4_), dimension(13) :: stat_result4
(  260)     integer(i8_), dimension(13) :: stat_result8
(  261)     character(len=256)          :: filename256
(  262) 






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 7

(  263)     ! init the string with spaces
(  264)     filename256(:)=' '
(  265) 
(  266)     ! Beware: the interface with c expects a stringlength
(  267)     !         of exactly 256 ! Therefore we have to copy the
(  268)     !         implicit length of filename to 256 by copying
(  269)     !         it to filename256 !!!
(  270)     IF (len_trim(filename) .gt. 256) THEN
(  271)        ! print *,"filename too long ....."
(  272)        size = -1
(  273)        return
(  274)     END IF
(  275)     filename256(:)=filename
(  276) 
(  277)     longsize = get_size_of_long()
(  278)     !print *,"inside F90: longsize = ",longsize
(  279) 
(  280)     IF (longsize .eq. nbytes_i4_) THEN
(  281)        ! call the c-wrapper function for stat()
(  282)        err4 = get_stat_result_c4(filename256, stat_result4)
(  283)        err = err4
(  284)        stat_result(:) = stat_result4(:)
(  285)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  286)        ! call the c-wrapper function for stat()
(  287)        err8 = get_stat_result_c8(filename256, stat_result8)
(  288)        err = int(err8,i4_)
(  289)        stat_result(:) = int(stat_result8(:),i4_)
(  290)     ELSE
(  291)        print *,"ERROR in get_filesize_f():"
(  292)        print *,"The interface between c and Fortran90 expects the long integer"
(  293)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  294)        print *,"current machine seems to use: ",longsize
(  295)        size = -1
(  296)        return
(  297)     END IF
(  298) 
(  299)     if (err .ne. 0) then
(  300)        !print *,"Error in c_support.F90[get_filesize_f]"
(  301)        !print *,"get_fstat_result_c() returned with err = ",err
(  302)        size = -1
(  303)        return
(  304)     end if
(  305) 
(  306)     !print *,"inside c_support.F90[get_filesize_f] stat_result = ",stat_result
(  307)     size = stat_result(stat_size)
(  308) 
(  309)     return
(  310) 
(  311)   end function get_filesize_f
(  312)     !  #]
(  313)   function get_hostname() result(hostname)
(  314)     !  #[ get this machines hostname
(  315)     character(len=25) :: hostname ! result
(  316) 
(  317)     ! local variables
(  318)     integer(i2_)      :: longsize
(  319)     integer(i4_)      :: err
(  320)     integer(i4_)      :: err4






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 8

(  321)     integer(i8_)      :: err8
(  322)     character(len=25) :: hostname_c
(  323) 
(  324)     longsize = get_size_of_long()
(  325)     IF (longsize .eq. nbytes_i4_) THEN
(  326)        err4 = gethostname_c4(hostname_c)
(  327)        err = err4
(  328)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  329)        err8 = gethostname_c8(hostname_c)
(  330)        err = int(err8,i4_)
(  331)     ELSE
(  332)        print *,"ERROR in get_hostname():"
(  333)        print *,"The interface between c and Fortran90 expects the long integer"
(  334)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  335)        print *,"current machine seems to use: ",longsize
(  336)        hostname = "unknown"
(  337)        return
(  338)     END IF
(  339) 
(  340)     if (err .ne. 0) then
(  341)        hostname = "unknown"
(  342)        return
(  343)     end if
(  344) 
(  345)     hostname = convert_string_c_to_fortran(hostname_c)
(  346) 
(  347)     return
(  348) 
(  349)   end function get_hostname
(  350)   !  #]
(  351)   function get_process_id() result(pid)
(  352)     !  #[ get the current pid number
(  353)     integer :: pid ! result
(  354) 
(  355)     ! local variables
(  356)     integer(i2_)      :: longsize
(  357)     integer(i4_)      :: pid4
(  358)     integer(i8_)      :: pid8
(  359) 
(  360)     longsize = get_size_of_long()
(  361)     IF (longsize .eq. nbytes_i4_) THEN
(  362)        pid4 = get_pid_c4()
(  363)        pid = pid4
(  364)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  365)        pid8 = get_pid_c8()
(  366)        pid = int(pid8,i4_)
(  367)     ELSE
(  368)        print *,"ERROR in get_process_id():"
(  369)        print *,"The interface between c and Fortran90 expects the long integer"
(  370)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  371)        print *,"current machine seems to use: ",longsize
(  372)        pid = -1
(  373)        return
(  374)     END IF
(  375) 
(  376)     return
(  377) 
(  378)   end function get_process_id






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 9

(  379)   !  #]
(  380)   subroutine remove_file(filename,error_flag)
(  381)     !  #[ remove a file
(  382)     character(len=*), intent(in)  :: filename   ! input
(  383)     integer,          intent(out) :: error_flag ! output
(  384) 
(  385)     ! local variables
(  386)     integer(i2_)       :: longsize
(  387)     integer(i4_)       :: err4,err
(  388)     integer(i8_)       :: err8
(  389)     character(len=256) :: filename256
(  390) 
(  391)     ! NOTE: an alternative way might be to use the fortran command
(  392)     !    close(unit=fileunit,status='delete',err=999)
(  393)     ! but this requires opening the file first.
(  394)     ! I only found out about this fortran90 option after implementing
(  395)     ! this c-workaround, so lets keep it as it is for now.
(  396) 
(  397)     error_flag = no_error
(  398) 
(  399)     ! init the string with spaces
(  400)     filename256(:)=' '
(  401) 
(  402)     ! Beware: the interface with c expects a stringlength
(  403)     !         of exactly 256 ! Therefore we have to copy the
(  404)     !         implicit length of filename to 256 by copying
(  405)     !         it to filename256 !!!
(  406)     IF (len_trim(filename) .gt. 256) THEN
(  407)        print *,"Error in remove_file():"
(  408)        print *,"filename too long ..... (max length is 256 chars)"
(  409)        error_flag = error_programming
(  410)        return
(  411)     END IF
(  412)     filename256 = filename
(  413) 
(  414)     longsize = get_size_of_long()
(  415)     IF (longsize .eq. nbytes_i4_) THEN
(  416)        err4 = remove_file_c4(filename256)
(  417)        err  = err4
(  418)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  419)        err8 = remove_file_c8(filename256)
(  420)        err = int(err8,i4_)
(  421)     ELSE
(  422)        print *,"ERROR in remove_file():"
(  423)        print *,"The interface between c and Fortran90 expects the long integer"
(  424)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  425)        print *,"current machine seems to use: ",longsize
(  426)        error_flag = error_c_interface
(  427)        return
(  428)     END IF
(  429) 
(  430)     IF (err .ne. 0) THEN
(  431)        print *,"ERROR in remove_file():"
(  432)        print *,"could not remove file: ",trim(filename)
(  433)        print *,"reported c error is: ",err
(  434)        ! TODO
(  435)        ! later I could add explanations for the possible error codes
(  436)        ! that may be returned by the c function






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 10

(  437)        error_flag = error_programming
(  438)        return
(  439)     END IF
(  440) 
(  441)     !print *,"succesfully removed file: ",trim(filename)
(  442) 
(  443)   end subroutine remove_file
(  444)     !  #]
(  445)   function convert_string_c_to_fortran(txt_c) result(txt)
(  446)     !  #[ helper function used by get_hostname
(  447) 
(  448)     ! remember the a c-style string is terminated with
(  449)     ! a zero, and may possibly have a bunch of undefined chars following it
(  450)     ! This function converts it to a proper Fortran90 string
(  451)     character(len=*)          :: txt_c ! input
(  452)     character(len=len(txt_c)) :: txt   ! result
(  453) 
(  454)     ! local variable
(  455)     integer                   :: i
(  456) 
(  457)     txt(:) = ' '
(  458)     copyloop: DO i=1,len(txt_c)
(  459)        IF (ichar(txt_c(i:i)) .eq. 0) exit copyloop
(  460)        txt(i:i) = txt_c(i:i)
(  461)     END DO copyloop
(  462) 
(  463)   end function convert_string_c_to_fortran
(  464)     !  #]
(  465)   function is_dir(dirname) result(flag)
(  466)     !  #[ check if a dir with this name exists
(  467)     character(len=*), intent(in) :: dirname ! input
(  468)     logical                      :: flag    ! result
(  469) 
(  470)     ! local variables
(  471)     integer(i2_)       :: longsize
(  472)     integer(i4_)       :: isdir
(  473)     integer(i4_)       :: isdir4
(  474)     integer(i8_)       :: isdir8
(  475)     character(len=256) :: dirname256
(  476) 
(  477)     ! init the string with spaces
(  478)     dirname256(:)=' '
(  479) 
(  480)     ! Beware: the interface with c expects a stringlength
(  481)     !         of exactly 256 ! Therefore we have to copy the
(  482)     !         implicit length of filename to 256 by copying
(  483)     !         it to filename256 !!!
(  484)     IF (len_trim(dirname) .gt. 256) THEN
(  485)        ! print *,"dirname too long ....."
(  486)        flag = .false.
(  487)        return
(  488)     END IF
(  489)     dirname256(:)=dirname
(  490)  
(  491)     longsize = get_size_of_long()
(  492)     !print *,"inside F90: longsize = ",longsize
(  493) 
(  494)     IF (longsize .eq. nbytes_i4_) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 11

(  495)        ! call the c-wrapper function for is_dir()
(  496)        isdir4 = is_dir_c4(dirname256)
(  497)        isdir = isdir4
(  498)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  499)        ! call the c-wrapper function for is_dir()
(  500)        isdir8 = is_dir_c8(dirname256)
(  501)        isdir = int(isdir8,i4_)
(  502)     ELSE
(  503)        print *,"ERROR in is_dir():"
(  504)        print *,"The interface between c and Fortran90 expects the long integer"
(  505)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  506)        print *,"current machine seems to use: ",longsize
(  507)        flag=.false.
(  508)        return
(  509)     END IF
(  510) 
(  511)     ! remark: is_dir_c4/is_dir_c8 return a value of 1 when the name
(  512)     !         is a proper directory, a value of 0 when it exists
(  513)     !         but is not a directory, and a value of -1 when it does not exist
(  514) 
(  515)     flag = .false.
(  516)     if (isdir .gt. 0) flag = .true.
(  517) 
(  518)     return
(  519) 
(  520)   end function is_dir
(  521)     !  #]
(  522)   subroutine system_cmd(command,error_flag)
(  523)     !  #[ execute a shell command
(  524)     character(len=*), intent(in)  :: command    ! input
(  525)     integer,          intent(out) :: error_flag ! output
(  526) 
(  527)     ! local variables
(  528)     integer(i2_)       :: longsize
(  529)     integer(i4_)       :: err4,err
(  530)     integer(i8_)       :: err8
(  531)     character(len=256) :: command256
(  532) 
(  533)     error_flag = no_error
(  534) 
(  535)     ! init the string with spaces
(  536)     command256(:)=' '
(  537) 
(  538)     ! Beware: the interface with c expects a stringlength
(  539)     !         of exactly 256 ! Therefore we have to copy the
(  540)     !         implicit length of command to 256 by copying
(  541)     !         it to command256 !!!
(  542)     IF (len_trim(command) .gt. 256) THEN
(  543)        print *,"Error in system_cmd():"
(  544)        print *,"command too long ..... (max length is 256 chars)"
(  545)        error_flag = error_programming
(  546)        return
(  547)     END IF
(  548)     command256 = command
(  549) 
(  550)     longsize = get_size_of_long()
(  551)     IF (longsize .eq. nbytes_i4_) THEN
(  552)        err4 = system_c4(command256)






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 12

(  553)        err  = err4
(  554)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  555)        err8 = system_c8(command256)
(  556)        err = int(err8,i4_)
(  557)     ELSE
(  558)        print *,"ERROR in system_cmd():"
(  559)        print *,"The interface between c and Fortran90 expects the long integer"
(  560)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  561)        print *,"current machine seems to use: ",longsize
(  562)        error_flag = error_c_interface
(  563)        return
(  564)     END IF
(  565) 
(  566)     IF (err .ne. 0) THEN
(  567)        print *,"ERROR in system_cmd():"
(  568)        print *,"failed command: ",trim(command)
(  569)        print *,"reported c error is: ",err
(  570)        error_flag = error_programming
(  571)        return
(  572)     END IF
(  573) 
(  574)     !print *,"succesfully executed command: ",trim(command)
(  575) 
(  576)   end subroutine system_cmd
(  577)     !  #]
(  578)   subroutine open_dir_for_listing(dirname, error_flag)
(  579)     !  #[ open directory for retrieving its listing
(  580)     character(len=*), intent(in)  :: dirname    ! input
(  581)     integer,          intent(out) :: error_flag ! output
(  582)     
(  583)     ! local variables
(  584)     integer(i2_)       :: longsize
(  585)     integer(i4_)       :: err4,err
(  586)     integer(i8_)       :: err8
(  587)     character(len=256) :: dirname256
(  588) 
(  589)     error_flag = no_error
(  590)     IF (len_trim(dirname) .gt. 256) THEN
(  591)        print *,"Error in open_dir_for_listing():"
(  592)        print *,"dirname too long ..... (max length is 256 chars)"
(  593)        error_flag = error_programming
(  594)        return
(  595)     END IF
(  596)     dirname256 = dirname
(  597)     
(  598)     longsize = get_size_of_long()
(  599)     IF (longsize .eq. nbytes_i4_) THEN
(  600)        err4 = opendir_c4(dirname256)
(  601)        err  = err4
(  602)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  603)        err8 = opendir_c8(dirname256)
(  604)        err = int(err8,i4_)
(  605)     ELSE
(  606)        print *,"ERROR in open_dir_for_listing():"
(  607)        print *,"The interface between c and Fortran90 expects the long integer"
(  608)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  609)        print *,"current machine seems to use: ",longsize
(  610)        error_flag = error_c_interface






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 13

(  611)        return
(  612)     END IF
(  613) 
(  614)     IF (err .ne. 0) THEN
(  615)        print *,"ERROR in open_dir_for_listing():"
(  616)        print *,"failed dirname: ",trim(dirname)
(  617)        print *,"reported c error is: ",err
(  618)        error_flag = error_programming
(  619)        return
(  620)     END IF
(  621) 
(  622)     !print *,"succesfully opened dir for listing: ",trim(dirname)
(  623) 
(  624)   end subroutine open_dir_for_listing
(  625)     !  #]
(  626)   subroutine get_next_direntry(direntry, end_reached, error_flag)
(  627)     !  #[ get next directory list entry
(  628)     character(len=*), intent(out) :: direntry    ! output
(  629)     logical,          intent(out) :: end_reached ! output
(  630)     integer,          intent(out) :: error_flag  ! output
(  631)     
(  632)     ! local variables
(  633)     integer(i2_)       :: longsize
(  634)     integer(i4_)       :: err4,err
(  635)     integer(i8_)       :: err8
(  636)     character(len=257) :: direntry257
(  637) 
(  638)     direntry(:) = ' '
(  639)     end_reached = .false.
(  640)     error_flag = no_error
(  641) 
(  642)     IF (len_trim(direntry) .gt. 256) THEN
(  643)        print *,"Error in get_next_direntry():"
(  644)        print *,"direntry variable too long ..... (max length is 256 chars)"
(  645)        error_flag = error_programming
(  646)        return
(  647)     END IF
(  648)     
(  649)     longsize = get_size_of_long()
(  650)     IF (longsize .eq. nbytes_i4_) THEN
(  651)        err4 = get_next_direntry_c4(direntry257)
(  652)        err  = err4
(  653)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  654)        err8 = get_next_direntry_c8(direntry257)
(  655)        err = int(err8,i4_)
(  656)     ELSE
(  657)        print *,"ERROR in get_next_direntry():"
(  658)        print *,"The interface between c and Fortran90 expects the long integer"
(  659)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  660)        print *,"current machine seems to use: ",longsize
(  661)        error_flag = error_c_interface
(  662)        return
(  663)     END IF
(  664) 
(  665)     ! a value of 2 signals that no more entries are available
(  666)     IF (err .eq. 2) THEN
(  667)        !print *,"No more entries!"
(  668)        end_reached = .true.






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 14

(  669)        return
(  670)     END IF
(  671) 
(  672)     ! this should never occur
(  673)     IF (err .ne. 0) THEN
(  674)        print *,"ERROR in get_next_direntry():"
(  675)        print *,"reported c error is: ",err
(  676)        error_flag = error_programming
(  677)        return
(  678)     END IF
(  679) 
(  680)     direntry257 = convert_string_c_to_fortran(direntry257)
(  681)     if (len_trim(direntry257) .gt. len(direntry)) then
(  682)        print *,"ERROR in get_next_direntry: "
(  683)        print *,"direntry variable too short, cannot return full result."
(  684)        print *,'len_trim(direntry257) = ',len_trim(direntry257)
(  685)        print *,'len(direntry) = ',len(direntry)
(  686)        error_flag = error_programming
(  687)        return
(  688)     end if
(  689)     direntry = direntry257
(  690)     !print *,"succesfully retrieved direntry: ",trim(direntry)
(  691) 
(  692)   end subroutine get_next_direntry
(  693)     !  #]
(  694)   subroutine close_dir_for_listing(error_flag)
(  695)     !  #[ close directory after retrieving its listing
(  696)     integer, intent(out) :: error_flag ! output
(  697)     
(  698)     ! local variables
(  699)     integer(i4_)       :: err
(  700) 
(  701)     error_flag = no_error
(  702)     
(  703)     err = closedir()
(  704)     IF (err .ne. 0) THEN
(  705)        print *,"ERROR in close_dir_for_listing():"
(  706)        print *,"reported c error is: ",err
(  707)        error_flag = error_programming
(  708)        return
(  709)     END IF
(  710) 
(  711)     !print *,"succesfully closed dir for listing "
(  712) 
(  713)   end subroutine close_dir_for_listing
(  714)     !  #]
(  715) 
(  716)   subroutine open_dir_for_listing_sorted(dirname, error_flag)
(  717)     !  #[ same as open_dir_for_listing, but ensure sorted results
(  718)     character(len=*), intent(in)  :: dirname    ! input
(  719)     integer,          intent(out) :: error_flag ! output
(  720) 
(  721)     ! local variables
(  722)     integer :: i, j, n, status
(  723)     logical :: end_reached
(  724)     character(len=256) :: direntry, name1, name2
(  725) 
(  726)     ! these are global saved module variables:






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 15

(  727)     !integer :: count, max_len
(  728)     !character(len=1), dimension(:,:), pointer :: stored_names
(  729) 
(  730)     error_flag = no_error
(  731)     nullify(stored_names)
(  732)     
(  733)     ! now first loop over all results to get count and longest name
(  734)     call open_dir_for_listing(dirname,error_flag)
(  735)     IF (error_flag .ne. no_error) return
(  736) 
(  737)     count = 0
(  738)     max_len = 0
(  739)     end_reached = .false.
(  740)     do while (.not. end_reached)
(  741)        call get_next_direntry(direntry, end_reached, error_flag)
(  742)        IF (error_flag .ne. no_error) return
(  743)        IF (.not. end_reached) THEN
(  744)           n = len_trim(direntry)
(  745)           if (n .gt. max_len) max_len = n
(  746)           count = count + 1
(  747)           !print *,"debug: n, maxlen, count, direntry = ",&
(  748)           !     n, max_len, count, trim(direntry)
(  749)        END IF
(  750)     end do
(  751) 
(  752)     call close_dir_for_listing(error_flag)
(  753)     IF (error_flag .ne. no_error) return
(  754) 
(  755)     !print *,'Debug: result: count, max_len = ', count, max_len
(  756) 
(  757)     allocate(stored_names(count,max_len),stat=status)
(  758)     if (status .ne. 0) then
(  759)        error_flag = error_allocate
(  760)        return
(  761)     end if
(  762) 
(  763)     ! init
(  764)     stored_names(:,:) = ' '
(  765) 
(  766)     ! now loop again over all results and store them
(  767)     call open_dir_for_listing(dirname,error_flag)
(  768)     IF (error_flag .ne. no_error) return
(  769) 
(  770)     end_reached = .false.
(  771)     i = 0
(  772)     do while (.not. end_reached)
(  773)        direntry(:) = ' '
(  774)        call get_next_direntry(direntry, end_reached, error_flag)
(  775)        IF (error_flag .ne. no_error) return
(  776)        IF (.not. end_reached) THEN
(  777)           n = len_trim(direntry)
(  778)           i = i + 1
(  779)           !print *,"debug: storing result: i, direntry = ",&
(  780)           !     i, trim(direntry)
(  781)           !stored_names(i,1:n) = transfer(direntry(1:n), stored_names(i,1:n))
(  782)           ! this transfer does the same as the next do loop over j
(  783)           ! but fails for the pgf90 compiler ...
(  784)           !do j=1,n






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 16

(  785)           !   stored_names(i,j) = direntry(j:j)
(  786)           !end do
(  787)           ! this helper function works correct for all compilers ...
(  788)           stored_names(i,1:n) = string2chararray(direntry(1:n))
(  789)        END IF
(  790)     end do
(  791) 
(  792)     call close_dir_for_listing(error_flag)
(  793)     IF (error_flag .ne. no_error) return
(  794) 
(  795)     ! copy for shorter notation
(  796)     n = max_len
(  797) 
(  798)     !print *,'debug: results1:'
(  799)     !name1(:) = ' '
(  800)     !do i=1,count
(  801)     !   name1(1:n) = transfer(stored_names(i,1:n),name1(1:n))
(  802)     !   print *,i,' : ',trim(name1)
(  803)     !end do
(  804) 
(  805)     ! sort the results
(  806)     do i=1,count-1
(  807)        do j=i+1,count
(  808)           name1(:) = ' '
(  809)           name2(:) = ' '
(  810)           direntry(:) = ' '
(  811)           name1(1:n) = chararray2string(stored_names(i,1:n))
(  812)           name2(1:n) = chararray2string(stored_names(j,1:n))
(  813)           if (name2(1:n) .lt. name1(1:n)) then
(  814)              ! swap them
(  815)              direntry(1:n) = name1(1:n)
(  816)              name1(1:n) = name2(1:n)
(  817)              name2(1:n) = direntry(1:n)
(  818)              stored_names(i,1:n) = string2chararray(name1(1:n))
(  819)              stored_names(j,1:n) = string2chararray(name2(1:n))
(  820)           end if
(  821)        end do
(  822)     end do
(  823)     
(  824)     !print *,'debug: results2:'
(  825)     !do i=1,count
(  826)     !   name1(1:n) = transfer(stored_names(i,1:n),name1(1:n))
(  827)     !   print *,i,' : ',trim(name1(1:n))
(  828)     !end do
(  829) 
(  830)     last_reported_direntry = 0
(  831) 
(  832)     !print *,"succesfully opened dir for listing (sorted): ",trim(dirname)
(  833) 
(  834)   end subroutine open_dir_for_listing_sorted
(  835)     !  #]
(  836) 
(  837)   subroutine get_next_direntry_sorted(direntry, end_reached, error_flag)
(  838)     !  #[ get next directory list entry (sorted)
(  839)     character(len=*), intent(out) :: direntry    ! output
(  840)     logical,          intent(out) :: end_reached ! output
(  841)     integer,          intent(out) :: error_flag  ! output
(  842)     






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 17

(  843)     ! local variables
(  844)     integer :: i, n
(  845) 
(  846)     direntry(:) = ' '
(  847)     end_reached = .false.
(  848)     error_flag = no_error
(  849) 
(  850)     if (last_reported_direntry .ge. count) then
(  851)        !print *,"No more entries!"
(  852)        end_reached = .true.
(  853)        return
(  854)     END IF
(  855) 
(  856)     last_reported_direntry = last_reported_direntry + 1
(  857)     i = last_reported_direntry
(  858)     n = max_len
(  859)     direntry(1:n) = transfer(stored_names(i,1:n),direntry(1:n))
(  860) 
(  861)     !print *,"succesfully retrieved direntry: ",trim(direntry)
(  862) 
(  863)   end subroutine get_next_direntry_sorted
(  864)     !  #]
(  865) 
(  866)   subroutine close_dir_for_listing_sorted(error_flag)
(  867)     !  #[ close directory after retrieving its sorted listing
(  868)     integer, intent(out) :: error_flag ! output
(  869)     
(  870)     error_flag = no_error
(  871)     if (associated(stored_names)) deallocate(stored_names)
(  872)     count = 0
(  873)     max_len = 0
(  874)     last_reported_direntry = 0
(  875) 
(  876)     !print *,"succesfully closed dir for listing (sorted)"
(  877) 
(  878)   end subroutine close_dir_for_listing_sorted
(  879)     !  #]
(  880) 
(  881)   subroutine openglobhandle(pattern, error_flag)
(  882)     !  #[ open glob for pattern search
(  883)     character(len=*), intent(in)  :: pattern    ! input
(  884)     integer,          intent(out) :: error_flag ! output
(  885)     
(  886)     ! local variables
(  887)     integer(i2_)       :: longsize
(  888)     integer(i4_)       :: err4,err
(  889)     integer(i8_)       :: err8
(  890)     character(len=256) :: pattern256
(  891) 
(  892)     error_flag = no_error
(  893)     IF (len_trim(pattern) .gt. 256) THEN
(  894)        print *,"Error in openglobhandle():"
(  895)        print *,"pattern too long ..... (max length is 256 chars)"
(  896)        error_flag = error_programming
(  897)        return
(  898)     END IF
(  899)     pattern256 = pattern
(  900)     






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 18

(  901)     longsize = get_size_of_long()
(  902)     IF (longsize .eq. nbytes_i4_) THEN
(  903)        err4 = openglob_c4(pattern256)
(  904)        err  = err4
(  905)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  906)        err8 = openglob_c8(pattern256)
(  907)        err = int(err8,i4_)
(  908)     ELSE
(  909)        print *,"ERROR in openglobhandle():"
(  910)        print *,"The interface between c and Fortran90 expects the long integer"
(  911)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  912)        print *,"current machine seems to use: ",longsize
(  913)        error_flag = error_c_interface
(  914)        return
(  915)     END IF
(  916) 
(  917)     IF (err .ne. 0) THEN
(  918)        print *,"ERROR in openglobhandle():"
(  919)        print *,"failed pattern: ",trim(pattern)
(  920)        print *,"reported c error is: ",err
(  921)        error_flag = error_programming
(  922)        return
(  923)     END IF
(  924) 
(  925)     !print *,"succesfully opened glob for pattern: ",trim(pattern)
(  926)     
(  927)   end subroutine openglobhandle
(  928)     !  #]
(  929)   subroutine getnextglobentry(match, end_reached, error_flag)
(  930)     !  #[ get next glob search result
(  931)     character(len=*), intent(out) :: match       ! output
(  932)     logical,          intent(out) :: end_reached ! output
(  933)     integer,          intent(out) :: error_flag  ! output
(  934)     
(  935)     ! local variables
(  936)     integer(i2_)       :: longsize
(  937)     integer(i4_)       :: err4,err
(  938)     integer(i8_)       :: err8
(  939)     character(len=257) :: match257
(  940) 
(  941)     match(:) = ' '
(  942)     end_reached = .false.
(  943)     error_flag = no_error
(  944) 
(  945)     IF (len_trim(match) .gt. 256) THEN
(  946)        print *,"Error in getnextglobentry():"
(  947)        print *,"match variable too long ..... (max length is 256 chars)"
(  948)        error_flag = error_programming
(  949)        return
(  950)     END IF
(  951)     
(  952)     longsize = get_size_of_long()
(  953)     IF (longsize .eq. nbytes_i4_) THEN
(  954)        err4 = getnextglobentry_c4(match257)
(  955)        err  = err4
(  956)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  957)        err8 = getnextglobentry_c8(match257)
(  958)        err = int(err8,i4_)






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 19

(  959)     ELSE
(  960)        print *,"ERROR in getnextglobentry():"
(  961)        print *,"The interface between c and Fortran90 expects the long integer"
(  962)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  963)        print *,"current machine seems to use: ",longsize
(  964)        error_flag = error_c_interface
(  965)        return
(  966)     END IF
(  967) 
(  968)     ! a value of 2 signals that no more entries are available
(  969)     IF (err .eq. 2) THEN
(  970)        !print *,"No more entries!"
(  971)        end_reached = .true.
(  972)        return
(  973)     END IF
(  974) 
(  975)     ! this should never occur
(  976)     IF (err .ne. 0) THEN
(  977)        print *,"ERROR in getnextglobentry():"
(  978)        print *,"reported c error is: ",err
(  979)        error_flag = error_programming
(  980)        return
(  981)     END IF
(  982) 
(  983)     match257 = convert_string_c_to_fortran(match257)
(  984)     if (len_trim(match257) .gt. len(match)) then
(  985)        print *,"ERROR in getnextglobentry: "
(  986)        print *,"match variable too short, cannot return full result."
(  987)        print *,'len_trim(match257) = ',len_trim(match257)
(  988)        print *,'len(match) = ',len(match)
(  989)        error_flag = error_programming
(  990)        return
(  991)     end if
(  992)     match = match257
(  993)     !print *,"succesfully retrieved glob pattern match: ",trim(match)
(  994) 
(  995)   end subroutine getnextglobentry
(  996)     !  #]
(  997)   subroutine closeglobhandle(error_flag)
(  998)     !  #[ close glob after retrieving pattern search results
(  999)     integer, intent(out) :: error_flag ! output
( 1000)     
( 1001)     ! local variables
( 1002)     integer(i4_)       :: err
( 1003) 
( 1004)     error_flag = no_error
( 1005)     
( 1006)     err = closeglob()
( 1007)     IF (err .ne. 0) THEN
( 1008)        print *,"ERROR in closeglob():"
( 1009)        print *,"reported c error is: ",err
( 1010)        error_flag = error_programming
( 1011)        return
( 1012)     END IF
( 1013) 
( 1014)     !print *,"succesfully closed glob"
( 1015) 
( 1016)   end subroutine closeglobhandle






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 20

( 1017)     !  #]
( 1018)   subroutine regexp_compile(pattern,error_flag)
( 1019)     !  #[ compile regexp for pattern search
( 1020)     character(len=*), intent(in)  :: pattern    ! input
( 1021)     integer,          intent(out) :: error_flag ! output
( 1022)     
( 1023)     ! local variables
( 1024)     integer(i2_)       :: longsize
( 1025)     integer(i4_)       :: err4,err
( 1026)     integer(i8_)       :: err8
( 1027)     character(len=256) :: pattern256
( 1028) 
( 1029)     error_flag = no_error
( 1030)     IF (len_trim(pattern) .gt. 256) THEN
( 1031)        print *,"Error in regexp_compile():"
( 1032)        print *,"pattern too long ..... (max length is 256 chars)"
( 1033)        error_flag = error_programming
( 1034)        return
( 1035)     END IF
( 1036)     pattern256 = pattern
( 1037)     
( 1038)     longsize = get_size_of_long()
( 1039)     IF (longsize .eq. nbytes_i4_) THEN
( 1040)        err4 = regexp_compile_c4(pattern256)
( 1041)        err  = err4
( 1042)     ELSEIF (longsize .eq. nbytes_i8_) THEN
( 1043)        err8 = regexp_compile_c8(pattern256)
( 1044)        err = int(err8,i4_)
( 1045)     ELSE
( 1046)        print *,"ERROR in regexp_compile():"
( 1047)        print *,"The interface between c and Fortran90 expects the long integer"
( 1048)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
( 1049)        print *,"current machine seems to use: ",longsize
( 1050)        error_flag = error_c_interface
( 1051)        return
( 1052)     END IF
( 1053) 
( 1054)     IF (err .ne. 0) THEN
( 1055)        print *,"ERROR in regexp_compile():"
( 1056)        print *,"failed pattern: ",trim(pattern)
( 1057)        print *,"reported c error is: ",err
( 1058)        error_flag = error_programming
( 1059)        return
( 1060)     END IF
( 1061) 
( 1062)     !print *,"succesfully compiled pattern: ",trim(pattern)
( 1063) 
( 1064)   end subroutine regexp_compile
( 1065)     !  #]
( 1066)   subroutine regexp_search(text, matches, error_flag)
( 1067)     !  #[ do pattern search
( 1068)     character(len=*), intent(in)  :: text       ! input
( 1069)     logical,          intent(out) :: matches    ! output
( 1070)     integer,          intent(out) :: error_flag ! output
( 1071)     
( 1072)     ! local variables
( 1073)     integer(i2_)       :: longsize
( 1074)     integer(i4_)       :: res4,res






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 21

( 1075)     integer(i8_)       :: res8
( 1076)     character(len=256) :: text256
( 1077) 
( 1078)     matches = .false.
( 1079)     error_flag = no_error
( 1080) 
( 1081)     IF (len_trim(text) .gt. 256) THEN
( 1082)        print *,"Error in regexp_search():"
( 1083)        print *,"text too long ..... (max length is 256 chars)"
( 1084)        error_flag = error_programming
( 1085)        return
( 1086)     END IF
( 1087)     text256 = text
( 1088)     
( 1089)     longsize = get_size_of_long()
( 1090)     IF (longsize .eq. nbytes_i4_) THEN
( 1091)        res4 = regexp_search_c4(text256)
( 1092)        res  = res4
( 1093)     ELSEIF (longsize .eq. nbytes_i8_) THEN
( 1094)        res8 = regexp_search_c8(text256)
( 1095)        res = int(res8,i4_)
( 1096)     ELSE
( 1097)        print *,"ERROR in regexp_search():"
( 1098)        print *,"The interface between c and Fortran90 expects the long integer"
( 1099)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
( 1100)        print *,"current machine seems to use: ",longsize
( 1101)        error_flag = error_c_interface
( 1102)        return
( 1103)     END IF
( 1104) 
( 1105)     if (res .eq.0) matches = .true.
( 1106)     
( 1107)     !print *,'regexp_search(): ',res
( 1108)     !print *,"search complete for text: ",trim(text)
( 1109) 
( 1110)   end subroutine regexp_search
( 1111)     !  #]
( 1112)   subroutine regexp_closesearch(error_flag)
( 1113)     !  #[ close regexp searcher
( 1114)     integer, intent(out) :: error_flag ! output
( 1115)     
( 1116)     ! local variables
( 1117)     integer(i4_)       :: err
( 1118) 
( 1119)     err = regexp_close()
( 1120)     IF (err .ne. 0) THEN
( 1121)        print *,"ERROR in regexp_close():"
( 1122)        print *,"reported c error is: ",err
( 1123)        error_flag = error_programming
( 1124)        return
( 1125)     END IF
( 1126) 
( 1127)     !print *,"succesfully closed regexp"
( 1128)     
( 1129)   end subroutine regexp_closesearch
( 1130)     !  #]
( 1131)   !------------------------------------------
( 1132) end module c_support






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 22

(    1) # 1 "c_support.F90"
(    1) module c_support
(    2)   !  #[ documentation
(    3)   !-------------------------------------------
(    4)   ! some routines for easier access to routines
(    5)   ! from the standard clib library, that are not
(    6)   ! easily available for fortran90
(    7)   !
(    8)   ! Modifications:
(    9)   !   27-Oct-2005 J. de Kloe added this module to the L2BP (copy from genscat)
(   10)   !   03-Apr-2006 J. de Kloe added wrappers for gethostname and get_process_id
(   11)   !   27-Jul-2006 J. de Kloe added wrappers for the remove() function
(   12)   !   22-Nov-2006 J. de Kloe added function convert_string_c_to_fortran
(   13)   !   10-Oct-2007 J. de Kloe added a few missing intents
(   14)   !   16-Jan-2008 J. de Kloe phase out integer kind i_ 
(   15)   !   08-Jan-2009 J. de Kloe added is_dir() function
(   16)   !   23-Jan-2009 J. de Kloe added system_cmd() subroutine
(   17)   !   20-Mar-2009 J. de Kloe adapted to changed get_size_of_long function
(   18)   !   11-Apr-2014 J. de Kloe implement dirlisting, glob and regexp support
(   19)   !   24-Apr-2014 J. de Kloe implement open_dir_for_listing_sorted
(   20)   !   30-Apr-2014 J. de Kloe fix sorting in open_dir_for_listing
(   21)   !                          which crashed for the pgf90 compiler
(   22)   !
(   23)   !-------------------------------------------
(   24)   !  #]
(   25)   !  #[ use statements
(   26)   USE StringTools, only: string2chararray, chararray2string
(   27)   USE numerics, only: i2_, i4_, i8_, nbytes_i4_, nbytes_i8_
(   28)   USE ErrorHandler, only: error_programming, error_c_interface, &
(   29)        error_allocate, no_error
(   30)   !  #]
(   31)   !  #[ variables and parameters 
(   32) # 33 "c_support.F90"
(   33)   implicit none
(   34) # 35 "c_support.F90"
(   35)   ! the next 4 saved global variables are used by open_dir_for_listing_sorted,
(   36)   ! get_next_direntry_sorted, and close_dir_for_listing_sorted
(   37)   integer, save :: count, max_len, last_reported_direntry
(   38)   character(len=1), dimension(:,:), pointer, save :: stored_names
(   39) # 41 "c_support.F90"
(   41)   ! see the manpage of stat for a description of these elements 
(   42)   integer, parameter :: stat_dev     = 1  ! device
(   43)   integer, parameter :: stat_ino     = 2  ! inode
(   44)   integer, parameter :: stat_mode    = 3  ! protection
(   45)   integer, parameter :: stat_nlink   = 4  ! number of hard links
(   46)   integer, parameter :: stat_uid     = 5  ! user ID of owner
(   47)   integer, parameter :: stat_gid     = 6  ! group ID of owner
(   48)   integer, parameter :: stat_rdev    = 7  ! device type (if inode device)
(   49)   integer, parameter :: stat_size    = 8  ! total size, in bytes
(   50)   integer, parameter :: stat_blksize = 9  ! blocksize for filesystem I/O
(   51)   integer, parameter :: stat_blocks  = 10 ! number of blocks allocated
(   52)   integer, parameter :: stat_atime   = 11 ! time of last access
(   53)   integer, parameter :: stat_mtime   = 12 ! time of last modification
(   54)   integer, parameter :: stat_ctime   = 13 ! time of last change
(   55)   !  #]
(   56)   !  #[ interface statements to external c functions
(   57)   ! this replaces the old "external" statement
(   58)   ! and provides the compiler a way of checking the interface !!






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 23

(   59)   interface 
(   60)      ! a version that is used when sizeof(long)=4
(   61)      function get_stat_result_c4(filename, stat_result) result(err)
(   62)        USE numerics, only: i4_
(   63)        character(len=*),            intent(in)  :: filename
(   64)        integer(i4_), dimension(13), intent(out) :: stat_result
(   65)        integer(i4_)                             :: err
(   66)      end function get_stat_result_c4
(   67)      ! a version that is used when sizeof(long)=8
(   68)      function get_stat_result_c8(filename, stat_result) result(err)
(   69)        USE numerics, only: i8_
(   70)        character(len=*),            intent(in)  :: filename
(   71)        integer(i8_), dimension(13), intent(out) :: stat_result
(   72)        integer(i8_)                             :: err
(   73)      end function get_stat_result_c8
(   74)      ! a function to request sizeof(long)
(   75)      function get_size_of_long() result(size)
(   76)        USE numerics, only:i2_
(   77)        integer(i2_) :: size
(   78)      end function get_size_of_long
(   79)      function gethostname_c4(hostname) result(err)
(   80)        USE numerics, only: i4_
(   81)        character(len=*), intent(out) :: hostname
(   82)        integer(i4_)                  :: err
(   83)      end function gethostname_c4
(   84)      function gethostname_c8(hostname) result(err)
(   85)        USE numerics, only: i8_
(   86)        character(len=*), intent(out) :: hostname
(   87)        integer(i8_)                  :: err
(   88)      end function gethostname_c8
(   89)      function get_pid_c4() result(pid)
(   90)        USE numerics, only: i4_
(   91)        integer(i4_) :: pid
(   92)      end function get_pid_c4
(   93)      function get_pid_c8() result(pid)
(   94)        USE numerics, only: i8_
(   95)        integer(i8_) :: pid
(   96)      end function get_pid_c8
(   97)      function remove_file_c4(filename) result(err)
(   98)        USE numerics, only: i4_
(   99)        character(len=*), intent(in) :: filename
(  100)        integer(i4_)                 :: err
(  101)      end function remove_file_c4
(  102)      function remove_file_c8(filename) result(err)
(  103)        USE numerics, only: i8_
(  104)        character(len=*), intent(in) :: filename
(  105)        integer(i8_)                 :: err
(  106)      end function remove_file_c8
(  107)      function is_dir_c4(dirname) result(isdir)
(  108)        USE numerics, only: i4_
(  109)        character(len=*), intent(in) :: dirname
(  110)        integer(i4_)                 :: isdir       
(  111)      end function is_dir_c4
(  112)      function is_dir_c8(dirname) result(isdir)
(  113)        USE numerics, only: i8_
(  114)        character(len=*), intent(in) :: dirname
(  115)        integer(i8_)                 :: isdir       
(  116)      end function is_dir_c8






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 24

(  117)      function system_c4(command) result(err)
(  118)        USE numerics, only: i4_
(  119)        character(len=*), intent(in) :: command
(  120)        integer(i4_)                 :: err
(  121)      end function system_c4
(  122)      function system_c8(command) result(err)
(  123)        USE numerics, only: i8_
(  124)        character(len=*), intent(in) :: command
(  125)        integer(i8_)                 :: err
(  126)      end function system_c8
(  127)      function opendir_c4(dirname) result(err)
(  128)        USE numerics, only: i4_
(  129)        character(len=*), intent(in) :: dirname
(  130)        integer(i4_)                 :: err
(  131)      end function opendir_c4
(  132)      function opendir_c8(dirname) result(err)
(  133)        USE numerics, only: i8_
(  134)        character(len=*), intent(in) :: dirname
(  135)        integer(i8_)                 :: err
(  136)      end function opendir_c8
(  137)      function get_next_direntry_c4(direntry257) result(err)
(  138)        USE numerics, only: i4_
(  139)        character(len=*), intent(in) :: direntry257
(  140)        integer(i4_)                 :: err
(  141)      end function get_next_direntry_c4
(  142)      function get_next_direntry_c8(direntry257) result(err)
(  143)        USE numerics, only: i8_
(  144)        character(len=*), intent(in) :: direntry257
(  145)        integer(i8_)                 :: err
(  146)      end function get_next_direntry_c8
(  147)      function closedir() result(err)
(  148)        USE numerics, only: i4_
(  149)        integer(i4_)                 :: err
(  150)      end function closedir
(  151)      function openglob_c4(pattern) result(err)
(  152)        USE numerics, only: i4_
(  153)        character(len=*), intent(in) :: pattern
(  154)        integer(i4_)                 :: err
(  155)      end function openglob_c4
(  156)      function openglob_c8(pattern) result(err)
(  157)        USE numerics, only: i8_
(  158)        character(len=*), intent(in) :: pattern
(  159)        integer(i8_)                 :: err
(  160)      end function openglob_c8
(  161)      function getnextglobentry_c4(match257) result(err)
(  162)        USE numerics, only: i4_
(  163)        character(len=*), intent(in) :: match257
(  164)        integer(i4_)                 :: err
(  165)      end function getnextglobentry_c4
(  166)      function getnextglobentry_c8(match257) result(err)
(  167)        USE numerics, only: i8_
(  168)        character(len=*), intent(in) :: match257
(  169)        integer(i8_)                 :: err
(  170)      end function getnextglobentry_c8
(  171)      function closeglob() result(err)
(  172)        USE numerics, only: i4_
(  173)        integer(i4_)                 :: err
(  174)      end function closeglob






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 25

(  175)      function regexp_compile_c4(pattern) result(err)
(  176)        USE numerics, only: i4_
(  177)        character(len=*), intent(in) :: pattern
(  178)        integer(i4_)                 :: err
(  179)      end function regexp_compile_c4
(  180)      function regexp_compile_c8(pattern) result(err)
(  181)        USE numerics, only: i8_
(  182)        character(len=*), intent(in) :: pattern
(  183)        integer(i8_)                 :: err
(  184)      end function regexp_compile_c8
(  185)      function regexp_search_c4(text) result(err)
(  186)        USE numerics, only: i4_
(  187)        character(len=*), intent(in) :: text
(  188)        integer(i4_)                 :: err
(  189)      end function regexp_search_c4
(  190)      function regexp_search_c8(text) result(err)
(  191)        USE numerics, only: i8_
(  192)        character(len=*), intent(in) :: text
(  193)        integer(i8_)                 :: err
(  194)      end function regexp_search_c8
(  195)      function regexp_close() result(err)
(  196)        USE numerics, only: i4_
(  197)        integer(i4_)                 :: err
(  198)      end function regexp_close
(  199)   end interface
(  200)   !  #]
(  201)   !  #[ overload some functions with multiple input interfaces
(  202)   ! overload the get_filesize function
(  203)   interface get_filesize
(  204)      module procedure get_filesize_u, get_filesize_f
(  205)   end interface
(  206)   !  #]
(  207) contains
(  208)   !------------------------------------------
(  209)   function get_filesize_u(fileunit) result(size)
(  210)     !  #[ get the filesize
(  211)     integer, intent(in) :: fileunit ! input
(  212)     integer             :: size     ! result
(  213) # 214 "c_support.F90"
(  214)     ! local variables
(  215)     logical            :: nmd
(  216)     character(len=256) :: fname
(  217) # 218 "c_support.F90"
(  218)     ! this trick with inquire to find out the filename is necessary
(  219)     ! because the c-fileunits differ from the fortran-fileunits,
(  220)     ! so the c-function fstat() cannot directly handle fortran
(  221)     ! fileunits as input.
(  222) # 223 "c_support.F90"
(  223)     inquire(unit=fileunit,named=nmd)
(  224)     if (nmd) then
(  225)        ! init the remainder of the string with spaces
(  226)        fname(:) = ' '
(  227) # 228 "c_support.F90"
(  228)        inquire(unit=fileunit,name=fname)
(  229) # 230 "c_support.F90"
(  230)        size = get_filesize_f(fname)
(  231)        !print *,"inside c_support.F90[get_filesize_u]: "
(  232)        !print *,"the size of this file is ",size," in bytes"






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 26

(  233)        !print *,"the name of this file is ",trim(fname)
(  234)     else
(  235)        print *,"Error in get_filesize_u():"
(  236)        print *,"The fileunit: ",fileunit," seems not to belong to a"
(  237)        print *,"named file. Therefore the wrapper to the stat() function"
(  238)        print *,"can not be called...."
(  239)        print *,"If this is needed please implement it yourself."
(  240)        size = -1 ! report -1 to indicate the error
(  241)        return
(  242)     end if
(  243) # 244 "c_support.F90"
(  244)     return
(  245) # 246 "c_support.F90"
(  246)   end function get_filesize_u
(  247)     !  #]
(  248)   function get_filesize_f(filename) result(size)
(  249)     !  #[ get the filesize 
(  250)     character(len=*), intent(in) :: filename ! input
(  251)     integer                      :: size     ! result
(  252) # 253 "c_support.F90"
(  253)     ! local variables
(  254)     integer(i2_)                :: longsize
(  255)     integer(i4_)                :: err
(  256)     integer(i4_)                :: err4
(  257)     integer(i8_)                :: err8
(  258)     integer(i4_), dimension(13) :: stat_result
(  259)     integer(i4_), dimension(13) :: stat_result4
(  260)     integer(i8_), dimension(13) :: stat_result8
(  261)     character(len=256)          :: filename256
(  262) # 263 "c_support.F90"
(  263)     ! init the string with spaces
(  264)     filename256(:)=' '
(  265) # 266 "c_support.F90"
(  266)     ! Beware: the interface with c expects a stringlength
(  267)     !         of exactly 256 ! Therefore we have to copy the
(  268)     !         implicit length of filename to 256 by copying
(  269)     !         it to filename256 !!!
(  270)     IF (len_trim(filename) .gt. 256) THEN
(  271)        ! print *,"filename too long ....."
(  272)        size = -1
(  273)        return
(  274)     END IF
(  275)     filename256(:)=filename
(  276) # 277 "c_support.F90"
(  277)     longsize = get_size_of_long()
(  278)     !print *,"inside F90: longsize = ",longsize
(  279) # 280 "c_support.F90"
(  280)     IF (longsize .eq. nbytes_i4_) THEN
(  281)        ! call the c-wrapper function for stat()
(  282)        err4 = get_stat_result_c4(filename256, stat_result4)
(  283)        err = err4
(  284)        stat_result(:) = stat_result4(:)
(  285)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  286)        ! call the c-wrapper function for stat()
(  287)        err8 = get_stat_result_c8(filename256, stat_result8)
(  288)        err = int(err8,i4_)
(  289)        stat_result(:) = int(stat_result8(:),i4_)
(  290)     ELSE






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 27

(  291)        print *,"ERROR in get_filesize_f():"
(  292)        print *,"The interface between c and Fortran90 expects the long integer"
(  293)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  294)        print *,"current machine seems to use: ",longsize
(  295)        size = -1
(  296)        return
(  297)     END IF
(  298) # 299 "c_support.F90"
(  299)     if (err .ne. 0) then
(  300)        !print *,"Error in c_support.F90[get_filesize_f]"
(  301)        !print *,"get_fstat_result_c() returned with err = ",err
(  302)        size = -1
(  303)        return
(  304)     end if
(  305) # 306 "c_support.F90"
(  306)     !print *,"inside c_support.F90[get_filesize_f] stat_result = ",stat_result
(  307)     size = stat_result(stat_size)
(  308) # 309 "c_support.F90"
(  309)     return
(  310) # 311 "c_support.F90"
(  311)   end function get_filesize_f
(  312)     !  #]
(  313)   function get_hostname() result(hostname)
(  314)     !  #[ get this machines hostname
(  315)     character(len=25) :: hostname ! result
(  316) # 317 "c_support.F90"
(  317)     ! local variables
(  318)     integer(i2_)      :: longsize
(  319)     integer(i4_)      :: err
(  320)     integer(i4_)      :: err4
(  321)     integer(i8_)      :: err8
(  322)     character(len=25) :: hostname_c
(  323) # 324 "c_support.F90"
(  324)     longsize = get_size_of_long()
(  325)     IF (longsize .eq. nbytes_i4_) THEN
(  326)        err4 = gethostname_c4(hostname_c)
(  327)        err = err4
(  328)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  329)        err8 = gethostname_c8(hostname_c)
(  330)        err = int(err8,i4_)
(  331)     ELSE
(  332)        print *,"ERROR in get_hostname():"
(  333)        print *,"The interface between c and Fortran90 expects the long integer"
(  334)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  335)        print *,"current machine seems to use: ",longsize
(  336)        hostname = "unknown"
(  337)        return
(  338)     END IF
(  339) # 340 "c_support.F90"
(  340)     if (err .ne. 0) then
(  341)        hostname = "unknown"
(  342)        return
(  343)     end if
(  344) # 345 "c_support.F90"
(  345)     hostname = convert_string_c_to_fortran(hostname_c)
(  346) # 347 "c_support.F90"
(  347)     return
(  348) # 349 "c_support.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 28

(  349)   end function get_hostname
(  350)   !  #]
(  351)   function get_process_id() result(pid)
(  352)     !  #[ get the current pid number
(  353)     integer :: pid ! result
(  354) # 355 "c_support.F90"
(  355)     ! local variables
(  356)     integer(i2_)      :: longsize
(  357)     integer(i4_)      :: pid4
(  358)     integer(i8_)      :: pid8
(  359) # 360 "c_support.F90"
(  360)     longsize = get_size_of_long()
(  361)     IF (longsize .eq. nbytes_i4_) THEN
(  362)        pid4 = get_pid_c4()
(  363)        pid = pid4
(  364)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  365)        pid8 = get_pid_c8()
(  366)        pid = int(pid8,i4_)
(  367)     ELSE
(  368)        print *,"ERROR in get_process_id():"
(  369)        print *,"The interface between c and Fortran90 expects the long integer"
(  370)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  371)        print *,"current machine seems to use: ",longsize
(  372)        pid = -1
(  373)        return
(  374)     END IF
(  375) # 376 "c_support.F90"
(  376)     return
(  377) # 378 "c_support.F90"
(  378)   end function get_process_id
(  379)   !  #]
(  380)   subroutine remove_file(filename,error_flag)
(  381)     !  #[ remove a file
(  382)     character(len=*), intent(in)  :: filename   ! input
(  383)     integer,          intent(out) :: error_flag ! output
(  384) # 385 "c_support.F90"
(  385)     ! local variables
(  386)     integer(i2_)       :: longsize
(  387)     integer(i4_)       :: err4,err
(  388)     integer(i8_)       :: err8
(  389)     character(len=256) :: filename256
(  390) # 391 "c_support.F90"
(  391)     ! NOTE: an alternative way might be to use the fortran command
(  392)     !    close(unit=fileunit,status='delete',err=999)
(  393)     ! but this requires opening the file first.
(  394)     ! I only found out about this fortran90 option after implementing
(  395)     ! this c-workaround, so lets keep it as it is for now.
(  396) # 397 "c_support.F90"
(  397)     error_flag = no_error
(  398) # 399 "c_support.F90"
(  399)     ! init the string with spaces
(  400)     filename256(:)=' '
(  401) # 402 "c_support.F90"
(  402)     ! Beware: the interface with c expects a stringlength
(  403)     !         of exactly 256 ! Therefore we have to copy the
(  404)     !         implicit length of filename to 256 by copying
(  405)     !         it to filename256 !!!
(  406)     IF (len_trim(filename) .gt. 256) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 29

(  407)        print *,"Error in remove_file():"
(  408)        print *,"filename too long ..... (max length is 256 chars)"
(  409)        error_flag = error_programming
(  410)        return
(  411)     END IF
(  412)     filename256 = filename
(  413) # 414 "c_support.F90"
(  414)     longsize = get_size_of_long()
(  415)     IF (longsize .eq. nbytes_i4_) THEN
(  416)        err4 = remove_file_c4(filename256)
(  417)        err  = err4
(  418)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  419)        err8 = remove_file_c8(filename256)
(  420)        err = int(err8,i4_)
(  421)     ELSE
(  422)        print *,"ERROR in remove_file():"
(  423)        print *,"The interface between c and Fortran90 expects the long integer"
(  424)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  425)        print *,"current machine seems to use: ",longsize
(  426)        error_flag = error_c_interface
(  427)        return
(  428)     END IF
(  429) # 430 "c_support.F90"
(  430)     IF (err .ne. 0) THEN
(  431)        print *,"ERROR in remove_file():"
(  432)        print *,"could not remove file: ",trim(filename)
(  433)        print *,"reported c error is: ",err
(  434)        ! TODO
(  435)        ! later I could add explanations for the possible error codes
(  436)        ! that may be returned by the c function
(  437)        error_flag = error_programming
(  438)        return
(  439)     END IF
(  440) # 441 "c_support.F90"
(  441)     !print *,"succesfully removed file: ",trim(filename)
(  442) # 443 "c_support.F90"
(  443)   end subroutine remove_file
(  444)     !  #]
(  445)   function convert_string_c_to_fortran(txt_c) result(txt)
(  446)     !  #[ helper function used by get_hostname
(  447) # 448 "c_support.F90"
(  448)     ! remember the a c-style string is terminated with
(  449)     ! a zero, and may possibly have a bunch of undefined chars following it
(  450)     ! This function converts it to a proper Fortran90 string
(  451)     character(len=*)          :: txt_c ! input
(  452)     character(len=len(txt_c)) :: txt   ! result
(  453) # 454 "c_support.F90"
(  454)     ! local variable
(  455)     integer                   :: i
(  456) # 457 "c_support.F90"
(  457)     txt(:) = ' '
(  458)     copyloop: DO i=1,len(txt_c)
(  459)        IF (ichar(txt_c(i:i)) .eq. 0) exit copyloop
(  460)        txt(i:i) = txt_c(i:i)
(  461)     END DO copyloop
(  462) # 463 "c_support.F90"
(  463)   end function convert_string_c_to_fortran
(  464)     !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 30

(  465)   function is_dir(dirname) result(flag)
(  466)     !  #[ check if a dir with this name exists
(  467)     character(len=*), intent(in) :: dirname ! input
(  468)     logical                      :: flag    ! result
(  469) # 470 "c_support.F90"
(  470)     ! local variables
(  471)     integer(i2_)       :: longsize
(  472)     integer(i4_)       :: isdir
(  473)     integer(i4_)       :: isdir4
(  474)     integer(i8_)       :: isdir8
(  475)     character(len=256) :: dirname256
(  476) # 477 "c_support.F90"
(  477)     ! init the string with spaces
(  478)     dirname256(:)=' '
(  479) # 480 "c_support.F90"
(  480)     ! Beware: the interface with c expects a stringlength
(  481)     !         of exactly 256 ! Therefore we have to copy the
(  482)     !         implicit length of filename to 256 by copying
(  483)     !         it to filename256 !!!
(  484)     IF (len_trim(dirname) .gt. 256) THEN
(  485)        ! print *,"dirname too long ....."
(  486)        flag = .false.
(  487)        return
(  488)     END IF
(  489)     dirname256(:)=dirname
(  490)  
(  491)     longsize = get_size_of_long()
(  492)     !print *,"inside F90: longsize = ",longsize
(  493) # 494 "c_support.F90"
(  494)     IF (longsize .eq. nbytes_i4_) THEN
(  495)        ! call the c-wrapper function for is_dir()
(  496)        isdir4 = is_dir_c4(dirname256)
(  497)        isdir = isdir4
(  498)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  499)        ! call the c-wrapper function for is_dir()
(  500)        isdir8 = is_dir_c8(dirname256)
(  501)        isdir = int(isdir8,i4_)
(  502)     ELSE
(  503)        print *,"ERROR in is_dir():"
(  504)        print *,"The interface between c and Fortran90 expects the long integer"
(  505)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  506)        print *,"current machine seems to use: ",longsize
(  507)        flag=.false.
(  508)        return
(  509)     END IF
(  510) # 511 "c_support.F90"
(  511)     ! remark: is_dir_c4/is_dir_c8 return a value of 1 when the name
(  512)     !         is a proper directory, a value of 0 when it exists
(  513)     !         but is not a directory, and a value of -1 when it does not exist
(  514) # 515 "c_support.F90"
(  515)     flag = .false.
(  516)     if (isdir .gt. 0) flag = .true.
(  517) # 518 "c_support.F90"
(  518)     return
(  519) # 520 "c_support.F90"
(  520)   end function is_dir
(  521)     !  #]
(  522)   subroutine system_cmd(command,error_flag)






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 31

(  523)     !  #[ execute a shell command
(  524)     character(len=*), intent(in)  :: command    ! input
(  525)     integer,          intent(out) :: error_flag ! output
(  526) # 527 "c_support.F90"
(  527)     ! local variables
(  528)     integer(i2_)       :: longsize
(  529)     integer(i4_)       :: err4,err
(  530)     integer(i8_)       :: err8
(  531)     character(len=256) :: command256
(  532) # 533 "c_support.F90"
(  533)     error_flag = no_error
(  534) # 535 "c_support.F90"
(  535)     ! init the string with spaces
(  536)     command256(:)=' '
(  537) # 538 "c_support.F90"
(  538)     ! Beware: the interface with c expects a stringlength
(  539)     !         of exactly 256 ! Therefore we have to copy the
(  540)     !         implicit length of command to 256 by copying
(  541)     !         it to command256 !!!
(  542)     IF (len_trim(command) .gt. 256) THEN
(  543)        print *,"Error in system_cmd():"
(  544)        print *,"command too long ..... (max length is 256 chars)"
(  545)        error_flag = error_programming
(  546)        return
(  547)     END IF
(  548)     command256 = command
(  549) # 550 "c_support.F90"
(  550)     longsize = get_size_of_long()
(  551)     IF (longsize .eq. nbytes_i4_) THEN
(  552)        err4 = system_c4(command256)
(  553)        err  = err4
(  554)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  555)        err8 = system_c8(command256)
(  556)        err = int(err8,i4_)
(  557)     ELSE
(  558)        print *,"ERROR in system_cmd():"
(  559)        print *,"The interface between c and Fortran90 expects the long integer"
(  560)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  561)        print *,"current machine seems to use: ",longsize
(  562)        error_flag = error_c_interface
(  563)        return
(  564)     END IF
(  565) # 566 "c_support.F90"
(  566)     IF (err .ne. 0) THEN
(  567)        print *,"ERROR in system_cmd():"
(  568)        print *,"failed command: ",trim(command)
(  569)        print *,"reported c error is: ",err
(  570)        error_flag = error_programming
(  571)        return
(  572)     END IF
(  573) # 574 "c_support.F90"
(  574)     !print *,"succesfully executed command: ",trim(command)
(  575) # 576 "c_support.F90"
(  576)   end subroutine system_cmd
(  577)     !  #]
(  578)   subroutine open_dir_for_listing(dirname, error_flag)
(  579)     !  #[ open directory for retrieving its listing
(  580)     character(len=*), intent(in)  :: dirname    ! input






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 32

(  581)     integer,          intent(out) :: error_flag ! output
(  582)     
(  583)     ! local variables
(  584)     integer(i2_)       :: longsize
(  585)     integer(i4_)       :: err4,err
(  586)     integer(i8_)       :: err8
(  587)     character(len=256) :: dirname256
(  588) # 589 "c_support.F90"
(  589)     error_flag = no_error
(  590)     IF (len_trim(dirname) .gt. 256) THEN
(  591)        print *,"Error in open_dir_for_listing():"
(  592)        print *,"dirname too long ..... (max length is 256 chars)"
(  593)        error_flag = error_programming
(  594)        return
(  595)     END IF
(  596)     dirname256 = dirname
(  597)     
(  598)     longsize = get_size_of_long()
(  599)     IF (longsize .eq. nbytes_i4_) THEN
(  600)        err4 = opendir_c4(dirname256)
(  601)        err  = err4
(  602)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  603)        err8 = opendir_c8(dirname256)
(  604)        err = int(err8,i4_)
(  605)     ELSE
(  606)        print *,"ERROR in open_dir_for_listing():"
(  607)        print *,"The interface between c and Fortran90 expects the long integer"
(  608)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  609)        print *,"current machine seems to use: ",longsize
(  610)        error_flag = error_c_interface
(  611)        return
(  612)     END IF
(  613) # 614 "c_support.F90"
(  614)     IF (err .ne. 0) THEN
(  615)        print *,"ERROR in open_dir_for_listing():"
(  616)        print *,"failed dirname: ",trim(dirname)
(  617)        print *,"reported c error is: ",err
(  618)        error_flag = error_programming
(  619)        return
(  620)     END IF
(  621) # 622 "c_support.F90"
(  622)     !print *,"succesfully opened dir for listing: ",trim(dirname)
(  623) # 624 "c_support.F90"
(  624)   end subroutine open_dir_for_listing
(  625)     !  #]
(  626)   subroutine get_next_direntry(direntry, end_reached, error_flag)
(  627)     !  #[ get next directory list entry
(  628)     character(len=*), intent(out) :: direntry    ! output
(  629)     logical,          intent(out) :: end_reached ! output
(  630)     integer,          intent(out) :: error_flag  ! output
(  631)     
(  632)     ! local variables
(  633)     integer(i2_)       :: longsize
(  634)     integer(i4_)       :: err4,err
(  635)     integer(i8_)       :: err8
(  636)     character(len=257) :: direntry257
(  637) # 638 "c_support.F90"
(  638)     direntry(:) = ' '






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 33

(  639)     end_reached = .false.
(  640)     error_flag = no_error
(  641) # 642 "c_support.F90"
(  642)     IF (len_trim(direntry) .gt. 256) THEN
(  643)        print *,"Error in get_next_direntry():"
(  644)        print *,"direntry variable too long ..... (max length is 256 chars)"
(  645)        error_flag = error_programming
(  646)        return
(  647)     END IF
(  648)     
(  649)     longsize = get_size_of_long()
(  650)     IF (longsize .eq. nbytes_i4_) THEN
(  651)        err4 = get_next_direntry_c4(direntry257)
(  652)        err  = err4
(  653)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  654)        err8 = get_next_direntry_c8(direntry257)
(  655)        err = int(err8,i4_)
(  656)     ELSE
(  657)        print *,"ERROR in get_next_direntry():"
(  658)        print *,"The interface between c and Fortran90 expects the long integer"
(  659)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  660)        print *,"current machine seems to use: ",longsize
(  661)        error_flag = error_c_interface
(  662)        return
(  663)     END IF
(  664) # 665 "c_support.F90"
(  665)     ! a value of 2 signals that no more entries are available
(  666)     IF (err .eq. 2) THEN
(  667)        !print *,"No more entries!"
(  668)        end_reached = .true.
(  669)        return
(  670)     END IF
(  671) # 672 "c_support.F90"
(  672)     ! this should never occur
(  673)     IF (err .ne. 0) THEN
(  674)        print *,"ERROR in get_next_direntry():"
(  675)        print *,"reported c error is: ",err
(  676)        error_flag = error_programming
(  677)        return
(  678)     END IF
(  679) # 680 "c_support.F90"
(  680)     direntry257 = convert_string_c_to_fortran(direntry257)
(  681)     if (len_trim(direntry257) .gt. len(direntry)) then
(  682)        print *,"ERROR in get_next_direntry: "
(  683)        print *,"direntry variable too short, cannot return full result."
(  684)        print *,'len_trim(direntry257) = ',len_trim(direntry257)
(  685)        print *,'len(direntry) = ',len(direntry)
(  686)        error_flag = error_programming
(  687)        return
(  688)     end if
(  689)     direntry = direntry257
(  690)     !print *,"succesfully retrieved direntry: ",trim(direntry)
(  691) # 692 "c_support.F90"
(  692)   end subroutine get_next_direntry
(  693)     !  #]
(  694)   subroutine close_dir_for_listing(error_flag)
(  695)     !  #[ close directory after retrieving its listing
(  696)     integer, intent(out) :: error_flag ! output






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 34

(  697)     
(  698)     ! local variables
(  699)     integer(i4_)       :: err
(  700) # 701 "c_support.F90"
(  701)     error_flag = no_error
(  702)     
(  703)     err = closedir()
(  704)     IF (err .ne. 0) THEN
(  705)        print *,"ERROR in close_dir_for_listing():"
(  706)        print *,"reported c error is: ",err
(  707)        error_flag = error_programming
(  708)        return
(  709)     END IF
(  710) # 711 "c_support.F90"
(  711)     !print *,"succesfully closed dir for listing "
(  712) # 713 "c_support.F90"
(  713)   end subroutine close_dir_for_listing
(  714)     !  #]
(  715) # 716 "c_support.F90"
(  716)   subroutine open_dir_for_listing_sorted(dirname, error_flag)
(  717)     !  #[ same as open_dir_for_listing, but ensure sorted results
(  718)     character(len=*), intent(in)  :: dirname    ! input
(  719)     integer,          intent(out) :: error_flag ! output
(  720) # 721 "c_support.F90"
(  721)     ! local variables
(  722)     integer :: i, j, n, status
(  723)     logical :: end_reached
(  724)     character(len=256) :: direntry, name1, name2
(  725) # 726 "c_support.F90"
(  726)     ! these are global saved module variables:
(  727)     !integer :: count, max_len
(  728)     !character(len=1), dimension(:,:), pointer :: stored_names
(  729) # 730 "c_support.F90"
(  730)     error_flag = no_error
(  731)     nullify(stored_names)
(  732)     
(  733)     ! now first loop over all results to get count and longest name
(  734)     call open_dir_for_listing(dirname,error_flag)
(  735)     IF (error_flag .ne. no_error) return
(  736) # 737 "c_support.F90"
(  737)     count = 0
(  738)     max_len = 0
(  739)     end_reached = .false.
(  740)     do while (.not. end_reached)
(  741)        call get_next_direntry(direntry, end_reached, error_flag)
(  742)        IF (error_flag .ne. no_error) return
(  743)        IF (.not. end_reached) THEN
(  744)           n = len_trim(direntry)
(  745)           if (n .gt. max_len) max_len = n
(  746)           count = count + 1
(  747)           !print *,"debug: n, maxlen, count, direntry = ",&
(  748)           !     n, max_len, count, trim(direntry)
(  749)        END IF
(  750)     end do
(  751) # 752 "c_support.F90"
(  752)     call close_dir_for_listing(error_flag)
(  753)     IF (error_flag .ne. no_error) return
(  754) # 755 "c_support.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 35

(  755)     !print *,'Debug: result: count, max_len = ', count, max_len
(  756) # 757 "c_support.F90"
(  757)     allocate(stored_names(count,max_len),stat=status)
(  758)     if (status .ne. 0) then
(  759)        error_flag = error_allocate
(  760)        return
(  761)     end if
(  762) # 763 "c_support.F90"
(  763)     ! init
(  764)     stored_names(:,:) = ' '
(  765) # 766 "c_support.F90"
(  766)     ! now loop again over all results and store them
(  767)     call open_dir_for_listing(dirname,error_flag)
(  768)     IF (error_flag .ne. no_error) return
(  769) # 770 "c_support.F90"
(  770)     end_reached = .false.
(  771)     i = 0
(  772)     do while (.not. end_reached)
(  773)        direntry(:) = ' '
(  774)        call get_next_direntry(direntry, end_reached, error_flag)
(  775)        IF (error_flag .ne. no_error) return
(  776)        IF (.not. end_reached) THEN
(  777)           n = len_trim(direntry)
(  778)           i = i + 1
(  779)           !print *,"debug: storing result: i, direntry = ",&
(  780)           !     i, trim(direntry)
(  781)           !stored_names(i,1:n) = transfer(direntry(1:n), stored_names(i,1:n))
(  782)           ! this transfer does the same as the next do loop over j
(  783)           ! but fails for the pgf90 compiler ...
(  784)           !do j=1,n
(  785)           !   stored_names(i,j) = direntry(j:j)
(  786)           !end do
(  787)           ! this helper function works correct for all compilers ...
(  788)           stored_names(i,1:n) = string2chararray(direntry(1:n))
(  789)        END IF
(  790)     end do
(  791) # 792 "c_support.F90"
(  792)     call close_dir_for_listing(error_flag)
(  793)     IF (error_flag .ne. no_error) return
(  794) # 795 "c_support.F90"
(  795)     ! copy for shorter notation
(  796)     n = max_len
(  797) # 798 "c_support.F90"
(  798)     !print *,'debug: results1:'
(  799)     !name1(:) = ' '
(  800)     !do i=1,count
(  801)     !   name1(1:n) = transfer(stored_names(i,1:n),name1(1:n))
(  802)     !   print *,i,' : ',trim(name1)
(  803)     !end do
(  804) # 805 "c_support.F90"
(  805)     ! sort the results
(  806)     do i=1,count-1
(  807)        do j=i+1,count
(  808)           name1(:) = ' '
(  809)           name2(:) = ' '
(  810)           direntry(:) = ' '
(  811)           name1(1:n) = chararray2string(stored_names(i,1:n))
(  812)           name2(1:n) = chararray2string(stored_names(j,1:n))






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 36

(  813)           if (name2(1:n) .lt. name1(1:n)) then
(  814)              ! swap them
(  815)              direntry(1:n) = name1(1:n)
(  816)              name1(1:n) = name2(1:n)
(  817)              name2(1:n) = direntry(1:n)
(  818)              stored_names(i,1:n) = string2chararray(name1(1:n))
(  819)              stored_names(j,1:n) = string2chararray(name2(1:n))
(  820)           end if
(  821)        end do
(  822)     end do
(  823)     
(  824)     !print *,'debug: results2:'
(  825)     !do i=1,count
(  826)     !   name1(1:n) = transfer(stored_names(i,1:n),name1(1:n))
(  827)     !   print *,i,' : ',trim(name1(1:n))
(  828)     !end do
(  829) # 830 "c_support.F90"
(  830)     last_reported_direntry = 0
(  831) # 832 "c_support.F90"
(  832)     !print *,"succesfully opened dir for listing (sorted): ",trim(dirname)
(  833) # 834 "c_support.F90"
(  834)   end subroutine open_dir_for_listing_sorted
(  835)     !  #]
(  836) # 837 "c_support.F90"
(  837)   subroutine get_next_direntry_sorted(direntry, end_reached, error_flag)
(  838)     !  #[ get next directory list entry (sorted)
(  839)     character(len=*), intent(out) :: direntry    ! output
(  840)     logical,          intent(out) :: end_reached ! output
(  841)     integer,          intent(out) :: error_flag  ! output
(  842)     
(  843)     ! local variables
(  844)     integer :: i, n
(  845) # 846 "c_support.F90"
(  846)     direntry(:) = ' '
(  847)     end_reached = .false.
(  848)     error_flag = no_error
(  849) # 850 "c_support.F90"
(  850)     if (last_reported_direntry .ge. count) then
(  851)        !print *,"No more entries!"
(  852)        end_reached = .true.
(  853)        return
(  854)     END IF
(  855) # 856 "c_support.F90"
(  856)     last_reported_direntry = last_reported_direntry + 1
(  857)     i = last_reported_direntry
(  858)     n = max_len
(  859)     direntry(1:n) = transfer(stored_names(i,1:n),direntry(1:n))
(  860) # 861 "c_support.F90"
(  861)     !print *,"succesfully retrieved direntry: ",trim(direntry)
(  862) # 863 "c_support.F90"
(  863)   end subroutine get_next_direntry_sorted
(  864)     !  #]
(  865) # 866 "c_support.F90"
(  866)   subroutine close_dir_for_listing_sorted(error_flag)
(  867)     !  #[ close directory after retrieving its sorted listing
(  868)     integer, intent(out) :: error_flag ! output
(  869)     
(  870)     error_flag = no_error






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 37

(  871)     if (associated(stored_names)) deallocate(stored_names)
(  872)     count = 0
(  873)     max_len = 0
(  874)     last_reported_direntry = 0
(  875) # 876 "c_support.F90"
(  876)     !print *,"succesfully closed dir for listing (sorted)"
(  877) # 878 "c_support.F90"
(  878)   end subroutine close_dir_for_listing_sorted
(  879)     !  #]
(  880) # 881 "c_support.F90"
(  881)   subroutine openglobhandle(pattern, error_flag)
(  882)     !  #[ open glob for pattern search
(  883)     character(len=*), intent(in)  :: pattern    ! input
(  884)     integer,          intent(out) :: error_flag ! output
(  885)     
(  886)     ! local variables
(  887)     integer(i2_)       :: longsize
(  888)     integer(i4_)       :: err4,err
(  889)     integer(i8_)       :: err8
(  890)     character(len=256) :: pattern256
(  891) # 892 "c_support.F90"
(  892)     error_flag = no_error
(  893)     IF (len_trim(pattern) .gt. 256) THEN
(  894)        print *,"Error in openglobhandle():"
(  895)        print *,"pattern too long ..... (max length is 256 chars)"
(  896)        error_flag = error_programming
(  897)        return
(  898)     END IF
(  899)     pattern256 = pattern
(  900)     
(  901)     longsize = get_size_of_long()
(  902)     IF (longsize .eq. nbytes_i4_) THEN
(  903)        err4 = openglob_c4(pattern256)
(  904)        err  = err4
(  905)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  906)        err8 = openglob_c8(pattern256)
(  907)        err = int(err8,i4_)
(  908)     ELSE
(  909)        print *,"ERROR in openglobhandle():"
(  910)        print *,"The interface between c and Fortran90 expects the long integer"
(  911)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  912)        print *,"current machine seems to use: ",longsize
(  913)        error_flag = error_c_interface
(  914)        return
(  915)     END IF
(  916) # 917 "c_support.F90"
(  917)     IF (err .ne. 0) THEN
(  918)        print *,"ERROR in openglobhandle():"
(  919)        print *,"failed pattern: ",trim(pattern)
(  920)        print *,"reported c error is: ",err
(  921)        error_flag = error_programming
(  922)        return
(  923)     END IF
(  924) # 925 "c_support.F90"
(  925)     !print *,"succesfully opened glob for pattern: ",trim(pattern)
(  926)     
(  927)   end subroutine openglobhandle
(  928)     !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 38

(  929)   subroutine getnextglobentry(match, end_reached, error_flag)
(  930)     !  #[ get next glob search result
(  931)     character(len=*), intent(out) :: match       ! output
(  932)     logical,          intent(out) :: end_reached ! output
(  933)     integer,          intent(out) :: error_flag  ! output
(  934)     
(  935)     ! local variables
(  936)     integer(i2_)       :: longsize
(  937)     integer(i4_)       :: err4,err
(  938)     integer(i8_)       :: err8
(  939)     character(len=257) :: match257
(  940) # 941 "c_support.F90"
(  941)     match(:) = ' '
(  942)     end_reached = .false.
(  943)     error_flag = no_error
(  944) # 945 "c_support.F90"
(  945)     IF (len_trim(match) .gt. 256) THEN
(  946)        print *,"Error in getnextglobentry():"
(  947)        print *,"match variable too long ..... (max length is 256 chars)"
(  948)        error_flag = error_programming
(  949)        return
(  950)     END IF
(  951)     
(  952)     longsize = get_size_of_long()
(  953)     IF (longsize .eq. nbytes_i4_) THEN
(  954)        err4 = getnextglobentry_c4(match257)
(  955)        err  = err4
(  956)     ELSEIF (longsize .eq. nbytes_i8_) THEN
(  957)        err8 = getnextglobentry_c8(match257)
(  958)        err = int(err8,i4_)
(  959)     ELSE
(  960)        print *,"ERROR in getnextglobentry():"
(  961)        print *,"The interface between c and Fortran90 expects the long integer"
(  962)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
(  963)        print *,"current machine seems to use: ",longsize
(  964)        error_flag = error_c_interface
(  965)        return
(  966)     END IF
(  967) # 968 "c_support.F90"
(  968)     ! a value of 2 signals that no more entries are available
(  969)     IF (err .eq. 2) THEN
(  970)        !print *,"No more entries!"
(  971)        end_reached = .true.
(  972)        return
(  973)     END IF
(  974) # 975 "c_support.F90"
(  975)     ! this should never occur
(  976)     IF (err .ne. 0) THEN
(  977)        print *,"ERROR in getnextglobentry():"
(  978)        print *,"reported c error is: ",err
(  979)        error_flag = error_programming
(  980)        return
(  981)     END IF
(  982) # 983 "c_support.F90"
(  983)     match257 = convert_string_c_to_fortran(match257)
(  984)     if (len_trim(match257) .gt. len(match)) then
(  985)        print *,"ERROR in getnextglobentry: "
(  986)        print *,"match variable too short, cannot return full result."






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 39

(  987)        print *,'len_trim(match257) = ',len_trim(match257)
(  988)        print *,'len(match) = ',len(match)
(  989)        error_flag = error_programming
(  990)        return
(  991)     end if
(  992)     match = match257
(  993)     !print *,"succesfully retrieved glob pattern match: ",trim(match)
(  994) # 995 "c_support.F90"
(  995)   end subroutine getnextglobentry
(  996)     !  #]
(  997)   subroutine closeglobhandle(error_flag)
(  998)     !  #[ close glob after retrieving pattern search results
(  999)     integer, intent(out) :: error_flag ! output
( 1000)     
( 1001)     ! local variables
( 1002)     integer(i4_)       :: err
( 1003) # 1004 "c_support.F90"
( 1004)     error_flag = no_error
( 1005)     
( 1006)     err = closeglob()
( 1007)     IF (err .ne. 0) THEN
( 1008)        print *,"ERROR in closeglob():"
( 1009)        print *,"reported c error is: ",err
( 1010)        error_flag = error_programming
( 1011)        return
( 1012)     END IF
( 1013) # 1014 "c_support.F90"
( 1014)     !print *,"succesfully closed glob"
( 1015) # 1016 "c_support.F90"
( 1016)   end subroutine closeglobhandle
( 1017)     !  #]
( 1018)   subroutine regexp_compile(pattern,error_flag)
( 1019)     !  #[ compile regexp for pattern search
( 1020)     character(len=*), intent(in)  :: pattern    ! input
( 1021)     integer,          intent(out) :: error_flag ! output
( 1022)     
( 1023)     ! local variables
( 1024)     integer(i2_)       :: longsize
( 1025)     integer(i4_)       :: err4,err
( 1026)     integer(i8_)       :: err8
( 1027)     character(len=256) :: pattern256
( 1028) # 1029 "c_support.F90"
( 1029)     error_flag = no_error
( 1030)     IF (len_trim(pattern) .gt. 256) THEN
( 1031)        print *,"Error in regexp_compile():"
( 1032)        print *,"pattern too long ..... (max length is 256 chars)"
( 1033)        error_flag = error_programming
( 1034)        return
( 1035)     END IF
( 1036)     pattern256 = pattern
( 1037)     
( 1038)     longsize = get_size_of_long()
( 1039)     IF (longsize .eq. nbytes_i4_) THEN
( 1040)        err4 = regexp_compile_c4(pattern256)
( 1041)        err  = err4
( 1042)     ELSEIF (longsize .eq. nbytes_i8_) THEN
( 1043)        err8 = regexp_compile_c8(pattern256)
( 1044)        err = int(err8,i4_)






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 40

( 1045)     ELSE
( 1046)        print *,"ERROR in regexp_compile():"
( 1047)        print *,"The interface between c and Fortran90 expects the long integer"
( 1048)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
( 1049)        print *,"current machine seems to use: ",longsize
( 1050)        error_flag = error_c_interface
( 1051)        return
( 1052)     END IF
( 1053) # 1054 "c_support.F90"
( 1054)     IF (err .ne. 0) THEN
( 1055)        print *,"ERROR in regexp_compile():"
( 1056)        print *,"failed pattern: ",trim(pattern)
( 1057)        print *,"reported c error is: ",err
( 1058)        error_flag = error_programming
( 1059)        return
( 1060)     END IF
( 1061) # 1062 "c_support.F90"
( 1062)     !print *,"succesfully compiled pattern: ",trim(pattern)
( 1063) # 1064 "c_support.F90"
( 1064)   end subroutine regexp_compile
( 1065)     !  #]
( 1066)   subroutine regexp_search(text, matches, error_flag)
( 1067)     !  #[ do pattern search
( 1068)     character(len=*), intent(in)  :: text       ! input
( 1069)     logical,          intent(out) :: matches    ! output
( 1070)     integer,          intent(out) :: error_flag ! output
( 1071)     
( 1072)     ! local variables
( 1073)     integer(i2_)       :: longsize
( 1074)     integer(i4_)       :: res4,res
( 1075)     integer(i8_)       :: res8
( 1076)     character(len=256) :: text256
( 1077) # 1078 "c_support.F90"
( 1078)     matches = .false.
( 1079)     error_flag = no_error
( 1080) # 1081 "c_support.F90"
( 1081)     IF (len_trim(text) .gt. 256) THEN
( 1082)        print *,"Error in regexp_search():"
( 1083)        print *,"text too long ..... (max length is 256 chars)"
( 1084)        error_flag = error_programming
( 1085)        return
( 1086)     END IF
( 1087)     text256 = text
( 1088)     
( 1089)     longsize = get_size_of_long()
( 1090)     IF (longsize .eq. nbytes_i4_) THEN
( 1091)        res4 = regexp_search_c4(text256)
( 1092)        res  = res4
( 1093)     ELSEIF (longsize .eq. nbytes_i8_) THEN
( 1094)        res8 = regexp_search_c8(text256)
( 1095)        res = int(res8,i4_)
( 1096)     ELSE
( 1097)        print *,"ERROR in regexp_search():"
( 1098)        print *,"The interface between c and Fortran90 expects the long integer"
( 1099)        print *,"type in c to hold either 4 or 8 bytes, but in stead the"
( 1100)        print *,"current machine seems to use: ",longsize
( 1101)        error_flag = error_c_interface
( 1102)        return






NVFORTRAN (Version     23.1)          02/24/2023  13:53:50      page 41

( 1103)     END IF
( 1104) # 1105 "c_support.F90"
( 1105)     if (res .eq.0) matches = .true.
( 1106)     
( 1107)     !print *,'regexp_search(): ',res
( 1108)     !print *,"search complete for text: ",trim(text)
( 1109) # 1110 "c_support.F90"
( 1110)   end subroutine regexp_search
( 1111)     !  #]
( 1112)   subroutine regexp_closesearch(error_flag)
( 1113)     !  #[ close regexp searcher
( 1114)     integer, intent(out) :: error_flag ! output
( 1115)     
( 1116)     ! local variables
( 1117)     integer(i4_)       :: err
( 1118) # 1119 "c_support.F90"
( 1119)     err = regexp_close()
( 1120)     IF (err .ne. 0) THEN
( 1121)        print *,"ERROR in regexp_close():"
( 1122)        print *,"reported c error is: ",err
( 1123)        error_flag = error_programming
( 1124)        return
( 1125)     END IF
( 1126) # 1127 "c_support.F90"
( 1127)     !print *,"succesfully closed regexp"
( 1128)     
( 1129)   end subroutine regexp_closesearch
( 1130)     !  #]
( 1131)   !------------------------------------------
( 1132) end module c_support
