


NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: errorhandler.F90

(    1) module ErrorHandler
(    2)   !  #[ Description
(    3)   !     a module to define parameters for the error conditions
(    4)   !     in the L2B program and its modules, and some functions
(    5)   !     to print information on the nature of the error
(    6)   !     and to gracefully abort the code
(    7)   !     This needs to be replaced by the IFS way of doing things later,
(    8)   !     but the standalone version needs this. Therefore I inserted
(    9)   !     this module, to have a single point of change to the 
(   10)   !     IFS interface.
(   11)   !
(   12)   !     written by: J. de Kloe, KNMI
(   13)   !
(   14)   !     Modifications:
(   15)   !     19-Apr-2006 J. de Kloe  added errortype error_diff_tool_syntax_error
(   16)   !     27-Jul-2006 J. de Kloe  added errors for c_support
(   17)   !     19-Sep-2006 J. de Kloe  added error_program_usage error type
(   18)   !     24-Nov-2006 J. de Kloe  added error_numerics_charsize
(   19)   !     13-Dec-2006 J. de Kloe  added error_numerics_hexval
(   20)   !     19-Dec-2007 P. Poli     added routine catch_error
(   21)   !     05-Jun-2008 J. de Kloe  imported changes from branch nl8_CY32R1_Jun04
(   22)   !     26-Sep-2008 J. de Kloe  added error_numerics_NaN_detected and
(   23)   !                             error_numerics_Inf_detected
(   24)   !     15-Jan-2009 J. de Kloe  added error_not_yet_implemented
(   25)   !     19-Feb-2009 J. de Kloe  added error_bufr_interface
(   26)   !     01-Apr-2009 J. de Kloe  add some BUFR specific error messages
(   27)   !     03-Feb-2010 J. de Kloe  added error_out_of_valid_range
(   28)   !     08-Jul-2010 J. de Kloe  added error_no_data_selected
(   29)   !                             and base reported exit code on error value
(   30)   !     02-Aug-2010 J. de Kloe  added get_error_text and abort_with_given_code






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 3

(   31)   !                             to allow reimplementing program_abort in the
(   32)   !                             logging module as well
(   33)   !     14-Dec-2010 J. de Kloe  change all STOP statements into calls to
(   34)   !                             exit_aeolus() to fix the pgf90 portability
(   35)   !     02-Feb-2011 M Rennie    bugfix in get_error_text in case error_flag
(   36)   !                             equals request_program_to_stop
(   37)   !     02-Nov-2011 J. de Kloe  added stop_iteration as special flag value
(   38)   !     24-Nov-2011 J. de Kloe  added error_deleting_file
(   39)   !     26-Feb-2014 J. de Kloe  disable MPI related errors
(   40)   !     26-Feb-2015 J. de Kloe  implement request_exit_code function
(   41)   !     09-Jun-2015 J. de Kloe  update error_xml definition
(   42)   !     08-Jun-2017 J. de Kloe  added error_illegal_algorithm_input
(   43)   !     19-Mar-2018 J. de Kloe  added an error for bufr table problems
(   44)   !                             and simplify abort_with_given_code
(   45)   !  #]
(   46)   !  #[ Modules used
(   47)   USE Compiler_Features, only: exit_aeolus
(   48)   !  #]
(   49)   !  #[ parameters
(   50)   implicit none
(   51) 
(   52)   ! these are not really errors, but conditions that
(   53)   ! may be signalled using the error_flag as well
(   54)   integer, parameter :: stop_iteration          = -3
(   55)   integer, parameter :: end_of_file_reached     = -2
(   56)   integer, parameter :: request_program_to_stop = -1
(   57) 
(   58)   ! all seems ok
(   59)   integer, parameter :: no_error                = 0
(   60) 
(   61)   ! general error codes
(   62)   integer, parameter :: error_opening_file        = 1
(   63)   integer, parameter :: error_closing_file        = 2
(   64)   integer, parameter :: error_reading_file        = 3
(   65)   integer, parameter :: error_writing_file        = 4
(   66)   integer, parameter :: error_deleting_file       = 5
(   67)   integer, parameter :: error_allocate            = 6
(   68)   integer, parameter :: error_deallocate          = 7
(   69)   integer, parameter :: error_programming         = 8
(   70)   integer, parameter :: error_cmdline_options     = 9
(   71)   integer, parameter :: error_program_usage       = 10
(   72)   integer, parameter :: error_not_yet_implemented = 11
(   73)   integer, parameter :: error_phased_out          = 12
(   74)   integer, parameter :: error_out_of_valid_range  = 13
(   75)   integer, parameter :: error_no_data_selected    = 14
(   76)   integer, parameter :: error_illegal_algorithm_input = 15
(   77)   
(   78)   ! error codes used by specific support modules       ! used in which module:
(   79)   integer, parameter :: error_invalid_date  = 50001 ! datetime module
(   80)   integer, parameter :: error_invalid_time  = 50002 ! datetime module
(   81)   integer, parameter :: error_xml           = 50101 ! xml module
(   82)   integer, parameter :: error_bufr_encode   = 50201 ! bufr module
(   83)   integer, parameter :: error_bufr_decode   = 50202 ! bufr module
(   84)   integer, parameter :: error_bufr_corr_msg = 50203 ! bufr module
(   85)   integer, parameter :: error_bufr_interface= 50204 ! bufr module
(   86)   integer, parameter :: error_bufr_bufren   = 50210 ! bufr module
(   87)   integer, parameter :: error_bufr_bufrex   = 50211 ! bufr module
(   88)   integer, parameter :: error_bufr_busel    = 50212 ! bufr module






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 4

(   89)   integer, parameter :: error_bufr_bus012   = 50213 ! bufr module
(   90)   integer, parameter :: error_bufr_buxdes   = 50214 ! bufr module
(   91)   integer, parameter :: error_bufr_bupkey   = 50215 ! bufr module
(   92)   integer, parameter :: error_bufr_tables   = 50216 ! bufr module
(   93) 
(   94)   ! warning: these next parameters should have the same value as the
(   95)   ! ones defined in the module numerics.F90.
(   96)   ! the numerics module can not USE this ErrorHandler module, however,
(   97)   ! because that would introduce a circular dependency
(   98)   ! (and a huge number of changes in other programs/modules, since
(   99)   ! almost every program/module that I make uses the numerics module
(  100)   ! as a standalone module without further dependencies)
(  101)   integer, parameter :: error_numerics_intsize      = 50301 ! numerics module
(  102)   integer, parameter :: error_numerics_realsize     = 50311 ! numerics module
(  103)   integer, parameter :: error_numerics_charsize     = 50321 ! numerics module
(  104)   integer, parameter :: error_numerics_hexval       = 50331 ! numerics module
(  105)   integer, parameter :: error_numerics_NaN_detected = 50341 ! numerics module
(  106)   integer, parameter :: error_numerics_Inf_detected = 50351 ! numerics module
(  107)   integer, parameter :: error_c_interface       = 50401 ! c_support
(  108) 
(  109)   ! error code used by the difftool
(  110)   integer, parameter :: error_diff_tool_syntax_error = 60001
(  111) 
(  112)   ! error code used by the mpi wrapper
(  113) !  integer, parameter :: error_mpi = 70001
(  114) 
(  115)   ! save settings to be used throughout the program
(  116)   logical, save :: do_abort_on_error = .true.
(  117) 
(  118)   !  #]
(  119) contains
(  120)   !-----------------------------------
(  121)   subroutine InitErrorHandler(abort_on_error)
(  122)     !  #[
(  123)     logical, optional, intent(in) :: abort_on_error
(  124) 
(  125)     IF (present(abort_on_error)) do_abort_on_error = abort_on_error
(  126) 
(  127)     IF (do_abort_on_error) THEN
(  128)        print *,"The Error Handler program_abort routine is set to "
(  129)        print *,"abort on first error..."
(  130)     ELSE
(  131)        print *,"The Error Handler program_abort routine is set to "
(  132)        print *,"return after each error,"
(  133)        print *,"in order to try and resume the program..."
(  134)     END IF
(  135) 
(  136)   end subroutine InitErrorHandler
(  137)     !  #]
(  138)   function get_error_text(error_flag,subroutine_name) result(error_text)
(  139)     !  #[
(  140)     integer,           intent(in) :: error_flag
(  141)     character(len=*),  intent(in) :: subroutine_name
(  142)     character(len=512)            :: error_text
(  143) 
(  144)     ! local variable
(  145)     character(len=30) :: error_flag_txt
(  146) 






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 5

(  147)     ! initialise
(  148)     error_text(:) = ' '
(  149) 
(  150)     IF (error_flag .gt. 0) &
(  151)          error_text = "an error was reported from within subroutine: "//&
(  152)                       trim(subroutine_name)//"; "
(  153) 
(  154)     select case(error_flag)
(  155)     case(stop_iteration)
(  156)        error_text = trim(error_text)//"Stop-Iteration was signalled"
(  157)     case(end_of_file_reached)
(  158)        error_text = trim(error_text)//"End-of-file reached"
(  159)     case(request_program_to_stop)
(  160)        error_text = trim(error_text)//"the program will be stopped"
(  161)     case(no_error)
(  162)        error_text = trim(error_text)//"there was no error ..."
(  163)        !  #[ general error codes
(  164)     case(error_opening_file)
(  165)        error_text = trim(error_text)//"error while opening a file"
(  166)     case(error_closing_file)
(  167)        error_text = trim(error_text)//"error while closing a file"
(  168)     case(error_reading_file)
(  169)        error_text = trim(error_text)//"error while reading data from a file"
(  170)     case(error_writing_file)
(  171)        error_text = trim(error_text)//"error while writing data to a file"
(  172)     case(error_deleting_file)
(  173)        error_text = trim(error_text)//"error while deleting a file"
(  174)     case(error_allocate)
(  175)        error_text = trim(error_text)//"error while allocating memory"
(  176)     case(error_deallocate)
(  177)        error_text = trim(error_text)//"error while deallocating memory"
(  178)     case(error_programming)
(  179)        error_text = trim(error_text)//"probably a programming error"
(  180)     case(error_cmdline_options)
(  181)        error_text = trim(error_text)//"error while parsing commandline options"
(  182)     case(error_program_usage)
(  183)        error_text = trim(error_text)//"error incorrect use of this "//&
(  184)             "program (check your settings!)"
(  185)     case(error_not_yet_implemented)
(  186)        error_text = trim(error_text)//"error; this feature is not yet "//&
(  187)             "implemented"
(  188)     case(error_phased_out)
(  189)        error_text = trim(error_text)//"error; this feature has been "//&
(  190)             "phased out and is no longer available"
(  191)     case(error_out_of_valid_range)
(  192)        error_text = trim(error_text)//"error; a number out of its "//&
(  193)             "expected range was detected. "//&
(  194)             "Usually this indicates an error in the input data screening "//&
(  195)             "and/or a programming error"
(  196)     case(error_no_data_selected)
(  197)        error_text = trim(error_text)//&
(  198)             "error; no input data was selected; this is not allowed."
(  199)     case(error_illegal_algorithm_input)
(  200)        error_text = trim(error_text)//&
(  201)             "error; the algorithm was provided with illegal input."
(  202)        !  #]
(  203)        !  #[ error codes used by the datetime module
(  204)     case(error_invalid_date)






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 6

(  205)        error_text = trim(error_text)//&
(  206)             "a date was detected to have an invalid/impossible value"
(  207)     case(error_invalid_time)
(  208)        error_text = trim(error_text)//&
(  209)             "a time was detected to have an invalid/impossible value"
(  210)        !  #]
(  211)        !  #[ error codes used by the ee_xml module
(  212)     case(error_xml)
(  213)        error_text = trim(error_text)//&
(  214)             "an error was reported by the xml handling software"
(  215) !            "an error was reported by the ee_cfi_software"
(  216)        !  #]
(  217)        !  #[ error codes used by the bufr module
(  218)     case(error_bufr_encode)
(  219)        error_text = trim(error_text)//&
(  220)             "error while encoding a bufr message"
(  221)     case(error_bufr_decode)
(  222)        error_text = trim(error_text)//&
(  223)             "error while decoding a bufr message"
(  224)     case(error_bufr_corr_msg)
(  225)        error_text = trim(error_text)//&
(  226)             "error BUFR message seems corrupt"
(  227)     case(error_bufr_interface)
(  228)        error_text = trim(error_text)//&
(  229)             "error BUFR fortran and c interfaces do not match"
(  230)     case(error_bufr_bufren)
(  231)        error_text = trim(error_text)//&
(  232)             "error reported by BUFREN library subroutine"
(  233)     case(error_bufr_bufrex)
(  234)        error_text = trim(error_text)//&
(  235)             "error reported by BUFREX library subroutine"
(  236)     case(error_bufr_busel)
(  237)        error_text = trim(error_text)//&
(  238)             "error reported by BUSEL library subroutine"
(  239)     case(error_bufr_bus012)
(  240)        error_text = trim(error_text)//&
(  241)             "error reported by BUS012 library subroutine"
(  242)     case(error_bufr_buxdes)
(  243)        error_text = trim(error_text)//&
(  244)             "error reported by BUXDES library subroutine"
(  245)     case(error_bufr_bupkey)
(  246)        error_text = trim(error_text)//&
(  247)             "error reported by BUPKEY library subroutine"
(  248)     case(error_bufr_tables)
(  249)        error_text = trim(error_text)//&
(  250)             "error while loading BUFR tables"
(  251)        !  #]
(  252)        !  #[ error codes used by the numerics module
(  253)     case(error_numerics_intsize)
(  254)        error_text = trim(error_text)//&
(  255)             "an error was reported by the numerics module: "//&
(  256)             "integer size differs from what is expected"
(  257)     case(error_numerics_realsize)
(  258)        error_text = trim(error_text)//&
(  259)             "an error was reported by the numerics module: "//&
(  260)             "real size differs from what is expected"
(  261)     case(error_numerics_charsize)
(  262)        error_text = trim(error_text)//&






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 7

(  263)             "an error was reported by the numerics module: "//&
(  264)             "character size differs from what is expected"
(  265)     case(error_numerics_hexval)
(  266)        error_text = trim(error_text)//&
(  267)             "an error was reported by the numerics module: "//&
(  268)             "hexadecimal to integer conversion differs "//&
(  269)             "from what is expected"
(  270)     case(error_numerics_NaN_detected)
(  271)        error_text = trim(error_text)//&
(  272)             "an error was reported by the numerics module: "//&
(  273)             "a real variable was found to contain the NaN value. "//&
(  274)             "Usually this points at a programming error..."
(  275)     case(error_numerics_Inf_detected)
(  276)        error_text = trim(error_text)//&
(  277)             "an error was reported by the numerics module: "//&
(  278)             "a real variable was found to contain the Inf value. "//&
(  279)             "Usually this points at a programming error..."
(  280)        !  #]
(  281)        !  #[ error codes used by the c_support module
(  282)     case(error_c_interface)
(  283)        error_text = trim(error_text)//&
(  284)             "an error was reported by the c_support module: "//&
(  285)             "c and fortran code cannot be properly interfaced "//&
(  286)             "with the available datatypes in the "//&
(  287)             "current c and fortran objects..."
(  288)        !  #]
(  289)        !  #[ error codes used by the difftool
(  290)     case(error_diff_tool_syntax_error)
(  291)        error_text = trim(error_text)//&
(  292)             "a syntax error was reported by the difftool"
(  293)        !  #]
(  294)        !  #[ error codes used by the mpi wrapper
(  295) !    case(error_mpi)
(  296) !       error_text = trim(error_text)//&
(  297) !            "an error was reported from within the MPI library"
(  298)        !  #]
(  299)     case default
(  300)        write(error_flag_txt,*,err=999) error_flag
(  301)        error_text = trim(error_text)//&
(  302)             "this error code was not yet defined: "//&
(  303)             trim(adjustl(error_flag_txt))
(  304)     end select
(  305) 
(  306)     return
(  307) 
(  308) 999 error_text = trim(error_text)//&
(  309)          "could not convert error_flag to string. Probably there is a "//&
(  310)          "programming error in errorhandler.F90"
(  311)     return
(  312) 
(  313)   end function get_error_text
(  314)     !  #]
(  315)   subroutine program_abort1(error_flag,subroutine_name)
(  316)     !  #[
(  317)     ! note on usage: this program_abort1 routine was deliberately
(  318)     ! renamed to mark that it should only be used inside the support
(  319)     ! directory, and only by those modules that cannot use the logging
(  320)     ! module (due to possibly circular dependency problems)






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 8

(  321)     ! All other code should use program_abort as defined in the
(  322)     ! logging module.
(  323) 
(  324)     integer,          intent(in) :: error_flag
(  325)     character(len=*), intent(in) :: subroutine_name
(  326) 
(  327)     ! local variable
(  328)     character(len=512) :: error_text
(  329) 
(  330)     error_text = get_error_text(error_flag,subroutine_name)
(  331)     print *,trim(error_text)
(  332) 
(  333)     IF (error_flag .eq. request_program_to_stop) stop 0 ! normal exit
(  334) 
(  335)     IF (do_abort_on_error) THEN
(  336)        ! make sure the exit status of the program will have different
(  337)        ! values on different error conditions
(  338)        call abort_with_given_code(error_flag)
(  339)     ELSE
(  340)        print *,"==> trying to resume the program ..."
(  341)        return
(  342)     END IF
(  343) 
(  344)   end subroutine program_abort1
(  345)     !  #]
(  346)   function request_exit_code(error_flag) result(code)
(  347)     !  #[
(  348)     ! a function that reports the exit code that will be used
(  349)     ! when the abort_with_given_code() subroutine is run with
(  350)     ! the same error_flag. This is needed to allow writing the
(  351)     ! exit code to the log file before actually terminating the program.
(  352) 
(  353)     integer, intent(in) :: error_flag ! input
(  354)     integer             :: code       ! result
(  355) 
(  356)     select case(error_flag)
(  357)     case(no_error,request_program_to_stop,stop_iteration)
(  358)        code = 0 ! normal exit
(  359)     case(end_of_file_reached,error_opening_file,error_closing_file,&
(  360)          error_reading_file,error_writing_file,error_xml, &
(  361)          error_deleting_file)
(  362)        code = 128 ! file related trouble
(  363)     case(error_allocate,error_deallocate)
(  364)        code = 129 ! allocation related trouble
(  365)     case(error_cmdline_options,error_program_usage,&
(  366)          error_illegal_algorithm_input)
(  367)        code = 130 ! wrong program usage
(  368)     case(error_programming,error_not_yet_implemented,error_phased_out)
(  369)        code = 131 ! programming related
(  370)     case(error_no_data_selected)
(  371)        code = 132 ! no data selected
(  372)     case(error_out_of_valid_range,error_numerics_intsize,&
(  373)          error_numerics_realsize,error_numerics_charsize,&
(  374)          error_numerics_hexval,error_numerics_NaN_detected,&
(  375)          error_numerics_Inf_detected)
(  376)        code = 133 ! range error
(  377)     case(error_invalid_date,error_invalid_time)
(  378)        code = 134 ! date/time error






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 9

(  379)     case(error_bufr_encode,error_bufr_decode,error_bufr_corr_msg,&
(  380)          error_bufr_interface,error_bufr_bufren,error_bufr_bufrex,&
(  381)          error_bufr_busel,error_bufr_bus012,error_bufr_buxdes,&
(  382)          error_bufr_bupkey,error_bufr_tables)
(  383)        code = 135 ! BUFR related trouble
(  384)     case(error_c_interface)
(  385)        code = 136 ! c interface trouble
(  386)     case(error_diff_tool_syntax_error)
(  387)        code = 137 ! diff tool trouble
(  388)     case default
(  389)        code = 255
(  390)     end select
(  391)     ! don't forget to also update abort_with_given_code
(  392)     ! if more codes are added here!
(  393)     
(  394)   end function request_exit_code
(  395)     !  #]
(  396)   subroutine abort_with_given_code(error_flag)
(  397)     !  #[
(  398)     ! a subroutine to help make sure the exit status of the program will
(  399)     ! have different values on different error conditions as requested 
(  400)     ! by C. Caspar
(  401)     ! in his email dd. 27-May-2010 titled "AI18.1 from L2B PM #18"
(  402)     ! (and this seems detailed in the PDS - IPF generic interface 
(  403)     ! guideline as well)
(  404)     ! TODO: add a description of these codes in our ICD document
(  405) 
(  406)     integer, intent(in) :: error_flag ! input
(  407) 
(  408)     ! local variable
(  409)     integer :: ex_code
(  410)     
(  411)     ex_code = request_exit_code(error_flag)
(  412)     call exit_aeolus(ex_code)
(  413)     
(  414)   end subroutine abort_with_given_code
(  415)     !  #]
(  416)   subroutine catch_error1(error_flag,subroutine_name)
(  417)     !  #[
(  418)     ! note on usage: this catch_error1 routine was deliberately
(  419)     ! renamed to mark that it should only be used inside the support
(  420)     ! directory, and only by those modules that cannot use the logging
(  421)     ! module (due to possibly circular dependency problems)
(  422)     ! (TestErrorHandler seems the only one for now)
(  423)     ! All other code should use catch_error as defined in the
(  424)     ! logging module.
(  425) 
(  426)     integer,          intent(in) :: error_flag
(  427)     character(len=*), intent(in) :: subroutine_name
(  428) 
(  429)     IF (error_flag .ne. no_error) &
(  430)          call program_abort1(error_flag,subroutine_name)
(  431) 
(  432)   end subroutine catch_error1
(  433)     !  #]
(  434)  !-----------------------------------
(  435) end module ErrorHandler







NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 10

(    1) # 1 "errorhandler.F90"
(    1) module ErrorHandler
(    2)   !  #[ Description
(    3)   !     a module to define parameters for the error conditions
(    4)   !     in the L2B program and its modules, and some functions
(    5)   !     to print information on the nature of the error
(    6)   !     and to gracefully abort the code
(    7)   !     This needs to be replaced by the IFS way of doing things later,
(    8)   !     but the standalone version needs this. Therefore I inserted
(    9)   !     this module, to have a single point of change to the 
(   10)   !     IFS interface.
(   11)   !
(   12)   !     written by: J. de Kloe, KNMI
(   13)   !
(   14)   !     Modifications:
(   15)   !     19-Apr-2006 J. de Kloe  added errortype error_diff_tool_syntax_error
(   16)   !     27-Jul-2006 J. de Kloe  added errors for c_support
(   17)   !     19-Sep-2006 J. de Kloe  added error_program_usage error type
(   18)   !     24-Nov-2006 J. de Kloe  added error_numerics_charsize
(   19)   !     13-Dec-2006 J. de Kloe  added error_numerics_hexval
(   20)   !     19-Dec-2007 P. Poli     added routine catch_error
(   21)   !     05-Jun-2008 J. de Kloe  imported changes from branch nl8_CY32R1_Jun04
(   22)   !     26-Sep-2008 J. de Kloe  added error_numerics_NaN_detected and
(   23)   !                             error_numerics_Inf_detected
(   24)   !     15-Jan-2009 J. de Kloe  added error_not_yet_implemented
(   25)   !     19-Feb-2009 J. de Kloe  added error_bufr_interface
(   26)   !     01-Apr-2009 J. de Kloe  add some BUFR specific error messages
(   27)   !     03-Feb-2010 J. de Kloe  added error_out_of_valid_range
(   28)   !     08-Jul-2010 J. de Kloe  added error_no_data_selected
(   29)   !                             and base reported exit code on error value
(   30)   !     02-Aug-2010 J. de Kloe  added get_error_text and abort_with_given_code
(   31)   !                             to allow reimplementing program_abort in the
(   32)   !                             logging module as well
(   33)   !     14-Dec-2010 J. de Kloe  change all STOP statements into calls to
(   34)   !                             exit_aeolus() to fix the pgf90 portability
(   35)   !     02-Feb-2011 M Rennie    bugfix in get_error_text in case error_flag
(   36)   !                             equals request_program_to_stop
(   37)   !     02-Nov-2011 J. de Kloe  added stop_iteration as special flag value
(   38)   !     24-Nov-2011 J. de Kloe  added error_deleting_file
(   39)   !     26-Feb-2014 J. de Kloe  disable MPI related errors
(   40)   !     26-Feb-2015 J. de Kloe  implement request_exit_code function
(   41)   !     09-Jun-2015 J. de Kloe  update error_xml definition
(   42)   !     08-Jun-2017 J. de Kloe  added error_illegal_algorithm_input
(   43)   !     19-Mar-2018 J. de Kloe  added an error for bufr table problems
(   44)   !                             and simplify abort_with_given_code
(   45)   !  #]
(   46)   !  #[ Modules used
(   47)   USE Compiler_Features, only: exit_aeolus
(   48)   !  #]
(   49)   !  #[ parameters
(   50)   implicit none
(   51) # 52 "errorhandler.F90"
(   52)   ! these are not really errors, but conditions that
(   53)   ! may be signalled using the error_flag as well
(   54)   integer, parameter :: stop_iteration          = -3
(   55)   integer, parameter :: end_of_file_reached     = -2
(   56)   integer, parameter :: request_program_to_stop = -1
(   57) # 58 "errorhandler.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 11

(   58)   ! all seems ok
(   59)   integer, parameter :: no_error                = 0
(   60) # 61 "errorhandler.F90"
(   61)   ! general error codes
(   62)   integer, parameter :: error_opening_file        = 1
(   63)   integer, parameter :: error_closing_file        = 2
(   64)   integer, parameter :: error_reading_file        = 3
(   65)   integer, parameter :: error_writing_file        = 4
(   66)   integer, parameter :: error_deleting_file       = 5
(   67)   integer, parameter :: error_allocate            = 6
(   68)   integer, parameter :: error_deallocate          = 7
(   69)   integer, parameter :: error_programming         = 8
(   70)   integer, parameter :: error_cmdline_options     = 9
(   71)   integer, parameter :: error_program_usage       = 10
(   72)   integer, parameter :: error_not_yet_implemented = 11
(   73)   integer, parameter :: error_phased_out          = 12
(   74)   integer, parameter :: error_out_of_valid_range  = 13
(   75)   integer, parameter :: error_no_data_selected    = 14
(   76)   integer, parameter :: error_illegal_algorithm_input = 15
(   77)   
(   78)   ! error codes used by specific support modules       ! used in which module:
(   79)   integer, parameter :: error_invalid_date  = 50001 ! datetime module
(   80)   integer, parameter :: error_invalid_time  = 50002 ! datetime module
(   81)   integer, parameter :: error_xml           = 50101 ! xml module
(   82)   integer, parameter :: error_bufr_encode   = 50201 ! bufr module
(   83)   integer, parameter :: error_bufr_decode   = 50202 ! bufr module
(   84)   integer, parameter :: error_bufr_corr_msg = 50203 ! bufr module
(   85)   integer, parameter :: error_bufr_interface= 50204 ! bufr module
(   86)   integer, parameter :: error_bufr_bufren   = 50210 ! bufr module
(   87)   integer, parameter :: error_bufr_bufrex   = 50211 ! bufr module
(   88)   integer, parameter :: error_bufr_busel    = 50212 ! bufr module
(   89)   integer, parameter :: error_bufr_bus012   = 50213 ! bufr module
(   90)   integer, parameter :: error_bufr_buxdes   = 50214 ! bufr module
(   91)   integer, parameter :: error_bufr_bupkey   = 50215 ! bufr module
(   92)   integer, parameter :: error_bufr_tables   = 50216 ! bufr module
(   93) # 94 "errorhandler.F90"
(   94)   ! warning: these next parameters should have the same value as the
(   95)   ! ones defined in the module numerics.F90.
(   96)   ! the numerics module can not USE this ErrorHandler module, however,
(   97)   ! because that would introduce a circular dependency
(   98)   ! (and a huge number of changes in other programs/modules, since
(   99)   ! almost every program/module that I make uses the numerics module
(  100)   ! as a standalone module without further dependencies)
(  101)   integer, parameter :: error_numerics_intsize      = 50301 ! numerics module
(  102)   integer, parameter :: error_numerics_realsize     = 50311 ! numerics module
(  103)   integer, parameter :: error_numerics_charsize     = 50321 ! numerics module
(  104)   integer, parameter :: error_numerics_hexval       = 50331 ! numerics module
(  105)   integer, parameter :: error_numerics_NaN_detected = 50341 ! numerics module
(  106)   integer, parameter :: error_numerics_Inf_detected = 50351 ! numerics module
(  107)   integer, parameter :: error_c_interface       = 50401 ! c_support
(  108) # 109 "errorhandler.F90"
(  109)   ! error code used by the difftool
(  110)   integer, parameter :: error_diff_tool_syntax_error = 60001
(  111) # 112 "errorhandler.F90"
(  112)   ! error code used by the mpi wrapper
(  113) !  integer, parameter :: error_mpi = 70001
(  114) # 115 "errorhandler.F90"
(  115)   ! save settings to be used throughout the program






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 12

(  116)   logical, save :: do_abort_on_error = .true.
(  117) # 118 "errorhandler.F90"
(  118)   !  #]
(  119) contains
(  120)   !-----------------------------------
(  121)   subroutine InitErrorHandler(abort_on_error)
(  122)     !  #[
(  123)     logical, optional, intent(in) :: abort_on_error
(  124) # 125 "errorhandler.F90"
(  125)     IF (present(abort_on_error)) do_abort_on_error = abort_on_error
(  126) # 127 "errorhandler.F90"
(  127)     IF (do_abort_on_error) THEN
(  128)        print *,"The Error Handler program_abort routine is set to "
(  129)        print *,"abort on first error..."
(  130)     ELSE
(  131)        print *,"The Error Handler program_abort routine is set to "
(  132)        print *,"return after each error,"
(  133)        print *,"in order to try and resume the program..."
(  134)     END IF
(  135) # 136 "errorhandler.F90"
(  136)   end subroutine InitErrorHandler
(  137)     !  #]
(  138)   function get_error_text(error_flag,subroutine_name) result(error_text)
(  139)     !  #[
(  140)     integer,           intent(in) :: error_flag
(  141)     character(len=*),  intent(in) :: subroutine_name
(  142)     character(len=512)            :: error_text
(  143) # 144 "errorhandler.F90"
(  144)     ! local variable
(  145)     character(len=30) :: error_flag_txt
(  146) # 147 "errorhandler.F90"
(  147)     ! initialise
(  148)     error_text(:) = ' '
(  149) # 150 "errorhandler.F90"
(  150)     IF (error_flag .gt. 0) &
(  151)          error_text = "an error was reported from within subroutine: "//&
(  152)                       trim(subroutine_name)//"; "
(  153) # 154 "errorhandler.F90"
(  154)     select case(error_flag)
(  155)     case(stop_iteration)
(  156)        error_text = trim(error_text)//"Stop-Iteration was signalled"
(  157)     case(end_of_file_reached)
(  158)        error_text = trim(error_text)//"End-of-file reached"
(  159)     case(request_program_to_stop)
(  160)        error_text = trim(error_text)//"the program will be stopped"
(  161)     case(no_error)
(  162)        error_text = trim(error_text)//"there was no error ..."
(  163)        !  #[ general error codes
(  164)     case(error_opening_file)
(  165)        error_text = trim(error_text)//"error while opening a file"
(  166)     case(error_closing_file)
(  167)        error_text = trim(error_text)//"error while closing a file"
(  168)     case(error_reading_file)
(  169)        error_text = trim(error_text)//"error while reading data from a file"
(  170)     case(error_writing_file)
(  171)        error_text = trim(error_text)//"error while writing data to a file"
(  172)     case(error_deleting_file)
(  173)        error_text = trim(error_text)//"error while deleting a file"






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 13

(  174)     case(error_allocate)
(  175)        error_text = trim(error_text)//"error while allocating memory"
(  176)     case(error_deallocate)
(  177)        error_text = trim(error_text)//"error while deallocating memory"
(  178)     case(error_programming)
(  179)        error_text = trim(error_text)//"probably a programming error"
(  180)     case(error_cmdline_options)
(  181)        error_text = trim(error_text)//"error while parsing commandline options"
(  182)     case(error_program_usage)
(  183)        error_text = trim(error_text)//"error incorrect use of this "//&
(  184)             "program (check your settings!)"
(  185)     case(error_not_yet_implemented)
(  186)        error_text = trim(error_text)//"error; this feature is not yet "//&
(  187)             "implemented"
(  188)     case(error_phased_out)
(  189)        error_text = trim(error_text)//"error; this feature has been "//&
(  190)             "phased out and is no longer available"
(  191)     case(error_out_of_valid_range)
(  192)        error_text = trim(error_text)//"error; a number out of its "//&
(  193)             "expected range was detected. "//&
(  194)             "Usually this indicates an error in the input data screening "//&
(  195)             "and/or a programming error"
(  196)     case(error_no_data_selected)
(  197)        error_text = trim(error_text)//&
(  198)             "error; no input data was selected; this is not allowed."
(  199)     case(error_illegal_algorithm_input)
(  200)        error_text = trim(error_text)//&
(  201)             "error; the algorithm was provided with illegal input."
(  202)        !  #]
(  203)        !  #[ error codes used by the datetime module
(  204)     case(error_invalid_date)
(  205)        error_text = trim(error_text)//&
(  206)             "a date was detected to have an invalid/impossible value"
(  207)     case(error_invalid_time)
(  208)        error_text = trim(error_text)//&
(  209)             "a time was detected to have an invalid/impossible value"
(  210)        !  #]
(  211)        !  #[ error codes used by the ee_xml module
(  212)     case(error_xml)
(  213)        error_text = trim(error_text)//&
(  214)             "an error was reported by the xml handling software"
(  215) !            "an error was reported by the ee_cfi_software"
(  216)        !  #]
(  217)        !  #[ error codes used by the bufr module
(  218)     case(error_bufr_encode)
(  219)        error_text = trim(error_text)//&
(  220)             "error while encoding a bufr message"
(  221)     case(error_bufr_decode)
(  222)        error_text = trim(error_text)//&
(  223)             "error while decoding a bufr message"
(  224)     case(error_bufr_corr_msg)
(  225)        error_text = trim(error_text)//&
(  226)             "error BUFR message seems corrupt"
(  227)     case(error_bufr_interface)
(  228)        error_text = trim(error_text)//&
(  229)             "error BUFR fortran and c interfaces do not match"
(  230)     case(error_bufr_bufren)
(  231)        error_text = trim(error_text)//&






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 14

(  232)             "error reported by BUFREN library subroutine"
(  233)     case(error_bufr_bufrex)
(  234)        error_text = trim(error_text)//&
(  235)             "error reported by BUFREX library subroutine"
(  236)     case(error_bufr_busel)
(  237)        error_text = trim(error_text)//&
(  238)             "error reported by BUSEL library subroutine"
(  239)     case(error_bufr_bus012)
(  240)        error_text = trim(error_text)//&
(  241)             "error reported by BUS012 library subroutine"
(  242)     case(error_bufr_buxdes)
(  243)        error_text = trim(error_text)//&
(  244)             "error reported by BUXDES library subroutine"
(  245)     case(error_bufr_bupkey)
(  246)        error_text = trim(error_text)//&
(  247)             "error reported by BUPKEY library subroutine"
(  248)     case(error_bufr_tables)
(  249)        error_text = trim(error_text)//&
(  250)             "error while loading BUFR tables"
(  251)        !  #]
(  252)        !  #[ error codes used by the numerics module
(  253)     case(error_numerics_intsize)
(  254)        error_text = trim(error_text)//&
(  255)             "an error was reported by the numerics module: "//&
(  256)             "integer size differs from what is expected"
(  257)     case(error_numerics_realsize)
(  258)        error_text = trim(error_text)//&
(  259)             "an error was reported by the numerics module: "//&
(  260)             "real size differs from what is expected"
(  261)     case(error_numerics_charsize)
(  262)        error_text = trim(error_text)//&
(  263)             "an error was reported by the numerics module: "//&
(  264)             "character size differs from what is expected"
(  265)     case(error_numerics_hexval)
(  266)        error_text = trim(error_text)//&
(  267)             "an error was reported by the numerics module: "//&
(  268)             "hexadecimal to integer conversion differs "//&
(  269)             "from what is expected"
(  270)     case(error_numerics_NaN_detected)
(  271)        error_text = trim(error_text)//&
(  272)             "an error was reported by the numerics module: "//&
(  273)             "a real variable was found to contain the NaN value. "//&
(  274)             "Usually this points at a programming error..."
(  275)     case(error_numerics_Inf_detected)
(  276)        error_text = trim(error_text)//&
(  277)             "an error was reported by the numerics module: "//&
(  278)             "a real variable was found to contain the Inf value. "//&
(  279)             "Usually this points at a programming error..."
(  280)        !  #]
(  281)        !  #[ error codes used by the c_support module
(  282)     case(error_c_interface)
(  283)        error_text = trim(error_text)//&
(  284)             "an error was reported by the c_support module: "//&
(  285)             "c and fortran code cannot be properly interfaced "//&
(  286)             "with the available datatypes in the "//&
(  287)             "current c and fortran objects..."
(  288)        !  #]
(  289)        !  #[ error codes used by the difftool






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 15

(  290)     case(error_diff_tool_syntax_error)
(  291)        error_text = trim(error_text)//&
(  292)             "a syntax error was reported by the difftool"
(  293)        !  #]
(  294)        !  #[ error codes used by the mpi wrapper
(  295) !    case(error_mpi)
(  296) !       error_text = trim(error_text)//&
(  297) !            "an error was reported from within the MPI library"
(  298)        !  #]
(  299)     case default
(  300)        write(error_flag_txt,*,err=999) error_flag
(  301)        error_text = trim(error_text)//&
(  302)             "this error code was not yet defined: "//&
(  303)             trim(adjustl(error_flag_txt))
(  304)     end select
(  305) # 306 "errorhandler.F90"
(  306)     return
(  307) # 308 "errorhandler.F90"
(  308) 999 error_text = trim(error_text)//&
(  309)          "could not convert error_flag to string. Probably there is a "//&
(  310)          "programming error in errorhandler.F90"
(  311)     return
(  312) # 313 "errorhandler.F90"
(  313)   end function get_error_text
(  314)     !  #]
(  315)   subroutine program_abort1(error_flag,subroutine_name)
(  316)     !  #[
(  317)     ! note on usage: this program_abort1 routine was deliberately
(  318)     ! renamed to mark that it should only be used inside the support
(  319)     ! directory, and only by those modules that cannot use the logging
(  320)     ! module (due to possibly circular dependency problems)
(  321)     ! All other code should use program_abort as defined in the
(  322)     ! logging module.
(  323) # 324 "errorhandler.F90"
(  324)     integer,          intent(in) :: error_flag
(  325)     character(len=*), intent(in) :: subroutine_name
(  326) # 327 "errorhandler.F90"
(  327)     ! local variable
(  328)     character(len=512) :: error_text
(  329) # 330 "errorhandler.F90"
(  330)     error_text = get_error_text(error_flag,subroutine_name)
(  331)     print *,trim(error_text)
(  332) # 333 "errorhandler.F90"
(  333)     IF (error_flag .eq. request_program_to_stop) stop 0 ! normal exit
(  334) # 335 "errorhandler.F90"
(  335)     IF (do_abort_on_error) THEN
(  336)        ! make sure the exit status of the program will have different
(  337)        ! values on different error conditions
(  338)        call abort_with_given_code(error_flag)
(  339)     ELSE
(  340)        print *,"==> trying to resume the program ..."
(  341)        return
(  342)     END IF
(  343) # 344 "errorhandler.F90"
(  344)   end subroutine program_abort1
(  345)     !  #]
(  346)   function request_exit_code(error_flag) result(code)
(  347)     !  #[






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 16

(  348)     ! a function that reports the exit code that will be used
(  349)     ! when the abort_with_given_code() subroutine is run with
(  350)     ! the same error_flag. This is needed to allow writing the
(  351)     ! exit code to the log file before actually terminating the program.
(  352) # 353 "errorhandler.F90"
(  353)     integer, intent(in) :: error_flag ! input
(  354)     integer             :: code       ! result
(  355) # 356 "errorhandler.F90"
(  356)     select case(error_flag)
(  357)     case(no_error,request_program_to_stop,stop_iteration)
(  358)        code = 0 ! normal exit
(  359)     case(end_of_file_reached,error_opening_file,error_closing_file,&
(  360)          error_reading_file,error_writing_file,error_xml, &
(  361)          error_deleting_file)
(  362)        code = 128 ! file related trouble
(  363)     case(error_allocate,error_deallocate)
(  364)        code = 129 ! allocation related trouble
(  365)     case(error_cmdline_options,error_program_usage,&
(  366)          error_illegal_algorithm_input)
(  367)        code = 130 ! wrong program usage
(  368)     case(error_programming,error_not_yet_implemented,error_phased_out)
(  369)        code = 131 ! programming related
(  370)     case(error_no_data_selected)
(  371)        code = 132 ! no data selected
(  372)     case(error_out_of_valid_range,error_numerics_intsize,&
(  373)          error_numerics_realsize,error_numerics_charsize,&
(  374)          error_numerics_hexval,error_numerics_NaN_detected,&
(  375)          error_numerics_Inf_detected)
(  376)        code = 133 ! range error
(  377)     case(error_invalid_date,error_invalid_time)
(  378)        code = 134 ! date/time error
(  379)     case(error_bufr_encode,error_bufr_decode,error_bufr_corr_msg,&
(  380)          error_bufr_interface,error_bufr_bufren,error_bufr_bufrex,&
(  381)          error_bufr_busel,error_bufr_bus012,error_bufr_buxdes,&
(  382)          error_bufr_bupkey,error_bufr_tables)
(  383)        code = 135 ! BUFR related trouble
(  384)     case(error_c_interface)
(  385)        code = 136 ! c interface trouble
(  386)     case(error_diff_tool_syntax_error)
(  387)        code = 137 ! diff tool trouble
(  388)     case default
(  389)        code = 255
(  390)     end select
(  391)     ! don't forget to also update abort_with_given_code
(  392)     ! if more codes are added here!
(  393)     
(  394)   end function request_exit_code
(  395)     !  #]
(  396)   subroutine abort_with_given_code(error_flag)
(  397)     !  #[
(  398)     ! a subroutine to help make sure the exit status of the program will
(  399)     ! have different values on different error conditions as requested 
(  400)     ! by C. Caspar
(  401)     ! in his email dd. 27-May-2010 titled "AI18.1 from L2B PM #18"
(  402)     ! (and this seems detailed in the PDS - IPF generic interface 
(  403)     ! guideline as well)
(  404)     ! TODO: add a description of these codes in our ICD document
(  405) # 406 "errorhandler.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:35:58      page 17

(  406)     integer, intent(in) :: error_flag ! input
(  407) # 408 "errorhandler.F90"
(  408)     ! local variable
(  409)     integer :: ex_code
(  410)     
(  411)     ex_code = request_exit_code(error_flag)
(  412)     call exit_aeolus(ex_code)
(  413)     
(  414)   end subroutine abort_with_given_code
(  415)     !  #]
(  416)   subroutine catch_error1(error_flag,subroutine_name)
(  417)     !  #[
(  418)     ! note on usage: this catch_error1 routine was deliberately
(  419)     ! renamed to mark that it should only be used inside the support
(  420)     ! directory, and only by those modules that cannot use the logging
(  421)     ! module (due to possibly circular dependency problems)
(  422)     ! (TestErrorHandler seems the only one for now)
(  423)     ! All other code should use catch_error as defined in the
(  424)     ! logging module.
(  425) # 426 "errorhandler.F90"
(  426)     integer,          intent(in) :: error_flag
(  427)     character(len=*), intent(in) :: subroutine_name
(  428) # 429 "errorhandler.F90"
(  429)     IF (error_flag .ne. no_error) &
(  430)          call program_abort1(error_flag,subroutine_name)
(  431) # 432 "errorhandler.F90"
(  432)   end subroutine catch_error1
(  433)     !  #]
(  434)  !-----------------------------------
(  435) end module ErrorHandler
