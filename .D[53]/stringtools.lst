


NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: stringtools.F90

(    1) module StringTools
(    2)   !  #[ Description
(    3)   !
(    4)   ! a module that collects some simple tools
(    5)   ! to make string handling easier
(    6)   ! Created 02-Feb-2006 by J. de Kloe
(    7)   !
(    8)   ! Modifications:
(    9)   !   01-Mar-2006 J. de Kloe  Added contains_spaces()
(   10)   !   08-Jun-2006 J. de Kloe  Added write_complex_number()
(   11)   !   07-Sep-2006 J. de Kloe  Added Split_path_and_filename()
(   12)   !   08-Sep-2006 J. de Kloe  Added Join_path_and_filename()
(   13)   !   13-Dec-2006 J. de Kloe  Bugfix for ifort in Added Join_path_and_filename
(   14)   !   26-Oct-2007 J. de Kloe  added new subroutine Split_filename_and_extension
(   15)   !   16-Jan-2008 J. de Kloe  phase out integer kind i_ 
(   16)   !   10-Mar-2008 J. de Kloe  removed bug in Split_filename_and_extension
(   17)   !   21-Nov-2012 J. de Kloe  add an error message in case string2chararray
(   18)   !                           is used in a way that makes older gfortran and
(   19)   !                           g95 versions crash
(   20)   !   30-Apr-2014 J. de Kloe  add a comment on transfer for the pgf90 compiler
(   21)   !   20-Jul-2016 J. de Kloe  implement subroutine Split_on_first_space
(   22)   !   12-Aug-2016 J. de Kloe  add more generic Split_on_first_delimiter
(   23)   !   19-Mar-2018 J. de Kloe  remove a hardcoded stop command
(   24)   !
(   25)   !  #]
(   26)   !  #[ Modules used
(   27)   USE Compiler_Features, only: retchar, newline
(   28)   USE Numerics, only: r8_
(   29)   USE ErrorHandler, only: error_programming, program_abort1
(   30)   !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 3

(   31)   !  #[ variables and parameters
(   32)   implicit none
(   33)   character(len=1), parameter :: space   = ' '
(   34)   !  #]
(   35) contains
(   36)   !--------------------------------------------
(   37)   ! todo: use this module in SimpleXML.F90
(   38)   ! todo: submit bug-report for gfortran
(   39)   function to_lowercase(txt_in) result(txt_out)
(   40)     !  #[
(   41)     character(len=*)           :: txt_in  ! input
(   42)     character(len=len(txt_in)) :: txt_out ! result
(   43) 
(   44)     ! local variables
(   45)     integer          :: i,n
(   46)     character(len=1) :: c
(   47)     integer, parameter :: offset_to_lowercase =  ichar('a') - ichar('A')
(   48) 
(   49)     txt_out(:) = ' '
(   50)     n = len_trim(txt_in)
(   51) 
(   52)     IF (n .gt. 0) THEN
(   53)        DO i=1,n
(   54)           c = txt_in(i:i)
(   55)           IF ( (c .ge. 'A') .and. (c .le. 'Z')) THEN
(   56)              c = achar(ichar(c)+offset_to_lowercase)
(   57)           END IF
(   58)           txt_out(i:i) = c
(   59)        END DO
(   60)     END IF
(   61) 
(   62)   end function to_lowercase
(   63)     !  #]
(   64)   function to_uppercase(txt_in) result(txt_out)
(   65)     !  #[
(   66)     character(len=*)           :: txt_in  ! input
(   67)     character(len=len(txt_in)) :: txt_out ! result
(   68) 
(   69)     ! local variables
(   70)     integer          :: i,n
(   71)     character(len=1) :: c
(   72)     integer, parameter :: offset_to_uppercase =  ichar('A') - ichar('a')
(   73) 
(   74)     txt_out(:) = ' '
(   75)     n = len_trim(txt_in)
(   76) 
(   77)     IF (n .gt. 0) THEN
(   78)        DO i=1,n
(   79)           c = txt_in(i:i)
(   80)           IF ( (c .ge. 'a') .and. (c .le. 'z')) THEN
(   81)              c = achar(ichar(c)+offset_to_uppercase)
(   82)           END IF
(   83)           txt_out(i:i) = c
(   84)        END DO
(   85)     END IF
(   86) 
(   87)   end function to_uppercase
(   88)     !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 4

(   89)   function chararray2string(chararray) result(text)
(   90)     !  #[
(   91)     character(len=1), dimension(:) :: chararray ! input
(   92)     character(len=size(chararray)) :: text      ! output
(   93) 
(   94)     integer :: n, i
(   95) 
(   96)     text(:) = ' '
(   97)     n = size(chararray)
(   98) 
(   99)     ! copy the data from the char array to a string
(  100)     ! dont use transfer here, since then the type will be converted
(  101)     ! in the same memory location, which is not how a function
(  102)     ! should behave
(  103)     ! Also the pgf90 compiler seems to have a bug when using transfer
(  104)     ! for this purpose.
(  105)     DO i=1,n
(  106)        text(i:i) = chararray(i)
(  107)     END DO
(  108) 
(  109)   end function chararray2string
(  110)     !  #]
(  111)   function string2chararray(text) result(chararray)
(  112)     !  #[
(  113)     character(len=*)                       :: text      ! input
(  114)     character(len=1), dimension(len(text)) :: chararray ! output
(  115) 
(  116)     integer :: n, i
(  117) 
(  118)     if (len(text) .eq.0) then
(  119)        print *,'ERROR: string2chararray cannot take empty strings as input!'
(  120)        print *,"Please handle this exception before calling string2chararray."
(  121)        call program_abort1(error_programming, 'string2chararray')
(  122)     end if
(  123) 
(  124)     chararray(:) = ' '
(  125)     n = len_trim(text)
(  126) 
(  127)     ! copy the text from the string to the char array
(  128)     ! dont use transfer here, since then the type will be converted
(  129)     ! in the same memory location, which is not how a function
(  130)     ! should behave
(  131)     ! Also the pgf90 compiler seems to have a bug when using transfer
(  132)     ! for this purpose.
(  133)     DO i=1,n
(  134)         chararray(i) = text(i:i)
(  135)     END DO
(  136)     
(  137)   end function string2chararray
(  138)     !  #]
(  139)   function remove_eol(txt_in) result(txt_out)
(  140)     !  #[ remove cr/newline characters
(  141)     character(len=*)           :: txt_in  ! input
(  142)     character(len=len(txt_in)) :: txt_out ! result
(  143) 
(  144)     ! local variables
(  145)     integer          :: i_in, i_out, n
(  146)     character(len=1) :: c






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 5

(  147) 
(  148)     txt_out(:) = ' '
(  149)     n = len_trim(txt_in)
(  150) 
(  151)     IF (n .gt. 0) THEN
(  152)        i_out=0
(  153)        DO i_in=1,n
(  154)           c = txt_in(i_in:i_in)
(  155)           IF ( (c .eq. retchar) .or. (c .eq. newline)) THEN
(  156)              ! just ignore this character
(  157)           ELSE
(  158)              ! copy this character
(  159)              i_out = i_out+1
(  160)              txt_out(i_out:i_out) = c
(  161)           END IF
(  162)        END DO
(  163)     END IF
(  164) 
(  165)   end function remove_eol
(  166)     !  #]
(  167)   function contains_spaces(text) result(spaces_present)
(  168)     !  #[ check if any spaces are present
(  169)     character(len=*) :: text           ! input
(  170)     logical          :: spaces_present ! result
(  171)     
(  172)     ! local variable
(  173)     integer :: i
(  174) 
(  175)     ! I could also use the scan() function to do this
(  176)     spaces_present = .false. ! assume no spaces
(  177)     scanloop: DO i=1,len_trim(text)
(  178)        if (text(i:i) .eq. space) then
(  179)           spaces_present = .true.
(  180)           exit scanloop
(  181)        end if
(  182)     END DO scanloop
(  183) 
(  184)   end function contains_spaces
(  185)     !  #]
(  186)   function contains_crnl(text) result(crnl_present)
(  187)     !  #[ check if a cr and/or newline character is present
(  188)     character(len=*) :: text          ! input
(  189)     logical          :: crnl_present ! result
(  190)     
(  191)     ! local variable
(  192)     integer :: i
(  193) 
(  194)     ! I could also use the scan() function to do this
(  195)     crnl_present = .false. ! assume no cr/nl characters
(  196)     scanloop: DO i=1,len_trim(text)
(  197)        if ( (text(i:i) .eq. newline) .or. &
(  198)             (text(i:i) .eq. retchar)      ) then
(  199)           crnl_present = .true.
(  200)           exit scanloop
(  201)        end if
(  202)     END DO scanloop
(  203) 
(  204)   end function contains_crnl






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 6

(  205)     !  #]
(  206)   function write_complex_number(c) result(c_string)
(  207)     !  #[
(  208)     ! REMARK: the L2BP difftool recognises only complex numbers that have
(  209)     ! the shape (a,b) without any spaces within the brackets. Most compilers
(  210)     ! use this form. However, the gfortran compiler is an exception, because
(  211)     ! it does write some extra spaces inside the brackets. Therefore the 
(  212)     ! following Write_Complex_Number() function was added. 
(  213)     ! For the moment the TestArraytools program is the only one in the L2BP
(  214)     ! that actually prints complex numbers. 
(  215)     ! Note that also the module RayleighBrillouinProcessing/tentispectrum.F90
(  216)     ! uses complex numbers, but these are not printed.
(  217)     ! JK, 8-6-2006
(  218) 
(  219)     complex(r8_), intent(in) :: c        ! input
(  220)     character(len=100)       :: c_string ! result
(  221) 
(  222)     ! local variables
(  223)     character(len=1), parameter :: space = ' '
(  224)     character(len=100) :: tmp_string
(  225)     integer            :: i,j
(  226) 
(  227)     ! init
(  228)     c_string(:)   = space
(  229)     tmp_string(:) = space
(  230) 
(  231)     ! convert the complex number to a string
(  232)     write(tmp_string,*,err=999) c
(  233) 
(  234)     ! remove all the spaces from the string
(  235)     j=0
(  236)     DO i=1,len_trim(tmp_string)
(  237)        IF (tmp_string(i:i) .ne. space) THEN
(  238)           j=j+1
(  239)           c_string(j:j) = tmp_string(i:i)
(  240)        END IF
(  241)     END DO
(  242) 
(  243)     ! done
(  244)     return
(  245) 
(  246)     ! warning: printing an error is not possible here, because then
(  247)     ! you cannot use this function as parameter to a print statement
(  248)     ! anymore (you will get recursive io errors)
(  249)     ! therefore just report "[conversion error]" if something is wrong...
(  250) 999 c_string = "[conversion error]"
(  251)     return
(  252) 
(  253)   end function write_complex_number
(  254)     !  #]
(  255)   subroutine Split_on_first_delimiter(text_in, delimiter, part1, part2)
(  256)     !  #[
(  257)     character(len=*),   intent(in)  :: text_in
(  258)     character(len=1),   intent(in)  :: delimiter
(  259)     character(len=len(text_in)), intent(out) :: part1
(  260)     character(len=len(text_in)), intent(out) :: part2
(  261)     
(  262)     ! local variables






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 7

(  263)     integer :: i, delimiter_pos, length
(  264) 
(  265)     part1(:) = ' '
(  266)     part2(:) = ' '
(  267)     
(  268)     ! find the first occurrence of delimiter
(  269)     delimiter_pos = -1
(  270)     length = len_trim(text_in)
(  271)     searchloop: do i=1,length
(  272)        if (text_in(i:i) .eq. delimiter) then
(  273)           delimiter_pos=i
(  274)           exit searchloop
(  275)        end if
(  276)     end do searchloop
(  277)     
(  278)     if (delimiter_pos .eq. -1) then
(  279)        part1 = trim(adjustl(text_in))
(  280)        return
(  281)     else
(  282)        part1 = trim(adjustl(text_in(1:delimiter_pos)))
(  283)        part2 = trim(adjustl(text_in(delimiter_pos+1:length)))
(  284)     end if
(  285)     
(  286)   end subroutine Split_on_first_delimiter
(  287)     !  #]
(  288)   subroutine Split_on_first_space(text_in, part1, part2)
(  289)     !  #[
(  290)     character(len=*),   intent(in)  :: text_in
(  291)     character(len=len(text_in)), intent(out) :: part1
(  292)     character(len=len(text_in)), intent(out) :: part2
(  293)     
(  294)     call Split_on_first_delimiter(text_in, ' ', part1, part2)
(  295)     
(  296)   end subroutine Split_on_first_space
(  297)     !  #]
(  298)   subroutine Split_path_and_filename(path_and_filename,path,filename)
(  299)     !  #[
(  300)     character(len=*),   intent(in)  :: path_and_filename
(  301)     character(len=256), intent(out) :: path
(  302)     character(len=256), intent(out) :: filename
(  303)     
(  304)     ! method: assume we are on a unix/linux like system, so just find
(  305)     ! the last slash and split the string at that point
(  306)     ! (or if no slashes are present, assume path is empty and just
(  307)     ! return the filename)
(  308)     ! NOTE: if we have to be compatible with windows (hope that will
(  309)     ! never happen), then we need to check backslashes .....
(  310) 
(  311)     ! local variables
(  312)     integer :: i, slash_pos, length
(  313) 
(  314)     path(:)     = ' '
(  315)     filename(:) = ' '
(  316) 
(  317)     ! find the last slash
(  318)     slash_pos = -1
(  319)     length = len_trim(path_and_filename)
(  320)     do i=1,length






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 8

(  321)        if (path_and_filename(i:i) .eq. '/') slash_pos=i
(  322)     end do
(  323) 
(  324)     if (slash_pos .eq. -1) then
(  325)        filename = path_and_filename
(  326)        return
(  327)     else
(  328)        path     = path_and_filename(1:slash_pos)
(  329)        filename = path_and_filename(slash_pos+1:length)
(  330)     end if
(  331)     
(  332)   end subroutine Split_path_and_filename
(  333)     !  #]
(  334)   function Join_path_and_filename(path,filename) result(path_and_filename)
(  335)     !  #[
(  336)     character(len=*), intent(in) :: path
(  337)     character(len=*), intent(in) :: filename
(  338)     character(len=len(path)+len(filename)+1) :: path_and_filename ! result
(  339) ! WARNING:
(  340) ! the following line DOES NOT work properly when compiled with the ifort
(  341) ! compiler (version 8.1). Later versions seem to have fixed this bug, but
(  342) ! since I have 8.1 installed, please don't use len_trim() to determine
(  343) ! the size of function results for the moment .....
(  344) !    character(len=len_trim(path)+len_trim(filename)+1) :: path_and_filename ! result
(  345)     
(  346)     ! method: assume we are on a unix/linux like system, so glue path and
(  347)     ! filename using a slash.
(  348)     ! NOTE: if we have to be compatible with windows (hope that will
(  349)     ! never happen), then we need to add a backslash .....
(  350) 
(  351)     path_and_filename(:)     = ' '
(  352) 
(  353)     if (len_trim(path) .eq. 0) then
(  354)        ! no path to add, so just return the filename
(  355)        path_and_filename = filename
(  356)     else
(  357)        if (path(len_trim(path):len_trim(path)) .eq. '/') then
(  358) !print *,"test inside: [",trim(path),"]"
(  359) !print *,"test inside: [",trim(filename),"]"
(  360)           ! the path already ends with a slash, so it doesn't need to be added
(  361)           path_and_filename = trim(path)//trim(filename)
(  362) !print *,"test inside: [",trim(path_and_filename),"]"
(  363) !print *,"test inside: len=",len_trim(path)+len_trim(filename)+1
(  364)        else
(  365)           ! add a slash in between path and filename
(  366)           path_and_filename = trim(path)//'/'//trim(filename)
(  367)        end if
(  368)     end if
(  369) 
(  370)     return
(  371) 
(  372)   end function Join_path_and_filename
(  373)     !  #]
(  374)   subroutine Split_filename_and_extension(path_filename_and_extension,&
(  375)                                           path_and_filename,extension)
(  376)     !  #[
(  377)     character(len=*),   intent(in)  :: path_filename_and_extension
(  378)     character(len=256), intent(out) :: path_and_filename






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 9

(  379)     character(len=256), intent(out) :: extension
(  380)     
(  381)     ! Method: find the last dot and split the string at that point
(  382)     ! (or if no dots are present, assume there is no extension).
(  383)     ! A path might be present, which needs to be removed before inspecting
(  384)     ! the filename, because it is legal to have dots in directory names,
(  385)     ! which will otherwise confuse this algorithm.
(  386)     ! Exception: if the only dot in the filename is at the first character, 
(  387)     ! the file is a hidden unix/linux file, and no extension is present.
(  388) 
(  389)     ! local variable
(  390)     integer :: i, dot_pos, length
(  391)     character(len=256) :: path
(  392)     character(len=256) :: filename
(  393)     character(len=256) :: filename_and_extension
(  394) 
(  395)     ! init
(  396)     path(:)                   = ' '
(  397)     filename(:)               = ' '
(  398)     filename_and_extension(:) = ' '
(  399)     extension(:)              = ' '
(  400)     path_and_filename(:)      = ' '
(  401) 
(  402) 
(  403)     ! first remove a path, which might be prepended
(  404)     ! this is needed, because a pathname may contain dots, which do NOT
(  405)     ! indicate the start of an extension, and which will confuse
(  406)     ! the simple search below for files without an extension....
(  407)     call Split_path_and_filename(path_filename_and_extension,&
(  408)                                  path,filename_and_extension)
(  409) 
(  410)     ! find the last dot
(  411)     dot_pos = -1
(  412)     length = len_trim(filename_and_extension)
(  413)     do i=1,length
(  414)        if (filename_and_extension(i:i) .eq. '.') dot_pos=i
(  415)     end do
(  416) 
(  417)     if (dot_pos .eq. -1) then
(  418)        ! no dots where present in the filename
(  419)        path_and_filename = path_filename_and_extension
(  420)        return
(  421)     else
(  422)        if (dot_pos .eq.1) then
(  423)           ! the last and only  dot is found at pos 1.
(  424)           ! These are the hidden files in unix/linux
(  425)           path_and_filename = path_filename_and_extension
(  426)           return
(  427)        else
(  428)           filename  = filename_and_extension(1:dot_pos-1)
(  429)           extension = filename_and_extension(dot_pos+1:length)
(  430)           ! finally, combine the filename again with the path
(  431)           ! before reporting the result
(  432)           path_and_filename = Join_path_and_filename(path,filename)
(  433)           return
(  434)        end if
(  435)     end if
(  436)     






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 10

(  437)   end subroutine Split_filename_and_extension
(  438)     !  #]
(  439)   !--------------------------------------------
(  440) end module StringTools




























































NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 11

(    1) # 1 "stringtools.F90"
(    1) module StringTools
(    2)   !  #[ Description
(    3)   !
(    4)   ! a module that collects some simple tools
(    5)   ! to make string handling easier
(    6)   ! Created 02-Feb-2006 by J. de Kloe
(    7)   !
(    8)   ! Modifications:
(    9)   !   01-Mar-2006 J. de Kloe  Added contains_spaces()
(   10)   !   08-Jun-2006 J. de Kloe  Added write_complex_number()
(   11)   !   07-Sep-2006 J. de Kloe  Added Split_path_and_filename()
(   12)   !   08-Sep-2006 J. de Kloe  Added Join_path_and_filename()
(   13)   !   13-Dec-2006 J. de Kloe  Bugfix for ifort in Added Join_path_and_filename
(   14)   !   26-Oct-2007 J. de Kloe  added new subroutine Split_filename_and_extension
(   15)   !   16-Jan-2008 J. de Kloe  phase out integer kind i_ 
(   16)   !   10-Mar-2008 J. de Kloe  removed bug in Split_filename_and_extension
(   17)   !   21-Nov-2012 J. de Kloe  add an error message in case string2chararray
(   18)   !                           is used in a way that makes older gfortran and
(   19)   !                           g95 versions crash
(   20)   !   30-Apr-2014 J. de Kloe  add a comment on transfer for the pgf90 compiler
(   21)   !   20-Jul-2016 J. de Kloe  implement subroutine Split_on_first_space
(   22)   !   12-Aug-2016 J. de Kloe  add more generic Split_on_first_delimiter
(   23)   !   19-Mar-2018 J. de Kloe  remove a hardcoded stop command
(   24)   !
(   25)   !  #]
(   26)   !  #[ Modules used
(   27)   USE Compiler_Features, only: retchar, newline
(   28)   USE Numerics, only: r8_
(   29)   USE ErrorHandler, only: error_programming, program_abort1
(   30)   !  #]
(   31)   !  #[ variables and parameters
(   32)   implicit none
(   33)   character(len=1), parameter :: space   = ' '
(   34)   !  #]
(   35) contains
(   36)   !--------------------------------------------
(   37)   ! todo: use this module in SimpleXML.F90
(   38)   ! todo: submit bug-report for gfortran
(   39)   function to_lowercase(txt_in) result(txt_out)
(   40)     !  #[
(   41)     character(len=*)           :: txt_in  ! input
(   42)     character(len=len(txt_in)) :: txt_out ! result
(   43) # 44 "stringtools.F90"
(   44)     ! local variables
(   45)     integer          :: i,n
(   46)     character(len=1) :: c
(   47)     integer, parameter :: offset_to_lowercase =  ichar('a') - ichar('A')
(   48) # 49 "stringtools.F90"
(   49)     txt_out(:) = ' '
(   50)     n = len_trim(txt_in)
(   51) # 52 "stringtools.F90"
(   52)     IF (n .gt. 0) THEN
(   53)        DO i=1,n
(   54)           c = txt_in(i:i)
(   55)           IF ( (c .ge. 'A') .and. (c .le. 'Z')) THEN
(   56)              c = achar(ichar(c)+offset_to_lowercase)
(   57)           END IF






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 12

(   58)           txt_out(i:i) = c
(   59)        END DO
(   60)     END IF
(   61) # 62 "stringtools.F90"
(   62)   end function to_lowercase
(   63)     !  #]
(   64)   function to_uppercase(txt_in) result(txt_out)
(   65)     !  #[
(   66)     character(len=*)           :: txt_in  ! input
(   67)     character(len=len(txt_in)) :: txt_out ! result
(   68) # 69 "stringtools.F90"
(   69)     ! local variables
(   70)     integer          :: i,n
(   71)     character(len=1) :: c
(   72)     integer, parameter :: offset_to_uppercase =  ichar('A') - ichar('a')
(   73) # 74 "stringtools.F90"
(   74)     txt_out(:) = ' '
(   75)     n = len_trim(txt_in)
(   76) # 77 "stringtools.F90"
(   77)     IF (n .gt. 0) THEN
(   78)        DO i=1,n
(   79)           c = txt_in(i:i)
(   80)           IF ( (c .ge. 'a') .and. (c .le. 'z')) THEN
(   81)              c = achar(ichar(c)+offset_to_uppercase)
(   82)           END IF
(   83)           txt_out(i:i) = c
(   84)        END DO
(   85)     END IF
(   86) # 87 "stringtools.F90"
(   87)   end function to_uppercase
(   88)     !  #]
(   89)   function chararray2string(chararray) result(text)
(   90)     !  #[
(   91)     character(len=1), dimension(:) :: chararray ! input
(   92)     character(len=size(chararray)) :: text      ! output
(   93) # 94 "stringtools.F90"
(   94)     integer :: n, i
(   95) # 96 "stringtools.F90"
(   96)     text(:) = ' '
(   97)     n = size(chararray)
(   98) # 99 "stringtools.F90"
(   99)     ! copy the data from the char array to a string
(  100)     ! dont use transfer here, since then the type will be converted
(  101)     ! in the same memory location, which is not how a function
(  102)     ! should behave
(  103)     ! Also the pgf90 compiler seems to have a bug when using transfer
(  104)     ! for this purpose.
(  105)     DO i=1,n
(  106)        text(i:i) = chararray(i)
(  107)     END DO
(  108) # 109 "stringtools.F90"
(  109)   end function chararray2string
(  110)     !  #]
(  111)   function string2chararray(text) result(chararray)
(  112)     !  #[
(  113)     character(len=*)                       :: text      ! input
(  114)     character(len=1), dimension(len(text)) :: chararray ! output
(  115) # 116 "stringtools.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 13

(  116)     integer :: n, i
(  117) # 118 "stringtools.F90"
(  118)     if (len(text) .eq.0) then
(  119)        print *,'ERROR: string2chararray cannot take empty strings as input!'
(  120)        print *,"Please handle this exception before calling string2chararray."
(  121)        call program_abort1(error_programming, 'string2chararray')
(  122)     end if
(  123) # 124 "stringtools.F90"
(  124)     chararray(:) = ' '
(  125)     n = len_trim(text)
(  126) # 127 "stringtools.F90"
(  127)     ! copy the text from the string to the char array
(  128)     ! dont use transfer here, since then the type will be converted
(  129)     ! in the same memory location, which is not how a function
(  130)     ! should behave
(  131)     ! Also the pgf90 compiler seems to have a bug when using transfer
(  132)     ! for this purpose.
(  133)     DO i=1,n
(  134)         chararray(i) = text(i:i)
(  135)     END DO
(  136)     
(  137)   end function string2chararray
(  138)     !  #]
(  139)   function remove_eol(txt_in) result(txt_out)
(  140)     !  #[ remove cr/newline characters
(  141)     character(len=*)           :: txt_in  ! input
(  142)     character(len=len(txt_in)) :: txt_out ! result
(  143) # 144 "stringtools.F90"
(  144)     ! local variables
(  145)     integer          :: i_in, i_out, n
(  146)     character(len=1) :: c
(  147) # 148 "stringtools.F90"
(  148)     txt_out(:) = ' '
(  149)     n = len_trim(txt_in)
(  150) # 151 "stringtools.F90"
(  151)     IF (n .gt. 0) THEN
(  152)        i_out=0
(  153)        DO i_in=1,n
(  154)           c = txt_in(i_in:i_in)
(  155)           IF ( (c .eq. retchar) .or. (c .eq. newline)) THEN
(  156)              ! just ignore this character
(  157)           ELSE
(  158)              ! copy this character
(  159)              i_out = i_out+1
(  160)              txt_out(i_out:i_out) = c
(  161)           END IF
(  162)        END DO
(  163)     END IF
(  164) # 165 "stringtools.F90"
(  165)   end function remove_eol
(  166)     !  #]
(  167)   function contains_spaces(text) result(spaces_present)
(  168)     !  #[ check if any spaces are present
(  169)     character(len=*) :: text           ! input
(  170)     logical          :: spaces_present ! result
(  171)     
(  172)     ! local variable
(  173)     integer :: i






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 14

(  174) # 175 "stringtools.F90"
(  175)     ! I could also use the scan() function to do this
(  176)     spaces_present = .false. ! assume no spaces
(  177)     scanloop: DO i=1,len_trim(text)
(  178)        if (text(i:i) .eq. space) then
(  179)           spaces_present = .true.
(  180)           exit scanloop
(  181)        end if
(  182)     END DO scanloop
(  183) # 184 "stringtools.F90"
(  184)   end function contains_spaces
(  185)     !  #]
(  186)   function contains_crnl(text) result(crnl_present)
(  187)     !  #[ check if a cr and/or newline character is present
(  188)     character(len=*) :: text          ! input
(  189)     logical          :: crnl_present ! result
(  190)     
(  191)     ! local variable
(  192)     integer :: i
(  193) # 194 "stringtools.F90"
(  194)     ! I could also use the scan() function to do this
(  195)     crnl_present = .false. ! assume no cr/nl characters
(  196)     scanloop: DO i=1,len_trim(text)
(  197)        if ( (text(i:i) .eq. newline) .or. &
(  198)             (text(i:i) .eq. retchar)      ) then
(  199)           crnl_present = .true.
(  200)           exit scanloop
(  201)        end if
(  202)     END DO scanloop
(  203) # 204 "stringtools.F90"
(  204)   end function contains_crnl
(  205)     !  #]
(  206)   function write_complex_number(c) result(c_string)
(  207)     !  #[
(  208)     ! REMARK: the L2BP difftool recognises only complex numbers that have
(  209)     ! the shape (a,b) without any spaces within the brackets. Most compilers
(  210)     ! use this form. However, the gfortran compiler is an exception, because
(  211)     ! it does write some extra spaces inside the brackets. Therefore the 
(  212)     ! following Write_Complex_Number() function was added. 
(  213)     ! For the moment the TestArraytools program is the only one in the L2BP
(  214)     ! that actually prints complex numbers. 
(  215)     ! Note that also the module RayleighBrillouinProcessing/tentispectrum.F90
(  216)     ! uses complex numbers, but these are not printed.
(  217)     ! JK, 8-6-2006
(  218) # 219 "stringtools.F90"
(  219)     complex(r8_), intent(in) :: c        ! input
(  220)     character(len=100)       :: c_string ! result
(  221) # 222 "stringtools.F90"
(  222)     ! local variables
(  223)     character(len=1), parameter :: space = ' '
(  224)     character(len=100) :: tmp_string
(  225)     integer            :: i,j
(  226) # 227 "stringtools.F90"
(  227)     ! init
(  228)     c_string(:)   = space
(  229)     tmp_string(:) = space
(  230) # 231 "stringtools.F90"
(  231)     ! convert the complex number to a string






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 15

(  232)     write(tmp_string,*,err=999) c
(  233) # 234 "stringtools.F90"
(  234)     ! remove all the spaces from the string
(  235)     j=0
(  236)     DO i=1,len_trim(tmp_string)
(  237)        IF (tmp_string(i:i) .ne. space) THEN
(  238)           j=j+1
(  239)           c_string(j:j) = tmp_string(i:i)
(  240)        END IF
(  241)     END DO
(  242) # 243 "stringtools.F90"
(  243)     ! done
(  244)     return
(  245) # 246 "stringtools.F90"
(  246)     ! warning: printing an error is not possible here, because then
(  247)     ! you cannot use this function as parameter to a print statement
(  248)     ! anymore (you will get recursive io errors)
(  249)     ! therefore just report "[conversion error]" if something is wrong...
(  250) 999 c_string = "[conversion error]"
(  251)     return
(  252) # 253 "stringtools.F90"
(  253)   end function write_complex_number
(  254)     !  #]
(  255)   subroutine Split_on_first_delimiter(text_in, delimiter, part1, part2)
(  256)     !  #[
(  257)     character(len=*),   intent(in)  :: text_in
(  258)     character(len=1),   intent(in)  :: delimiter
(  259)     character(len=len(text_in)), intent(out) :: part1
(  260)     character(len=len(text_in)), intent(out) :: part2
(  261)     
(  262)     ! local variables
(  263)     integer :: i, delimiter_pos, length
(  264) # 265 "stringtools.F90"
(  265)     part1(:) = ' '
(  266)     part2(:) = ' '
(  267)     
(  268)     ! find the first occurrence of delimiter
(  269)     delimiter_pos = -1
(  270)     length = len_trim(text_in)
(  271)     searchloop: do i=1,length
(  272)        if (text_in(i:i) .eq. delimiter) then
(  273)           delimiter_pos=i
(  274)           exit searchloop
(  275)        end if
(  276)     end do searchloop
(  277)     
(  278)     if (delimiter_pos .eq. -1) then
(  279)        part1 = trim(adjustl(text_in))
(  280)        return
(  281)     else
(  282)        part1 = trim(adjustl(text_in(1:delimiter_pos)))
(  283)        part2 = trim(adjustl(text_in(delimiter_pos+1:length)))
(  284)     end if
(  285)     
(  286)   end subroutine Split_on_first_delimiter
(  287)     !  #]
(  288)   subroutine Split_on_first_space(text_in, part1, part2)
(  289)     !  #[






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 16

(  290)     character(len=*),   intent(in)  :: text_in
(  291)     character(len=len(text_in)), intent(out) :: part1
(  292)     character(len=len(text_in)), intent(out) :: part2
(  293)     
(  294)     call Split_on_first_delimiter(text_in, ' ', part1, part2)
(  295)     
(  296)   end subroutine Split_on_first_space
(  297)     !  #]
(  298)   subroutine Split_path_and_filename(path_and_filename,path,filename)
(  299)     !  #[
(  300)     character(len=*),   intent(in)  :: path_and_filename
(  301)     character(len=256), intent(out) :: path
(  302)     character(len=256), intent(out) :: filename
(  303)     
(  304)     ! method: assume we are on a 1/1 like system, so just find
(  305)     ! the last slash and split the string at that point
(  306)     ! (or if no slashes are present, assume path is empty and just
(  307)     ! return the filename)
(  308)     ! NOTE: if we have to be compatible with windows (hope that will
(  309)     ! never happen), then we need to check backslashes .....
(  310) # 311 "stringtools.F90"
(  311)     ! local variables
(  312)     integer :: i, slash_pos, length
(  313) # 314 "stringtools.F90"
(  314)     path(:)     = ' '
(  315)     filename(:) = ' '
(  316) # 317 "stringtools.F90"
(  317)     ! find the last slash
(  318)     slash_pos = -1
(  319)     length = len_trim(path_and_filename)
(  320)     do i=1,length
(  321)        if (path_and_filename(i:i) .eq. '/') slash_pos=i
(  322)     end do
(  323) # 324 "stringtools.F90"
(  324)     if (slash_pos .eq. -1) then
(  325)        filename = path_and_filename
(  326)        return
(  327)     else
(  328)        path     = path_and_filename(1:slash_pos)
(  329)        filename = path_and_filename(slash_pos+1:length)
(  330)     end if
(  331)     
(  332)   end subroutine Split_path_and_filename
(  333)     !  #]
(  334)   function Join_path_and_filename(path,filename) result(path_and_filename)
(  335)     !  #[
(  336)     character(len=*), intent(in) :: path
(  337)     character(len=*), intent(in) :: filename
(  338)     character(len=len(path)+len(filename)+1) :: path_and_filename ! result
(  339) ! WARNING:
(  340) ! the following line DOES NOT work properly when compiled with the ifort
(  341) ! compiler (version 8.1). Later versions seem to have fixed this bug, but
(  342) ! since I have 8.1 installed, please don't use len_trim() to determine
(  343) ! the size of function results for the moment .....
(  344) !    character(len=len_trim(path)+len_trim(filename)+1) :: path_and_filename ! result
(  345)     
(  346)     ! method: assume we are on a 1/1 like system, so glue path and
(  347)     ! filename using a slash.






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 17

(  348)     ! NOTE: if we have to be compatible with windows (hope that will
(  349)     ! never happen), then we need to add a backslash .....
(  350) # 351 "stringtools.F90"
(  351)     path_and_filename(:)     = ' '
(  352) # 353 "stringtools.F90"
(  353)     if (len_trim(path) .eq. 0) then
(  354)        ! no path to add, so just return the filename
(  355)        path_and_filename = filename
(  356)     else
(  357)        if (path(len_trim(path):len_trim(path)) .eq. '/') then
(  358) !print *,"test inside: [",trim(path),"]"
(  359) !print *,"test inside: [",trim(filename),"]"
(  360)           ! the path already ends with a slash, so it doesn't need to be added
(  361)           path_and_filename = trim(path)//trim(filename)
(  362) !print *,"test inside: [",trim(path_and_filename),"]"
(  363) !print *,"test inside: len=",len_trim(path)+len_trim(filename)+1
(  364)        else
(  365)           ! add a slash in between path and filename
(  366)           path_and_filename = trim(path)//'/'//trim(filename)
(  367)        end if
(  368)     end if
(  369) # 370 "stringtools.F90"
(  370)     return
(  371) # 372 "stringtools.F90"
(  372)   end function Join_path_and_filename
(  373)     !  #]
(  374)   subroutine Split_filename_and_extension(path_filename_and_extension,&
(  375)                                           path_and_filename,extension)
(  376)     !  #[
(  377)     character(len=*),   intent(in)  :: path_filename_and_extension
(  378)     character(len=256), intent(out) :: path_and_filename
(  379)     character(len=256), intent(out) :: extension
(  380)     
(  381)     ! Method: find the last dot and split the string at that point
(  382)     ! (or if no dots are present, assume there is no extension).
(  383)     ! A path might be present, which needs to be removed before inspecting
(  384)     ! the filename, because it is legal to have dots in directory names,
(  385)     ! which will otherwise confuse this algorithm.
(  386)     ! Exception: if the only dot in the filename is at the first character, 
(  387)     ! the file is a hidden 1/1 file, and no extension is present.
(  388) # 389 "stringtools.F90"
(  389)     ! local variable
(  390)     integer :: i, dot_pos, length
(  391)     character(len=256) :: path
(  392)     character(len=256) :: filename
(  393)     character(len=256) :: filename_and_extension
(  394) # 395 "stringtools.F90"
(  395)     ! init
(  396)     path(:)                   = ' '
(  397)     filename(:)               = ' '
(  398)     filename_and_extension(:) = ' '
(  399)     extension(:)              = ' '
(  400)     path_and_filename(:)      = ' '
(  401) # 403 "stringtools.F90"
(  403)     ! first remove a path, which might be prepended
(  404)     ! this is needed, because a pathname may contain dots, which do NOT
(  405)     ! indicate the start of an extension, and which will confuse
(  406)     ! the simple search below for files without an extension....






NVFORTRAN (Version     23.1)          02/24/2023  13:46:10      page 18

(  407)     call Split_path_and_filename(path_filename_and_extension,&
(  408)                                  path,filename_and_extension)
(  409) # 410 "stringtools.F90"
(  410)     ! find the last dot
(  411)     dot_pos = -1
(  412)     length = len_trim(filename_and_extension)
(  413)     do i=1,length
(  414)        if (filename_and_extension(i:i) .eq. '.') dot_pos=i
(  415)     end do
(  416) # 417 "stringtools.F90"
(  417)     if (dot_pos .eq. -1) then
(  418)        ! no dots where present in the filename
(  419)        path_and_filename = path_filename_and_extension
(  420)        return
(  421)     else
(  422)        if (dot_pos .eq.1) then
(  423)           ! the last and only  dot is found at pos 1.
(  424)           ! These are the hidden files in 1/1
(  425)           path_and_filename = path_filename_and_extension
(  426)           return
(  427)        else
(  428)           filename  = filename_and_extension(1:dot_pos-1)
(  429)           extension = filename_and_extension(dot_pos+1:length)
(  430)           ! finally, combine the filename again with the path
(  431)           ! before reporting the result
(  432)           path_and_filename = Join_path_and_filename(path,filename)
(  433)           return
(  434)        end if
(  435)     end if
(  436)     
(  437)   end subroutine Split_filename_and_extension
(  438)     !  #]
(  439)   !--------------------------------------------
(  440) end module StringTools
