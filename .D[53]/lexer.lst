


NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: lexer.F90

(    1) ! NOTE:
(    2) !    this lexer code is only used by:
(    3) !    L2C_construction/append_l2c.F90
(    4) !    which is a local ECMWF module, not used by or needed by
(    5) !    the actual L2B_processor code.
(    6) !    For this reason the TestLexer.F90 program is not compiled
(    7) !    by default and not tested by the test suite.
(    8) 
(    9) ! ============================================================================
(   10) !
(   11) ! lexer - transforming ascii stream into tokens.
(   12) !
(   13) !   use lexer
(   14) !
(   15) !   type(lexer_type) :: s
(   16) !
(   17) !   lexer_init (s, unit)    -- initialize lexer; input will be read from unit
(   18) !
(   19) !   lexer_gettoken (s)      -- get next token from the input stream;
(   20) !                              token is stored in s%token, token value in
(   21) !                              s%cval, s%rval, s%ival or s%sval
(   22) !   lexer_ungettoken (s)    -- return token read with lexer_gettoken() back to the stream
(   23) !
(   24) !   See also PUBLIC section of lexer_type definition for
(   25) !   other interface elements;
(   26) !
(   27) ! 27-Aug-2005  B.Krzeminski   initial version.
(   28) ! 22-Jun-2010  B.Krzeminski   Adapted for ADM Aeolus L2C Processor
(   29) ! 02-Dec-2010  J. de Kloe     make one int-to-real conversion explicit
(   30) ! 04-Feb-2011  M. Rennie      Added use Parkindl






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 3

(   31) ! 13-Apr-2012  J. de Kloe     implement a workarount for rfmt(s%toklen) as
(   32) !                             suggested by Christophe Payan to circumvent a
(   33) !                             gfortran bug in older versions (see his email 3-Apr-2012)
(   34) !
(   35) ! ============================================================================
(   36) 
(   37) 
(   38) module lexer
(   39) 
(   40) 
(   41)   implicit none
(   42) 
(   43)   save
(   44) 
(   45)   public :: lexer_type
(   46)  
(   47)   ! subroutines
(   48)   public :: lexer_init
(   49)   public :: lexer_gettoken
(   50)   public :: lexer_ungettoken
(   51) 
(   52)   ! tokens
(   53)   public :: tok_int
(   54)   public :: tok_real
(   55)   public :: tok_word
(   56)   public :: tok_string
(   57)   public :: tok_newline
(   58)   public :: tok_eof
(   59) 
(   60)   ! character types
(   61)   public :: ctype_skip
(   62)   public :: ctype_symb
(   63)   public :: ctype_word
(   64)   public :: ctype_strd
(   65)   ! convenience subroutine
(   66)   public :: lexer_modify_ctype
(   67) 
(   68)   ! error codes
(   69)   public :: lexer_err_quote
(   70)   public :: lexer_err_eof
(   71)   public :: lexer_err_ioerr
(   72) 
(   73)   ! array of error messages
(   74)   public :: lexer_err_msg
(   75)  
(   76) 
(   77) 
(   78)   private
(   79) 
(   80) 
(   81)   ! tokens
(   82)   integer,parameter :: &
(   83)       tok_null    =  9999  ,& !token is undefined
(   84)       tok_int     =  1000  ,& !integer
(   85)       tok_real    =  1001  ,& !real
(   86)       tok_word    =  1003  ,& !word
(   87)       tok_string  =  1004  ,& !quoted string
(   88)       tok_newline =  10    ,& !new line






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 4

(   89)       tok_eof     =  128      !end of file
(   90) 
(   91)  
(   92) 
(   93)   ! character types
(   94)   integer, parameter :: &
(   95)       ctype_symb  = 0      ,& !translates to a single-character token
(   96)       ctype_word  = 1      ,& !part of a 'word'
(   97)       ctype_comm  = 2      ,& !comment
(   98)       ctype_strd  = 3      ,& !string delimiter
(   99)       ctype_skip  = 4         !ignored character
(  100) 
(  101) 
(  102)  
(  103) 
(  104)   ! error codes for the lexer_XXXX() subroutines (s%err)
(  105)   integer, parameter ::   &
(  106)     lexer_err_quote = 1  ,&   !missing closing quote for string
(  107)     lexer_err_eof   = 2  ,&   !unexpected end of file (do we need that?)
(  108)     lexer_err_ioerr = 3       !I/O error (error code is in lexer%iostat)
(  109) 
(  110) 
(  111) 
(  112)   ! error messages
(  113)   character(len=22), parameter :: lexer_err_msg(1:3) = (/ &
(  114)     'unterminated string   ',        &
(  115)     'unexpected end of file',        &
(  116)     'error reading input   '         &
(  117)   /)
(  118) 
(  119) 
(  120) 
(  121)   character(len=7), parameter :: ascii(0:128) = (/ &   !based on www.asciitable.com
(  122)   '<NUL>  ','<SOH>  ','<STX>  ','<ETX>  ','<EOT>  ','<ENQ>  ','<ACK>  ','<BEL>  ',&
(  123)   '<BS>   ','<TAB>  ','<NEWLN>','<VT>   ','<FF>   ','<CR>   ','<SO>   ','<SI>   ',&
(  124)   '<DLE>  ','<DC1>  ','<DC2>  ','<DC3>  ','<DC4>  ','<NAK>  ','<SYN>  ','<ETB>  ',&
(  125)   '<CAN>  ','<EM>   ','<SUB>  ','<ESC>  ','<FS>   ','<GS>   ','<RS>   ','<US>   ',&
(  126)   '<SPACE>','!      ','"      ','#      ','$      ','%      ','&      ',"'      ",&
(  127)   '(      ',')      ','*      ','+      ',',      ','-      ','.      ','/      ',&
(  128)   '0      ','1      ','2      ','3      ','4      ','5      ','6      ','7      ',&
(  129)   '8      ','9      ',':      ',';      ','<      ','=      ','>      ','?      ',&
(  130)   '@      ','A      ','B      ','C      ','D      ','E      ','F      ','G      ',&
(  131)   'H      ','I      ','J      ','K      ','L      ','M      ','N      ','O      ',&
(  132)   'P      ','Q      ','R      ','S      ','T      ','U      ','V      ','W      ',&
(  133)   'X      ','Y      ','Z      ','[      ','       ',']      ','^      ','_      ',&
(  134)   '`      ','a      ','b      ','c      ','d      ','e      ','f      ','g      ',&
(  135)   'h      ','i      ','j      ','k      ','l      ','m      ','n      ','o      ',&
(  136)   'p      ','q      ','r      ','s      ','t      ','u      ','v      ','w      ',&
(  137)   'x      ','y      ','z      ','{      ','|      ','}      ','~      ','<DEL>  ',&
(  138)   '<EOF>  '/) !<--- not really an ASCII code!
(  139) 
(  140)   !NOTE:backslash is missing from the table as xlf90 compiler complained about it.
(  141)   !Instead, backslash is treated in a special way in lexer_gettoken()
(  142) 
(  143) 
(  144)   !lookup table for real number format strings
(  145)   character(len=8) :: rfmt(80)
(  146)   character(len=8) :: rmft_current






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 5

(  147) 
(  148)   !lookup table for integer format strings
(  149)   character(len=4) :: ifmt(80)
(  150) 
(  151) 
(  152) 
(  153)   ! Size of the input buffer (number of characters)
(  154)   integer,parameter :: inbuf_maxlen = 100
(  155) 
(  156)   ! Maximum length of a token
(  157)   integer,parameter :: tok_maxlen = 80
(  158)   ! Maximum length of a string
(  159)   integer,parameter :: str_maxlen = 1024
(  160)  
(  161)   ! format string for reading data into buffer
(  162)   character(len=32) :: inbuf_fmt
(  163) 
(  164) 
(  165) 
(  166)   type lexer_type
(  167) 
(  168)     ! PUBLIC --------------------------------------------------------
(  169) 
(  170)     integer                      :: token  !last token read with lexer_gettoken()
(  171)     character(len=tok_maxlen)    :: cval   !character value of the token
(  172)     integer                      :: ival   !integer value of the token
(  173)     real                         :: rval   !real value of the token
(  174)     character(len=str_maxlen)    :: sval   !string value of the token (for quoted strings)
(  175)     integer,dimension(tok_maxlen):: ascii  !token as an array of ascii codes
(  176)     integer                      :: toklen !length of the token (number of characters)
(  177)     integer                      :: lineno !line number of the token
(  178)     integer                      :: column !colum number of the first character of the token
(  179)     integer                      :: funit  !unit number associated with the input
(  180)     character(len=1024)          :: path   !file path (not required by lexer.F90)
(  181)     integer                      :: err    !error status of lexer_XXXXX() calls
(  182)     integer                      :: iostat !status of readig from input
(  183) 
(  184)     ! these can be modified on-the-fly to suit input data formatting:
(  185)     integer              :: comment        !comment character(default:#)
(  186)     integer              :: ctype(0:128)   !character type lookup table
(  187) 
(  188)     ! PRIVATE --------------------------------------------------------
(  189) 
(  190)     integer              :: lastc         !last character read with getc()
(  191)     integer              :: cnum          !column number of the last read character
(  192)     integer              :: lnum          !line number of the last read character
(  193)     integer              :: ungetc        !is there some character in the 'ungetc' buffer?
(  194)     integer              :: inbuf_len     !actual number of characters in input buffer
(  195)     integer              :: inbuf_pos     !position in buffer
(  196)     logical              :: inbuf_eor_chunk !indicates if chunk contains end of record
(  197)     logical              :: get_new_chunk !
(  198)     character(len=inbuf_maxlen) :: inbuf  !buffer for input stream
(  199)     ! one-character buffer for lexer_ungettoken()
(  200)     integer              :: utoken        !token returned to the stream by lexer_ungettoken()
(  201)     character(len=tok_maxlen) :: ucval    !character representation of the token
(  202)     integer              :: uival         !integer value of the token
(  203)     real                 :: urval         !real value of the token
(  204)     character(len=str_maxlen) :: usval    !string value of the token (for quoted strings)






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 6

(  205)     integer              :: ulineno       !position of the token
(  206)     integer              :: ucolumn       !position of the token
(  207) 
(  208)   end type
(  209) 
(  210) 
(  211) 
(  212) 
(  213) 
(  214) contains
(  215) 
(  216) 
(  217) 
(  218) 
(  219) ! itialize lexer
(  220) 
(  221) subroutine lexer_init (s, unit_number)
(  222) 
(  223)   implicit none
(  224)   type(lexer_type) :: s
(  225)   integer, intent(in) :: unit_number
(  226)   character (len=3) :: s1, s2
(  227)   integer :: i
(  228) 
(  229)   s%funit      = unit_number
(  230)   s%path       = ''
(  231) 
(  232)   s%comment    = iachar('#')
(  233) 
(  234)   s%inbuf_pos  = 0
(  235)   s%inbuf_len  = 0
(  236)   write(inbuf_fmt,*) inbuf_maxlen
(  237)   inbuf_fmt    = '(a'//inbuf_fmt(2:len_trim(inbuf_fmt))//')'
(  238) 
(  239)   s%lineno     = 0
(  240)   s%column     = 0
(  241) 
(  242)   s%lnum       = 0
(  243)   s%cnum       = 0
(  244)   s%lastc      = 10
(  245)   s%ungetc     = 0
(  246) 
(  247)   s%token      = tok_null
(  248)   s%ival       = 0
(  249)   s%rval       = 0.0
(  250)   s%cval       = ''
(  251)   s%sval       = ''
(  252)  
(  253)   s%utoken     = tok_null
(  254)   s%ucval      = ''
(  255)   s%uival      = 0
(  256)   s%urval      = 0.0
(  257)   s%usval      = ''
(  258)  
(  259)   s%get_new_chunk = .false.
(  260) 
(  261)   !valid 'word' characters
(  262) 






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 7

(  263)   s%ctype = ctype_skip !initialize table of character types
(  264) 
(  265)   !REMARK: by default, +,-,. are not treated as tokens when they are
(  266)   !   inside a string of non-blank characters so that number like -12.3E+6
(  267)   !   will be treated as a single token (but an expression -12.3E+6+10.0 will
(  268)   !   be also translated to a single token of type tok_word!). In a proper lexer
(  269)   !   numbers, words, quoted strings etc. would be recognized with
(  270)   !   regular expressions.
(  271) 
(  272)   !valid 'word' characters
(  273) 
(  274)   call lexer_modify_ctype &
(  275)     (s, "+-.0123456789ABCDEFGHIJKLMNOPRSTUVWXYZabcdefghijklmnopqrstuvwxyz_", &
(  276)      ctype_word)
(  277) 
(  278)   !one-character tokens (symbols)
(  279) 
(  280)   call lexer_modify_ctype (s, '!"#$%&()*:;<=>?@[\]^`{|}~,', ctype_symb)
(  281)   s%ctype(128) = ctype_symb !<EOF>
(  282) 
(  283)   !string delimiter
(  284) 
(  285)   call lexer_modify_ctype (s, "'", ctype_strd)
(  286) 
(  287)   !all other characters will be ignored (including newline!)
(  288) 
(  289)   s%err = 0
(  290)   s%iostat = 0
(  291) 
(  292)   !fill formatting lookup tables
(  293) 
(  294)   do i = 1,80
(  295)     write(s1,'(I2)') i
(  296)     write(s2,'(I2)') i-1
(  297)     rfmt(i) = '(F' // trim(adjustl(s1)) // '.' // trim(adjustl(s2)) // ')'
(  298)     ifmt(i) = '(I' // trim(adjustl(s1)) // ')'
(  299)   enddo
(  300) 
(  301)   return
(  302) end subroutine
(  303) 
(  304) 
(  305) 
(  306) 
(  307) 
(  308) subroutine lexer_modify_ctype (s, chars, ctype)
(  309)   implicit none
(  310)   type (lexer_type) :: s
(  311)   character(len=*), intent(in) :: chars
(  312)   integer, intent(in) :: ctype
(  313)   integer :: i,slen
(  314)   slen = len(chars)
(  315)   do i = 1,slen
(  316)     s%ctype(iachar(chars(i:i))) = ctype
(  317)   enddo
(  318) end subroutine
(  319) 
(  320) 






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 8

(  321) 
(  322) ! Get one character from input.
(  323) ! Comments are converted to newlines.
(  324) ! This is very low level and heavily used
(  325) ! subroutine - tried to optimize it at a
(  326) ! cost of clarity.
(  327) 
(  328) function getc(s)
(  329)     implicit none
(  330) 
(  331)     type (lexer_type) :: s
(  332)     integer :: c, getc
(  333) 
(  334)     c=0
(  335)     getc=0
(  336)     s%get_new_chunk=.false.
(  337) 
(  338)     if (s%ungetc/=0) then                   !if buffer isn't empty..
(  339)         c=s%ungetc                          !  return buffered character
(  340)         s%ungetc=0                          !  clear buffer
(  341)         goto 400                            !  exit
(  342)     endif                                   !
(  343)     if (s%lastc==10) then                   !if '\n' was read previously...
(  344)         s%cnum=1                            !  set position to the next line
(  345)         s%lnum=s%lnum+1                     !  and
(  346)         s%get_new_chunk=.true.              !  we will read new chunk of text
(  347)     else if (s%lastc==128) then             !EOF reached last time?
(  348)         goto 300                            !  if yes, keep returning EOF.
(  349)     else                                    !else
(  350)         s%cnum=s%cnum+1                     !  move to nxt char in current line
(  351)         s%inbuf_pos=s%inbuf_pos+1           !  move forward in input buffer
(  352)         if (s%inbuf_pos==s%inbuf_len+1) then!  end of buffer ?
(  353)             if (s%inbuf_eor_chunk) then     !    if yes: last chunk in line?
(  354)                 c=10                        !      if yes: return '\n'
(  355)                 goto 400                    !      exit
(  356)             else                            !    not last chunk in line:
(  357)                 s%get_new_chunk=.true.      !      we will read new chunk.
(  358)             endif                           !
(  359)         endif                               !
(  360)     endif                                   !
(  361)     if (s%get_new_chunk) then               !  need next chunk?:
(  362)         read(s%funit, inbuf_fmt, size=s%inbuf_len, &!   yes:read next chunk of text
(  363)             advance='no', eor=100, end=300, err=500, iostat=s%iostat) s%inbuf
(  364)         s%inbuf_pos=1                       !    reset pos in input buffer
(  365)         s%inbuf_eor_chunk=.false.           !    this chunk doesn't contain end-of-record
(  366)         goto 200                            !
(  367) 100     if (s%inbuf_len==0) then            ! eor: 0 chars were read?
(  368)             c=10                            !      yes: return '\n'
(  369)             goto 400                        !      exit
(  370)         else                                !    no (1 or more chars read):
(  371)             s%inbuf_eor_chunk=.true.        !      this chunk contains eor
(  372)             s%inbuf_pos=1                   !      reset pos in input buffer
(  373)             goto 200                        !
(  374)         endif                               !
(  375)     endif                                   !
(  376)                                             !
(  377) 200 continue                                !
(  378)     c=iachar(s%inbuf(s%inbuf_pos:s%inbuf_pos)) !get next char from input buffer






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 9

(  379)     if (c==35) then                         !comment line ?:
(  380)         c=10                                !  convert it to '\n' character
(  381)         if (.not.s%inbuf_eor_chunk) then    !  skip to the next record
(  382)             read(s%funit,'(a1)',end=300, err=500, iostat=s%iostat) s%inbuf
(  383)         endif                               !
(  384)         goto 400                            !  exit
(  385)     endif                                   !
(  386)     if (c==0) then
(  387)       print *, 'getc(): internal error', s%lineno, s%column !this should never happen
(  388)       stop 1
(  389)     endif
(  390)     goto 400                                !exit
(  391) 300 c=128                                   !return end of file
(  392)     goto 400                                !exit
(  393) 400 continue                                !
(  394)     s%lastc=c                               !
(  395)     getc=c                                  !
(  396)     return                                  !
(  397) 500 continue
(  398)     s%err = lexer_err_ioerr                 ! I/O error
(  399)     return
(  400) end function
(  401) 
(  402) 
(  403) 
(  404) 
(  405) 
(  406) ! tokenizer
(  407) 
(  408) subroutine lexer_gettoken (s)
(  409)   implicit none
(  410)   type (lexer_type) :: s
(  411)   integer :: ival,i,c,ios
(  412)   real    :: rval
(  413) 
(  414)   !try to use token previously returned to the stream, if any
(  415)   if (s%utoken /= tok_null) then
(  416)     s%token  = s%utoken
(  417)     s%ival = s%uival
(  418)     s%rval = s%urval
(  419)     s%cval = s%ucval
(  420)     s%sval = s%usval
(  421)     s%utoken = tok_null
(  422)     s%lineno = s%ulineno
(  423)     s%column = s%ucolumn
(  424)     goto 200
(  425)   endif
(  426) 
(  427)   !skip to the first non-blank character
(  428) 
(  429)   do
(  430)     c=getc(s)
(  431)     if (s%ctype(c) /= ctype_skip) exit
(  432)   enddo
(  433) 
(  434)   !save location of the token's first character
(  435) 
(  436)   s%lineno = s%lnum






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 10

(  437)   s%column = s%cnum
(  438) 
(  439)   if (s%err==lexer_err_ioerr) return
(  440) 
(  441)   ! reset token value
(  442)   s%cval = ''
(  443)   s%ival = 0
(  444)   s%rval = 0.0
(  445)   s%sval = ''
(  446) 
(  447)   !quoted string?
(  448) 
(  449)   if (s%ctype(c) == ctype_strd) then
(  450)       i = 0
(  451)       strloop: do
(  452)           c = getc(s)
(  453)           if (s%ctype(c)==ctype_strd) exit
(  454)           if (c==10 .or. c==128) then
(  455)             !unterminated string
(  456)             s%err = lexer_err_quote
(  457)             return
(  458)           endif
(  459)           i=i+1
(  460)           if (i>str_maxlen) then
(  461)             s%err = lexer_err_quote
(  462)             return
(  463)           endif
(  464)           s%sval(i:i) = char(c)
(  465)       enddo strloop
(  466)       s%token = tok_string
(  467)       s%cval = '<string>'
(  468)       goto 200
(  469)   endif
(  470) 
(  471) 
(  472)   !symbol?
(  473) 
(  474)   if (s%ctype(c)==ctype_symb)  then
(  475)       s%token = c
(  476)       if (c==92) then
(  477)         s%cval = achar(92) !workaround for backslash
(  478)       else
(  479)         s%cval = ascii(c)
(  480)       endif
(  481)       s%ascii(1) = c
(  482)       goto 200
(  483)   end if
(  484) 
(  485)   s%ungetc = c
(  486) 
(  487) 
(  488)   ! get a 'word'
(  489) 
(  490)   i = 0
(  491)   do
(  492)     if (i>=tok_maxlen) then
(  493)       !silently truncate long token (TODO: return error?)
(  494)       exit






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 11

(  495)     endif
(  496)     c = getc(s)
(  497)     if (s%ctype(c) /= ctype_word) then
(  498)       s%ungetc = c
(  499)       exit
(  500)     endif
(  501)     i = i+1
(  502)     s%ascii(i) = c
(  503)     s%cval(i:i) = char(c)
(  504)   enddo
(  505)   s%toklen = i
(  506) 
(  507) 
(  508)   if (s%ascii(1) >= 43 .and. s%ascii(1) <= 57) then
(  509) 
(  510)     !may be a number
(  511) 
(  512)     do i = 1, s%toklen
(  513)       !We assume that a real number has a dot somewhere
(  514)       if (s%ascii(i) == 46) then
(  515)         !real number?
(  516)         ! the 2 step passing of rfmt(s%toklen) to the read statement
(  517)         ! is needed to circumvent a bug in older gfortran versions
(  518)         rmft_current=rfmt(s%toklen) 
(  519)         read(s%cval, rmft_current, iostat=ios) rval
(  520)         if (ios == 0) then
(  521)           s%token = tok_real
(  522)           s%rval = rval
(  523)           goto 200
(  524)         endif
(  525)         exit
(  526)       endif
(  527)     enddo
(  528) 
(  529)     !integer?
(  530) 
(  531)     read(s%cval, ifmt(s%toklen), iostat=ios) ival
(  532)     if (ios == 0) then
(  533)       s%token = tok_int
(  534)       s%ival = ival
(  535)       s%rval = real(ival)
(  536)       goto 200
(  537)     endif
(  538) 
(  539)   endif
(  540) 
(  541)   !fallback
(  542) 
(  543)   s%token = tok_word
(  544) 
(  545) 200 continue
(  546)   return
(  547) end subroutine
(  548) 
(  549) 
(  550) 
(  551) 
(  552) ! Return current token to the input stream.






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 12

(  553) ! The unget buffer can hold only one character!
(  554) !
(  555) subroutine lexer_ungettoken (s)
(  556)   implicit none
(  557)   type(lexer_type) :: s
(  558) 
(  559)   if (s%token == tok_null) then
(  560)     !this indicates incorrect use of lexer (programmer's error)
(  561)     print *, 'lexer_ungettoken(): internal error (nothing to unget!)'
(  562)     stop 1
(  563)   endif
(  564) 
(  565)   s%utoken  = s%token
(  566)   s%ucval   = s%cval
(  567)   s%uival   = s%ival
(  568)   s%urval   = s%rval
(  569)   s%usval   = s%sval
(  570)   s%ulineno = s%lineno
(  571)   s%ucolumn = s%column
(  572)   s%token   = tok_null
(  573) 
(  574)   return
(  575) end subroutine
(  576) 
(  577) 
(  578) 
(  579) end module





































NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 13

(    1) # 1 "lexer.F90"
(    1) ! NOTE:
(    2) !    this lexer code is only used by:
(    3) !    L2C_construction/append_l2c.F90
(    4) !    which is a local ECMWF module, not used by or needed by
(    5) !    the actual L2B_processor code.
(    6) !    For this reason the TestLexer.F90 program is not compiled
(    7) !    by default and not tested by the test suite.
(    8) # 9 "lexer.F90"
(    9) ! ============================================================================
(   10) !
(   11) ! lexer - transforming ascii stream into tokens.
(   12) !
(   13) !   use lexer
(   14) !
(   15) !   type(lexer_type) :: s
(   16) !
(   17) !   lexer_init (s, unit)    -- initialize lexer; input will be read from unit
(   18) !
(   19) !   lexer_gettoken (s)      -- get next token from the input stream;
(   20) !                              token is stored in s%token, token value in
(   21) !                              s%cval, s%rval, s%ival or s%sval
(   22) !   lexer_ungettoken (s)    -- return token read with lexer_gettoken() back to the stream
(   23) !
(   24) !   See also PUBLIC section of lexer_type definition for
(   25) !   other interface elements;
(   26) !
(   27) ! 27-Aug-2005  B.Krzeminski   initial version.
(   28) ! 22-Jun-2010  B.Krzeminski   Adapted for ADM Aeolus L2C Processor
(   29) ! 02-Dec-2010  J. de Kloe     make one int-to-real conversion explicit
(   30) ! 04-Feb-2011  M. Rennie      Added use Parkindl
(   31) ! 13-Apr-2012  J. de Kloe     implement a workarount for rfmt(s%toklen) as
(   32) !                             suggested by Christophe Payan to circumvent a
(   33) !                             gfortran bug in older versions (see his email 3-Apr-2012)
(   34) !
(   35) ! ============================================================================
(   36) # 38 "lexer.F90"
(   38) module lexer
(   39) # 41 "lexer.F90"
(   41)   implicit none
(   42) # 43 "lexer.F90"
(   43)   save
(   44) # 45 "lexer.F90"
(   45)   public :: lexer_type
(   46)  
(   47)   ! subroutines
(   48)   public :: lexer_init
(   49)   public :: lexer_gettoken
(   50)   public :: lexer_ungettoken
(   51) # 52 "lexer.F90"
(   52)   ! tokens
(   53)   public :: tok_int
(   54)   public :: tok_real
(   55)   public :: tok_word
(   56)   public :: tok_string
(   57)   public :: tok_newline
(   58)   public :: tok_eof
(   59) # 60 "lexer.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 14

(   60)   ! character types
(   61)   public :: ctype_skip
(   62)   public :: ctype_symb
(   63)   public :: ctype_word
(   64)   public :: ctype_strd
(   65)   ! convenience subroutine
(   66)   public :: lexer_modify_ctype
(   67) # 68 "lexer.F90"
(   68)   ! error codes
(   69)   public :: lexer_err_quote
(   70)   public :: lexer_err_eof
(   71)   public :: lexer_err_ioerr
(   72) # 73 "lexer.F90"
(   73)   ! array of error messages
(   74)   public :: lexer_err_msg
(   75)  
(   76) # 78 "lexer.F90"
(   78)   private
(   79) # 81 "lexer.F90"
(   81)   ! tokens
(   82)   integer,parameter :: &
(   83)       tok_null    =  9999  ,& !token is undefined
(   84)       tok_int     =  1000  ,& !integer
(   85)       tok_real    =  1001  ,& !real
(   86)       tok_word    =  1003  ,& !word
(   87)       tok_string  =  1004  ,& !quoted string
(   88)       tok_newline =  10    ,& !new line
(   89)       tok_eof     =  128      !end of file
(   90) # 91 "lexer.F90"
(   91)  
(   92) # 93 "lexer.F90"
(   93)   ! character types
(   94)   integer, parameter :: &
(   95)       ctype_symb  = 0      ,& !translates to a single-character token
(   96)       ctype_word  = 1      ,& !part of a 'word'
(   97)       ctype_comm  = 2      ,& !comment
(   98)       ctype_strd  = 3      ,& !string delimiter
(   99)       ctype_skip  = 4         !ignored character
(  100) # 102 "lexer.F90"
(  102)  
(  103) # 104 "lexer.F90"
(  104)   ! error codes for the lexer_XXXX() subroutines (s%err)
(  105)   integer, parameter ::   &
(  106)     lexer_err_quote = 1  ,&   !missing closing quote for string
(  107)     lexer_err_eof   = 2  ,&   !unexpected end of file (do we need that?)
(  108)     lexer_err_ioerr = 3       !I/O error (error code is in lexer%iostat)
(  109) # 112 "lexer.F90"
(  112)   ! error messages
(  113)   character(len=22), parameter :: lexer_err_msg(1:3) = (/ &
(  114)     'unterminated string   ',        &
(  115)     'unexpected end of file',        &
(  116)     'error reading input   '         &
(  117)   /)
(  118) # 121 "lexer.F90"
(  121)   character(len=7), parameter :: ascii(0:128) = (/ &   !based on www.asciitable.com
(  122)   '<NUL>  ','<SOH>  ','<STX>  ','<ETX>  ','<EOT>  ','<ENQ>  ','<ACK>  ','<BEL>  ',&
(  123)   '<BS>   ','<TAB>  ','<NEWLN>','<VT>   ','<FF>   ','<CR>   ','<SO>   ','<SI>   ',&
(  124)   '<DLE>  ','<DC1>  ','<DC2>  ','<DC3>  ','<DC4>  ','<NAK>  ','<SYN>  ','<ETB>  ',&






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 15

(  125)   '<CAN>  ','<EM>   ','<SUB>  ','<ESC>  ','<FS>   ','<GS>   ','<RS>   ','<US>   ',&
(  126)   '<SPACE>','!      ','"      ','#      ','$      ','%      ','&      ',"'      ",&
(  127)   '(      ',')      ','*      ','+      ',',      ','-      ','.      ','/      ',&
(  128)   '0      ','1      ','2      ','3      ','4      ','5      ','6      ','7      ',&
(  129)   '8      ','9      ',':      ',';      ','<      ','=      ','>      ','?      ',&
(  130)   '@      ','A      ','B      ','C      ','D      ','E      ','F      ','G      ',&
(  131)   'H      ','I      ','J      ','K      ','L      ','M      ','N      ','O      ',&
(  132)   'P      ','Q      ','R      ','S      ','T      ','U      ','V      ','W      ',&
(  133)   'X      ','Y      ','Z      ','[      ','       ',']      ','^      ','_      ',&
(  134)   '`      ','a      ','b      ','c      ','d      ','e      ','f      ','g      ',&
(  135)   'h      ','i      ','j      ','k      ','l      ','m      ','n      ','o      ',&
(  136)   'p      ','q      ','r      ','s      ','t      ','u      ','v      ','w      ',&
(  137)   'x      ','y      ','z      ','{      ','|      ','}      ','~      ','<DEL>  ',&
(  138)   '<EOF>  '/) !<--- not really an ASCII code!
(  139) # 140 "lexer.F90"
(  140)   !NOTE:backslash is missing from the table as xlf90 compiler complained about it.
(  141)   !Instead, backslash is treated in a special way in lexer_gettoken()
(  142) # 144 "lexer.F90"
(  144)   !lookup table for real number format strings
(  145)   character(len=8) :: rfmt(80)
(  146)   character(len=8) :: rmft_current
(  147) # 148 "lexer.F90"
(  148)   !lookup table for integer format strings
(  149)   character(len=4) :: ifmt(80)
(  150) # 153 "lexer.F90"
(  153)   ! Size of the input buffer (number of characters)
(  154)   integer,parameter :: inbuf_maxlen = 100
(  155) # 156 "lexer.F90"
(  156)   ! Maximum length of a token
(  157)   integer,parameter :: tok_maxlen = 80
(  158)   ! Maximum length of a string
(  159)   integer,parameter :: str_maxlen = 1024
(  160)  
(  161)   ! format string for reading data into buffer
(  162)   character(len=32) :: inbuf_fmt
(  163) # 166 "lexer.F90"
(  166)   type lexer_type
(  167) # 168 "lexer.F90"
(  168)     ! PUBLIC --------------------------------------------------------
(  169) # 170 "lexer.F90"
(  170)     integer                      :: token  !last token read with lexer_gettoken()
(  171)     character(len=tok_maxlen)    :: cval   !character value of the token
(  172)     integer                      :: ival   !integer value of the token
(  173)     real                         :: rval   !real value of the token
(  174)     character(len=str_maxlen)    :: sval   !string value of the token (for quoted strings)
(  175)     integer,dimension(tok_maxlen):: ascii  !token as an array of ascii codes
(  176)     integer                      :: toklen !length of the token (number of characters)
(  177)     integer                      :: lineno !line number of the token
(  178)     integer                      :: column !colum number of the first character of the token
(  179)     integer                      :: funit  !unit number associated with the input
(  180)     character(len=1024)          :: path   !file path (not required by lexer.F90)
(  181)     integer                      :: err    !error status of lexer_XXXXX() calls
(  182)     integer                      :: iostat !status of readig from input
(  183) # 184 "lexer.F90"
(  184)     ! these can be modified on-the-fly to suit input data formatting:
(  185)     integer              :: comment        !comment character(default:#)
(  186)     integer              :: ctype(0:128)   !character type lookup table
(  187) # 188 "lexer.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 16

(  188)     ! PRIVATE --------------------------------------------------------
(  189) # 190 "lexer.F90"
(  190)     integer              :: lastc         !last character read with getc()
(  191)     integer              :: cnum          !column number of the last read character
(  192)     integer              :: lnum          !line number of the last read character
(  193)     integer              :: ungetc        !is there some character in the 'ungetc' buffer?
(  194)     integer              :: inbuf_len     !actual number of characters in input buffer
(  195)     integer              :: inbuf_pos     !position in buffer
(  196)     logical              :: inbuf_eor_chunk !indicates if chunk contains end of record
(  197)     logical              :: get_new_chunk !
(  198)     character(len=inbuf_maxlen) :: inbuf  !buffer for input stream
(  199)     ! one-character buffer for lexer_ungettoken()
(  200)     integer              :: utoken        !token returned to the stream by lexer_ungettoken()
(  201)     character(len=tok_maxlen) :: ucval    !character representation of the token
(  202)     integer              :: uival         !integer value of the token
(  203)     real                 :: urval         !real value of the token
(  204)     character(len=str_maxlen) :: usval    !string value of the token (for quoted strings)
(  205)     integer              :: ulineno       !position of the token
(  206)     integer              :: ucolumn       !position of the token
(  207) # 208 "lexer.F90"
(  208)   end type
(  209) # 214 "lexer.F90"
(  214) contains
(  215) # 219 "lexer.F90"
(  219) ! itialize lexer
(  220) # 221 "lexer.F90"
(  221) subroutine lexer_init (s, unit_number)
(  222) # 223 "lexer.F90"
(  223)   implicit none
(  224)   type(lexer_type) :: s
(  225)   integer, intent(in) :: unit_number
(  226)   character (len=3) :: s1, s2
(  227)   integer :: i
(  228) # 229 "lexer.F90"
(  229)   s%funit      = unit_number
(  230)   s%path       = ''
(  231) # 232 "lexer.F90"
(  232)   s%comment    = iachar('#')
(  233) # 234 "lexer.F90"
(  234)   s%inbuf_pos  = 0
(  235)   s%inbuf_len  = 0
(  236)   write(inbuf_fmt,*) inbuf_maxlen
(  237)   inbuf_fmt    = '(a'//inbuf_fmt(2:len_trim(inbuf_fmt))//')'
(  238) # 239 "lexer.F90"
(  239)   s%lineno     = 0
(  240)   s%column     = 0
(  241) # 242 "lexer.F90"
(  242)   s%lnum       = 0
(  243)   s%cnum       = 0
(  244)   s%lastc      = 10
(  245)   s%ungetc     = 0
(  246) # 247 "lexer.F90"
(  247)   s%token      = tok_null
(  248)   s%ival       = 0
(  249)   s%rval       = 0.0
(  250)   s%cval       = ''
(  251)   s%sval       = ''
(  252)  






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 17

(  253)   s%utoken     = tok_null
(  254)   s%ucval      = ''
(  255)   s%uival      = 0
(  256)   s%urval      = 0.0
(  257)   s%usval      = ''
(  258)  
(  259)   s%get_new_chunk = .false.
(  260) # 261 "lexer.F90"
(  261)   !valid 'word' characters
(  262) # 263 "lexer.F90"
(  263)   s%ctype = ctype_skip !initialize table of character types
(  264) # 265 "lexer.F90"
(  265)   !REMARK: by default, +,-,. are not treated as tokens when they are
(  266)   !   inside a string of non-blank characters so that number like -12.3E+6
(  267)   !   will be treated as a single token (but an expression -12.3E+6+10.0 will
(  268)   !   be also translated to a single token of type tok_word!). In a proper lexer
(  269)   !   numbers, words, quoted strings etc. would be recognized with
(  270)   !   regular expressions.
(  271) # 272 "lexer.F90"
(  272)   !valid 'word' characters
(  273) # 274 "lexer.F90"
(  274)   call lexer_modify_ctype &
(  275)     (s, "+-.0123456789ABCDEFGHIJKLMNOPRSTUVWXYZabcdefghijklmnopqrstuvwxyz_", &
(  276)      ctype_word)
(  277) # 278 "lexer.F90"
(  278)   !one-character tokens (symbols)
(  279) # 280 "lexer.F90"
(  280)   call lexer_modify_ctype (s, '!"#$%&()*:;<=>?@[\]^`{|}~,', ctype_symb)
(  281)   s%ctype(128) = ctype_symb !<EOF>
(  282) # 283 "lexer.F90"
(  283)   !string delimiter
(  284) # 285 "lexer.F90"
(  285)   call lexer_modify_ctype (s, "'", ctype_strd)
(  286) # 287 "lexer.F90"
(  287)   !all other characters will be ignored (including newline!)
(  288) # 289 "lexer.F90"
(  289)   s%err = 0
(  290)   s%iostat = 0
(  291) # 292 "lexer.F90"
(  292)   !fill formatting lookup tables
(  293) # 294 "lexer.F90"
(  294)   do i = 1,80
(  295)     write(s1,'(I2)') i
(  296)     write(s2,'(I2)') i-1
(  297)     rfmt(i) = '(F' // trim(adjustl(s1)) // '.' // trim(adjustl(s2)) // ')'
(  298)     ifmt(i) = '(I' // trim(adjustl(s1)) // ')'
(  299)   enddo
(  300) # 301 "lexer.F90"
(  301)   return
(  302) end subroutine
(  303) # 308 "lexer.F90"
(  308) subroutine lexer_modify_ctype (s, chars, ctype)
(  309)   implicit none
(  310)   type (lexer_type) :: s
(  311)   character(len=*), intent(in) :: chars
(  312)   integer, intent(in) :: ctype
(  313)   integer :: i,slen
(  314)   slen = len(chars)






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 18

(  315)   do i = 1,slen
(  316)     s%ctype(iachar(chars(i:i))) = ctype
(  317)   enddo
(  318) end subroutine
(  319) # 322 "lexer.F90"
(  322) ! Get one character from input.
(  323) ! Comments are converted to newlines.
(  324) ! This is very low level and heavily used
(  325) ! subroutine - tried to optimize it at a
(  326) ! cost of clarity.
(  327) # 328 "lexer.F90"
(  328) function getc(s)
(  329)     implicit none
(  330) # 331 "lexer.F90"
(  331)     type (lexer_type) :: s
(  332)     integer :: c, getc
(  333) # 334 "lexer.F90"
(  334)     c=0
(  335)     getc=0
(  336)     s%get_new_chunk=.false.
(  337) # 338 "lexer.F90"
(  338)     if (s%ungetc/=0) then                   !if buffer isn't empty..
(  339)         c=s%ungetc                          !  return buffered character
(  340)         s%ungetc=0                          !  clear buffer
(  341)         goto 400                            !  exit
(  342)     endif                                   !
(  343)     if (s%lastc==10) then                   !if '\n' was read previously...
(  344)         s%cnum=1                            !  set position to the next line
(  345)         s%lnum=s%lnum+1                     !  and
(  346)         s%get_new_chunk=.true.              !  we will read new chunk of text
(  347)     else if (s%lastc==128) then             !EOF reached last time?
(  348)         goto 300                            !  if yes, keep returning EOF.
(  349)     else                                    !else
(  350)         s%cnum=s%cnum+1                     !  move to nxt char in current line
(  351)         s%inbuf_pos=s%inbuf_pos+1           !  move forward in input buffer
(  352)         if (s%inbuf_pos==s%inbuf_len+1) then!  end of buffer ?
(  353)             if (s%inbuf_eor_chunk) then     !    if yes: last chunk in line?
(  354)                 c=10                        !      if yes: return '\n'
(  355)                 goto 400                    !      exit
(  356)             else                            !    not last chunk in line:
(  357)                 s%get_new_chunk=.true.      !      we will read new chunk.
(  358)             endif                           !
(  359)         endif                               !
(  360)     endif                                   !
(  361)     if (s%get_new_chunk) then               !  need next chunk?:
(  362)         read(s%funit, inbuf_fmt, size=s%inbuf_len, &!   yes:read next chunk of text
(  363)             advance='no', eor=100, end=300, err=500, iostat=s%iostat) s%inbuf
(  364)         s%inbuf_pos=1                       !    reset pos in input buffer
(  365)         s%inbuf_eor_chunk=.false.           !    this chunk doesn't contain end-of-record
(  366)         goto 200                            !
(  367) 100     if (s%inbuf_len==0) then            ! eor: 0 chars were read?
(  368)             c=10                            !      yes: return '\n'
(  369)             goto 400                        !      exit
(  370)         else                                !    no (1 or more chars read):
(  371)             s%inbuf_eor_chunk=.true.        !      this chunk contains eor
(  372)             s%inbuf_pos=1                   !      reset pos in input buffer
(  373)             goto 200                        !
(  374)         endif                               !






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 19

(  375)     endif                                   !
(  376)                                             !
(  377) 200 continue                                !
(  378)     c=iachar(s%inbuf(s%inbuf_pos:s%inbuf_pos)) !get next char from input buffer
(  379)     if (c==35) then                         !comment line ?:
(  380)         c=10                                !  convert it to '\n' character
(  381)         if (.not.s%inbuf_eor_chunk) then    !  skip to the next record
(  382)             read(s%funit,'(a1)',end=300, err=500, iostat=s%iostat) s%inbuf
(  383)         endif                               !
(  384)         goto 400                            !  exit
(  385)     endif                                   !
(  386)     if (c==0) then
(  387)       print *, 'getc(): internal error', s%lineno, s%column !this should never happen
(  388)       stop 1
(  389)     endif
(  390)     goto 400                                !exit
(  391) 300 c=128                                   !return end of file
(  392)     goto 400                                !exit
(  393) 400 continue                                !
(  394)     s%lastc=c                               !
(  395)     getc=c                                  !
(  396)     return                                  !
(  397) 500 continue
(  398)     s%err = lexer_err_ioerr                 ! I/O error
(  399)     return
(  400) end function
(  401) # 406 "lexer.F90"
(  406) ! tokenizer
(  407) # 408 "lexer.F90"
(  408) subroutine lexer_gettoken (s)
(  409)   implicit none
(  410)   type (lexer_type) :: s
(  411)   integer :: ival,i,c,ios
(  412)   real    :: rval
(  413) # 414 "lexer.F90"
(  414)   !try to use token previously returned to the stream, if any
(  415)   if (s%utoken /= tok_null) then
(  416)     s%token  = s%utoken
(  417)     s%ival = s%uival
(  418)     s%rval = s%urval
(  419)     s%cval = s%ucval
(  420)     s%sval = s%usval
(  421)     s%utoken = tok_null
(  422)     s%lineno = s%ulineno
(  423)     s%column = s%ucolumn
(  424)     goto 200
(  425)   endif
(  426) # 427 "lexer.F90"
(  427)   !skip to the first non-blank character
(  428) # 429 "lexer.F90"
(  429)   do
(  430)     c=getc(s)
(  431)     if (s%ctype(c) /= ctype_skip) exit
(  432)   enddo
(  433) # 434 "lexer.F90"
(  434)   !save location of the token's first character
(  435) # 436 "lexer.F90"
(  436)   s%lineno = s%lnum






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 20

(  437)   s%column = s%cnum
(  438) # 439 "lexer.F90"
(  439)   if (s%err==lexer_err_ioerr) return
(  440) # 441 "lexer.F90"
(  441)   ! reset token value
(  442)   s%cval = ''
(  443)   s%ival = 0
(  444)   s%rval = 0.0
(  445)   s%sval = ''
(  446) # 447 "lexer.F90"
(  447)   !quoted string?
(  448) # 449 "lexer.F90"
(  449)   if (s%ctype(c) == ctype_strd) then
(  450)       i = 0
(  451)       strloop: do
(  452)           c = getc(s)
(  453)           if (s%ctype(c)==ctype_strd) exit
(  454)           if (c==10 .or. c==128) then
(  455)             !unterminated string
(  456)             s%err = lexer_err_quote
(  457)             return
(  458)           endif
(  459)           i=i+1
(  460)           if (i>str_maxlen) then
(  461)             s%err = lexer_err_quote
(  462)             return
(  463)           endif
(  464)           s%sval(i:i) = char(c)
(  465)       enddo strloop
(  466)       s%token = tok_string
(  467)       s%cval = '<string>'
(  468)       goto 200
(  469)   endif
(  470) # 472 "lexer.F90"
(  472)   !symbol?
(  473) # 474 "lexer.F90"
(  474)   if (s%ctype(c)==ctype_symb)  then
(  475)       s%token = c
(  476)       if (c==92) then
(  477)         s%cval = achar(92) !workaround for backslash
(  478)       else
(  479)         s%cval = ascii(c)
(  480)       endif
(  481)       s%ascii(1) = c
(  482)       goto 200
(  483)   end if
(  484) # 485 "lexer.F90"
(  485)   s%ungetc = c
(  486) # 488 "lexer.F90"
(  488)   ! get a 'word'
(  489) # 490 "lexer.F90"
(  490)   i = 0
(  491)   do
(  492)     if (i>=tok_maxlen) then
(  493)       !silently truncate long token (TODO: return error?)
(  494)       exit
(  495)     endif
(  496)     c = getc(s)






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 21

(  497)     if (s%ctype(c) /= ctype_word) then
(  498)       s%ungetc = c
(  499)       exit
(  500)     endif
(  501)     i = i+1
(  502)     s%ascii(i) = c
(  503)     s%cval(i:i) = char(c)
(  504)   enddo
(  505)   s%toklen = i
(  506) # 508 "lexer.F90"
(  508)   if (s%ascii(1) >= 43 .and. s%ascii(1) <= 57) then
(  509) # 510 "lexer.F90"
(  510)     !may be a number
(  511) # 512 "lexer.F90"
(  512)     do i = 1, s%toklen
(  513)       !We assume that a real number has a dot somewhere
(  514)       if (s%ascii(i) == 46) then
(  515)         !real number?
(  516)         ! the 2 step passing of rfmt(s%toklen) to the read statement
(  517)         ! is needed to circumvent a bug in older gfortran versions
(  518)         rmft_current=rfmt(s%toklen) 
(  519)         read(s%cval, rmft_current, iostat=ios) rval
(  520)         if (ios == 0) then
(  521)           s%token = tok_real
(  522)           s%rval = rval
(  523)           goto 200
(  524)         endif
(  525)         exit
(  526)       endif
(  527)     enddo
(  528) # 529 "lexer.F90"
(  529)     !integer?
(  530) # 531 "lexer.F90"
(  531)     read(s%cval, ifmt(s%toklen), iostat=ios) ival
(  532)     if (ios == 0) then
(  533)       s%token = tok_int
(  534)       s%ival = ival
(  535)       s%rval = real(ival)
(  536)       goto 200
(  537)     endif
(  538) # 539 "lexer.F90"
(  539)   endif
(  540) # 541 "lexer.F90"
(  541)   !fallback
(  542) # 543 "lexer.F90"
(  543)   s%token = tok_word
(  544) # 545 "lexer.F90"
(  545) 200 continue
(  546)   return
(  547) end subroutine
(  548) # 552 "lexer.F90"
(  552) ! Return current token to the input stream.
(  553) ! The unget buffer can hold only one character!
(  554) !
(  555) subroutine lexer_ungettoken (s)
(  556)   implicit none
(  557)   type(lexer_type) :: s
(  558) # 559 "lexer.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:31:02      page 22

(  559)   if (s%token == tok_null) then
(  560)     !this indicates incorrect use of lexer (programmer's error)
(  561)     print *, 'lexer_ungettoken(): internal error (nothing to unget!)'
(  562)     stop 1
(  563)   endif
(  564) # 565 "lexer.F90"
(  565)   s%utoken  = s%token
(  566)   s%ucval   = s%cval
(  567)   s%uival   = s%ival
(  568)   s%urval   = s%rval
(  569)   s%usval   = s%sval
(  570)   s%ulineno = s%lineno
(  571)   s%ucolumn = s%column
(  572)   s%token   = tok_null
(  573) # 574 "lexer.F90"
(  574)   return
(  575) end subroutine
(  576) # 579 "lexer.F90"
(  579) end module
