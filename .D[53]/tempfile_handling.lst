


NVFORTRAN (Version     23.1)          02/24/2023  13:57:11      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:57:11      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: tempfile_handling.F90

(    1) module tempfile_handling
(    2)   !  #[ documentation
(    3)   ! a module to provide a unique temporary filename
(    4)   ! after each call.
(    5)   !
(    6)   ! written by: J. de Kloe, KNMI
(    7)   !
(    8)   ! Modifications:
(    9)   !   26-Nov-2007 J. de Kloe  initial version
(   10)   !   13-Oct-2008 J. de Kloe  remove a typo
(   11)   !   26-Jan-2009 J. de Kloe  added check for existence of the tempfile
(   12)   !   19-Mar-2018 J. de Kloe  remove a hardcoded stop command
(   13)   !
(   14)   !  #]
(   15)   !  #[ modules used
(   16)   use c_support, only: get_process_id, remove_file, get_filesize, is_dir
(   17)   use errorhandler, only: no_error, error_writing_file, error_programming
(   18)   !  #]
(   19)   !  #[ variables and parameters
(   20)   implicit none
(   21)   character(len=*), parameter :: tempdir1 = "/tmp"
(   22)   character(len=*), parameter :: tempdir2 = "/temp"
(   23)   integer,          parameter :: max_num_tries = 99
(   24)   character(len=256), save :: tempdir
(   25)   integer, save :: tmpfile_count=0
(   26)   !  #]
(   27) contains
(   28)   !-----------------------------------
(   29)   subroutine InitTempFileHandling(error_flag)
(   30)     !  #[






NVFORTRAN (Version     23.1)          02/24/2023  13:57:11      page 3

(   31)     
(   32)     ! check for the presence of the possible temp directories
(   33)     ! to see which is available for use at this machine
(   34) 
(   35)     ! to check:
(   36)     ! /tmp
(   37)     ! $SCRATCH
(   38)     ! $TMPDIR
(   39) 
(   40)     integer, intent(out) :: error_flag
(   41)     
(   42)     error_flag = no_error
(   43)     
(   44)     !print *,"inside: InitTempFileHandling"
(   45)     tempdir=tempdir1
(   46)     if (is_dir(tempdir)) return
(   47)     tempdir=tempdir2
(   48)     if (is_dir(tempdir)) return
(   49) 
(   50)     print *,"ERROR in InitTempFileHandling:"
(   51)     print *,"The implemented temp directories do not exist"
(   52)     print *,"please modify the tempfile_handling.F90 module"
(   53)     error_flag = error_programming
(   54)     return
(   55) 
(   56)   end subroutine InitTempFileHandling
(   57)     !  #]
(   58)   subroutine get_temp_filename(temp_filename, error_flag)
(   59)     !  #[
(   60)     character(len=256), intent(out) :: temp_filename
(   61)     integer,            intent(out) :: error_flag
(   62) 
(   63)     ! local variables
(   64)     integer           :: pid_nr, ios, count_tries, size
(   65)     character(len=10) :: pid_str
(   66)     character(len=10) :: tmpfile_count_str
(   67) 
(   68)     error_flag = no_error
(   69)     temp_filename(:) = ' '
(   70) 
(   71)     ! get the process ID number to construct a unique set of filenames
(   72)     ! for the temporary files for the current process.
(   73)     ! then use an internal counter inside this module
(   74)     ! to make sure each following name is unique.
(   75) 
(   76)     pid_nr = get_process_id()
(   77)     write(pid_str,"(i10.10)",iostat=ios) pid_nr
(   78)     IF (ios .ne. 0) THEN
(   79)        print *,"ERROR in get_temp_filename(): "
(   80)        print *,"could not convert pid nr ",pid_nr," to a proper string ..."
(   81)        error_flag = error_writing_file
(   82)        return
(   83)     END IF
(   84) 
(   85)     count_tries = 0
(   86)     tryloop: do while (count_tries .lt. max_num_tries)
(   87)        tmpfile_count = tmpfile_count+1
(   88)        count_tries   = count_tries+1






NVFORTRAN (Version     23.1)          02/24/2023  13:57:11      page 4

(   89)        write(tmpfile_count_str,"(i10.10)",iostat=ios) tmpfile_count
(   90)        IF (ios .ne. 0) THEN
(   91)           print *,"ERROR in get_temp_filename(): "
(   92)           print *,"could not convert tmpfile_count ",tmpfile_count,&
(   93)                " to a proper string ..."
(   94)           error_flag = error_writing_file
(   95)           return
(   96)        END IF
(   97) 
(   98)        ! construct the temporary filename
(   99)        temp_filename = trim(tempdir)//"/tempfile."//pid_str//&
(  100)                                       "."//tmpfile_count_str
(  101) 
(  102)        ! see if this file already exists, if so take another name
(  103)        ! the filesize should be reported as -1 if the file does not exist
(  104)        size = get_filesize(temp_filename)
(  105)        if (size .lt. 0) exit tryloop
(  106)     end do tryloop
(  107) 
(  108)     ! check if we really found a filename that does not yet exist
(  109)     ! the filesize should be reported as -1 if the file does not exist
(  110)     size = get_filesize(temp_filename)
(  111)     if (size .ge. 0) then
(  112)        print *,"ERROR in get_temp_filename(): "
(  113)        print *,"could not find a filename to be used for the temporary file"
(  114)        print *,"even after trying ",max_num_tries," times"
(  115)        print *,"Last name tried was: "//trim(temp_filename)
(  116)        print *,"Please check the temp_filehandling module ..."
(  117)        error_flag = error_writing_file
(  118)        return
(  119)        
(  120)     end if
(  121) 
(  122)   end subroutine get_temp_filename
(  123)     !  #]
(  124)   subroutine free_temp_filename(temp_filename, error_flag)
(  125)     !  #[
(  126)     character(len=256), intent(in)  :: temp_filename
(  127)     integer,            intent(out) :: error_flag
(  128) 
(  129)     ! local variable
(  130)     integer :: filesize
(  131) 
(  132)     error_flag = no_error
(  133) 
(  134)     filesize = get_filesize(temp_filename)
(  135)     if (filesize .ge.0) then
(  136)        call remove_file(temp_filename, error_flag)
(  137)     else
(  138)        print *,"no tempfile present with name: ",trim(temp_filename)
(  139)     end if
(  140) 
(  141)   end subroutine free_temp_filename
(  142)     !  #]
(  143)   !-----------------------------------
(  144) end module tempfile_handling
(  145)  







NVFORTRAN (Version     23.1)          02/24/2023  13:57:11      page 5

(    1) # 1 "tempfile_handling.F90"
(    1) module tempfile_handling
(    2)   !  #[ documentation
(    3)   ! a module to provide a unique temporary filename
(    4)   ! after each call.
(    5)   !
(    6)   ! written by: J. de Kloe, KNMI
(    7)   !
(    8)   ! Modifications:
(    9)   !   26-Nov-2007 J. de Kloe  initial version
(   10)   !   13-Oct-2008 J. de Kloe  remove a typo
(   11)   !   26-Jan-2009 J. de Kloe  added check for existence of the tempfile
(   12)   !   19-Mar-2018 J. de Kloe  remove a hardcoded stop command
(   13)   !
(   14)   !  #]
(   15)   !  #[ modules used
(   16)   use c_support, only: get_process_id, remove_file, get_filesize, is_dir
(   17)   use errorhandler, only: no_error, error_writing_file, error_programming
(   18)   !  #]
(   19)   !  #[ variables and parameters
(   20)   implicit none
(   21)   character(len=*), parameter :: tempdir1 = "/tmp"
(   22)   character(len=*), parameter :: tempdir2 = "/temp"
(   23)   integer,          parameter :: max_num_tries = 99
(   24)   character(len=256), save :: tempdir
(   25)   integer, save :: tmpfile_count=0
(   26)   !  #]
(   27) contains
(   28)   !-----------------------------------
(   29)   subroutine InitTempFileHandling(error_flag)
(   30)     !  #[
(   31)     
(   32)     ! check for the presence of the possible temp directories
(   33)     ! to see which is available for use at this machine
(   34) # 35 "tempfile_handling.F90"
(   35)     ! to check:
(   36)     ! /tmp
(   37)     ! $SCRATCH
(   38)     ! $TMPDIR
(   39) # 40 "tempfile_handling.F90"
(   40)     integer, intent(out) :: error_flag
(   41)     
(   42)     error_flag = no_error
(   43)     
(   44)     !print *,"inside: InitTempFileHandling"
(   45)     tempdir=tempdir1
(   46)     if (is_dir(tempdir)) return
(   47)     tempdir=tempdir2
(   48)     if (is_dir(tempdir)) return
(   49) # 50 "tempfile_handling.F90"
(   50)     print *,"ERROR in InitTempFileHandling:"
(   51)     print *,"The implemented temp directories do not exist"
(   52)     print *,"please modify the tempfile_handling.F90 module"
(   53)     error_flag = error_programming
(   54)     return
(   55) # 56 "tempfile_handling.F90"
(   56)   end subroutine InitTempFileHandling
(   57)     !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:57:11      page 6

(   58)   subroutine get_temp_filename(temp_filename, error_flag)
(   59)     !  #[
(   60)     character(len=256), intent(out) :: temp_filename
(   61)     integer,            intent(out) :: error_flag
(   62) # 63 "tempfile_handling.F90"
(   63)     ! local variables
(   64)     integer           :: pid_nr, ios, count_tries, size
(   65)     character(len=10) :: pid_str
(   66)     character(len=10) :: tmpfile_count_str
(   67) # 68 "tempfile_handling.F90"
(   68)     error_flag = no_error
(   69)     temp_filename(:) = ' '
(   70) # 71 "tempfile_handling.F90"
(   71)     ! get the process ID number to construct a unique set of filenames
(   72)     ! for the temporary files for the current process.
(   73)     ! then use an internal counter inside this module
(   74)     ! to make sure each following name is unique.
(   75) # 76 "tempfile_handling.F90"
(   76)     pid_nr = get_process_id()
(   77)     write(pid_str,"(i10.10)",iostat=ios) pid_nr
(   78)     IF (ios .ne. 0) THEN
(   79)        print *,"ERROR in get_temp_filename(): "
(   80)        print *,"could not convert pid nr ",pid_nr," to a proper string ..."
(   81)        error_flag = error_writing_file
(   82)        return
(   83)     END IF
(   84) # 85 "tempfile_handling.F90"
(   85)     count_tries = 0
(   86)     tryloop: do while (count_tries .lt. max_num_tries)
(   87)        tmpfile_count = tmpfile_count+1
(   88)        count_tries   = count_tries+1
(   89)        write(tmpfile_count_str,"(i10.10)",iostat=ios) tmpfile_count
(   90)        IF (ios .ne. 0) THEN
(   91)           print *,"ERROR in get_temp_filename(): "
(   92)           print *,"could not convert tmpfile_count ",tmpfile_count,&
(   93)                " to a proper string ..."
(   94)           error_flag = error_writing_file
(   95)           return
(   96)        END IF
(   97) # 98 "tempfile_handling.F90"
(   98)        ! construct the temporary filename
(   99)        temp_filename = trim(tempdir)//"/tempfile."//pid_str//&
(  100)                                       "."//tmpfile_count_str
(  101) # 102 "tempfile_handling.F90"
(  102)        ! see if this file already exists, if so take another name
(  103)        ! the filesize should be reported as -1 if the file does not exist
(  104)        size = get_filesize(temp_filename)
(  105)        if (size .lt. 0) exit tryloop
(  106)     end do tryloop
(  107) # 108 "tempfile_handling.F90"
(  108)     ! check if we really found a filename that does not yet exist
(  109)     ! the filesize should be reported as -1 if the file does not exist
(  110)     size = get_filesize(temp_filename)
(  111)     if (size .ge. 0) then
(  112)        print *,"ERROR in get_temp_filename(): "
(  113)        print *,"could not find a filename to be used for the temporary file"
(  114)        print *,"even after trying ",max_num_tries," times"
(  115)        print *,"Last name tried was: "//trim(temp_filename)






NVFORTRAN (Version     23.1)          02/24/2023  13:57:11      page 7

(  116)        print *,"Please check the temp_filehandling module ..."
(  117)        error_flag = error_writing_file
(  118)        return
(  119)        
(  120)     end if
(  121) # 122 "tempfile_handling.F90"
(  122)   end subroutine get_temp_filename
(  123)     !  #]
(  124)   subroutine free_temp_filename(temp_filename, error_flag)
(  125)     !  #[
(  126)     character(len=256), intent(in)  :: temp_filename
(  127)     integer,            intent(out) :: error_flag
(  128) # 129 "tempfile_handling.F90"
(  129)     ! local variable
(  130)     integer :: filesize
(  131) # 132 "tempfile_handling.F90"
(  132)     error_flag = no_error
(  133) # 134 "tempfile_handling.F90"
(  134)     filesize = get_filesize(temp_filename)
(  135)     if (filesize .ge.0) then
(  136)        call remove_file(temp_filename, error_flag)
(  137)     else
(  138)        print *,"no tempfile present with name: ",trim(temp_filename)
(  139)     end if
(  140) # 141 "tempfile_handling.F90"
(  141)   end subroutine free_temp_filename
(  142)     !  #]
(  143)   !-----------------------------------
(  144) end module tempfile_handling
(  145)  
