


NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: interp1.F90

(    1) MODULE INTERP1
(    2)   !  #[ Documentation
(    3) 
(    4)   ! This module contains the interface and definition of 
(    5)   ! a function for 1-d spline interpolation
(    6)   !
(    7)   !    Jun 2005 Paul Poli    Original code
(    8)   !    Nov 2005 J. de Kloe   corrected bug in Hunt_Nearest
(    9)   !    Jan 2006 Paul Poli    Changed routines to public source
(   10)   !    May 2006 J. de Kloe   added interpolate() function wrapper
(   11)   !    Oct 2007 P. Poli      added extrapolation option for finterp1
(   12)   ! 16-Jan-2008 J. de Kloe   phase out integer kind i_ 
(   13)   ! 15-Apr-2009 J. de Kloe   converted d(1)**2._r8_ to d(1)*d(1)
(   14)   ! 15-Apr-2009 J. de Kloe   added some safety catches to be sure no
(   15)   !                          divisions by zero can occur
(   16)   ! 28-Apr-2009 D. Tan       Real exponent a**2._r8_ -> a*a
(   17)   ! 28-Apr-2014 J. de Kloe   implement Hunt_JdK to replace the old HUNT_NR
(   18)   !                          which is copyright numerical recipes
(   19)   ! 07-Aug-2015 J. de Kloe   delete the old HUNT_NR code from this file
(   20)   !
(   21)   !  #]
(   22)   !  #[ Modules used
(   23)   USE Numerics, only: r8_,missing_indicator_real_r8
(   24)   USE ErrorHandler, only: no_error,error_programming
(   25)   IMPLICIT NONE
(   26) 
(   27)   ! used for zero/equality checking of reals
(   28)   real(r8_), parameter :: eps = 1.e-30
(   29) 
(   30)   !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 3

(   31) CONTAINS
(   32)   !------------------------
(   33)   SUBROUTINE HUNT_JdK(n,xx,x,jlo)
(   34)     !  #[ rewritten to prevent copyright trouble with numercial recipes
(   35)     integer,   intent(in)    :: n
(   36)     integer,   intent(inout) :: jlo
(   37)     real(r8_), intent(in)    :: xx(1:n)
(   38)     real(r8_), intent(in)    :: x
(   39)     
(   40)     !
(   41)     ! Given an array xx(1:n) and given a value x returns a value jlo
(   42)     ! such that x is between xx(jlo) and xx(jlo+1). xx(1:n) must be monotonic,
(   43)     ! either increasing or decreasing. 
(   44)     ! reported jlo values are between 1 and n-1.
(   45)     ! jlo=0 or jlo=n is returned to indicate that x is out of range.
(   46)     ! the input jlo is kept to keep identical interface to the 
(   47)     ! numerical recipes version of the routine but is not used.
(   48)     !
(   49)     ! Method, devide the array in 2 halves and check in which part the
(   50)     ! the requested point occurs. Then repeat this untill the exact location
(   51)     ! is found.
(   52)     !
(   53)     ! 28-Apr-2014 initial version by J. de Kloe, KNMI
(   54)     ! 
(   55)     
(   56)     integer   :: i_left, i_right, i_mid
(   57)     real(r8_) :: x_left, x_right, x_mid
(   58)     logical   :: ascending
(   59)     
(   60)     ascending = .true.
(   61)     if (xx(n).lt.xx(1)) ascending = .false.
(   62)     
(   63)     !print *,'Looking for x=',x
(   64)     !print *,'n=',n,'xx(1) = ',xx(1),'xx(n) = ',xx(n)
(   65) 
(   66)     i_left  = 1
(   67)     i_right = n
(   68)     x_left  = xx(i_left)
(   69)     x_right = xx(i_right)
(   70) 
(   71)     if (ascending) then
(   72)        if (x .lt. x_left) then
(   73)           jlo = 0
(   74)           return
(   75)        end if
(   76)        if (x .gt. x_right) then
(   77)           jlo=n
(   78)           return
(   79)        end if
(   80)     else ! descending
(   81)        if (x .gt. x_left) then
(   82)           jlo = 0
(   83)           return
(   84)        end if
(   85)        if (x .lt. x_right) then
(   86)           jlo=n
(   87)           return
(   88)        end if






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 4

(   89)     end if
(   90) 
(   91)     searchloop: do
(   92)        i_mid = (i_left+i_right)/2
(   93)        x_mid = xx(i_mid)
(   94)        !print *,'old: i left,mid,right = ',i_left,i_mid,i_right
(   95)        !print *,'old: x left,mid,right = ',x_left,x_mid,x_right
(   96)        if ((i_mid .eq. i_left) .or. (i_mid .eq. i_right)) exit searchloop
(   97) 
(   98)        if (ascending) then
(   99)           if ((x .ge. x_left) .and. (x .le. x_mid)) then
(  100)              ! continue search in left halve of current area
(  101)              !i_left = i_left
(  102)              !x_left = x_left
(  103)              i_right = i_mid
(  104)              x_right = x_mid
(  105)           else
(  106)              ! continue search in right halve of current area
(  107)              i_left = i_mid
(  108)              x_left = x_mid
(  109)              !i_right = i_right
(  110)              !x_right = x_right   
(  111)           end if
(  112)        else ! descending
(  113)           if ((x .le. x_left) .and. (x .ge. x_mid)) then
(  114)              ! continue search in left halve of current area
(  115)              !i_left = i_left
(  116)              !x_left = x_left
(  117)              i_right = i_mid
(  118)              x_right = x_mid
(  119)           else
(  120)              ! continue search in right halve of current area
(  121)              i_left = i_mid
(  122)              x_left = x_mid
(  123)              !i_right = i_right
(  124)              !x_right = x_right   
(  125)           end if
(  126)        end if
(  127)        !print *,'new: i left,mid,right = ',i_left,i_mid,i_right
(  128)        !print *,'new: x left,mid,right = ',x_left,x_mid,x_right
(  129)     end do searchloop
(  130) 
(  131)     if (x .le. x_mid) then
(  132)        ! solution found in left halve of current area
(  133)        jlo = i_left
(  134)     else
(  135)        ! solution found in right halve of current area
(  136)        jlo = i_mid
(  137)     end if
(  138)     
(  139)     if (jlo.eq.n) jlo=n-1
(  140) 
(  141)   END SUBROUTINE HUNT_JDK
(  142)     !  #]
(  143)   SUBROUTINE Spline_Calc (n, x, y, b, c, d, m, x0, y0, &
(  144)                           error_flag, flag_extrapolate)
(  145)     !  #[
(  146) 






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 5

(  147)     ! This routine calculates, given inputs x(1:n),y(1:n)
(  148)     ! and arrays b,c,d, (1:n) calculated by Spline_Init
(  149)     ! the cubic-spline interpolated values y0(1:m) at positions
(  150)     ! x0(1:m)
(  151)     ! Source: http://www.netlib.org/fmm/ NO RESTRICTIONS ON THIS CODE
(  152)     !
(  153)     ! Modifications
(  154)     ! 2007 Paul Poli     Add extrapolation option
(  155)     
(  156)     ! I/O variables
(  157)     integer,     intent(in)  :: n,m
(  158)     real(r8_),   intent(in)  :: x(1:n),y(1:n),b(1:n),c(1:n),d(1:n),x0(1:m)
(  159)     real(r8_),   intent(out) :: y0(1:m)
(  160)     integer,     intent(out) :: error_flag
(  161)     logical,     intent(in), optional :: flag_extrapolate
(  162)     
(  163)     ! local variables
(  164)     integer   :: i,klo !not used: ,khi
(  165)     real(r8_) :: dx
(  166)     logical   :: do_extrapolate
(  167)    
(  168)     error_flag = no_error
(  169) 
(  170)     do_extrapolate=.FALSE.
(  171)     IF (present(flag_extrapolate)) do_extrapolate=flag_extrapolate
(  172) 
(  173)     klo=1
(  174)     do i=1,m
(  175)        call hunt_JdK(n,x,x0(i),klo)
(  176)        if (klo.lt.n.and.klo.ge.1) then
(  177)           !khi=klo+1 ! not used !
(  178)           dx=x0(i)-x(klo)
(  179)           y0(i)=y(klo) + dx*( b(klo) + dx*( c(klo) + dx* d(klo) ) )
(  180)        else
(  181)           !print *,"Spline_Calc: WARNING interpolation out of range klo=",klo,x0(i),x(1),x(n)
(  182)           IF (do_extrapolate) THEN
(  183)              IF (klo .ge. n) THEN
(  184)                 klo=n-1
(  185)              ELSE
(  186)                 klo=1
(  187)              ENDIF
(  188)              dx=x0(i)-x(klo)
(  189)              y0(i)=y(klo) + dx*( b(klo) + dx*( c(klo) + dx* d(klo) ) )
(  190)           ELSE
(  191)              y0(i)=missing_indicator_real_r8
(  192)           ENDIF
(  193)        endif
(  194)     enddo
(  195)     
(  196)   END SUBROUTINE Spline_Calc
(  197)     !  #]
(  198)   SUBROUTINE Spline_Init (n, x, y, b, c, d, error_flag)
(  199)     !  #[
(  200)     !  The coefficients b(i), c(i), and d(i), i=1,2,...,n are computed
(  201)     !  for a cubic interpolating spline
(  202)     !    s(x) = y(i) + b(i)*(x-x(i)) + c(i)*(x-x(i))**2 + d(i)*(x-x(i))**3
(  203)     !    for  x(i) .le. x .le. x(i+1)
(  204)     !  Input variables:






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 6

(  205)     !    n = the number of data points or knots (n.ge.2)
(  206)     !    x = the abscissas of the knots in strictly increasing order
(  207)     !    y = the ordinates of the knots
(  208)     !  Output variables:
(  209)     !    b, c, d  = arrays of spline coefficients as defined above.
(  210)     !  Using p to denote differentiation:
(  211)     !    y(i) = s(x(i))
(  212)     !    b(i) = sp(x(i))
(  213)     !    c(i) = spp(x(i))/2
(  214)     !    d(i) = sppp(x(i))/6  (derivative from the right)
(  215)     ! Source: http://www.netlib.org/fmm/ NO RESTRICTIONS ON THIS CODE
(  216) 
(  217)     ! I/O variables
(  218)     integer,   intent(in)  :: n
(  219)     real(r8_), intent(in)  :: x(1:n), y(1:n)
(  220)     real(r8_), intent(out) :: b(1:n), c(1:n), d(1:n)
(  221)     integer,   intent(out) :: error_flag
(  222)     
(  223)     ! local variables
(  224)     integer   :: nm1, ib, i
(  225)     real(r8_) :: t
(  226)     
(  227)     error_flag = no_error
(  228) 
(  229)     nm1 = n-1
(  230)     
(  231)     IF (n .lt. 2) THEN
(  232)        print *,"Spline_Init: ERROR only ",n," point in input"
(  233)        error_flag = error_programming
(  234)        return
(  235)     ENDIF
(  236) 
(  237)     ! note: we use this code on regularly gridded data,
(  238)     ! so dividing by d(i) or by (x(n)-(x(m)) is safe
(  239)     ! provided that n .ne. m .....
(  240) 
(  241)     IF (n .lt. 3) goto 50
(  242)     !  set up tridiagonal system
(  243)     !  b = diagonal, d = offdiagonal, c = right hand side.
(  244)     d(1) = x(2) - x(1)
(  245)     c(2) = (y(2) - y(1))/d(1)
(  246)     DO i = 2, nm1
(  247)        d(i) = x(i+1) - x(i)
(  248)        b(i) = 2._r8_*(d(i-1) + d(i))
(  249)        c(i+1) = (y(i+1) - y(i))/d(i)
(  250)        c(i) = c(i+1) - c(i)
(  251)     ENDDO
(  252)     !  end conditions.  third derivatives at  x(1)  and  x(n)
(  253)     !  obtained from divided differences
(  254)     b(1) = -d(1)
(  255)     b(n) = -d(n-1)
(  256)     c(1) = 0._r8_
(  257)     c(n) = 0._r8_
(  258)     IF ( n .eq. 3 ) goto 15
(  259)     c(1) = c(3)/(x(4)-x(2)) - c(2)/(x(3)-x(1))
(  260)     c(n) = c(n-1)/(x(n)-x(n-2)) - c(n-2)/(x(n-1)-x(n-3))
(  261)     c(1) = c(1)*d(1)*d(1)/(x(4)-x(1))
(  262)     c(n) = -c(n)*d(n-1)*d(n-1)/(x(n)-x(n-3))






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 7

(  263)     !  forward elimination
(  264)  15 DO i = 2, n
(  265)        ! for this b(i-1) I am not absolutely sure that it will never 
(  266)        ! be zero, so apply a test for it before deviding
(  267)        if (abs(b(i-1)) .lt. eps) then
(  268)           print *,"Spline_Init: ERROR division by zero intercepted:"
(  269)           print *,"offending value: b(i-1) = ",b(i-1)
(  270)           error_flag = error_programming
(  271)           return
(  272)        end if
(  273)        t = d(i-1)/b(i-1)
(  274)        b(i) = b(i) - t*d(i-1)
(  275)        c(i) = c(i) - t*c(i-1)
(  276)     ENDDO
(  277) 
(  278)     ! for this b(n) I am not absolutely sure that it will never 
(  279)     ! be zero, so apply a test for it before deviding
(  280)     if (abs(b(n)) .lt. eps) then
(  281)        print *,"Spline_Init: ERROR division by zero intercepted:"
(  282)        print *,"offending value: b(n) = ",b(n)
(  283)        error_flag = error_programming
(  284)        return
(  285)     end if
(  286) 
(  287)     !  back substitution
(  288)     c(n) = c(n)/b(n)
(  289)     DO ib = 1, nm1
(  290)        i = n-ib
(  291) 
(  292)        ! for this b(i) I am not absolutely sure that it will never 
(  293)        ! be zero, so apply a test for it before deviding
(  294)        if (abs(b(i)) .lt. eps) then
(  295)           print *,"Spline_Init: ERROR division by zero intercepted:"
(  296)           print *,"offending value: b(i) = ",b(i)
(  297)           error_flag = error_programming
(  298)           return
(  299)        end if
(  300) 
(  301)        c(i) = (c(i) - d(i)*c(i+1))/b(i)
(  302)     ENDDO
(  303) 
(  304)     !  compute polynomial coefficients
(  305)     b(n) = (y(n) - y(nm1))/d(nm1) + d(nm1)*(c(nm1) + 2._r8_*c(n))
(  306)     DO i = 1, nm1
(  307)        b(i) = (y(i+1) - y(i))/d(i) - d(i)*(c(i+1) + 2._r8_*c(i))
(  308)        d(i) = (c(i+1) - c(i))/d(i)
(  309)        c(i) = 3._r8_*c(i)
(  310)     ENDDO
(  311)     c(n) = 3._r8_*c(n)
(  312)     d(n) = d(n-1)
(  313)     
(  314)     return
(  315)     
(  316)  50 b(1) = (y(2)-y(1))/(x(2)-x(1))
(  317)     c(1) = 0._r8_
(  318)     d(1) = 0._r8_
(  319)     b(2) = b(1)
(  320)     c(2) = 0._r8_






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 8

(  321)     d(2) = 0._r8_
(  322) 
(  323)     return
(  324) 
(  325)   END SUBROUTINE Spline_Init
(  326)     !  #]
(  327)   FUNCTION FINTERP1(x1,y1,x2,flag_extrapolate) result(y2)
(  328)     !  #[
(  329)     !
(  330)     ! Performs a 1D-spline interpolation from the array values y1 at positions x1
(  331)     ! to positions x2 ; returns the result in the array y2
(  332)     !
(  333)     ! 29/06/2005  Paul Poli   Original code
(  334)     ! 10/01/2006  P. Poli     Changed subroutines called
(  335)     ! 10/10/2007  P. Poli     Add extrapolation option
(  336)     
(  337)     ! I/O variables
(  338)     
(  339)     real(r8_), dimension(:), intent(in)             :: x1,y1,x2
(  340)     real(r8_), dimension(lbound(x2,1):ubound(x2,1)) :: y2
(  341)     logical, intent(in), optional                   :: flag_extrapolate
(  342)     
(  343)     ! local variables
(  344)     
(  345)     integer :: n1,n2, error_flag
(  346)     real(r8_), dimension(:), allocatable :: b,c,d
(  347)     
(  348)     n1=size(x1)
(  349)     n2=size(x2)
(  350)     allocate (b(n1),c(n1),d(n1))
(  351)     call Spline_Init(n1,x1,y1,b,c,d,error_flag)
(  352)     call Spline_Calc(n1,x1,y1,b,c,d,n2,x2,y2,error_flag,flag_extrapolate)
(  353)     deallocate(b,c,d)
(  354)     
(  355)   END FUNCTION FINTERP1
(  356)     !  #]
(  357)   SUBROUTINE HUNT_NEAREST(n,xx,x,j0,jlo,jhi)
(  358)     !  #[
(  359)     integer,   intent(in)    :: n
(  360)     integer,   intent(out)   :: j0,jlo,jhi
(  361)     real(r8_), intent(in)    :: x,xx(1:n)
(  362)     
(  363)     !
(  364)     ! Given an array xx(1:n) and given a value x returns the values j0,jlo,jhi
(  365)     ! such that x(j0) is the closest to x, and x is between xx(jlo) and xx(jhi)
(  366)     ! xx(1:n) must be monotonic, either increasing r decreasing.
(  367)     ! j0=-1 or j0=n+1 is returned to indicate that x is out f range.
(  368)     !
(  369)     ! 2005 Paul Poli   First F90 version
(  370)     ! 
(  371)     ! Modified: 
(  372)     ! 16-Nov-2005, J. de Kloe: corrected bug that occurs when x is outside
(  373)     !              the range defined by xx. This resulted in the runtime error
(  374)     !              "Array element out of bounds"
(  375)     
(  376)     ! local variables
(  377)     integer   :: inc,j
(  378)     logical   :: ascnd






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 9

(  379)     real(r8_) :: xmin, xmax    
(  380) 
(  381)     ascnd=xx(n).ge.xx(1)
(  382)     ! True if ascending order of table,false otherwise. 
(  383) 
(  384)     if (ascnd) then
(  385)        xmin=xx(1)
(  386)        xmax=xx(n)
(  387)     else
(  388)        xmin=xx(n)
(  389)        xmax=xx(1)
(  390)     end if
(  391) 
(  392)     j0=-1
(  393)     jlo=-1
(  394)     jhi=-1
(  395)     if (x .lt. xmin) return
(  396)     if (x .gt. xmax) return
(  397)     ! we are outside the range defined by xx, 
(  398)     ! so return with indices set to -1
(  399) 
(  400)     j0=0
(  401)     if (ascnd) then
(  402)        j=1
(  403)        inc=1
(  404)        jlo=0
(  405)        jhi=n+1
(  406)        do while (j.ne.n+1)
(  407)           !if (xx(j).eq.x) j0=j
(  408)           if (xx(j).le.x) jlo=maxval((/jlo,j/))
(  409)           if (xx(j).gt.x) jhi=minval((/jhi,j/))
(  410)           j=j+inc
(  411)        enddo
(  412)        if (j0.eq.1) jlo=1
(  413)        if (j0.eq.n) jhi=n
(  414)     else
(  415)        j=n
(  416)        inc=-1
(  417)        jlo=n+1
(  418)        jhi=0
(  419)        do while (j.ne.0)
(  420)           !if (xx(j).eq.x) j0=j
(  421)           if (xx(j).le.x) jlo=minval((/jlo,j/))
(  422)           if (xx(j).gt.x) jhi=maxval((/jhi,j/))
(  423)           j=j+inc
(  424)        enddo
(  425)        if (j0.eq.1) jhi=1
(  426)        if (j0.eq.n) jlo=n
(  427)     endif
(  428)     if (j0.eq.0) then
(  429)        ! no exact value was found
(  430)        if (abs(x-xx(jlo)).le.abs(x-xx(jhi))) then
(  431)           ! requested value is closer to jlo
(  432)           j0=jlo
(  433)           if (jlo.gt.1.and.jlo.lt.n) jlo=jlo-inc
(  434)        else
(  435)           ! requested value is closer to jhi
(  436)           j0=jhi






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 10

(  437)           if (jhi.gt.1.and.jhi.lt.n) jhi=jhi+inc
(  438)        endif
(  439)     endif
(  440)     
(  441)   END SUBROUTINE HUNT_NEAREST
(  442)   !  #]
(  443)   function interpolate(x,y,xres) result(yres)
(  444)     !  #[
(  445)     ! a simple wrapper to enable giving a scalar number
(  446)     ! rather than an array for xres
(  447)     real(r8_), dimension(:), intent(in) :: x,y
(  448)     real(r8_),               intent(in) :: xres
(  449)     real(r8_)                           :: yres ! result
(  450) 
(  451)     ! local variable
(  452)     real(r8_), dimension(1) :: xres_array, yres_array
(  453) 
(  454)     xres_array(1) = xres
(  455)     yres_array    = FINTERP1(x,y,xres_array)
(  456)     yres          = yres_array(1)
(  457) 
(  458)   end function interpolate
(  459)     !  #]
(  460)   !------------------------
(  461) END MODULE INTERP1
(  462) 






































NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 11

(    1) # 1 "interp1.F90"
(    1) MODULE INTERP1
(    2)   !  #[ Documentation
(    3) # 4 "interp1.F90"
(    4)   ! This module contains the interface and definition of 
(    5)   ! a function for 1-d spline interpolation
(    6)   !
(    7)   !    Jun 2005 Paul Poli    Original code
(    8)   !    Nov 2005 J. de Kloe   corrected bug in Hunt_Nearest
(    9)   !    Jan 2006 Paul Poli    Changed routines to public source
(   10)   !    May 2006 J. de Kloe   added interpolate() function wrapper
(   11)   !    Oct 2007 P. Poli      added extrapolation option for finterp1
(   12)   ! 16-Jan-2008 J. de Kloe   phase out integer kind i_ 
(   13)   ! 15-Apr-2009 J. de Kloe   converted d(1)**2._r8_ to d(1)*d(1)
(   14)   ! 15-Apr-2009 J. de Kloe   added some safety catches to be sure no
(   15)   !                          divisions by zero can occur
(   16)   ! 28-Apr-2009 D. Tan       Real exponent a**2._r8_ -> a*a
(   17)   ! 28-Apr-2014 J. de Kloe   implement Hunt_JdK to replace the old HUNT_NR
(   18)   !                          which is copyright numerical recipes
(   19)   ! 07-Aug-2015 J. de Kloe   delete the old HUNT_NR code from this file
(   20)   !
(   21)   !  #]
(   22)   !  #[ Modules used
(   23)   USE Numerics, only: r8_,missing_indicator_real_r8
(   24)   USE ErrorHandler, only: no_error,error_programming
(   25)   IMPLICIT NONE
(   26) # 27 "interp1.F90"
(   27)   ! used for zero/equality checking of reals
(   28)   real(r8_), parameter :: eps = 1.e-30
(   29) # 30 "interp1.F90"
(   30)   !  #]
(   31) CONTAINS
(   32)   !------------------------
(   33)   SUBROUTINE HUNT_JdK(n,xx,x,jlo)
(   34)     !  #[ rewritten to prevent copyright trouble with numercial recipes
(   35)     integer,   intent(in)    :: n
(   36)     integer,   intent(inout) :: jlo
(   37)     real(r8_), intent(in)    :: xx(1:n)
(   38)     real(r8_), intent(in)    :: x
(   39)     
(   40)     !
(   41)     ! Given an array xx(1:n) and given a value x returns a value jlo
(   42)     ! such that x is between xx(jlo) and xx(jlo+1). xx(1:n) must be monotonic,
(   43)     ! either increasing or decreasing. 
(   44)     ! reported jlo values are between 1 and n-1.
(   45)     ! jlo=0 or jlo=n is returned to indicate that x is out of range.
(   46)     ! the input jlo is kept to keep identical interface to the 
(   47)     ! numerical recipes version of the routine but is not used.
(   48)     !
(   49)     ! Method, devide the array in 2 halves and check in which part the
(   50)     ! the requested point occurs. Then repeat this untill the exact location
(   51)     ! is found.
(   52)     !
(   53)     ! 28-Apr-2014 initial version by J. de Kloe, KNMI
(   54)     ! 
(   55)     
(   56)     integer   :: i_left, i_right, i_mid
(   57)     real(r8_) :: x_left, x_right, x_mid






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 12

(   58)     logical   :: ascending
(   59)     
(   60)     ascending = .true.
(   61)     if (xx(n).lt.xx(1)) ascending = .false.
(   62)     
(   63)     !print *,'Looking for x=',x
(   64)     !print *,'n=',n,'xx(1) = ',xx(1),'xx(n) = ',xx(n)
(   65) # 66 "interp1.F90"
(   66)     i_left  = 1
(   67)     i_right = n
(   68)     x_left  = xx(i_left)
(   69)     x_right = xx(i_right)
(   70) # 71 "interp1.F90"
(   71)     if (ascending) then
(   72)        if (x .lt. x_left) then
(   73)           jlo = 0
(   74)           return
(   75)        end if
(   76)        if (x .gt. x_right) then
(   77)           jlo=n
(   78)           return
(   79)        end if
(   80)     else ! descending
(   81)        if (x .gt. x_left) then
(   82)           jlo = 0
(   83)           return
(   84)        end if
(   85)        if (x .lt. x_right) then
(   86)           jlo=n
(   87)           return
(   88)        end if
(   89)     end if
(   90) # 91 "interp1.F90"
(   91)     searchloop: do
(   92)        i_mid = (i_left+i_right)/2
(   93)        x_mid = xx(i_mid)
(   94)        !print *,'old: i left,mid,right = ',i_left,i_mid,i_right
(   95)        !print *,'old: x left,mid,right = ',x_left,x_mid,x_right
(   96)        if ((i_mid .eq. i_left) .or. (i_mid .eq. i_right)) exit searchloop
(   97) # 98 "interp1.F90"
(   98)        if (ascending) then
(   99)           if ((x .ge. x_left) .and. (x .le. x_mid)) then
(  100)              ! continue search in left halve of current area
(  101)              !i_left = i_left
(  102)              !x_left = x_left
(  103)              i_right = i_mid
(  104)              x_right = x_mid
(  105)           else
(  106)              ! continue search in right halve of current area
(  107)              i_left = i_mid
(  108)              x_left = x_mid
(  109)              !i_right = i_right
(  110)              !x_right = x_right   
(  111)           end if
(  112)        else ! descending
(  113)           if ((x .le. x_left) .and. (x .ge. x_mid)) then
(  114)              ! continue search in left halve of current area
(  115)              !i_left = i_left






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 13

(  116)              !x_left = x_left
(  117)              i_right = i_mid
(  118)              x_right = x_mid
(  119)           else
(  120)              ! continue search in right halve of current area
(  121)              i_left = i_mid
(  122)              x_left = x_mid
(  123)              !i_right = i_right
(  124)              !x_right = x_right   
(  125)           end if
(  126)        end if
(  127)        !print *,'new: i left,mid,right = ',i_left,i_mid,i_right
(  128)        !print *,'new: x left,mid,right = ',x_left,x_mid,x_right
(  129)     end do searchloop
(  130) # 131 "interp1.F90"
(  131)     if (x .le. x_mid) then
(  132)        ! solution found in left halve of current area
(  133)        jlo = i_left
(  134)     else
(  135)        ! solution found in right halve of current area
(  136)        jlo = i_mid
(  137)     end if
(  138)     
(  139)     if (jlo.eq.n) jlo=n-1
(  140) # 141 "interp1.F90"
(  141)   END SUBROUTINE HUNT_JDK
(  142)     !  #]
(  143)   SUBROUTINE Spline_Calc (n, x, y, b, c, d, m, x0, y0, &
(  144)                           error_flag, flag_extrapolate)
(  145)     !  #[
(  146) # 147 "interp1.F90"
(  147)     ! This routine calculates, given inputs x(1:n),y(1:n)
(  148)     ! and arrays b,c,d, (1:n) calculated by Spline_Init
(  149)     ! the cubic-spline interpolated values y0(1:m) at positions
(  150)     ! x0(1:m)
(  151)     ! Source: http://www.netlib.org/fmm/ NO RESTRICTIONS ON THIS CODE
(  152)     !
(  153)     ! Modifications
(  154)     ! 2007 Paul Poli     Add extrapolation option
(  155)     
(  156)     ! I/O variables
(  157)     integer,     intent(in)  :: n,m
(  158)     real(r8_),   intent(in)  :: x(1:n),y(1:n),b(1:n),c(1:n),d(1:n),x0(1:m)
(  159)     real(r8_),   intent(out) :: y0(1:m)
(  160)     integer,     intent(out) :: error_flag
(  161)     logical,     intent(in), optional :: flag_extrapolate
(  162)     
(  163)     ! local variables
(  164)     integer   :: i,klo !not used: ,khi
(  165)     real(r8_) :: dx
(  166)     logical   :: do_extrapolate
(  167)    
(  168)     error_flag = no_error
(  169) # 170 "interp1.F90"
(  170)     do_extrapolate=.FALSE.
(  171)     IF (present(flag_extrapolate)) do_extrapolate=flag_extrapolate
(  172) # 173 "interp1.F90"
(  173)     klo=1






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 14

(  174)     do i=1,m
(  175)        call hunt_JdK(n,x,x0(i),klo)
(  176)        if (klo.lt.n.and.klo.ge.1) then
(  177)           !khi=klo+1 ! not used !
(  178)           dx=x0(i)-x(klo)
(  179)           y0(i)=y(klo) + dx*( b(klo) + dx*( c(klo) + dx* d(klo) ) )
(  180)        else
(  181)           !print *,"Spline_Calc: WARNING interpolation out of range klo=",klo,x0(i),x(1),x(n)
(  182)           IF (do_extrapolate) THEN
(  183)              IF (klo .ge. n) THEN
(  184)                 klo=n-1
(  185)              ELSE
(  186)                 klo=1
(  187)              ENDIF
(  188)              dx=x0(i)-x(klo)
(  189)              y0(i)=y(klo) + dx*( b(klo) + dx*( c(klo) + dx* d(klo) ) )
(  190)           ELSE
(  191)              y0(i)=missing_indicator_real_r8
(  192)           ENDIF
(  193)        endif
(  194)     enddo
(  195)     
(  196)   END SUBROUTINE Spline_Calc
(  197)     !  #]
(  198)   SUBROUTINE Spline_Init (n, x, y, b, c, d, error_flag)
(  199)     !  #[
(  200)     !  The coefficients b(i), c(i), and d(i), i=1,2,...,n are computed
(  201)     !  for a cubic interpolating spline
(  202)     !    s(x) = y(i) + b(i)*(x-x(i)) + c(i)*(x-x(i))**2 + d(i)*(x-x(i))**3
(  203)     !    for  x(i) .le. x .le. x(i+1)
(  204)     !  Input variables:
(  205)     !    n = the number of data points or knots (n.ge.2)
(  206)     !    x = the abscissas of the knots in strictly increasing order
(  207)     !    y = the ordinates of the knots
(  208)     !  Output variables:
(  209)     !    b, c, d  = arrays of spline coefficients as defined above.
(  210)     !  Using p to denote differentiation:
(  211)     !    y(i) = s(x(i))
(  212)     !    b(i) = sp(x(i))
(  213)     !    c(i) = spp(x(i))/2
(  214)     !    d(i) = sppp(x(i))/6  (derivative from the right)
(  215)     ! Source: http://www.netlib.org/fmm/ NO RESTRICTIONS ON THIS CODE
(  216) # 217 "interp1.F90"
(  217)     ! I/O variables
(  218)     integer,   intent(in)  :: n
(  219)     real(r8_), intent(in)  :: x(1:n), y(1:n)
(  220)     real(r8_), intent(out) :: b(1:n), c(1:n), d(1:n)
(  221)     integer,   intent(out) :: error_flag
(  222)     
(  223)     ! local variables
(  224)     integer   :: nm1, ib, i
(  225)     real(r8_) :: t
(  226)     
(  227)     error_flag = no_error
(  228) # 229 "interp1.F90"
(  229)     nm1 = n-1
(  230)     
(  231)     IF (n .lt. 2) THEN






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 15

(  232)        print *,"Spline_Init: ERROR only ",n," point in input"
(  233)        error_flag = error_programming
(  234)        return
(  235)     ENDIF
(  236) # 237 "interp1.F90"
(  237)     ! note: we use this code on regularly gridded data,
(  238)     ! so dividing by d(i) or by (x(n)-(x(m)) is safe
(  239)     ! provided that n .ne. m .....
(  240) # 241 "interp1.F90"
(  241)     IF (n .lt. 3) goto 50
(  242)     !  set up tridiagonal system
(  243)     !  b = diagonal, d = offdiagonal, c = right hand side.
(  244)     d(1) = x(2) - x(1)
(  245)     c(2) = (y(2) - y(1))/d(1)
(  246)     DO i = 2, nm1
(  247)        d(i) = x(i+1) - x(i)
(  248)        b(i) = 2._r8_*(d(i-1) + d(i))
(  249)        c(i+1) = (y(i+1) - y(i))/d(i)
(  250)        c(i) = c(i+1) - c(i)
(  251)     ENDDO
(  252)     !  end conditions.  third derivatives at  x(1)  and  x(n)
(  253)     !  obtained from divided differences
(  254)     b(1) = -d(1)
(  255)     b(n) = -d(n-1)
(  256)     c(1) = 0._r8_
(  257)     c(n) = 0._r8_
(  258)     IF ( n .eq. 3 ) goto 15
(  259)     c(1) = c(3)/(x(4)-x(2)) - c(2)/(x(3)-x(1))
(  260)     c(n) = c(n-1)/(x(n)-x(n-2)) - c(n-2)/(x(n-1)-x(n-3))
(  261)     c(1) = c(1)*d(1)*d(1)/(x(4)-x(1))
(  262)     c(n) = -c(n)*d(n-1)*d(n-1)/(x(n)-x(n-3))
(  263)     !  forward elimination
(  264)  15 DO i = 2, n
(  265)        ! for this b(i-1) I am not absolutely sure that it will never 
(  266)        ! be zero, so apply a test for it before deviding
(  267)        if (abs(b(i-1)) .lt. eps) then
(  268)           print *,"Spline_Init: ERROR division by zero intercepted:"
(  269)           print *,"offending value: b(i-1) = ",b(i-1)
(  270)           error_flag = error_programming
(  271)           return
(  272)        end if
(  273)        t = d(i-1)/b(i-1)
(  274)        b(i) = b(i) - t*d(i-1)
(  275)        c(i) = c(i) - t*c(i-1)
(  276)     ENDDO
(  277) # 278 "interp1.F90"
(  278)     ! for this b(n) I am not absolutely sure that it will never 
(  279)     ! be zero, so apply a test for it before deviding
(  280)     if (abs(b(n)) .lt. eps) then
(  281)        print *,"Spline_Init: ERROR division by zero intercepted:"
(  282)        print *,"offending value: b(n) = ",b(n)
(  283)        error_flag = error_programming
(  284)        return
(  285)     end if
(  286) # 287 "interp1.F90"
(  287)     !  back substitution
(  288)     c(n) = c(n)/b(n)
(  289)     DO ib = 1, nm1






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 16

(  290)        i = n-ib
(  291) # 292 "interp1.F90"
(  292)        ! for this b(i) I am not absolutely sure that it will never 
(  293)        ! be zero, so apply a test for it before deviding
(  294)        if (abs(b(i)) .lt. eps) then
(  295)           print *,"Spline_Init: ERROR division by zero intercepted:"
(  296)           print *,"offending value: b(i) = ",b(i)
(  297)           error_flag = error_programming
(  298)           return
(  299)        end if
(  300) # 301 "interp1.F90"
(  301)        c(i) = (c(i) - d(i)*c(i+1))/b(i)
(  302)     ENDDO
(  303) # 304 "interp1.F90"
(  304)     !  compute polynomial coefficients
(  305)     b(n) = (y(n) - y(nm1))/d(nm1) + d(nm1)*(c(nm1) + 2._r8_*c(n))
(  306)     DO i = 1, nm1
(  307)        b(i) = (y(i+1) - y(i))/d(i) - d(i)*(c(i+1) + 2._r8_*c(i))
(  308)        d(i) = (c(i+1) - c(i))/d(i)
(  309)        c(i) = 3._r8_*c(i)
(  310)     ENDDO
(  311)     c(n) = 3._r8_*c(n)
(  312)     d(n) = d(n-1)
(  313)     
(  314)     return
(  315)     
(  316)  50 b(1) = (y(2)-y(1))/(x(2)-x(1))
(  317)     c(1) = 0._r8_
(  318)     d(1) = 0._r8_
(  319)     b(2) = b(1)
(  320)     c(2) = 0._r8_
(  321)     d(2) = 0._r8_
(  322) # 323 "interp1.F90"
(  323)     return
(  324) # 325 "interp1.F90"
(  325)   END SUBROUTINE Spline_Init
(  326)     !  #]
(  327)   FUNCTION FINTERP1(x1,y1,x2,flag_extrapolate) result(y2)
(  328)     !  #[
(  329)     !
(  330)     ! Performs a 1D-spline interpolation from the array values y1 at positions x1
(  331)     ! to positions x2 ; returns the result in the array y2
(  332)     !
(  333)     ! 29/06/2005  Paul Poli   Original code
(  334)     ! 10/01/2006  P. Poli     Changed subroutines called
(  335)     ! 10/10/2007  P. Poli     Add extrapolation option
(  336)     
(  337)     ! I/O variables
(  338)     
(  339)     real(r8_), dimension(:), intent(in)             :: x1,y1,x2
(  340)     real(r8_), dimension(lbound(x2,1):ubound(x2,1)) :: y2
(  341)     logical, intent(in), optional                   :: flag_extrapolate
(  342)     
(  343)     ! local variables
(  344)     
(  345)     integer :: n1,n2, error_flag
(  346)     real(r8_), dimension(:), allocatable :: b,c,d
(  347)     






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 17

(  348)     n1=size(x1)
(  349)     n2=size(x2)
(  350)     allocate (b(n1),c(n1),d(n1))
(  351)     call Spline_Init(n1,x1,y1,b,c,d,error_flag)
(  352)     call Spline_Calc(n1,x1,y1,b,c,d,n2,x2,y2,error_flag,flag_extrapolate)
(  353)     deallocate(b,c,d)
(  354)     
(  355)   END FUNCTION FINTERP1
(  356)     !  #]
(  357)   SUBROUTINE HUNT_NEAREST(n,xx,x,j0,jlo,jhi)
(  358)     !  #[
(  359)     integer,   intent(in)    :: n
(  360)     integer,   intent(out)   :: j0,jlo,jhi
(  361)     real(r8_), intent(in)    :: x,xx(1:n)
(  362)     
(  363)     !
(  364)     ! Given an array xx(1:n) and given a value x returns the values j0,jlo,jhi
(  365)     ! such that x(j0) is the closest to x, and x is between xx(jlo) and xx(jhi)
(  366)     ! xx(1:n) must be monotonic, either increasing r decreasing.
(  367)     ! j0=-1 or j0=n+1 is returned to indicate that x is out f range.
(  368)     !
(  369)     ! 2005 Paul Poli   First F90 version
(  370)     ! 
(  371)     ! Modified: 
(  372)     ! 16-Nov-2005, J. de Kloe: corrected bug that occurs when x is outside
(  373)     !              the range defined by xx. This resulted in the runtime error
(  374)     !              "Array element out of bounds"
(  375)     
(  376)     ! local variables
(  377)     integer   :: inc,j
(  378)     logical   :: ascnd
(  379)     real(r8_) :: xmin, xmax    
(  380) # 381 "interp1.F90"
(  381)     ascnd=xx(n).ge.xx(1)
(  382)     ! True if ascending order of table,false otherwise. 
(  383) # 384 "interp1.F90"
(  384)     if (ascnd) then
(  385)        xmin=xx(1)
(  386)        xmax=xx(n)
(  387)     else
(  388)        xmin=xx(n)
(  389)        xmax=xx(1)
(  390)     end if
(  391) # 392 "interp1.F90"
(  392)     j0=-1
(  393)     jlo=-1
(  394)     jhi=-1
(  395)     if (x .lt. xmin) return
(  396)     if (x .gt. xmax) return
(  397)     ! we are outside the range defined by xx, 
(  398)     ! so return with indices set to -1
(  399) # 400 "interp1.F90"
(  400)     j0=0
(  401)     if (ascnd) then
(  402)        j=1
(  403)        inc=1
(  404)        jlo=0
(  405)        jhi=n+1






NVFORTRAN (Version     23.1)          02/24/2023  13:47:38      page 18

(  406)        do while (j.ne.n+1)
(  407)           !if (xx(j).eq.x) j0=j
(  408)           if (xx(j).le.x) jlo=maxval((/jlo,j/))
(  409)           if (xx(j).gt.x) jhi=minval((/jhi,j/))
(  410)           j=j+inc
(  411)        enddo
(  412)        if (j0.eq.1) jlo=1
(  413)        if (j0.eq.n) jhi=n
(  414)     else
(  415)        j=n
(  416)        inc=-1
(  417)        jlo=n+1
(  418)        jhi=0
(  419)        do while (j.ne.0)
(  420)           !if (xx(j).eq.x) j0=j
(  421)           if (xx(j).le.x) jlo=minval((/jlo,j/))
(  422)           if (xx(j).gt.x) jhi=maxval((/jhi,j/))
(  423)           j=j+inc
(  424)        enddo
(  425)        if (j0.eq.1) jhi=1
(  426)        if (j0.eq.n) jlo=n
(  427)     endif
(  428)     if (j0.eq.0) then
(  429)        ! no exact value was found
(  430)        if (abs(x-xx(jlo)).le.abs(x-xx(jhi))) then
(  431)           ! requested value is closer to jlo
(  432)           j0=jlo
(  433)           if (jlo.gt.1.and.jlo.lt.n) jlo=jlo-inc
(  434)        else
(  435)           ! requested value is closer to jhi
(  436)           j0=jhi
(  437)           if (jhi.gt.1.and.jhi.lt.n) jhi=jhi+inc
(  438)        endif
(  439)     endif
(  440)     
(  441)   END SUBROUTINE HUNT_NEAREST
(  442)   !  #]
(  443)   function interpolate(x,y,xres) result(yres)
(  444)     !  #[
(  445)     ! a simple wrapper to enable giving a scalar number
(  446)     ! rather than an array for xres
(  447)     real(r8_), dimension(:), intent(in) :: x,y
(  448)     real(r8_),               intent(in) :: xres
(  449)     real(r8_)                           :: yres ! result
(  450) # 451 "interp1.F90"
(  451)     ! local variable
(  452)     real(r8_), dimension(1) :: xres_array, yres_array
(  453) # 454 "interp1.F90"
(  454)     xres_array(1) = xres
(  455)     yres_array    = FINTERP1(x,y,xres_array)
(  456)     yres          = yres_array(1)
(  457) # 458 "interp1.F90"
(  458)   end function interpolate
(  459)     !  #]
(  460)   !------------------------
(  461) END MODULE INTERP1
