


NVFORTRAN (Version     23.1)          02/24/2023  13:57:18      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:57:18      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: TestLexer.F90

(    1) !=================================================
(    2) ! Test lexer.F90 module
(    3) !   2010-08-09   B.Krzeminski     first version
(    4) !=================================================
(    5) 
(    6) program TestLexer
(    7) 
(    8) 
(    9) use lexer, only: &
(   10)     lexer_type, lexer_init, lexer_gettoken, &
(   11)     lexer_ungettoken, tok_real, tok_int, tok_string, &
(   12)     tok_word, tok_newline, tok_eof, lexer_err_ioerr, &
(   13)     lexer_err_msg, ungettoken=>lexer_ungettoken
(   14) 
(   15) use LunManager, only: get_lun, free_lun
(   16) 
(   17) 
(   18) implicit none
(   19) 
(   20) type (lexer_type)   :: s
(   21) integer             :: ios
(   22) integer             :: unit
(   23) 
(   24) 
(   25) unit = get_lun()
(   26) 
(   27) open (unit, file="testinput.TestLexer", status="OLD", action="READ", iostat=ios)
(   28) if (ios /= 0) then
(   29)   print *,"error opening input file; iostat:", ios
(   30)   stop 1






NVFORTRAN (Version     23.1)          02/24/2023  13:57:18      page 3

(   31) endif
(   32) 
(   33) 
(   34) call lexer_init (s, unit)
(   35) 
(   36) 
(   37) write(*,*) "REALACC(1)"
(   38) 
(   39) 
(   40) do
(   41) 
(   42)   call gettoken(s)
(   43) 
(   44) 
(   45)   if (s%token==tok_real .or. s%cval=="NULL") then
(   46)     call ungettoken(s)
(   47)     write(*,*) " "
(   48)     write(*,*) ">> PARSING A BLOCK OF REAL NUMBERS:"
(   49)     write(*,*) " "
(   50)     do
(   51)       call gettoken(s)
(   52)       if (s%token == tok_real) then
(   53)         write(*,*) s%rval
(   54)       else if (s%cval == "NULL") then
(   55)         write(*,*) "missing value"
(   56)       else
(   57)         !end of block
(   58)         call ungettoken(s)
(   59)         exit
(   60)       endif
(   61)     enddo
(   62) 
(   63) 
(   64)   else if (s%cval == "LIST") then
(   65)     write(*,*) " "
(   66)     write(*,*) ">> PARSING COMMA-SEPARATED LIST OF NUMBERS:"
(   67)     write(*,*) " "
(   68)     call gettoken(s)  !skip "="
(   69)     do
(   70)       call gettoken(s)
(   71)       if (s%token == tok_real) then
(   72)         write(*,*) s%rval
(   73)       else if (s%token == tok_int) then
(   74)         write(*,*) s%ival
(   75)       else
(   76)         call parsing_error(s)
(   77)       endif
(   78)       call gettoken(s)
(   79)       if (s%cval /= ",") then
(   80)         call ungettoken(s)
(   81)         exit
(   82)       endif
(   83)     enddo
(   84) 
(   85) 
(   86)   else if (s%cval == "TOKENIZE") then
(   87)     write(*,*) " "
(   88)     write(*,*) ">> TESTING TOKENS:"






NVFORTRAN (Version     23.1)          02/24/2023  13:57:18      page 4

(   89)     write(*,*) " "
(   90)     call gettoken(s)  !skip "{"
(   91)     do
(   92)       call gettoken(s)
(   93)       if (s%cval == "}") exit
(   94)       write(*,"(A8,1X,A15)",advance="no") " lexeme:", adjustl(s%cval)
(   95)       if (s%token == tok_real) then
(   96)         write(*,*) " type: real          value:", s%rval
(   97)       else if (s%token == tok_int) then
(   98)         write(*,*) " type: integer       value:", s%ival
(   99)       else if (s%token == tok_string) then
(  100)         write(*,*) " type: string        value: ", trim(s%sval)
(  101)       else if (s%token == tok_word) then
(  102)         write(*,*) " type: word          value: ", trim(s%cval)
(  103)       else if (s%token == tok_newline) then
(  104)         write(*,*) " type: newline"
(  105)       else if (s%token == tok_eof) then
(  106)         write(*,*) " type: end-of-file"
(  107)       else
(  108)         write(*,*) " type: symbol        value: ", trim(s%cval)
(  109)       endif
(  110)     enddo
(  111) 
(  112) 
(  113)   else if (s%token == tok_eof) then
(  114)     write(*,*) " "
(  115)     write(*,*) ">> END OF FILE"
(  116)     write(*,*) " "
(  117)     exit
(  118) 
(  119) 
(  120)   else
(  121)     call parsing_error(s)
(  122)   endif
(  123) 
(  124) 
(  125) enddo
(  126) 
(  127) 
(  128) write(*,*) "ENDREALACC"
(  129) 
(  130) close(10)
(  131) 
(  132) call free_lun(unit)
(  133) 
(  134) 
(  135) contains
(  136) 
(  137) 
(  138) 
(  139) subroutine parsing_error (s)
(  140)   type (lexer_type) :: s
(  141)   print *,">> PARSE ERROR: "", trim(s%cval), &
(  142)    & "" at line", s%lineno, ", column", s%column
(  143)   stop 1
(  144) end subroutine
(  145) 
(  146) 






NVFORTRAN (Version     23.1)          02/24/2023  13:57:18      page 5

(  147) 
(  148) ! Wrapper for lexer_gettoken() with error handling
(  149) 
(  150) subroutine gettoken(s)
(  151)   type (lexer_type) :: s
(  152)   call lexer_gettoken(s)
(  153)   if (s%err /= 0) then
(  154)     if (s%err == lexer_err_ioerr) then
(  155)       print *, "LEXER ERROR: ", trim(lexer_err_msg(s%err)), ", IOSTAT:", s%iostat
(  156)     else
(  157)       print *, "LEXER ERROR: ", trim(lexer_err_msg(s%err))
(  158)     endif
(  159)     close(s%funit)
(  160)     stop 1
(  161)   endif
(  162) end subroutine
(  163) 
(  164) 
(  165) end program













































NVFORTRAN (Version     23.1)          02/24/2023  13:57:18      page 6

(    1) # 1 "TestLexer.F90"
(    1) !=================================================
(    2) ! Test lexer.F90 module
(    3) !   2010-08-09   B.Krzeminski     first version
(    4) !=================================================
(    5) # 6 "TestLexer.F90"
(    6) program TestLexer
(    7) # 9 "TestLexer.F90"
(    9) use lexer, only: &
(   10)     lexer_type, lexer_init, lexer_gettoken, &
(   11)     lexer_ungettoken, tok_real, tok_int, tok_string, &
(   12)     tok_word, tok_newline, tok_eof, lexer_err_ioerr, &
(   13)     lexer_err_msg, ungettoken=>lexer_ungettoken
(   14) # 15 "TestLexer.F90"
(   15) use LunManager, only: get_lun, free_lun
(   16) # 18 "TestLexer.F90"
(   18) implicit none
(   19) # 20 "TestLexer.F90"
(   20) type (lexer_type)   :: s
(   21) integer             :: ios
(   22) integer             :: unit
(   23) # 25 "TestLexer.F90"
(   25) unit = get_lun()
(   26) # 27 "TestLexer.F90"
(   27) open (unit, file="testinput.TestLexer", status="OLD", action="READ", iostat=ios)
(   28) if (ios /= 0) then
(   29)   print *,"error opening input file; iostat:", ios
(   30)   stop 1
(   31) endif
(   32) # 34 "TestLexer.F90"
(   34) call lexer_init (s, unit)
(   35) # 37 "TestLexer.F90"
(   37) write(*,*) "REALACC(1)"
(   38) # 40 "TestLexer.F90"
(   40) do
(   41) # 42 "TestLexer.F90"
(   42)   call gettoken(s)
(   43) # 45 "TestLexer.F90"
(   45)   if (s%token==tok_real .or. s%cval=="NULL") then
(   46)     call ungettoken(s)
(   47)     write(*,*) " "
(   48)     write(*,*) ">> PARSING A BLOCK OF REAL NUMBERS:"
(   49)     write(*,*) " "
(   50)     do
(   51)       call gettoken(s)
(   52)       if (s%token == tok_real) then
(   53)         write(*,*) s%rval
(   54)       else if (s%cval == "NULL") then
(   55)         write(*,*) "missing value"
(   56)       else
(   57)         !end of block
(   58)         call ungettoken(s)
(   59)         exit
(   60)       endif
(   61)     enddo
(   62) # 64 "TestLexer.F90"
(   64)   else if (s%cval == "LIST") then
(   65)     write(*,*) " "






NVFORTRAN (Version     23.1)          02/24/2023  13:57:18      page 7

(   66)     write(*,*) ">> PARSING COMMA-SEPARATED LIST OF NUMBERS:"
(   67)     write(*,*) " "
(   68)     call gettoken(s)  !skip "="
(   69)     do
(   70)       call gettoken(s)
(   71)       if (s%token == tok_real) then
(   72)         write(*,*) s%rval
(   73)       else if (s%token == tok_int) then
(   74)         write(*,*) s%ival
(   75)       else
(   76)         call parsing_error(s)
(   77)       endif
(   78)       call gettoken(s)
(   79)       if (s%cval /= ",") then
(   80)         call ungettoken(s)
(   81)         exit
(   82)       endif
(   83)     enddo
(   84) # 86 "TestLexer.F90"
(   86)   else if (s%cval == "TOKENIZE") then
(   87)     write(*,*) " "
(   88)     write(*,*) ">> TESTING TOKENS:"
(   89)     write(*,*) " "
(   90)     call gettoken(s)  !skip "{"
(   91)     do
(   92)       call gettoken(s)
(   93)       if (s%cval == "}") exit
(   94)       write(*,"(A8,1X,A15)",advance="no") " lexeme:", adjustl(s%cval)
(   95)       if (s%token == tok_real) then
(   96)         write(*,*) " type: real          value:", s%rval
(   97)       else if (s%token == tok_int) then
(   98)         write(*,*) " type: integer       value:", s%ival
(   99)       else if (s%token == tok_string) then
(  100)         write(*,*) " type: string        value: ", trim(s%sval)
(  101)       else if (s%token == tok_word) then
(  102)         write(*,*) " type: word          value: ", trim(s%cval)
(  103)       else if (s%token == tok_newline) then
(  104)         write(*,*) " type: newline"
(  105)       else if (s%token == tok_eof) then
(  106)         write(*,*) " type: end-of-file"
(  107)       else
(  108)         write(*,*) " type: symbol        value: ", trim(s%cval)
(  109)       endif
(  110)     enddo
(  111) # 113 "TestLexer.F90"
(  113)   else if (s%token == tok_eof) then
(  114)     write(*,*) " "
(  115)     write(*,*) ">> END OF FILE"
(  116)     write(*,*) " "
(  117)     exit
(  118) # 120 "TestLexer.F90"
(  120)   else
(  121)     call parsing_error(s)
(  122)   endif
(  123) # 125 "TestLexer.F90"
(  125) enddo
(  126) # 128 "TestLexer.F90"
(  128) write(*,*) "ENDREALACC"






NVFORTRAN (Version     23.1)          02/24/2023  13:57:18      page 8

(  129) # 130 "TestLexer.F90"
(  130) close(10)
(  131) # 132 "TestLexer.F90"
(  132) call free_lun(unit)
(  133) # 135 "TestLexer.F90"
(  135) contains
(  136) # 139 "TestLexer.F90"
(  139) subroutine parsing_error (s)
(  140)   type (lexer_type) :: s
(  141)   print *,">> PARSE ERROR: "", trim(s%cval), &
(  142)    & "" at line", s%lineno, ", column", s%column
(  143)   stop 1
(  144) end subroutine
(  145) # 148 "TestLexer.F90"
(  148) ! Wrapper for lexer_gettoken() with error handling
(  149) # 150 "TestLexer.F90"
(  150) subroutine gettoken(s)
(  151)   type (lexer_type) :: s
(  152)   call lexer_gettoken(s)
(  153)   if (s%err /= 0) then
(  154)     if (s%err == lexer_err_ioerr) then
(  155)       print *, "LEXER ERROR: ", trim(lexer_err_msg(s%err)), ", IOSTAT:", s%iostat
(  156)     else
(  157)       print *, "LEXER ERROR: ", trim(lexer_err_msg(s%err))
(  158)     endif
(  159)     close(s%funit)
(  160)     stop 1
(  161)   endif
(  162) end subroutine
(  163) # 165 "TestLexer.F90"
(  165) end program
