


NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: arraytools.F90

(    1) MODULE ARRAYTOOLS
(    2)   !  #[ documentation
(    3)   !
(    4)   ! This module contains a handful of functions 
(    5)   ! to create and manipulate arrays
(    6)   !
(    7)   !    Jun 2005 P. Poli     Original version
(    8)   !    Aug 2005 J. de Kloe  adapted to F90 standard
(    9)   ! 25-Jul-2006 J. de Kloe  added some remarks in LUDCMP
(   10)   ! 16-Jan-2008 J. de Kloe  phase out integer kind i_ 
(   11)   ! 08-Feb-2012 J. de Kloe  implement finvert_simple as replacement for
(   12)   !                         FINVERT to avoid possible copyright issues
(   13)   ! 20-Jun-2012 J. de Kloe  delete all numerical recipes code
(   14)   ! 16-Apr-2013 M. Rennie   Add FCENTRED_ARRAY and FCENTRED_ARRAY_NUM
(   15)   !                         for symmetrical arrays around zero
(   16)   ! 15-Aug-2013 M. Rennie   Modify finvert_simple to not 'stop' if
(   17)   !                         problem occurs, but to fill matrix
(   18)   !                         with missing values
(   19)   ! 04-Sep-2013 J. de Kloe  change allocatable array for pointer array
(   20)   !                         to make the code more portable  
(   21)   ! 21-Jan-2014 J. de Kloe  add missing DIFFTOOLIGNORE commands
(   22)   ! 25-Feb-2014 J. de Kloe  relax zero test a little to allow ifort to
(   23)   !                         pass test107 in main as well
(   24)   ! 20-Nov-2014 M. Rennie   Give a warning message if matrix inversion
(   25)   !                         fails
(   26)   ! 16-Feb-2015 M. Rennie   To allow consistent results between gfortran
(   27)   !                         and pgf90, need to relax eps2
(   28)   ! 19-Nov-2015 J. de Kloe  change log levels as suggested by PDGS
(   29)   ! 19-Mar-2018 J. de Kloe  remove hardcoded stop commands
(   30)   !






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 3

(   31)   !  #]
(   32)   !  #[ modules used
(   33)   USE Numerics, only: r8_, missing_indicator_real_r8, missing_real
(   34)   USE ErrorHandler, only: error_programming
(   35)   USE Logging, only: logmsg, log_warn, log_science_warn, log_error, &
(   36)        program_abort
(   37)   !  #]
(   38)   !  #[ variables
(   39)   implicit none
(   40)   !  #]
(   41)   !  #[ interface
(   42) !  INTERFACE
(   43) ! ...
(   44) !     The explicit interface is already defined when using a module,
(   45) !     and specifying it by hand is not needed anymore.
(   46) !     Specifying the interface is only needed when overloading several
(   47) !     routines to a single name, or when specifying an operator.
(   48) !     Specifying them with the same name again is against the F90 standard
(   49) !     and my default compiler (g95) refuses to compile the module
(   50) !     with this interface in it.
(   51) !     Therefore I removed the interface statements (JK).
(   52) ! ...
(   53) !  END INTERFACE
(   54)   !  #]
(   55) CONTAINS
(   56)   !--------
(   57)   FUNCTION FARRAY1(mini,step,n) result(array_out)
(   58)     !  #[ Create a real*8 array of size n, and fill it
(   59)     ! with ascending values, starting with 0.,increasing by "step"
(   60) 
(   61)     ! I/O variables
(   62)     real (r8_),                  intent (in)  :: mini, step
(   63)     integer ,                    intent (in)  :: n
(   64)     real (r8_),    dimension(n)               :: array_out
(   65)     
(   66)     ! local variables
(   67)     integer :: i
(   68)     integer, dimension(:), allocatable :: tabi
(   69)     
(   70)     ! Why this (somewhat) complicated trick with allocate?
(   71)     ! Why not just say, (which saves a lot of memory for large arrays):
(   72)     ! do i=1,n
(   73)     !   array_out(i)=step*(i-1)+mini
(   74)     ! end
(   75)     ! if there is an anvantage in the efficiency of this
(   76)     ! calculation by using the allocated array, a little 
(   77)     ! explanation would be in place here.
(   78) 
(   79)     allocate(tabi(n))
(   80)     do i=1,n
(   81)        tabi(i)=i-1
(   82)     enddo
(   83)     array_out(1:n)=step*tabi(1:n)
(   84)     array_out(1:n)=array_out(1:n)+mini
(   85)     deallocate(tabi)
(   86)     
(   87)   END FUNCTION FARRAY1
(   88)   !  #]






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 4

(   89)   FUNCTION FCENTRED_ARRAY(step,max_val) result(array_out)
(   90)     !  #[ Create a real*8 array of size TBD, centred on zero
(   91)     ! and symmetrical either side of zero, in steps of step
(   92) 
(   93)     ! M. Rennie 16/04/13  Useful for AUX_BRC freq. arrays
(   94) 
(   95)     ! I/O variables
(   96)     real (r8_),                  intent (in)  :: step, max_val
(   97)     real (r8_),    dimension(:), pointer      :: array_out
(   98) 
(   99)     ! local variables
(  100)     integer :: i, n_half, n_total
(  101)     real (r8_) :: temp_val    
(  102) 
(  103)     nullify(array_out)
(  104) 
(  105)     !1.  count how many elements in the array
(  106)     n_half=0
(  107)     temp_val=step
(  108)     !top half of array
(  109)     do while(temp_val .le. max_val)
(  110)       n_half=n_half+1
(  111)       temp_val=temp_val+step
(  112)     end do
(  113) 
(  114)     n_total=2*n_half + 1
(  115) 
(  116)     allocate(array_out(n_total))
(  117) 
(  118)     !create symmetric array of with centre value 0.0
(  119)     array_out(:)=-9999.9_r8_  !missing value for safety
(  120)     array_out(n_half+1)=0.0_r8_  !centre value
(  121)     i=1
(  122)     temp_val=step
(  123)     !fill top half
(  124)     do while(temp_val .le. max_val)
(  125)       array_out(i+n_half+1)=temp_val
(  126)       !update
(  127)       i=i+1
(  128)       temp_val=temp_val+step
(  129)     end do
(  130) 
(  131)     i=0
(  132)     temp_val=-step
(  133)     !fill bottom half
(  134)     do while(temp_val .ge. -max_val)
(  135)       array_out(n_half-i)=temp_val
(  136)       !update
(  137)       i=i+1
(  138)       temp_val=temp_val-step
(  139)     end do
(  140) 
(  141)   END FUNCTION FCENTRED_ARRAY
(  142)   !  #]
(  143)   FUNCTION FCENTRED_ARRAY_NUM(step,max_val) result(n_total)
(  144)     !  #[ Find size of array centred on zero
(  145)     ! and symmetrical either side of zero, in steps of step
(  146) 






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 5

(  147)     ! M. Rennie 16/04/13  Useful for AUX_BRC freq. arrays
(  148) 
(  149)     ! I/O variables
(  150)     real (r8_),                  intent (in)  :: step, max_val
(  151) 
(  152)     ! local variables
(  153)     integer :: n_half, n_total
(  154)     real (r8_) :: temp_val
(  155) 
(  156)     !1.  count how many elements in the array
(  157)     n_half=0
(  158)     temp_val=step
(  159)     !top half of array
(  160)     do while(temp_val .le. max_val)
(  161)       n_half=n_half+1
(  162)       temp_val=temp_val+step
(  163)     end do
(  164) 
(  165)     n_total=2*n_half + 1
(  166) 
(  167)   END FUNCTION FCENTRED_ARRAY_NUM
(  168)   !  #]
(  169)   FUNCTION FCALCN (miny,stepy,maxy) result (n)
(  170)     !  #[ Calculate the size of a matlab-like array [miny:stepy:maxy]
(  171)     !
(  172)     !  15/06/2005  Paul Poli    Original code
(  173) 
(  174)     ! I/O variables
(  175)     real(r8_), intent(in) :: miny,stepy,maxy
(  176)     integer               :: n
(  177)     
(  178)     ! local variables
(  179)     ! none
(  180)     
(  181)     n=floor((maxy-miny)/stepy)
(  182)     n=n+1
(  183)     
(  184)   END FUNCTION FCALCN
(  185)   !  #]
(  186)   FUNCTION FCUMPROD_R(n,tabin) result(tabout)
(  187)     !  #[ Returns the cumulative product of a real*8 array
(  188)     ! History/modifications
(  189)     ! 09/06/2005   Paul Poli, METEO FRANCE    Original code
(  190) 
(  191)     ! I/O variables
(  192)     integer,                 intent (in) :: n
(  193)     real(r8_), dimension(n), intent (in) :: tabin
(  194)     real(r8_), dimension(n)              :: tabout
(  195)     
(  196)     ! local variables
(  197)     integer :: i
(  198)     
(  199)     tabout(1)=tabin(1)
(  200)     if (n>1) then
(  201)        do i=2,n
(  202)           tabout(i)=tabout(i-1)*tabin(i)
(  203)        enddo
(  204)     endif






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 6

(  205)     
(  206)   END FUNCTION FCUMPROD_R
(  207)   !  #]
(  208)   FUNCTION FCUMPROD_C(n,tabin) result(tabout)
(  209)     !  #[ Returns the cumulative product of a complex array
(  210)     ! History/modifications
(  211)     ! 09/06/2005   Paul Poli, METEO FRANCE    Original code
(  212)     
(  213)     ! I/O variables
(  214)     integer,                    intent (in) :: n
(  215)     complex(r8_), dimension(n), intent (in) :: tabin
(  216)     complex(r8_), dimension(n)              :: tabout
(  217)     
(  218)     ! local variables
(  219)     integer :: i
(  220)     
(  221)     tabout(1)=tabin(1)
(  222)     if (n>1) then
(  223)        do i=2,n
(  224)           tabout(i)=tabout(i-1)*tabin(i)
(  225)        enddo
(  226)     endif
(  227)     
(  228)   END FUNCTION FCUMPROD_C
(  229)   !  #]
(  230)   FUNCTION FDIFF_R(n,tabin) result(tabout)
(  231)     !  #[ Return the cumulative diff of the elements in a real*8 array
(  232)     ! History/modifications
(  233)     ! 09/06/2005   Paul Poli, METEO FRANCE    Original code
(  234)     
(  235)     ! I/O variables
(  236)     integer,                   intent (in) :: n
(  237)     real(r8_), dimension(n+1), intent (in) :: tabin
(  238)     real(r8_), dimension(n)                :: tabout
(  239)     
(  240)     ! local variables
(  241)     integer :: i
(  242)     
(  243)     do i=1,n
(  244)        tabout(i)=tabin(i+1)-tabin(i)
(  245)     enddo
(  246)     
(  247)   END FUNCTION FDIFF_R
(  248)   !  #]
(  249)   FUNCTION FDIFF_C(n,tabin) result(tabout)
(  250)     !  #[ Return the cumulative diff of the elements in a complex array
(  251)     ! History/modifications
(  252)     ! 09/06/2005   Paul Poli, METEO FRANCE    Original code
(  253) 
(  254)     ! I/O variables
(  255)     integer,                      intent (in) :: n
(  256)     complex(r8_), dimension(n+1), intent (in) :: tabin
(  257)     complex(r8_), dimension(n)                :: tabout
(  258)     
(  259)     ! local variables
(  260)     integer :: i
(  261) 
(  262)     do i=1,n






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 7

(  263)        tabout(i)=tabin(i+1)-tabin(i)
(  264)     enddo
(  265) 
(  266)   END FUNCTION FDIFF_C
(  267)   !  #]
(  268)   function almost_zero(x,eps) result(alm_zero)
(  269)     !  #[
(  270)     real(r8_), intent(in) :: x,eps
(  271)     logical               :: alm_zero ! result
(  272) 
(  273)     alm_zero = .false.
(  274)     if (abs(x) .lt. eps) alm_zero = .true.
(  275)     
(  276)   end function almost_zero
(  277)     !  #]
(  278)   function vector_almost_zero(v,eps) result(alm_zero)
(  279)     !  #[
(  280)     real(r8_), dimension(:), intent(in) :: v
(  281)     real(r8_), intent(in) :: eps
(  282)     logical               :: alm_zero ! result
(  283) 
(  284)     ! local variables
(  285)     integer :: i
(  286)     logical :: non_zero_found
(  287) 
(  288)     non_zero_found = .false.
(  289)     do i=1,size(v)
(  290)        if (.not. almost_zero(v(i),eps)) non_zero_found = .true.
(  291)     end do
(  292) 
(  293)     alm_zero = .true.
(  294)     if (non_zero_found) alm_zero = .false.
(  295) 
(  296)   end function vector_almost_zero
(  297)     !  #]
(  298)   function finvert_simple(m) result(m_inv)
(  299)     !  #[ Matrix inversion
(  300)     ! A routine to invert a square matrix as alternative to the
(  301)     ! code from Num. Recipes that we used here before.
(  302)     !
(  303)     ! This code was written from scratch based only on basic 1st year 
(  304)     ! linear algebra. This method is at least 2000 years old, no no
(  305)     ! problems on copyrights or patents expected here ....
(  306)     ! (see for example
(  307)     ! http://en.wikipedia.org/wiki/Gaussian_elimination)
(  308)     ! Maybe not the fastest and efficient way to do it, but for our purposes
(  309)     ! it works just fine.
(  310)     !
(  311)     ! Written by J. de Kloe, KNMI, 2012.
(  312) 
(  313)     real(r8_), dimension(:,:), intent(in) :: m
(  314)     real(r8_), dimension(lbound(m,1):ubound(m,1), &
(  315)                          lbound(m,2):ubound(m,2)) :: m_inv
(  316) 
(  317)     ! local variables
(  318)     real(r8_), dimension(lbound(m,1):ubound(m,1), &
(  319)                          lbound(m,2):ubound(m,2)) :: m_copy
(  320)     real(r8_), dimension(lbound(m,1):ubound(m,1)) :: vec






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 8

(  321) 
(  322)     real(r8_) :: factor, s
(  323)     integer :: i, j, largest_i !, i2, j2
(  324)     integer :: n ! size of m and m_inv
(  325) 
(  326)     ! used in almost zero check on input matrix elements
(  327)     real(r8_), parameter :: eps1 = 1.e-99_r8_
(  328)     ! used inalmost zero check on m*m_inv result
(  329)     real(r8_), parameter :: eps2 = 1.e-5_r8_
(  330) 
(  331)     ! 1) assumes input matrix is square
(  332)     ! 2) assumes input matrix can be inverted
(  333)     
(  334)     n = size(m,1)
(  335)     ! debug print and stop
(  336)     !print *,"n=",n
(  337)     !stop 127
(  338) 
(  339)     if (size(m,2) .ne. n) then
(  340)        call logmsg(log_error, &
(  341)             'ERROR in finvert_simple: input matrix must be square!')
(  342)        call program_abort(error_programming, "finvert_simple")
(  343)     end if
(  344) 
(  345)     m_copy(:,:) = m(:,:)
(  346) 
(  347)     ! init m_inv
(  348)     m_inv(:,:) = 0._r8_
(  349)     do i=1,n
(  350)        m_inv(i,i) = 1._r8_
(  351)     end do
(  352)     
(  353)     ! do Gaussian elimination to find a triangular form.
(  354)     do i=1,n
(  355) 
(  356)        ! double check
(  357)        if (vector_almost_zero(m_copy(i,:),eps1)) then
(  358)           call logmsg(log_error, &
(  359)                'ERROR in finvert_simple: solving not possible')
(  360)           call program_abort(error_programming, "finvert_simple")
(  361)        end if
(  362) 
(  363)        if (almost_zero(m_copy(i,i), eps1)) then
(  364)           ! replace with a lower row
(  365)           ! switch rows if the largest is not at location i
(  366)           largest_i = i-1+maxloc(m_copy(i:n,i),1)
(  367)           if (largest_i .ne. i) then
(  368)              ! print *,"switching rows: ",i," and ",largest_i
(  369)              vec(:) = m_copy(i,:)
(  370)              m_copy(i,:) = m_copy(largest_i,:)
(  371)              m_copy(largest_i,:) = vec(:)
(  372)              vec(:) = m_inv(i,:)
(  373)              m_inv(i,:) = m_inv(largest_i,:)
(  374)              m_inv(largest_i,:) = vec(:)
(  375)           end if
(  376)        end if
(  377) 
(  378)        ! double check to ensure m_copy(i,i) is not zero now






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 9

(  379)        if (almost_zero(m_copy(i,i),eps1)) then
(  380)           call logmsg(log_error, &
(  381)                'ERROR in finvert_simple: solving not possible')
(  382)           call program_abort(error_programming, "finvert_simple")
(  383)        end if
(  384) 
(  385)        factor = 1._r8_/m_copy(i,i)
(  386)        m_copy(i,:) = factor*m_copy(i,:)
(  387)        m_inv(i,:) = factor*m_inv(i,:)
(  388) 
(  389)        ! subtract this row from all rows below if needed
(  390)        do j=i+1,n
(  391)           if (.not. almost_zero(m_copy(j,i),eps1)) then
(  392)              factor = m_copy(j,i)/m_copy(i,i)
(  393)              m_copy(j,:) = m_copy(j,:) - factor*m_copy(i,:)
(  394)              m_inv(j,:)  = m_inv(j,:)  - factor*m_inv(i,:)
(  395)           end if
(  396) 
(  397)        end do
(  398) 
(  399)        !do i2=1,n
(  400)        !   print *,'(',(m_copy(i2,j),' ',j=1,n),'|',(m_inv(i2,j),' ',j=1,n),')'
(  401)        !end do
(  402) 
(  403)     end do
(  404) 
(  405)     ! now do back-substitution to find the inverse
(  406)     do i=n,1,-1
(  407)        if (almost_zero(m_copy(i,i), eps1)) then
(  408)           call logmsg(log_error, &
(  409)                'ERROR in finvert_simple: solving not possible')
(  410)           call program_abort(error_programming, "finvert_simple")
(  411)        end if
(  412) 
(  413)        ! subtract this row from all rows above if needed
(  414)        do j=1,i-1
(  415)           if (.not. almost_zero(m_copy(j,i),eps1)) then
(  416)              factor = m_copy(j,i)/m_copy(i,i)
(  417)              m_copy(j,:) = m_copy(j,:) - factor*m_copy(i,:)
(  418)              m_inv(j,:) = m_inv(j,:) - factor*m_inv(i,:)
(  419)           end if
(  420)           
(  421)        end do
(  422) 
(  423)        !do i2=1,n
(  424)        !   print *,'(',(m_copy(i2,j),' ',j=1,n),'|',(m_inv(i2,j),' ',j=1,n),')'
(  425)        !end do
(  426)     end do
(  427) 
(  428)     ! double check: invert both matrices and ensure the result is I
(  429)     do i=1,n
(  430)        do j=1,n
(  431)           s=0._r8_
(  432)           s = sum(m(i,:)*m_inv(:,j))
(  433)           if (i .eq. j) then
(  434)              ! verify 1
(  435)              if (.not. almost_zero(s-1._r8_,eps2)) then
(  436)                 ! numerical output here may be anything






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 10

(  437)                 ! (numbers in a wide range of order of magnitudes may
(  438)                 ! occur here. Values pf 1.6e-10 upto 4.5e43 have been
(  439)                 ! observed to occur sometimes!)
(  440)                 ! so it is absolutely not usefull to try and compare this
(  441)                 ! to some expected value.
(  442)                 !print *,"DIFFTOOLIGNORE"
(  443)                 !print *,"s-1._r8_",s-1._r8_
(  444)                 !print *,"Matrix inversion failed ..."
(  445)                 !print *,"diagonal element of m*m_inv is not close to one:"
(  446)                 !print *,"i,j,value = ",i,j,s
(  447)                 !print *,"Filling with missing values"
(  448)                 !print *,"DIFFTOOLENDIGNORE"
(  449)                 call logmsg(log_science_warn, &
(  450)                      "Matrix inversion failed (verify 1), "//&
(  451)                      "returning a missing value")
(  452) 
(  453)                 m_inv(:,:)=missing_indicator_real_r8
(  454)                 return
(  455)              end if
(  456)           else
(  457)              ! verify 0
(  458)              if (.not. almost_zero(s,eps2)) then
(  459)                 ! numerical output here may be anything
(  460)                 ! (numbers in a wide range of order of magnitudes may
(  461)                 ! occur here. Values pf 1.6e-10 upto 4.5e43 have been
(  462)                 ! observed to occur sometimes!)
(  463)                 ! so it is absolutely not usefull to try and compare this
(  464)                 ! to some expected value.
(  465)                 !print *,"DIFFTOOLIGNORE"
(  466)                 !print *,"s",s
(  467)                 !print *,"Matrix inversion failed ..."
(  468)                 !print *,"(non-diagonal element of m*m_inv is not close to zero"
(  469)                 !print *,"i,j,value = ",i,j,s
(  470)                 !print *,"Filling with missing values"
(  471)                 !print *,"DIFFTOOLENDIGNORE"
(  472) 
(  473)                 call logmsg(log_science_warn, &
(  474)                      "Matrix inversion failed (verify 0), "//&
(  475)                      "returning a missing value")
(  476) 
(  477)                 m_inv(:,:)=missing_indicator_real_r8
(  478)                 return
(  479)              end if
(  480)           end if
(  481)        end do
(  482)     end do
(  483) 
(  484)   end function finvert_simple
(  485)     !  #]
(  486)   FUNCTION FSIGN(x) result(y)
(  487)     !  #[ Function which returns the sign of the argument
(  488)     !
(  489)     ! 2005 Paul Poli   Original version
(  490) 
(  491)     ! isn't there a standard fortran function for this?
(  492) 
(  493)     ! I/O variables
(  494)     real(r8_), intent(in) :: x






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 11

(  495)     real(r8_)             :: y
(  496)     
(  497)     IF (x.gt.0._r8_) THEN
(  498)        y=1._r8_
(  499)     ELSE
(  500)        IF (x.lt.0._r8_) THEN
(  501)           y=-1._r8_
(  502)        ELSE
(  503)           y=0._r8_
(  504)        ENDIF
(  505)     ENDIF
(  506)        
(  507)   END FUNCTION FSIGN
(  508)   !  #]
(  509)   !--------
(  510) END MODULE ARRAYTOOLS
(  511) 















































NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 12

(    1) # 1 "arraytools.F90"
(    1) MODULE ARRAYTOOLS
(    2)   !  #[ documentation
(    3)   !
(    4)   ! This module contains a handful of functions 
(    5)   ! to create and manipulate arrays
(    6)   !
(    7)   !    Jun 2005 P. Poli     Original version
(    8)   !    Aug 2005 J. de Kloe  adapted to F90 standard
(    9)   ! 25-Jul-2006 J. de Kloe  added some remarks in LUDCMP
(   10)   ! 16-Jan-2008 J. de Kloe  phase out integer kind i_ 
(   11)   ! 08-Feb-2012 J. de Kloe  implement finvert_simple as replacement for
(   12)   !                         FINVERT to avoid possible copyright issues
(   13)   ! 20-Jun-2012 J. de Kloe  delete all numerical recipes code
(   14)   ! 16-Apr-2013 M. Rennie   Add FCENTRED_ARRAY and FCENTRED_ARRAY_NUM
(   15)   !                         for symmetrical arrays around zero
(   16)   ! 15-Aug-2013 M. Rennie   Modify finvert_simple to not 'stop' if
(   17)   !                         problem occurs, but to fill matrix
(   18)   !                         with missing values
(   19)   ! 04-Sep-2013 J. de Kloe  change allocatable array for pointer array
(   20)   !                         to make the code more portable  
(   21)   ! 21-Jan-2014 J. de Kloe  add missing DIFFTOOLIGNORE commands
(   22)   ! 25-Feb-2014 J. de Kloe  relax zero test a little to allow ifort to
(   23)   !                         pass test107 in main as well
(   24)   ! 20-Nov-2014 M. Rennie   Give a warning message if matrix inversion
(   25)   !                         fails
(   26)   ! 16-Feb-2015 M. Rennie   To allow consistent results between gfortran
(   27)   !                         and pgf90, need to relax eps2
(   28)   ! 19-Nov-2015 J. de Kloe  change log levels as suggested by PDGS
(   29)   ! 19-Mar-2018 J. de Kloe  remove hardcoded stop commands
(   30)   !
(   31)   !  #]
(   32)   !  #[ modules used
(   33)   USE Numerics, only: r8_, missing_indicator_real_r8, missing_real
(   34)   USE ErrorHandler, only: error_programming
(   35)   USE Logging, only: logmsg, log_warn, log_science_warn, log_error, &
(   36)        program_abort
(   37)   !  #]
(   38)   !  #[ variables
(   39)   implicit none
(   40)   !  #]
(   41)   !  #[ interface
(   42) !  INTERFACE
(   43) ! ...
(   44) !     The explicit interface is already defined when using a module,
(   45) !     and specifying it by hand is not needed anymore.
(   46) !     Specifying the interface is only needed when overloading several
(   47) !     routines to a single name, or when specifying an operator.
(   48) !     Specifying them with the same name again is against the F90 standard
(   49) !     and my default compiler (g95) refuses to compile the module
(   50) !     with this interface in it.
(   51) !     Therefore I removed the interface statements (JK).
(   52) ! ...
(   53) !  END INTERFACE
(   54)   !  #]
(   55) CONTAINS
(   56)   !--------
(   57)   FUNCTION FARRAY1(mini,step,n) result(array_out)






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 13

(   58)     !  #[ Create a real*8 array of size n, and fill it
(   59)     ! with ascending values, starting with 0.,increasing by "step"
(   60) # 61 "arraytools.F90"
(   61)     ! I/O variables
(   62)     real (r8_),                  intent (in)  :: mini, step
(   63)     integer ,                    intent (in)  :: n
(   64)     real (r8_),    dimension(n)               :: array_out
(   65)     
(   66)     ! local variables
(   67)     integer :: i
(   68)     integer, dimension(:), allocatable :: tabi
(   69)     
(   70)     ! Why this (somewhat) complicated trick with allocate?
(   71)     ! Why not just say, (which saves a lot of memory for large arrays):
(   72)     ! do i=1,n
(   73)     !   array_out(i)=step*(i-1)+mini
(   74)     ! end
(   75)     ! if there is an anvantage in the efficiency of this
(   76)     ! calculation by using the allocated array, a little 
(   77)     ! explanation would be in place here.
(   78) # 79 "arraytools.F90"
(   79)     allocate(tabi(n))
(   80)     do i=1,n
(   81)        tabi(i)=i-1
(   82)     enddo
(   83)     array_out(1:n)=step*tabi(1:n)
(   84)     array_out(1:n)=array_out(1:n)+mini
(   85)     deallocate(tabi)
(   86)     
(   87)   END FUNCTION FARRAY1
(   88)   !  #]
(   89)   FUNCTION FCENTRED_ARRAY(step,max_val) result(array_out)
(   90)     !  #[ Create a real*8 array of size TBD, centred on zero
(   91)     ! and symmetrical either side of zero, in steps of step
(   92) # 93 "arraytools.F90"
(   93)     ! M. Rennie 16/04/13  Useful for AUX_BRC freq. arrays
(   94) # 95 "arraytools.F90"
(   95)     ! I/O variables
(   96)     real (r8_),                  intent (in)  :: step, max_val
(   97)     real (r8_),    dimension(:), pointer      :: array_out
(   98) # 99 "arraytools.F90"
(   99)     ! local variables
(  100)     integer :: i, n_half, n_total
(  101)     real (r8_) :: temp_val    
(  102) # 103 "arraytools.F90"
(  103)     nullify(array_out)
(  104) # 105 "arraytools.F90"
(  105)     !1.  count how many elements in the array
(  106)     n_half=0
(  107)     temp_val=step
(  108)     !top half of array
(  109)     do while(temp_val .le. max_val)
(  110)       n_half=n_half+1
(  111)       temp_val=temp_val+step
(  112)     end do
(  113) # 114 "arraytools.F90"
(  114)     n_total=2*n_half + 1
(  115) # 116 "arraytools.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 14

(  116)     allocate(array_out(n_total))
(  117) # 118 "arraytools.F90"
(  118)     !create symmetric array of with centre value 0.0
(  119)     array_out(:)=-9999.9_r8_  !missing value for safety
(  120)     array_out(n_half+1)=0.0_r8_  !centre value
(  121)     i=1
(  122)     temp_val=step
(  123)     !fill top half
(  124)     do while(temp_val .le. max_val)
(  125)       array_out(i+n_half+1)=temp_val
(  126)       !update
(  127)       i=i+1
(  128)       temp_val=temp_val+step
(  129)     end do
(  130) # 131 "arraytools.F90"
(  131)     i=0
(  132)     temp_val=-step
(  133)     !fill bottom half
(  134)     do while(temp_val .ge. -max_val)
(  135)       array_out(n_half-i)=temp_val
(  136)       !update
(  137)       i=i+1
(  138)       temp_val=temp_val-step
(  139)     end do
(  140) # 141 "arraytools.F90"
(  141)   END FUNCTION FCENTRED_ARRAY
(  142)   !  #]
(  143)   FUNCTION FCENTRED_ARRAY_NUM(step,max_val) result(n_total)
(  144)     !  #[ Find size of array centred on zero
(  145)     ! and symmetrical either side of zero, in steps of step
(  146) # 147 "arraytools.F90"
(  147)     ! M. Rennie 16/04/13  Useful for AUX_BRC freq. arrays
(  148) # 149 "arraytools.F90"
(  149)     ! I/O variables
(  150)     real (r8_),                  intent (in)  :: step, max_val
(  151) # 152 "arraytools.F90"
(  152)     ! local variables
(  153)     integer :: n_half, n_total
(  154)     real (r8_) :: temp_val
(  155) # 156 "arraytools.F90"
(  156)     !1.  count how many elements in the array
(  157)     n_half=0
(  158)     temp_val=step
(  159)     !top half of array
(  160)     do while(temp_val .le. max_val)
(  161)       n_half=n_half+1
(  162)       temp_val=temp_val+step
(  163)     end do
(  164) # 165 "arraytools.F90"
(  165)     n_total=2*n_half + 1
(  166) # 167 "arraytools.F90"
(  167)   END FUNCTION FCENTRED_ARRAY_NUM
(  168)   !  #]
(  169)   FUNCTION FCALCN (miny,stepy,maxy) result (n)
(  170)     !  #[ Calculate the size of a matlab-like array [miny:stepy:maxy]
(  171)     !
(  172)     !  15/06/2005  Paul Poli    Original code
(  173) # 174 "arraytools.F90"






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 15

(  174)     ! I/O variables
(  175)     real(r8_), intent(in) :: miny,stepy,maxy
(  176)     integer               :: n
(  177)     
(  178)     ! local variables
(  179)     ! none
(  180)     
(  181)     n=floor((maxy-miny)/stepy)
(  182)     n=n+1
(  183)     
(  184)   END FUNCTION FCALCN
(  185)   !  #]
(  186)   FUNCTION FCUMPROD_R(n,tabin) result(tabout)
(  187)     !  #[ Returns the cumulative product of a real*8 array
(  188)     ! History/modifications
(  189)     ! 09/06/2005   Paul Poli, METEO FRANCE    Original code
(  190) # 191 "arraytools.F90"
(  191)     ! I/O variables
(  192)     integer,                 intent (in) :: n
(  193)     real(r8_), dimension(n), intent (in) :: tabin
(  194)     real(r8_), dimension(n)              :: tabout
(  195)     
(  196)     ! local variables
(  197)     integer :: i
(  198)     
(  199)     tabout(1)=tabin(1)
(  200)     if (n>1) then
(  201)        do i=2,n
(  202)           tabout(i)=tabout(i-1)*tabin(i)
(  203)        enddo
(  204)     endif
(  205)     
(  206)   END FUNCTION FCUMPROD_R
(  207)   !  #]
(  208)   FUNCTION FCUMPROD_C(n,tabin) result(tabout)
(  209)     !  #[ Returns the cumulative product of a complex array
(  210)     ! History/modifications
(  211)     ! 09/06/2005   Paul Poli, METEO FRANCE    Original code
(  212)     
(  213)     ! I/O variables
(  214)     integer,                    intent (in) :: n
(  215)     complex(r8_), dimension(n), intent (in) :: tabin
(  216)     complex(r8_), dimension(n)              :: tabout
(  217)     
(  218)     ! local variables
(  219)     integer :: i
(  220)     
(  221)     tabout(1)=tabin(1)
(  222)     if (n>1) then
(  223)        do i=2,n
(  224)           tabout(i)=tabout(i-1)*tabin(i)
(  225)        enddo
(  226)     endif
(  227)     
(  228)   END FUNCTION FCUMPROD_C
(  229)   !  #]
(  230)   FUNCTION FDIFF_R(n,tabin) result(tabout)
(  231)     !  #[ Return the cumulative diff of the elements in a real*8 array






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 16

(  232)     ! History/modifications
(  233)     ! 09/06/2005   Paul Poli, METEO FRANCE    Original code
(  234)     
(  235)     ! I/O variables
(  236)     integer,                   intent (in) :: n
(  237)     real(r8_), dimension(n+1), intent (in) :: tabin
(  238)     real(r8_), dimension(n)                :: tabout
(  239)     
(  240)     ! local variables
(  241)     integer :: i
(  242)     
(  243)     do i=1,n
(  244)        tabout(i)=tabin(i+1)-tabin(i)
(  245)     enddo
(  246)     
(  247)   END FUNCTION FDIFF_R
(  248)   !  #]
(  249)   FUNCTION FDIFF_C(n,tabin) result(tabout)
(  250)     !  #[ Return the cumulative diff of the elements in a complex array
(  251)     ! History/modifications
(  252)     ! 09/06/2005   Paul Poli, METEO FRANCE    Original code
(  253) # 254 "arraytools.F90"
(  254)     ! I/O variables
(  255)     integer,                      intent (in) :: n
(  256)     complex(r8_), dimension(n+1), intent (in) :: tabin
(  257)     complex(r8_), dimension(n)                :: tabout
(  258)     
(  259)     ! local variables
(  260)     integer :: i
(  261) # 262 "arraytools.F90"
(  262)     do i=1,n
(  263)        tabout(i)=tabin(i+1)-tabin(i)
(  264)     enddo
(  265) # 266 "arraytools.F90"
(  266)   END FUNCTION FDIFF_C
(  267)   !  #]
(  268)   function almost_zero(x,eps) result(alm_zero)
(  269)     !  #[
(  270)     real(r8_), intent(in) :: x,eps
(  271)     logical               :: alm_zero ! result
(  272) # 273 "arraytools.F90"
(  273)     alm_zero = .false.
(  274)     if (abs(x) .lt. eps) alm_zero = .true.
(  275)     
(  276)   end function almost_zero
(  277)     !  #]
(  278)   function vector_almost_zero(v,eps) result(alm_zero)
(  279)     !  #[
(  280)     real(r8_), dimension(:), intent(in) :: v
(  281)     real(r8_), intent(in) :: eps
(  282)     logical               :: alm_zero ! result
(  283) # 284 "arraytools.F90"
(  284)     ! local variables
(  285)     integer :: i
(  286)     logical :: non_zero_found
(  287) # 288 "arraytools.F90"
(  288)     non_zero_found = .false.
(  289)     do i=1,size(v)






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 17

(  290)        if (.not. almost_zero(v(i),eps)) non_zero_found = .true.
(  291)     end do
(  292) # 293 "arraytools.F90"
(  293)     alm_zero = .true.
(  294)     if (non_zero_found) alm_zero = .false.
(  295) # 296 "arraytools.F90"
(  296)   end function vector_almost_zero
(  297)     !  #]
(  298)   function finvert_simple(m) result(m_inv)
(  299)     !  #[ Matrix inversion
(  300)     ! A routine to invert a square matrix as alternative to the
(  301)     ! code from Num. Recipes that we used here before.
(  302)     !
(  303)     ! This code was written from scratch based only on basic 1st year 
(  304)     ! linear algebra. This method is at least 2000 years old, no no
(  305)     ! problems on copyrights or patents expected here ....
(  306)     ! (see for example
(  307)     ! http://en.wikipedia.org/wiki/Gaussian_elimination)
(  308)     ! Maybe not the fastest and efficient way to do it, but for our purposes
(  309)     ! it works just fine.
(  310)     !
(  311)     ! Written by J. de Kloe, KNMI, 2012.
(  312) # 313 "arraytools.F90"
(  313)     real(r8_), dimension(:,:), intent(in) :: m
(  314)     real(r8_), dimension(lbound(m,1):ubound(m,1), &
(  315)                          lbound(m,2):ubound(m,2)) :: m_inv
(  316) # 317 "arraytools.F90"
(  317)     ! local variables
(  318)     real(r8_), dimension(lbound(m,1):ubound(m,1), &
(  319)                          lbound(m,2):ubound(m,2)) :: m_copy
(  320)     real(r8_), dimension(lbound(m,1):ubound(m,1)) :: vec
(  321) # 322 "arraytools.F90"
(  322)     real(r8_) :: factor, s
(  323)     integer :: i, j, largest_i !, i2, j2
(  324)     integer :: n ! size of m and m_inv
(  325) # 326 "arraytools.F90"
(  326)     ! used in almost zero check on input matrix elements
(  327)     real(r8_), parameter :: eps1 = 1.e-99_r8_
(  328)     ! used inalmost zero check on m*m_inv result
(  329)     real(r8_), parameter :: eps2 = 1.e-5_r8_
(  330) # 331 "arraytools.F90"
(  331)     ! 1) assumes input matrix is square
(  332)     ! 2) assumes input matrix can be inverted
(  333)     
(  334)     n = size(m,1)
(  335)     ! debug print and stop
(  336)     !print *,"n=",n
(  337)     !stop 127
(  338) # 339 "arraytools.F90"
(  339)     if (size(m,2) .ne. n) then
(  340)        call logmsg(log_error, &
(  341)             'ERROR in finvert_simple: input matrix must be square!')
(  342)        call program_abort(error_programming, "finvert_simple")
(  343)     end if
(  344) # 345 "arraytools.F90"
(  345)     m_copy(:,:) = m(:,:)
(  346) # 347 "arraytools.F90"
(  347)     ! init m_inv






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 18

(  348)     m_inv(:,:) = 0._r8_
(  349)     do i=1,n
(  350)        m_inv(i,i) = 1._r8_
(  351)     end do
(  352)     
(  353)     ! do Gaussian elimination to find a triangular form.
(  354)     do i=1,n
(  355) # 356 "arraytools.F90"
(  356)        ! double check
(  357)        if (vector_almost_zero(m_copy(i,:),eps1)) then
(  358)           call logmsg(log_error, &
(  359)                'ERROR in finvert_simple: solving not possible')
(  360)           call program_abort(error_programming, "finvert_simple")
(  361)        end if
(  362) # 363 "arraytools.F90"
(  363)        if (almost_zero(m_copy(i,i), eps1)) then
(  364)           ! replace with a lower row
(  365)           ! switch rows if the largest is not at location i
(  366)           largest_i = i-1+maxloc(m_copy(i:n,i),1)
(  367)           if (largest_i .ne. i) then
(  368)              ! print *,"switching rows: ",i," and ",largest_i
(  369)              vec(:) = m_copy(i,:)
(  370)              m_copy(i,:) = m_copy(largest_i,:)
(  371)              m_copy(largest_i,:) = vec(:)
(  372)              vec(:) = m_inv(i,:)
(  373)              m_inv(i,:) = m_inv(largest_i,:)
(  374)              m_inv(largest_i,:) = vec(:)
(  375)           end if
(  376)        end if
(  377) # 378 "arraytools.F90"
(  378)        ! double check to ensure m_copy(i,i) is not zero now
(  379)        if (almost_zero(m_copy(i,i),eps1)) then
(  380)           call logmsg(log_error, &
(  381)                'ERROR in finvert_simple: solving not possible')
(  382)           call program_abort(error_programming, "finvert_simple")
(  383)        end if
(  384) # 385 "arraytools.F90"
(  385)        factor = 1._r8_/m_copy(i,i)
(  386)        m_copy(i,:) = factor*m_copy(i,:)
(  387)        m_inv(i,:) = factor*m_inv(i,:)
(  388) # 389 "arraytools.F90"
(  389)        ! subtract this row from all rows below if needed
(  390)        do j=i+1,n
(  391)           if (.not. almost_zero(m_copy(j,i),eps1)) then
(  392)              factor = m_copy(j,i)/m_copy(i,i)
(  393)              m_copy(j,:) = m_copy(j,:) - factor*m_copy(i,:)
(  394)              m_inv(j,:)  = m_inv(j,:)  - factor*m_inv(i,:)
(  395)           end if
(  396) # 397 "arraytools.F90"
(  397)        end do
(  398) # 399 "arraytools.F90"
(  399)        !do i2=1,n
(  400)        !   print *,'(',(m_copy(i2,j),' ',j=1,n),'|',(m_inv(i2,j),' ',j=1,n),')'
(  401)        !end do
(  402) # 403 "arraytools.F90"
(  403)     end do
(  404) # 405 "arraytools.F90"
(  405)     ! now do back-substitution to find the inverse






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 19

(  406)     do i=n,1,-1
(  407)        if (almost_zero(m_copy(i,i), eps1)) then
(  408)           call logmsg(log_error, &
(  409)                'ERROR in finvert_simple: solving not possible')
(  410)           call program_abort(error_programming, "finvert_simple")
(  411)        end if
(  412) # 413 "arraytools.F90"
(  413)        ! subtract this row from all rows above if needed
(  414)        do j=1,i-1
(  415)           if (.not. almost_zero(m_copy(j,i),eps1)) then
(  416)              factor = m_copy(j,i)/m_copy(i,i)
(  417)              m_copy(j,:) = m_copy(j,:) - factor*m_copy(i,:)
(  418)              m_inv(j,:) = m_inv(j,:) - factor*m_inv(i,:)
(  419)           end if
(  420)           
(  421)        end do
(  422) # 423 "arraytools.F90"
(  423)        !do i2=1,n
(  424)        !   print *,'(',(m_copy(i2,j),' ',j=1,n),'|',(m_inv(i2,j),' ',j=1,n),')'
(  425)        !end do
(  426)     end do
(  427) # 428 "arraytools.F90"
(  428)     ! double check: invert both matrices and ensure the result is I
(  429)     do i=1,n
(  430)        do j=1,n
(  431)           s=0._r8_
(  432)           s = sum(m(i,:)*m_inv(:,j))
(  433)           if (i .eq. j) then
(  434)              ! verify 1
(  435)              if (.not. almost_zero(s-1._r8_,eps2)) then
(  436)                 ! numerical output here may be anything
(  437)                 ! (numbers in a wide range of order of magnitudes may
(  438)                 ! occur here. Values pf 1.6e-10 upto 4.5e43 have been
(  439)                 ! observed to occur sometimes!)
(  440)                 ! so it is absolutely not usefull to try and compare this
(  441)                 ! to some expected value.
(  442)                 !print *,"DIFFTOOLIGNORE"
(  443)                 !print *,"s-1._r8_",s-1._r8_
(  444)                 !print *,"Matrix inversion failed ..."
(  445)                 !print *,"diagonal element of m*m_inv is not close to one:"
(  446)                 !print *,"i,j,value = ",i,j,s
(  447)                 !print *,"Filling with missing values"
(  448)                 !print *,"DIFFTOOLENDIGNORE"
(  449)                 call logmsg(log_science_warn, &
(  450)                      "Matrix inversion failed (verify 1), "//&
(  451)                      "returning a missing value")
(  452) # 453 "arraytools.F90"
(  453)                 m_inv(:,:)=missing_indicator_real_r8
(  454)                 return
(  455)              end if
(  456)           else
(  457)              ! verify 0
(  458)              if (.not. almost_zero(s,eps2)) then
(  459)                 ! numerical output here may be anything
(  460)                 ! (numbers in a wide range of order of magnitudes may
(  461)                 ! occur here. Values pf 1.6e-10 upto 4.5e43 have been
(  462)                 ! observed to occur sometimes!)
(  463)                 ! so it is absolutely not usefull to try and compare this






NVFORTRAN (Version     23.1)          02/24/2023  13:58:46      page 20

(  464)                 ! to some expected value.
(  465)                 !print *,"DIFFTOOLIGNORE"
(  466)                 !print *,"s",s
(  467)                 !print *,"Matrix inversion failed ..."
(  468)                 !print *,"(non-diagonal element of m*m_inv is not close to zero"
(  469)                 !print *,"i,j,value = ",i,j,s
(  470)                 !print *,"Filling with missing values"
(  471)                 !print *,"DIFFTOOLENDIGNORE"
(  472) # 473 "arraytools.F90"
(  473)                 call logmsg(log_science_warn, &
(  474)                      "Matrix inversion failed (verify 0), "//&
(  475)                      "returning a missing value")
(  476) # 477 "arraytools.F90"
(  477)                 m_inv(:,:)=missing_indicator_real_r8
(  478)                 return
(  479)              end if
(  480)           end if
(  481)        end do
(  482)     end do
(  483) # 484 "arraytools.F90"
(  484)   end function finvert_simple
(  485)     !  #]
(  486)   FUNCTION FSIGN(x) result(y)
(  487)     !  #[ Function which returns the sign of the argument
(  488)     !
(  489)     ! 2005 Paul Poli   Original version
(  490) # 491 "arraytools.F90"
(  491)     ! isn't there a standard fortran function for this?
(  492) # 493 "arraytools.F90"
(  493)     ! I/O variables
(  494)     real(r8_), intent(in) :: x
(  495)     real(r8_)             :: y
(  496)     
(  497)     IF (x.gt.0._r8_) THEN
(  498)        y=1._r8_
(  499)     ELSE
(  500)        IF (x.lt.0._r8_) THEN
(  501)           y=-1._r8_
(  502)        ELSE
(  503)           y=0._r8_
(  504)        ENDIF
(  505)     ENDIF
(  506)        
(  507)   END FUNCTION FSIGN
(  508)   !  #]
(  509)   !--------
(  510) END MODULE ARRAYTOOLS
