


NVFORTRAN (Version     23.1)          02/24/2023  13:32:51      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir .D[1]
          -idir .D[2]
          -idir .D[3]
          -idir .D[4]
          -idir .D[5]
          -idir .D[6]
          -idir .D[7]
          -idir .D[8]
          -idir .D[9]
          -idir .D[10]
          -idir .D[11]
          -idir .D[12]
          -idir .D[13]
          -idir .D[14]
          -idir .D[15]
          -idir .D[16]
          -idir .D[17]
          -idir .D[18]
          -idir .D[19]
          -idir .D[20]
          -idir .D[21]
          -idir .D[22]
          -idir .D[23]
          -idir .D[24]
          -idir .D[25]
          -idir .D[26]
          -idir .D[27]
          -idir .D[28]
          -idir .D[29]
          -idir .D[30]
          -idir .D[31]
          -idir .D[32]
          -idir .D[33]
          -idir .D[34]
          -idir .D[35]
          -idir .D[36]
          -idir .D[37]
          -idir .D[38]
          -idir .D[39]
          -idir .D[40]
          -idir .D[41]
          -idir .D[42]
          -idir .D[43]
          -idir .D[44]
          -idir .D[45]
          -idir .D[46]
          -idir .D[47]
          -idir .D[48]
          -idir .D[49]
          -idir .D[50]
          -idir .D[51]
          -idir .D[52]
          -idir .D[53]
          -idir .D[54]
          -idir .D[55]
          -idir .D[56]
          -idir .D[57]






NVFORTRAN (Version     23.1)          02/24/2023  13:32:51      page 2

          -idir .D[58]
          -idir .D[59]
          -idir .D[60]
          -idir .D[61]
          -idir .D[62]
          -idir .D[63]
          -idir .D[64]
          -idir .D[65]
          -idir .D[66]
          -idir .D[67]
          -idir .D[68]
          -idir .D[69]
          -idir .D[70]
          -idir .D[71]
          -idir .D[72]
          -idir .D[73]
          -idir .D[74]
          -idir .D[75]
          -idir .D[76]
          -idir .D[77]
          -idir .D[78]
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/include
          -idir /opt/softs/nvidia/hpc_sdk/Linux_x86_64/23.1/comm_libs/openmpi/openmpi-3.1.5/lib
          -inform severe -opt 0 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: compiler_features.F90

(    1) MODULE Compiler_Features
(    2)   !  #[ Description
(    3) 
(    4)   !---------------------------------------------------
(    5)   ! a module to manage all the compiler-dependent problems
(    6)   ! This one handles pgf90
(    7)   ! When executing the Set_MakeOptions, the file Compiler_Features creates
(    8)   ! a link to this module.
(    9)   !---------------------------------------------------
(   10)   !    Written by:  Jos de Kloe
(   11)   !    created:     14-Dec-2010
(   12)   !
(   13)   ! Modifications:
(   14)   !    14-Dec-2010 J. de Kloe taken a copy from compiler_features_generic.F90
(   15)   !
(   16)   !---------------------------------------------------
(   17) 
(   18)   !  #]
(   19)   !  #[ modules used
(   20)   USE Numerics, only: i4_
(   21)   !  #]
(   22)   !  #[ Variables and parameters
(   23)   IMPLICIT NONE
(   24) 
(   25)   character, parameter :: tabchar = '\t'
(   26)   character, parameter :: retchar = '\r'
(   27)   character, parameter :: newline = '\n'
(   28)   character, parameter :: bs = '\\'
(   29) 
(   30)   ! this little piece of test code was used inside SimpleXML.F90






NVFORTRAN (Version     23.1)          02/24/2023  13:32:51      page 3

(   31)   ! to test that the \t, \r and \r are the expected escape codes,
(   32)   ! and do return achar(9), achar(13) and achar(10)
(   33)   !print *,'xxx\txxx',ichar('\t'),'jjj',achar(9),'kkk'
(   34)   !print *,'xxx\rxxx',ichar('\r'),'jjj',achar(13),'kkk'
(   35)   !print *,'xxx\nxxx',ichar('\n'),'jjj',achar(10),'kkk'
(   36) 
(   37)   !  #]
(   38) CONTAINS 
(   39)   !----------------------------------------
(   40)   function iargc_aeolus() result(nargs)
(   41)     !  #[
(   42)     ! Points to the routine which returns the number of arguments
(   43)     integer :: nargs
(   44)     !  #[ Interfaces
(   45)     ! specify explicit interface for the fortran extension iargc()
(   46)     interface
(   47)       function iargc() result(result)  !  system fortran function
(   48)         integer :: result
(   49)       end function iargc
(   50)     end interface
(   51)     !  #]
(   52) 
(   53)     nargs = iargc()
(   54)     end function iargc_aeolus
(   55)     !  #]
(   56)   !--------------------------------
(   57)   subroutine getarg_aeolus(i_in,c_out)
(   58)     !  #[
(   59)     ! Returns the string of arguments in input
(   60)     integer,          intent(in)  :: i_in
(   61)     character(len=*), intent(out) :: c_out
(   62)     !  #[ Interfaces
(   63)     ! specify explicit interface for the fortran extension iargc()
(   64)     interface
(   65)       subroutine getarg(i, c) !  system fortran routine
(   66)         integer,          intent(in)  :: i
(   67)         character(len=*), intent(out) :: c
(   68)       end subroutine getarg
(   69)     end interface
(   70)     !  #]
(   71) 
(   72)     call getarg(i_in,c_out)
(   73)     end subroutine getarg_aeolus
(   74)     !  #]
(   75)   !--------------------------------
(   76)   subroutine flush_aeolus(fileunit)
(   77)     !  #[
(   78)     integer :: fileunit
(   79) 
(   80)     ! remarks:
(   81)     ! the thin-layer requires the processor to flush the text written
(   82)     ! to the logs after EVERY message, to be sure it is not delayed.
(   83)     ! However, Fortran90 has no flush() function specified, and the next
(   84)     ! call is an extention to the standard. Therefore it may be necessary
(   85)     ! for some compilers to deactivate it, and do nothing, and thus violate
(   86)     ! the thin-layer requirements.
(   87)     ! Note also that is is not usefull to call the flush function in the
(   88)     ! c-runtime library (does it exist there?) since fortran may/will use






NVFORTRAN (Version     23.1)          02/24/2023  13:32:51      page 4

(   89)     ! some buffering, independent of the underlying c-code.
(   90) 
(   91)     ! note also that the next call DOES work for the g95 compiler
(   92)     ! which uses this generic version of the COmpiler_Features module
(   93) 
(   94)     call flush(fileunit)
(   95) 
(   96)   end subroutine flush_aeolus
(   97)     !  #]
(   98)   !--------------------------------
(   99)   subroutine getenv_aeolus(name,value)
(  100)     !  #[
(  101)     ! Returns the value of the environment variable
(  102)     character(len=*), intent(in)  :: name
(  103)     character(len=*), intent(out) :: value
(  104)     !  #[ Interfaces (no longer needed)
(  105)     ! specify explicit interface for the fortran extension getenv()
(  106)     !interface
(  107)     !  subroutine getenv(name, value) !  system fortran routine
(  108)     !    character(len=*), intent(in)  :: name
(  109)     !    character(len=*), intent(out) :: value
(  110)     !  end subroutine getenv
(  111)     !end interface
(  112)     !  #]
(  113) 
(  114)     !call getenv(name,value)
(  115)     ! as suggested by Meteo France replaced by
(  116)     call get_environment_variable(name,value)
(  117) 
(  118)   end subroutine getenv_aeolus
(  119)     !  #]
(  120)   !--------------------------------
(  121)   subroutine exit_aeolus(exitcode)
(  122)     !  #[ 
(  123)     integer, intent(in) :: exitcode
(  124) 
(  125)     ! NOTE: we found that the action by the STOP command is not fully
(  126)     ! compatible between the different Fortran90 compilers, and especially
(  127)     ! the Portland pgf90 compiler seems not to set the status environment
(  128)     ! variable when a STOP command is issued followed by a non-zero integer.
(  129)     ! See this discussion: http://www.pgroup.com/userforum/viewtopic.php?p=8870
(  130)     ! It also seems this behaviour is not part of the Fortran90 standard,
(  131)     ! so we have to handle the exception ourselves.
(  132)     ! However, we have an ESA requirement to generate non-zero exit status
(  133)     ! when our programs terminate with an error.
(  134)     ! Therefore, for the pgf90 compiler, we use the suggested call to the
(  135)     ! c function exit() as a temporary workaround.
(  136) 
(  137)     ! this parameter definition is copied inhere from lunmanager.F90
(  138)     ! to prevent circular dependencies between support modules.
(  139)     ! (since lunmanager needs stringtools, and stringtools needs
(  140)     !  compiler_features !!)
(  141)     integer, parameter :: fileunit_stderr = 0
(  142) 
(  143)     write(fileunit_stderr,"(a,i3)") 'STOP ',exitcode
(  144)     call exit(exitcode)
(  145) 
(  146)   end subroutine exit_aeolus






NVFORTRAN (Version     23.1)          02/24/2023  13:32:51      page 5

(  147)     !  #]
(  148)   !--------------------------------
(  149) END MODULE Compiler_Features





























































NVFORTRAN (Version     23.1)          02/24/2023  13:32:51      page 6

(    1) # 1 "compiler_features.F90"
(    1) MODULE Compiler_Features
(    2)   !  #[ Description
(    3) # 4 "compiler_features.F90"
(    4)   !---------------------------------------------------
(    5)   ! a module to manage all the compiler-dependent problems
(    6)   ! This one handles pgf90
(    7)   ! When executing the Set_MakeOptions, the file Compiler_Features creates
(    8)   ! a link to this module.
(    9)   !---------------------------------------------------
(   10)   !    Written by:  Jos de Kloe
(   11)   !    created:     14-Dec-2010
(   12)   !
(   13)   ! Modifications:
(   14)   !    14-Dec-2010 J. de Kloe taken a copy from compiler_features_generic.F90
(   15)   !
(   16)   !---------------------------------------------------
(   17) # 18 "compiler_features.F90"
(   18)   !  #]
(   19)   !  #[ modules used
(   20)   USE Numerics, only: i4_
(   21)   !  #]
(   22)   !  #[ Variables and parameters
(   23)   IMPLICIT NONE
(   24) # 25 "compiler_features.F90"
(   25)   character, parameter :: tabchar = '\t'
(   26)   character, parameter :: retchar = '\r'
(   27)   character, parameter :: newline = '\n'
(   28)   character, parameter :: bs = '\\'
(   29) # 30 "compiler_features.F90"
(   30)   ! this little piece of test code was used inside SimpleXML.F90
(   31)   ! to test that the \t, \r and \r are the expected escape codes,
(   32)   ! and do return achar(9), achar(13) and achar(10)
(   33)   !print *,'xxx\txxx',ichar('\t'),'jjj',achar(9),'kkk'
(   34)   !print *,'xxx\rxxx',ichar('\r'),'jjj',achar(13),'kkk'
(   35)   !print *,'xxx\nxxx',ichar('\n'),'jjj',achar(10),'kkk'
(   36) # 37 "compiler_features.F90"
(   37)   !  #]
(   38) CONTAINS 
(   39)   !----------------------------------------
(   40)   function iargc_aeolus() result(nargs)
(   41)     !  #[
(   42)     ! Points to the routine which returns the number of arguments
(   43)     integer :: nargs
(   44)     !  #[ Interfaces
(   45)     ! specify explicit interface for the fortran extension iargc()
(   46)     interface
(   47)       function iargc() result(result)  !  system fortran function
(   48)         integer :: result
(   49)       end function iargc
(   50)     end interface
(   51)     !  #]
(   52) # 53 "compiler_features.F90"
(   53)     nargs = iargc()
(   54)     end function iargc_aeolus
(   55)     !  #]
(   56)   !--------------------------------
(   57)   subroutine getarg_aeolus(i_in,c_out)






NVFORTRAN (Version     23.1)          02/24/2023  13:32:51      page 7

(   58)     !  #[
(   59)     ! Returns the string of arguments in input
(   60)     integer,          intent(in)  :: i_in
(   61)     character(len=*), intent(out) :: c_out
(   62)     !  #[ Interfaces
(   63)     ! specify explicit interface for the fortran extension iargc()
(   64)     interface
(   65)       subroutine getarg(i, c) !  system fortran routine
(   66)         integer,          intent(in)  :: i
(   67)         character(len=*), intent(out) :: c
(   68)       end subroutine getarg
(   69)     end interface
(   70)     !  #]
(   71) # 72 "compiler_features.F90"
(   72)     call getarg(i_in,c_out)
(   73)     end subroutine getarg_aeolus
(   74)     !  #]
(   75)   !--------------------------------
(   76)   subroutine flush_aeolus(fileunit)
(   77)     !  #[
(   78)     integer :: fileunit
(   79) # 80 "compiler_features.F90"
(   80)     ! remarks:
(   81)     ! the thin-layer requires the processor to flush the text written
(   82)     ! to the logs after EVERY message, to be sure it is not delayed.
(   83)     ! However, Fortran90 has no flush() function specified, and the next
(   84)     ! call is an extention to the standard. Therefore it may be necessary
(   85)     ! for some compilers to deactivate it, and do nothing, and thus violate
(   86)     ! the thin-layer requirements.
(   87)     ! Note also that is is not usefull to call the flush function in the
(   88)     ! c-runtime library (does it exist there?) since fortran may/will use
(   89)     ! some buffering, independent of the underlying c-code.
(   90) # 91 "compiler_features.F90"
(   91)     ! note also that the next call DOES work for the g95 compiler
(   92)     ! which uses this generic version of the COmpiler_Features module
(   93) # 94 "compiler_features.F90"
(   94)     call flush(fileunit)
(   95) # 96 "compiler_features.F90"
(   96)   end subroutine flush_aeolus
(   97)     !  #]
(   98)   !--------------------------------
(   99)   subroutine getenv_aeolus(name,value)
(  100)     !  #[
(  101)     ! Returns the value of the environment variable
(  102)     character(len=*), intent(in)  :: name
(  103)     character(len=*), intent(out) :: value
(  104)     !  #[ Interfaces (no longer needed)
(  105)     ! specify explicit interface for the fortran extension getenv()
(  106)     !interface
(  107)     !  subroutine getenv(name, value) !  system fortran routine
(  108)     !    character(len=*), intent(in)  :: name
(  109)     !    character(len=*), intent(out) :: value
(  110)     !  end subroutine getenv
(  111)     !end interface
(  112)     !  #]
(  113) # 114 "compiler_features.F90"
(  114)     !call getenv(name,value)
(  115)     ! as suggested by Meteo France replaced by






NVFORTRAN (Version     23.1)          02/24/2023  13:32:51      page 8

(  116)     call get_environment_variable(name,value)
(  117) # 118 "compiler_features.F90"
(  118)   end subroutine getenv_aeolus
(  119)     !  #]
(  120)   !--------------------------------
(  121)   subroutine exit_aeolus(exitcode)
(  122)     !  #[ 
(  123)     integer, intent(in) :: exitcode
(  124) # 125 "compiler_features.F90"
(  125)     ! NOTE: we found that the action by the STOP command is not fully
(  126)     ! compatible between the different Fortran90 compilers, and especially
(  127)     ! the Portland pgf90 compiler seems not to set the status environment
(  128)     ! variable when a STOP command is issued followed by a non-zero integer.
(  129)     ! See this discussion: http://www.pgroup.com/userforum/viewtopic.php?p=8870
(  130)     ! It also seems this behaviour is not part of the Fortran90 standard,
(  131)     ! so we have to handle the exception ourselves.
(  132)     ! However, we have an ESA requirement to generate non-zero exit status
(  133)     ! when our programs terminate with an error.
(  134)     ! Therefore, for the pgf90 compiler, we use the suggested call to the
(  135)     ! c function exit() as a temporary workaround.
(  136) # 137 "compiler_features.F90"
(  137)     ! this parameter definition is copied inhere from lunmanager.F90
(  138)     ! to prevent circular dependencies between support modules.
(  139)     ! (since lunmanager needs stringtools, and stringtools needs
(  140)     !  compiler_features !!)
(  141)     integer, parameter :: fileunit_stderr = 0
(  142) # 143 "compiler_features.F90"
(  143)     write(fileunit_stderr,"(a,i3)") 'STOP ',exitcode
(  144)     call exit(exitcode)
(  145) # 146 "compiler_features.F90"
(  146)   end subroutine exit_aeolus
(  147)     !  #]
(  148)   !--------------------------------
(  149) END MODULE Compiler_Features
